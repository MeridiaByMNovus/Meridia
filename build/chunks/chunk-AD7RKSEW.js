import {
  init_monaco_editor_core as init_monaco_editor_core5,
  languages as languages2
} from "./chunk-MNW4KTRE.js";
import {
  init_monaco_editor_core as init_monaco_editor_core4
} from "./chunk-ZSDMMBCL.js";
import {
  init_monaco_contribution
} from "./chunk-2NRVTU35.js";
import {
  init_monaco_editor_core
} from "./chunk-AGTBZAXD.js";
import {
  init_monaco_editor_core as init_monaco_editor_core2
} from "./chunk-T3ZPCE7Q.js";
import {
  init_monaco_editor_core as init_monaco_editor_core3
} from "./chunk-GDBJUM7E.js";
import {
  $,
  AccessibilityHelpNLS,
  Action,
  ActionBar,
  ActionRunner,
  ActionViewItem,
  BaseActionViewItem,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CSSIcon,
  CancellationToken,
  CancellationTokenSource,
  CancellationTokenSource2,
  CharacterSet,
  CodeActionProviderRegistry,
  CodeEditorWidget,
  CodeLensProviderRegistry,
  Codicon,
  Color,
  ColorProviderRegistry,
  ColorScheme,
  CommandsRegistry,
  CompletionProviderRegistry,
  Configuration,
  ContextKeyExpr,
  CopyOptions,
  CoreEditingCommands,
  CountBadge,
  CursorColumns,
  CursorMoveCommands,
  CursorState,
  DataUri,
  DeclarationProviderRegistry,
  DefinitionProviderRegistry,
  Delayer,
  Dimension,
  Disposable,
  DisposableStore,
  DocumentHighlightKind,
  DocumentHighlightProviderRegistry,
  DocumentRangeFormattingEditProviderRegistry,
  DocumentRangeSemanticTokensProviderRegistry,
  DocumentSymbolProviderRegistry,
  DomEmitter,
  DomScrollableElement,
  EditOperation,
  EditorAction,
  EditorCommand,
  EditorContextKeys,
  EditorFontLigatures,
  EditorOptions,
  EditorState,
  EditorStateCancellationTokenSource,
  EditorZoom,
  Emitter,
  Emitter2,
  Event,
  EventHelper,
  EventType,
  EventType2,
  Extensions,
  Extensions2,
  FileAccess,
  FoldingRangeKind,
  FoldingRangeProviderRegistry,
  FormattingEdit,
  FuzzyScore,
  Gesture,
  GlobalMouseMoveMonitor,
  GoToLineNLS,
  HSVA,
  HighlightedLabel,
  HistoryInputBox,
  HoverProviderRegistry,
  IAccessibilityService,
  IBulkEditService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextKeyService,
  IContextMenuService,
  IContextViewService,
  IDialogService,
  IEditorProgressService,
  IEditorWorkerService,
  IInstantiationService,
  IKeybindingService,
  ILabelService,
  IListService,
  ILogService,
  IMarkerData,
  IMarkerDecorationsService,
  IMarkerService,
  IMenuService,
  IModeService,
  IModelService,
  INotificationService,
  IOpenerService,
  IQuickInputService,
  IStandaloneThemeService,
  IStorageService,
  ITelemetryService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IUndoRedoService,
  IWorkspaceContextService,
  IconLabel,
  IdGenerator,
  IdleValue,
  ImplementationProviderRegistry,
  InMemoryClipboardMetadataManager,
  IndentAction,
  InlayHintKind,
  InlayHintsProviderRegistry,
  InlineCompletionTriggerKind,
  InlineCompletionsProviderRegistry,
  InspectTokensNLS,
  IsWindowsContext,
  Iterable,
  KeyChord,
  KeyCode,
  KeyMod,
  KeybindingsRegistry,
  LRUCache,
  LanguageConfigurationRegistry,
  LanguageFeatureRequestDelays,
  LcsDiff,
  LineDecoration,
  LineTokens,
  LinkProviderRegistry,
  LinkedEditingRangeProviderRegistry,
  LinkedList,
  List,
  MarkdownString,
  MarkerSeverity,
  MarkerSeverity2,
  MarkerTag,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  MinimapPosition,
  ModelDecorationOptions,
  ModifierKeyEmitter,
  MoveOperations,
  MultiCommand,
  MultiEditorAction,
  MutableDisposable,
  NULL_STATE,
  NullOpenerService,
  OS,
  OnTypeFormattingEditProviderRegistry,
  OrthogonalEdge,
  OverviewRulerLane,
  PLAINTEXT_MODE_ID,
  Position,
  Position2,
  Progress,
  QuickCommandNLS,
  QuickHelpNLS,
  QuickOutlineNLS,
  RGBA,
  Range,
  Range2,
  RawContextKey,
  RedoCommand,
  ReferenceProviderRegistry,
  Registry,
  RenameProviderRegistry,
  RenderLineInput,
  ReplaceCommand,
  ReplaceCommandThatPreservesSelection,
  ReplaceCommandThatSelectsText,
  ResourceEdit,
  ResourceMap,
  RunOnceScheduler,
  SEMANTIC_HIGHLIGHTING_SETTING_ID,
  Sash,
  Schemas,
  ScrollableElement,
  SearchParams,
  Selection,
  Selection2,
  SelectionDirection,
  SelectionRangeRegistry,
  Separator,
  ShiftCommand,
  SignatureHelpProviderRegistry,
  SignatureHelpTriggerKind,
  SimpleKeybinding,
  Sizing,
  SplitView,
  StableEditorScrollState,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StopWatch,
  SubmenuAction,
  SubmenuItemAction,
  SymbolKinds,
  TabFocus,
  TernarySearchTree,
  TextModel,
  TextModelCancellationTokenSource,
  ThemeIcon,
  TimeoutTimer,
  ToggleHighContrastNLS,
  Token,
  TokenMetadata,
  TokenizationRegistry,
  TypeDefinitionProviderRegistry,
  TypeOperations,
  UILabelProvider,
  URI,
  UndoCommand,
  Uri,
  Widget,
  WillSaveStateReason,
  WordOperations,
  WordPartOperations,
  WorkbenchAsyncDataTree,
  WorkbenchListFocusContextKey,
  activeContrastBorder,
  addDisposableGenericMouseDownListner,
  addDisposableGenericMouseUpListner,
  addDisposableListener,
  addDisposableNonBubblingMouseOutListener,
  addStandardDisposableGenericMouseDownListner,
  addStandardDisposableListener,
  alert,
  alertFormattingEdits,
  anyScore,
  append,
  asArray,
  asCSSUrl,
  assertIsDefined,
  assertType,
  attachBadgeStyler,
  attachListStyler,
  basename,
  basename2,
  basenameOrAuthority,
  binarySearch,
  canceled,
  clamp,
  clearNode,
  cloneAndChange,
  coalesce,
  combinedDisposable,
  commonPrefixLength,
  commonSuffixLength,
  compare,
  compareIgnoreCase,
  completionKindFromString,
  completionKindToCssClass,
  containsRTL,
  containsUppercaseCharacter,
  contrastBorder,
  createCSSRule,
  createCancelablePromise,
  createDecorator,
  createElement,
  createFastDomNode,
  createMatches,
  createStringBuilder,
  createStyleSheet,
  deepClone,
  defaultGenerator,
  dirname,
  dirname2,
  disposableTimeout,
  dispose,
  editor,
  editorActiveLinkForeground,
  editorBackground,
  editorBracketMatchBackground,
  editorBracketMatchBorder,
  editorCodeLensForeground,
  editorErrorBorder,
  editorErrorForeground,
  editorFindMatch,
  editorFindMatchBorder,
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder,
  editorFindRangeHighlight,
  editorFindRangeHighlightBorder,
  editorForeground,
  editorHoverBackground,
  editorHoverBorder,
  editorHoverForeground,
  editorHoverHighlight,
  editorHoverStatusBarBackground,
  editorInfoBorder,
  editorInfoForeground,
  editorInlayHintBackground,
  editorInlayHintForeground,
  editorInlayHintParameterBackground,
  editorInlayHintParameterForeground,
  editorInlayHintTypeBackground,
  editorInlayHintTypeForeground,
  editorLightBulbAutoFixForeground,
  editorLightBulbForeground,
  editorSelectionBackground,
  editorSelectionHighlight,
  editorSelectionHighlightBorder,
  editorWarningBorder,
  editorWarningForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editorWidgetForeground,
  editorWidgetResizeBorder,
  equals,
  errorForeground,
  escape,
  escapeRegExpCharacters,
  extUri,
  findFirstInSorted,
  first,
  firstNonWhitespaceIndex,
  flatten,
  focusBorder,
  foreground,
  format,
  formatDocumentRangesWithSelectedProvider,
  formatDocumentWithSelectedProvider,
  fuzzyScore,
  fuzzyScoreGracefulAggressive,
  getClientArea,
  getCodeEditor,
  getComputedStyle,
  getDocumentRangeSemanticTokensProvider,
  getDomNodePagePosition,
  getLeadingWhitespace,
  getMapForWordSeparators,
  getOnTypeFormattingEdits,
  getShadowRoot,
  getTopLeftOffset,
  getTotalWidth,
  ghostTextBorder,
  ghostTextForeground,
  groupBy,
  hasDriveLetter,
  hash,
  hide,
  iconForeground,
  illegalArgument,
  init_accessibility,
  init_actionViewItems,
  init_actionbar,
  init_actions,
  init_actions2,
  init_aria,
  init_arrays,
  init_async,
  init_browser,
  init_bulkEditService,
  init_cancellation,
  init_characterClassifier,
  init_clipboardService,
  init_codeEditorService,
  init_codeEditorWidget,
  init_codiconStyles,
  init_codicons,
  init_color,
  init_colorRegistry,
  init_commands,
  init_commonEditorConfig,
  init_configuration,
  init_configuration2,
  init_configurationRegistry,
  init_contextView,
  init_contextkey,
  init_contextkeys,
  init_coreCommands,
  init_countBadge,
  init_cursorCommon,
  init_cursorMoveCommands,
  init_cursorMoveOperations,
  init_cursorTypeOperations,
  init_cursorWordOperations,
  init_dialogs,
  init_diff,
  init_diffEditorWidget,
  init_diffNavigator,
  init_dom,
  init_editOperation,
  init_editorBrowser,
  init_editorColorRegistry,
  init_editorContextKeys,
  init_editorExtensions,
  init_editorOptions,
  init_editorState,
  init_editorWorkerService,
  init_editorZoom,
  init_editor_api,
  init_errors,
  init_event,
  init_event2,
  init_extensions,
  init_extpath,
  init_fastDomNode,
  init_filters,
  init_format,
  init_formattedTextRenderer,
  init_formattingEdit,
  init_functional,
  init_getSemanticTokens,
  init_globalMouseMoveMonitor,
  init_hash,
  init_highlightedLabel,
  init_htmlContent,
  init_iconLabel,
  init_iconLabels,
  init_iconLabels2,
  init_iconRegistry,
  init_idGenerator,
  init_inputBox,
  init_instantiation,
  init_iterator,
  init_keyCodes,
  init_keybinding,
  init_keybindingLabels,
  init_keybindingsRegistry,
  init_keyboardEvent,
  init_label,
  init_languageConfiguration,
  init_languageConfigurationRegistry,
  init_languageFeatureRegistry,
  init_lifecycle,
  init_lineDecorations,
  init_lineTokens,
  init_linkedList,
  init_listService,
  init_listWidget,
  init_log,
  init_map,
  init_markers,
  init_markersDecorationService,
  init_marshalling,
  init_modeService,
  init_model,
  init_modelService,
  init_modelServiceImpl,
  init_modes,
  init_modesRegistry,
  init_mouseEvent,
  init_network,
  init_nls,
  init_notification,
  init_nullMode,
  init_numbers,
  init_objects,
  init_opener,
  init_path,
  init_platform,
  init_platform2,
  init_position,
  init_progress,
  init_quickAccess,
  init_quickInput,
  init_range,
  init_replaceCommand,
  init_resolverService,
  init_resources,
  init_sash,
  init_scrollableElement,
  init_selection,
  init_semanticTokensProviderStyling,
  init_severity,
  init_shiftCommand,
  init_splitview,
  init_standaloneStrings,
  init_standaloneThemeService,
  init_stopwatch,
  init_storage,
  init_stringBuilder,
  init_strings,
  init_styler,
  init_telemetry,
  init_textAreaInput,
  init_textModel,
  init_textModelSearch,
  init_textResourceConfigurationService,
  init_textToHtmlTokenizer,
  init_theme,
  init_themeService,
  init_touch,
  init_types,
  init_undoRedo,
  init_uri,
  init_viewLineRenderer,
  init_widget,
  init_wordCharacterClassifier,
  init_workspace,
  inputActiveOptionBackground,
  inputActiveOptionBorder,
  inputActiveOptionForeground,
  inputBackground,
  inputBorder,
  inputForeground,
  inputValidationErrorBackground,
  inputValidationErrorBorder,
  inputValidationErrorForeground,
  inputValidationInfoBackground,
  inputValidationInfoBorder,
  inputValidationInfoForeground,
  inputValidationWarningBackground,
  inputValidationWarningBorder,
  inputValidationWarningForeground,
  isArray,
  isBasicASCII,
  isCodeEditor,
  isDiffEditor,
  isDisposable,
  isEmptyMarkdownString,
  isEqual,
  isFalsyOrEmpty,
  isFalsyOrWhitespace,
  isFirefox,
  isHighSurrogate,
  isIOS,
  isInDOM,
  isInShadowDOM,
  isLinux,
  isLocationLink,
  isLowSurrogate,
  isLowerAsciiLetter,
  isMacintosh,
  isNative,
  isNonEmptyArray,
  isNumber,
  isObject,
  isPromiseCanceledError,
  isRootOrDriveLetter,
  isSemanticColoringEnabled,
  isStandalone,
  isString,
  isUndefined,
  isUpperAsciiLetter,
  isWeb,
  isWindows,
  joinPath,
  languages,
  lastNonWhitespaceIndex,
  listFocusHighlightForeground,
  listHighlightForeground,
  localize,
  markdownEscapeEscapedIcons,
  matchesContiguousSubString,
  matchesPrefix,
  matchesWords,
  minimapFindMatch,
  minimapSelectionOccurrenceHighlight,
  mixin,
  nullTokenize,
  nullTokenize2,
  onDidChangeZoomLevel,
  onUnexpectedError,
  onUnexpectedExternalError,
  once,
  oneOf,
  or,
  originalFSPath,
  overviewRulerFindMatchForeground,
  overviewRulerRangeHighlight,
  overviewRulerSelectionHighlightForeground,
  parse,
  parseHrefAndDimensions,
  prepend,
  problemsErrorIconForeground,
  problemsInfoIconForeground,
  problemsWarningIconForeground,
  quickInputListFocusBackground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickSelect,
  raceCancellation,
  registerColor,
  registerEditorAction,
  registerEditorCommand,
  registerEditorContribution,
  registerIcon,
  registerInstantiatedEditorAction,
  registerModelAndPositionCommand,
  registerModelCommand,
  registerMultiEditorAction,
  registerSingleton,
  registerThemingParticipant,
  removeCSSRulesContainingSelector,
  removeMarkdownEscapes,
  renderFormattedText,
  renderLabelWithIcons,
  renderViewLine,
  reset,
  resolvePath,
  runWhenIdle,
  sep,
  severity_default,
  show,
  size,
  snippetFinalTabstopHighlightBackground,
  snippetFinalTabstopHighlightBorder,
  snippetTabstopHighlightBackground,
  snippetTabstopHighlightBorder,
  splitLines,
  standardMouseMoveMerger,
  status,
  stripIcons,
  stripWildcards,
  textCodeBlockBackground,
  textLinkActiveForeground,
  textLinkForeground,
  themeColorFromId,
  timeout,
  toDisposable,
  toMultilineTokens2,
  tokenizeToString,
  toolbarHoverBackground,
  trackFocus,
  transparent,
  trim,
  widgetClose,
  widgetShadow,
  withNullAsUndefined
} from "./chunk-ULLJH66C.js";
import {
  init_workbench_editor_theme,
  registerTheme
} from "./chunk-6LGQ3OPY.js";
import {
  getLanguage,
  init_workbench_utils
} from "./chunk-XIEV3R25.js";
import {
  init_workbench_store_selector,
  select
} from "./chunk-EEHJVTSK.js";
import {
  dispatch,
  init_workbench_store
} from "./chunk-FPULJOSR.js";
import {
  init_workbench_store_slice,
  update_editor_tabs
} from "./chunk-EWJVXHY4.js";
import {
  init_workbench_standalone,
  registerStandalone
} from "./chunk-5XOEW5AM.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-KH45J4DC.js";

// node_modules/monaco-editor/esm/vs/language/css/monaco.contribution.js
function getMode() {
  return import("./cssMode-ML6KBZMM.js");
}
var LanguageServiceDefaultsImpl, optionsDefault, modeConfigurationDefault, cssDefaults, scssDefaults, lessDefaults;
var init_monaco_contribution2 = __esm({
  "node_modules/monaco-editor/esm/vs/language/css/monaco.contribution.js"() {
    init_editor_api();
    init_monaco_editor_core();
    LanguageServiceDefaultsImpl = /** @class */
    (function() {
      function LanguageServiceDefaultsImpl4(languageId, options, modeConfiguration) {
        this._onDidChange = new Emitter2();
        this._languageId = languageId;
        this.setOptions(options);
        this.setModeConfiguration(modeConfiguration);
      }
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "onDidChange", {
        get: function() {
          return this._onDidChange.event;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "modeConfiguration", {
        get: function() {
          return this._modeConfiguration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "diagnosticsOptions", {
        get: function() {
          return this.options;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "options", {
        get: function() {
          return this._options;
        },
        enumerable: false,
        configurable: true
      });
      LanguageServiceDefaultsImpl4.prototype.setOptions = function(options) {
        this._options = options || /* @__PURE__ */ Object.create(null);
        this._onDidChange.fire(this);
      };
      LanguageServiceDefaultsImpl4.prototype.setDiagnosticsOptions = function(options) {
        this.setOptions(options);
      };
      LanguageServiceDefaultsImpl4.prototype.setModeConfiguration = function(modeConfiguration) {
        this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
        this._onDidChange.fire(this);
      };
      return LanguageServiceDefaultsImpl4;
    })();
    optionsDefault = {
      validate: true,
      lint: {
        compatibleVendorPrefixes: "ignore",
        vendorPrefix: "warning",
        duplicateProperties: "warning",
        emptyRules: "warning",
        importStatement: "ignore",
        boxModel: "ignore",
        universalSelector: "ignore",
        zeroUnits: "ignore",
        fontFaceProperties: "warning",
        hexColorLength: "error",
        argumentsInColorFunction: "error",
        unknownProperties: "warning",
        ieHack: "ignore",
        unknownVendorSpecificProperties: "ignore",
        propertyIgnoredDueToDisplay: "warning",
        important: "ignore",
        float: "ignore",
        idSelector: "ignore"
      },
      data: { useDefaultDataProvider: true }
    };
    modeConfigurationDefault = {
      completionItems: true,
      hovers: true,
      documentSymbols: true,
      definitions: true,
      references: true,
      documentHighlights: true,
      rename: true,
      colors: true,
      foldingRanges: true,
      diagnostics: true,
      selectionRanges: true
    };
    cssDefaults = new LanguageServiceDefaultsImpl("css", optionsDefault, modeConfigurationDefault);
    scssDefaults = new LanguageServiceDefaultsImpl("scss", optionsDefault, modeConfigurationDefault);
    lessDefaults = new LanguageServiceDefaultsImpl("less", optionsDefault, modeConfigurationDefault);
    languages.css = { cssDefaults, lessDefaults, scssDefaults };
    languages.onLanguage("less", function() {
      getMode().then(function(mode) {
        return mode.setupMode(lessDefaults);
      });
    });
    languages.onLanguage("scss", function() {
      getMode().then(function(mode) {
        return mode.setupMode(scssDefaults);
      });
    });
    languages.onLanguage("css", function() {
      getMode().then(function(mode) {
        return mode.setupMode(cssDefaults);
      });
    });
  }
});

// node_modules/monaco-editor/esm/vs/language/json/monaco.contribution.js
function getMode2() {
  return import("./jsonMode-DUAOWPC2.js");
}
var LanguageServiceDefaultsImpl2, diagnosticDefault, modeConfigurationDefault2, jsonDefaults;
var init_monaco_contribution3 = __esm({
  "node_modules/monaco-editor/esm/vs/language/json/monaco.contribution.js"() {
    init_editor_api();
    init_monaco_editor_core2();
    LanguageServiceDefaultsImpl2 = /** @class */
    (function() {
      function LanguageServiceDefaultsImpl4(languageId, diagnosticsOptions, modeConfiguration) {
        this._onDidChange = new Emitter2();
        this._languageId = languageId;
        this.setDiagnosticsOptions(diagnosticsOptions);
        this.setModeConfiguration(modeConfiguration);
      }
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "onDidChange", {
        get: function() {
          return this._onDidChange.event;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "modeConfiguration", {
        get: function() {
          return this._modeConfiguration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "diagnosticsOptions", {
        get: function() {
          return this._diagnosticsOptions;
        },
        enumerable: false,
        configurable: true
      });
      LanguageServiceDefaultsImpl4.prototype.setDiagnosticsOptions = function(options) {
        this._diagnosticsOptions = options || /* @__PURE__ */ Object.create(null);
        this._onDidChange.fire(this);
      };
      LanguageServiceDefaultsImpl4.prototype.setModeConfiguration = function(modeConfiguration) {
        this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
        this._onDidChange.fire(this);
      };
      return LanguageServiceDefaultsImpl4;
    })();
    diagnosticDefault = {
      validate: true,
      allowComments: true,
      schemas: [],
      enableSchemaRequest: false,
      schemaRequest: "warning",
      schemaValidation: "warning",
      comments: "error",
      trailingCommas: "error"
    };
    modeConfigurationDefault2 = {
      documentFormattingEdits: true,
      documentRangeFormattingEdits: true,
      completionItems: true,
      hovers: true,
      documentSymbols: true,
      tokens: true,
      colors: true,
      foldingRanges: true,
      diagnostics: true,
      selectionRanges: true
    };
    jsonDefaults = new LanguageServiceDefaultsImpl2("json", diagnosticDefault, modeConfigurationDefault2);
    languages.json = { jsonDefaults };
    languages.register({
      id: "json",
      extensions: [".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc", ".har"],
      aliases: ["JSON", "json"],
      mimetypes: ["application/json"]
    });
    languages.onLanguage("json", function() {
      getMode2().then(function(mode) {
        return mode.setupMode(jsonDefaults);
      });
    });
  }
});

// node_modules/monaco-editor/esm/vs/language/html/monaco.contribution.js
function getConfigurationDefault(languageId) {
  return {
    completionItems: true,
    hovers: true,
    documentSymbols: true,
    links: true,
    documentHighlights: true,
    rename: true,
    colors: true,
    foldingRanges: true,
    selectionRanges: true,
    diagnostics: languageId === htmlLanguageId,
    documentFormattingEdits: languageId === htmlLanguageId,
    documentRangeFormattingEdits: languageId === htmlLanguageId
    // turned off for Razor and Handlebar
  };
}
function getMode3() {
  return import("./htmlMode-RTW2UXH3.js");
}
function registerHTMLLanguageService(languageId, options, modeConfiguration) {
  var _this = this;
  if (options === void 0) {
    options = optionsDefault2;
  }
  if (modeConfiguration === void 0) {
    modeConfiguration = getConfigurationDefault(languageId);
  }
  var defaults = new LanguageServiceDefaultsImpl3(languageId, options, modeConfiguration);
  var mode;
  var onLanguageListener = languages.onLanguage(languageId, function() {
    return __awaiter(_this, void 0, void 0, function() {
      return __generator(this, function(_a5) {
        switch (_a5.label) {
          case 0:
            return [4, getMode3()];
          case 1:
            mode = _a5.sent().setupMode(defaults);
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
  return {
    defaults,
    dispose: function() {
      onLanguageListener.dispose();
      mode === null || mode === void 0 ? void 0 : mode.dispose();
      mode = void 0;
    }
  };
}
var __awaiter, __generator, LanguageServiceDefaultsImpl3, formatDefaults, optionsDefault2, htmlLanguageId, handlebarsLanguageId, razorLanguageId, htmlLanguageService, htmlDefaults, handlebarLanguageService, handlebarDefaults, razorLanguageService, razorDefaults;
var init_monaco_contribution4 = __esm({
  "node_modules/monaco-editor/esm/vs/language/html/monaco.contribution.js"() {
    init_editor_api();
    init_monaco_editor_core3();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    LanguageServiceDefaultsImpl3 = /** @class */
    (function() {
      function LanguageServiceDefaultsImpl4(languageId, options, modeConfiguration) {
        this._onDidChange = new Emitter2();
        this._languageId = languageId;
        this.setOptions(options);
        this.setModeConfiguration(modeConfiguration);
      }
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "onDidChange", {
        get: function() {
          return this._onDidChange.event;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "options", {
        get: function() {
          return this._options;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LanguageServiceDefaultsImpl4.prototype, "modeConfiguration", {
        get: function() {
          return this._modeConfiguration;
        },
        enumerable: false,
        configurable: true
      });
      LanguageServiceDefaultsImpl4.prototype.setOptions = function(options) {
        this._options = options || /* @__PURE__ */ Object.create(null);
        this._onDidChange.fire(this);
      };
      LanguageServiceDefaultsImpl4.prototype.setModeConfiguration = function(modeConfiguration) {
        this._modeConfiguration = modeConfiguration || /* @__PURE__ */ Object.create(null);
        this._onDidChange.fire(this);
      };
      return LanguageServiceDefaultsImpl4;
    })();
    formatDefaults = {
      tabSize: 4,
      insertSpaces: false,
      wrapLineLength: 120,
      unformatted: 'default": "a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',
      contentUnformatted: "pre",
      indentInnerHtml: false,
      preserveNewLines: true,
      maxPreserveNewLines: null,
      indentHandlebars: false,
      endWithNewline: false,
      extraLiners: "head, body, /html",
      wrapAttributes: "auto"
    };
    optionsDefault2 = {
      format: formatDefaults,
      suggest: {},
      data: { useDefaultDataProvider: true }
    };
    htmlLanguageId = "html";
    handlebarsLanguageId = "handlebars";
    razorLanguageId = "razor";
    htmlLanguageService = registerHTMLLanguageService(htmlLanguageId, optionsDefault2, getConfigurationDefault(htmlLanguageId));
    htmlDefaults = htmlLanguageService.defaults;
    handlebarLanguageService = registerHTMLLanguageService(handlebarsLanguageId, optionsDefault2, getConfigurationDefault(handlebarsLanguageId));
    handlebarDefaults = handlebarLanguageService.defaults;
    razorLanguageService = registerHTMLLanguageService(razorLanguageId, optionsDefault2, getConfigurationDefault(razorLanguageId));
    razorDefaults = razorLanguageService.defaults;
    languages.html = { htmlDefaults, razorDefaults, handlebarDefaults, htmlLanguageService, handlebarLanguageService, razorLanguageService, registerHTMLLanguageService };
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js
function registerLanguage(def) {
  var languageId = def.id;
  languageDefinitions[languageId] = def;
  languages.register(def);
  var lazyLanguageLoader = LazyLanguageLoader.getOrCreate(languageId);
  languages.setMonarchTokensProvider(languageId, lazyLanguageLoader.whenLoaded().then(function(mod) {
    return mod.language;
  }));
  languages.onLanguage(languageId, function() {
    lazyLanguageLoader.load().then(function(mod) {
      languages.setLanguageConfiguration(languageId, mod.conf);
    });
  });
}
var languageDefinitions, lazyLanguageLoaders, LazyLanguageLoader;
var init_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js"() {
    init_monaco_editor_core4();
    languageDefinitions = {};
    lazyLanguageLoaders = {};
    LazyLanguageLoader = /** @class */
    (function() {
      function LazyLanguageLoader3(languageId) {
        var _this = this;
        this._languageId = languageId;
        this._loadingTriggered = false;
        this._lazyLoadPromise = new Promise(function(resolve, reject) {
          _this._lazyLoadPromiseResolve = resolve;
          _this._lazyLoadPromiseReject = reject;
        });
      }
      LazyLanguageLoader3.getOrCreate = function(languageId) {
        if (!lazyLanguageLoaders[languageId]) {
          lazyLanguageLoaders[languageId] = new LazyLanguageLoader3(languageId);
        }
        return lazyLanguageLoaders[languageId];
      };
      LazyLanguageLoader3.prototype.whenLoaded = function() {
        return this._lazyLoadPromise;
      };
      LazyLanguageLoader3.prototype.load = function() {
        var _this = this;
        if (!this._loadingTriggered) {
          this._loadingTriggered = true;
          languageDefinitions[this._languageId].loader().then(function(mod) {
            return _this._lazyLoadPromiseResolve(mod);
          }, function(err) {
            return _this._lazyLoadPromiseReject(err);
          });
        }
        return this._lazyLoadPromise;
      };
      return LazyLanguageLoader3;
    })();
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/abap/abap.contribution.js
var init_abap_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/abap/abap.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "abap",
      extensions: [".abap"],
      aliases: ["abap", "ABAP"],
      loader: function() {
        return import("./abap-MHCYWLFJ.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/apex/apex.contribution.js
var init_apex_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/apex/apex.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "apex",
      extensions: [".cls"],
      aliases: ["Apex", "apex"],
      mimetypes: ["text/x-apex-source", "text/x-apex"],
      loader: function() {
        return import("./apex-ROGJO2MN.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/azcli/azcli.contribution.js
var init_azcli_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/azcli/azcli.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "azcli",
      extensions: [".azcli"],
      aliases: ["Azure CLI", "azcli"],
      loader: function() {
        return import("./azcli-OBZTLMFD.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/bat/bat.contribution.js
var init_bat_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/bat/bat.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "bat",
      extensions: [".bat", ".cmd"],
      aliases: ["Batch", "bat"],
      loader: function() {
        return import("./bat-ZUGWNYXE.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/bicep/bicep.contribution.js
var init_bicep_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/bicep/bicep.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "bicep",
      extensions: [".bicep"],
      aliases: ["Bicep"],
      loader: function() {
        return import("./bicep-3BBK4C6G.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/cameligo/cameligo.contribution.js
var init_cameligo_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/cameligo/cameligo.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "cameligo",
      extensions: [".mligo"],
      aliases: ["Cameligo"],
      loader: function() {
        return import("./cameligo-IZGWUUX7.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/clojure/clojure.contribution.js
var init_clojure_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/clojure/clojure.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "clojure",
      extensions: [".clj", ".cljs", ".cljc", ".edn"],
      aliases: ["clojure", "Clojure"],
      loader: function() {
        return import("./clojure-PFSG4LWY.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/coffee/coffee.contribution.js
var init_coffee_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/coffee/coffee.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "coffeescript",
      extensions: [".coffee"],
      aliases: ["CoffeeScript", "coffeescript", "coffee"],
      mimetypes: ["text/x-coffeescript", "text/coffeescript"],
      loader: function() {
        return import("./coffee-XQE7YQAU.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/cpp/cpp.contribution.js
var init_cpp_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/cpp/cpp.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "c",
      extensions: [".c", ".h"],
      aliases: ["C", "c"],
      loader: function() {
        return import("./cpp-M2KJUXUJ.js");
      }
    });
    registerLanguage({
      id: "cpp",
      extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx"],
      aliases: ["C++", "Cpp", "cpp"],
      loader: function() {
        return import("./cpp-M2KJUXUJ.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/csharp/csharp.contribution.js
var init_csharp_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/csharp/csharp.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "csharp",
      extensions: [".cs", ".csx", ".cake"],
      aliases: ["C#", "csharp"],
      loader: function() {
        return import("./csharp-ODH4K5ZK.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/csp/csp.contribution.js
var init_csp_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/csp/csp.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "csp",
      extensions: [],
      aliases: ["CSP", "csp"],
      loader: function() {
        return import("./csp-K3MRJGES.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/css/css.contribution.js
var init_css_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/css/css.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "css",
      extensions: [".css"],
      aliases: ["CSS", "css"],
      mimetypes: ["text/css"],
      loader: function() {
        return import("./css-WU6YFQCS.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/dart/dart.contribution.js
var init_dart_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/dart/dart.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "dart",
      extensions: [".dart"],
      aliases: ["Dart", "dart"],
      mimetypes: ["text/x-dart-source", "text/x-dart"],
      loader: function() {
        return import("./dart-FQ7AUW6L.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/dockerfile/dockerfile.contribution.js
var init_dockerfile_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/dockerfile/dockerfile.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "dockerfile",
      extensions: [".dockerfile"],
      filenames: ["Dockerfile"],
      aliases: ["Dockerfile"],
      loader: function() {
        return import("./dockerfile-MG5BCU6Q.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ecl/ecl.contribution.js
var init_ecl_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/ecl/ecl.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "ecl",
      extensions: [".ecl"],
      aliases: ["ECL", "Ecl", "ecl"],
      loader: function() {
        return import("./ecl-HMW6U62Z.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.contribution.js
var init_elixir_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "elixir",
      extensions: [".ex", ".exs"],
      aliases: ["Elixir", "elixir", "ex"],
      loader: function() {
        return import("./elixir-ZE5XBPYP.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/flow9/flow9.contribution.js
var init_flow9_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/flow9/flow9.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "flow9",
      extensions: [".flow"],
      aliases: ["Flow9", "Flow", "flow9", "flow"],
      loader: function() {
        return import("./flow9-T5F75RCK.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/fsharp/fsharp.contribution.js
var init_fsharp_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/fsharp/fsharp.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "fsharp",
      extensions: [".fs", ".fsi", ".ml", ".mli", ".fsx", ".fsscript"],
      aliases: ["F#", "FSharp", "fsharp"],
      loader: function() {
        return import("./fsharp-6OUFUIJZ.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/go/go.contribution.js
var init_go_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/go/go.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "go",
      extensions: [".go"],
      aliases: ["Go"],
      loader: function() {
        return import("./go-SNJH4RI3.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/graphql/graphql.contribution.js
var init_graphql_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/graphql/graphql.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "graphql",
      extensions: [".graphql", ".gql"],
      aliases: ["GraphQL", "graphql", "gql"],
      mimetypes: ["application/graphql"],
      loader: function() {
        return import("./graphql-ZTKUJ7WU.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/handlebars/handlebars.contribution.js
var init_handlebars_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/handlebars/handlebars.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "handlebars",
      extensions: [".handlebars", ".hbs"],
      aliases: ["Handlebars", "handlebars", "hbs"],
      mimetypes: ["text/x-handlebars-template"],
      loader: function() {
        return import("./handlebars-XU7BDJ6B.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/hcl/hcl.contribution.js
var init_hcl_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/hcl/hcl.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "hcl",
      extensions: [".tf", ".tfvars", ".hcl"],
      aliases: ["Terraform", "tf", "HCL", "hcl"],
      loader: function() {
        return import("./hcl-4N6VSGGJ.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/html/html.contribution.js
var init_html_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/html/html.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "html",
      extensions: [".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm"],
      aliases: ["HTML", "htm", "html", "xhtml"],
      mimetypes: ["text/html", "text/x-jshtm", "text/template", "text/ng-template"],
      loader: function() {
        return import("./html-M2FNJDM3.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ini/ini.contribution.js
var init_ini_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/ini/ini.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "ini",
      extensions: [".ini", ".properties", ".gitconfig"],
      filenames: ["config", ".gitattributes", ".gitconfig", ".editorconfig"],
      aliases: ["Ini", "ini"],
      loader: function() {
        return import("./ini-OV6NPXYC.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/java/java.contribution.js
var init_java_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/java/java.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "java",
      extensions: [".java", ".jav"],
      aliases: ["Java", "java"],
      mimetypes: ["text/x-java-source", "text/x-java"],
      loader: function() {
        return import("./java-V6VA2X4Y.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution.js
var init_javascript_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "javascript",
      extensions: [".js", ".es6", ".jsx", ".mjs"],
      firstLine: "^#!.*\\bnode",
      filenames: ["jakefile"],
      aliases: ["JavaScript", "javascript", "js"],
      mimetypes: ["text/javascript"],
      loader: function() {
        return import("./javascript-VFMY2FSV.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/julia/julia.contribution.js
var init_julia_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/julia/julia.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "julia",
      extensions: [".jl"],
      aliases: ["julia", "Julia"],
      loader: function() {
        return import("./julia-C4O74MXH.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/kotlin/kotlin.contribution.js
var init_kotlin_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/kotlin/kotlin.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "kotlin",
      extensions: [".kt"],
      aliases: ["Kotlin", "kotlin"],
      mimetypes: ["text/x-kotlin-source", "text/x-kotlin"],
      loader: function() {
        return import("./kotlin-CQFOXLWO.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/less/less.contribution.js
var init_less_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/less/less.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "less",
      extensions: [".less"],
      aliases: ["Less", "less"],
      mimetypes: ["text/x-less", "text/less"],
      loader: function() {
        return import("./less-66VRG25Q.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/lexon/lexon.contribution.js
var init_lexon_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/lexon/lexon.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "lexon",
      extensions: [".lex"],
      aliases: ["Lexon"],
      loader: function() {
        return import("./lexon-WNZZS6HF.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/lua/lua.contribution.js
var init_lua_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/lua/lua.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "lua",
      extensions: [".lua"],
      aliases: ["Lua", "lua"],
      loader: function() {
        return import("./lua-GJVOWMXC.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/liquid/liquid.contribution.js
var init_liquid_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/liquid/liquid.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "liquid",
      extensions: [".liquid", ".html.liquid"],
      aliases: ["Liquid", "liquid"],
      mimetypes: ["application/liquid"],
      loader: function() {
        return import("./liquid-K6MSZE6H.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/m3/m3.contribution.js
var init_m3_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/m3/m3.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "m3",
      extensions: [".m3", ".i3", ".mg", ".ig"],
      aliases: ["Modula-3", "Modula3", "modula3", "m3"],
      loader: function() {
        return import("./m3-GYS6GV5H.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/markdown/markdown.contribution.js
var init_markdown_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/markdown/markdown.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "markdown",
      extensions: [".md", ".markdown", ".mdown", ".mkdn", ".mkd", ".mdwn", ".mdtxt", ".mdtext"],
      aliases: ["Markdown", "markdown"],
      loader: function() {
        return import("./markdown-4LQE7CKT.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/mips/mips.contribution.js
var init_mips_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/mips/mips.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "mips",
      extensions: [".s"],
      aliases: ["MIPS", "MIPS-V"],
      mimetypes: ["text/x-mips", "text/mips", "text/plaintext"],
      loader: function() {
        return import("./mips-KNUYHOTR.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/msdax/msdax.contribution.js
var init_msdax_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/msdax/msdax.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "msdax",
      extensions: [".dax", ".msdax"],
      aliases: ["DAX", "MSDAX"],
      loader: function() {
        return import("./msdax-KHKZGBAK.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/mysql/mysql.contribution.js
var init_mysql_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/mysql/mysql.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "mysql",
      extensions: [],
      aliases: ["MySQL", "mysql"],
      loader: function() {
        return import("./mysql-6KP4Y4KT.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/objective-c/objective-c.contribution.js
var init_objective_c_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/objective-c/objective-c.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "objective-c",
      extensions: [".m"],
      aliases: ["Objective-C"],
      loader: function() {
        return import("./objective-c-56V22OAX.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.contribution.js
var init_pascal_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "pascal",
      extensions: [".pas", ".p", ".pp"],
      aliases: ["Pascal", "pas"],
      mimetypes: ["text/x-pascal-source", "text/x-pascal"],
      loader: function() {
        return import("./pascal-EUYE4ZEA.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pascaligo/pascaligo.contribution.js
var init_pascaligo_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/pascaligo/pascaligo.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "pascaligo",
      extensions: [".ligo"],
      aliases: ["Pascaligo", "ligo"],
      loader: function() {
        return import("./pascaligo-GKVKMOYK.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/perl/perl.contribution.js
var init_perl_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/perl/perl.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "perl",
      extensions: [".pl"],
      aliases: ["Perl", "pl"],
      loader: function() {
        return import("./perl-S6XCO64A.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pgsql/pgsql.contribution.js
var init_pgsql_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/pgsql/pgsql.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "pgsql",
      extensions: [],
      aliases: ["PostgreSQL", "postgres", "pg", "postgre"],
      loader: function() {
        return import("./pgsql-4DPWBSM5.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/php/php.contribution.js
var init_php_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/php/php.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "php",
      extensions: [".php", ".php4", ".php5", ".phtml", ".ctp"],
      aliases: ["PHP", "php"],
      mimetypes: ["application/x-php"],
      loader: function() {
        return import("./php-ZK32Y6NY.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/postiats/postiats.contribution.js
var init_postiats_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/postiats/postiats.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "postiats",
      extensions: [".dats", ".sats", ".hats"],
      aliases: ["ATS", "ATS/Postiats"],
      loader: function() {
        return import("./postiats-7NW6CVZW.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/powerquery/powerquery.contribution.js
var init_powerquery_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/powerquery/powerquery.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "powerquery",
      extensions: [".pq", ".pqm"],
      aliases: ["PQ", "M", "Power Query", "Power Query M"],
      loader: function() {
        return import("./powerquery-QO46NAVD.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/powershell/powershell.contribution.js
var init_powershell_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/powershell/powershell.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "powershell",
      extensions: [".ps1", ".psm1", ".psd1"],
      aliases: ["PowerShell", "powershell", "ps", "ps1"],
      loader: function() {
        return import("./powershell-HZAVQLN5.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pug/pug.contribution.js
var init_pug_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/pug/pug.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "pug",
      extensions: [".jade", ".pug"],
      aliases: ["Pug", "Jade", "jade"],
      loader: function() {
        return import("./pug-4K7MCFTE.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/python/python.contribution.js
var init_python_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/python/python.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "python",
      extensions: [".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi"],
      aliases: ["Python", "py"],
      firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
      loader: function() {
        return import("./python-RT3DDFFK.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/qsharp/qsharp.contribution.js
var init_qsharp_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/qsharp/qsharp.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "qsharp",
      extensions: [".qs"],
      aliases: ["Q#", "qsharp"],
      loader: function() {
        return import("./qsharp-AZHAG2LD.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/r/r.contribution.js
var init_r_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/r/r.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "r",
      extensions: [".r", ".rhistory", ".rmd", ".rprofile", ".rt"],
      aliases: ["R", "r"],
      loader: function() {
        return import("./r-SSKPZ4Q5.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/razor/razor.contribution.js
var init_razor_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/razor/razor.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "razor",
      extensions: [".cshtml"],
      aliases: ["Razor", "razor"],
      mimetypes: ["text/x-cshtml"],
      loader: function() {
        return import("./razor-2RL3DNCE.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/redis/redis.contribution.js
var init_redis_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/redis/redis.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "redis",
      extensions: [".redis"],
      aliases: ["redis"],
      loader: function() {
        return import("./redis-WCGKJAFI.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/redshift/redshift.contribution.js
var init_redshift_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/redshift/redshift.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "redshift",
      extensions: [],
      aliases: ["Redshift", "redshift"],
      loader: function() {
        return import("./redshift-B7PI7GBP.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/restructuredtext/restructuredtext.contribution.js
var init_restructuredtext_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/restructuredtext/restructuredtext.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "restructuredtext",
      extensions: [".rst"],
      aliases: ["reStructuredText", "restructuredtext"],
      loader: function() {
        return import("./restructuredtext-H4PRUU42.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.contribution.js
var init_ruby_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "ruby",
      extensions: [".rb", ".rbx", ".rjs", ".gemspec", ".pp"],
      filenames: ["rakefile", "Gemfile"],
      aliases: ["Ruby", "rb"],
      loader: function() {
        return import("./ruby-TKDEE7DP.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/rust/rust.contribution.js
var init_rust_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/rust/rust.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "rust",
      extensions: [".rs", ".rlib"],
      aliases: ["Rust", "rust"],
      loader: function() {
        return import("./rust-ECQYCFD5.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sb/sb.contribution.js
var init_sb_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/sb/sb.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "sb",
      extensions: [".sb"],
      aliases: ["Small Basic", "sb"],
      loader: function() {
        return import("./sb-OKIBKHCD.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scala/scala.contribution.js
var init_scala_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/scala/scala.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "scala",
      extensions: [".scala", ".sc", ".sbt"],
      aliases: ["Scala", "scala", "SBT", "Sbt", "sbt", "Dotty", "dotty"],
      mimetypes: ["text/x-scala-source", "text/x-scala", "text/x-sbt", "text/x-dotty"],
      loader: function() {
        return import("./scala-5YOOYZZB.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scheme/scheme.contribution.js
var init_scheme_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/scheme/scheme.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "scheme",
      extensions: [".scm", ".ss", ".sch", ".rkt"],
      aliases: ["scheme", "Scheme"],
      loader: function() {
        return import("./scheme-IQPXJPQU.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scss/scss.contribution.js
var init_scss_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/scss/scss.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "scss",
      extensions: [".scss"],
      aliases: ["Sass", "sass", "scss"],
      mimetypes: ["text/x-scss", "text/scss"],
      loader: function() {
        return import("./scss-MQE75MNB.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/shell/shell.contribution.js
var init_shell_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/shell/shell.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "shell",
      extensions: [".sh", ".bash"],
      aliases: ["Shell", "sh"],
      loader: function() {
        return import("./shell-WJD3DCWM.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/solidity/solidity.contribution.js
var init_solidity_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/solidity/solidity.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "sol",
      extensions: [".sol"],
      aliases: ["sol", "solidity", "Solidity"],
      loader: function() {
        return import("./solidity-GORBUIHF.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sophia/sophia.contribution.js
var init_sophia_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/sophia/sophia.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "aes",
      extensions: [".aes"],
      aliases: ["aes", "sophia", "Sophia"],
      loader: function() {
        return import("./sophia-E2KFUW43.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sparql/sparql.contribution.js
var init_sparql_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/sparql/sparql.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "sparql",
      extensions: [".rq"],
      aliases: ["sparql", "SPARQL"],
      loader: function() {
        return import("./sparql-6IMYXWBE.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sql/sql.contribution.js
var init_sql_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/sql/sql.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "sql",
      extensions: [".sql"],
      aliases: ["SQL"],
      loader: function() {
        return import("./sql-2TCCGZK7.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/st/st.contribution.js
var init_st_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/st/st.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "st",
      extensions: [".st", ".iecst", ".iecplc", ".lc3lib"],
      aliases: ["StructuredText", "scl", "stl"],
      loader: function() {
        return import("./st-35ZT2BWU.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/swift/swift.contribution.js
var init_swift_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/swift/swift.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "swift",
      aliases: ["Swift", "swift"],
      extensions: [".swift"],
      mimetypes: ["text/swift"],
      loader: function() {
        return import("./swift-U4R7PYWD.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/systemverilog/systemverilog.contribution.js
var init_systemverilog_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/systemverilog/systemverilog.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "systemverilog",
      extensions: [".sv", ".svh"],
      aliases: ["SV", "sv", "SystemVerilog", "systemverilog"],
      loader: function() {
        return import("./systemverilog-VBZI5UEH.js");
      }
    });
    registerLanguage({
      id: "verilog",
      extensions: [".v", ".vh"],
      aliases: ["V", "v", "Verilog", "verilog"],
      loader: function() {
        return import("./systemverilog-VBZI5UEH.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/tcl/tcl.contribution.js
var init_tcl_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/tcl/tcl.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "tcl",
      extensions: [".tcl"],
      aliases: ["tcl", "Tcl", "tcltk", "TclTk", "tcl/tk", "Tcl/Tk"],
      loader: function() {
        return import("./tcl-D7NZKN5L.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/twig/twig.contribution.js
var init_twig_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/twig/twig.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "twig",
      extensions: [".twig"],
      aliases: ["Twig", "twig"],
      mimetypes: ["text/x-twig"],
      loader: function() {
        return import("./twig-X3BNVIKY.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js
var init_typescript_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "typescript",
      extensions: [".ts", ".tsx"],
      aliases: ["TypeScript", "ts", "typescript"],
      mimetypes: ["text/typescript"],
      loader: function() {
        return import("./typescript-KJY22O3V.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/vb/vb.contribution.js
var init_vb_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/vb/vb.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "vb",
      extensions: [".vb"],
      aliases: ["Visual Basic", "vb"],
      loader: function() {
        return import("./vb-JHFCAWPB.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/xml/xml.contribution.js
var init_xml_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/xml/xml.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "xml",
      extensions: [
        ".xml",
        ".dtd",
        ".ascx",
        ".csproj",
        ".config",
        ".wxi",
        ".wxl",
        ".wxs",
        ".xaml",
        ".svg",
        ".svgz",
        ".opf",
        ".xsl"
      ],
      firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
      aliases: ["XML", "xml"],
      mimetypes: ["text/xml", "application/xml", "application/xaml+xml", "application/xml-dtd"],
      loader: function() {
        return import("./xml-PL4IMJYT.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/yaml/yaml.contribution.js
var init_yaml_contribution = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/yaml/yaml.contribution.js"() {
    init_contribution();
    registerLanguage({
      id: "yaml",
      extensions: [".yaml", ".yml"],
      aliases: ["YAML", "yaml", "YML", "yml"],
      mimetypes: ["application/x-yaml", "text/x-yaml"],
      loader: function() {
        return import("./yaml-NGXC4OBO.js");
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/monaco.contribution.js
var init_monaco_contribution5 = __esm({
  "node_modules/monaco-editor/esm/vs/basic-languages/monaco.contribution.js"() {
    init_editor_api();
    init_abap_contribution();
    init_apex_contribution();
    init_azcli_contribution();
    init_bat_contribution();
    init_bicep_contribution();
    init_cameligo_contribution();
    init_clojure_contribution();
    init_coffee_contribution();
    init_cpp_contribution();
    init_csharp_contribution();
    init_csp_contribution();
    init_css_contribution();
    init_dart_contribution();
    init_dockerfile_contribution();
    init_ecl_contribution();
    init_elixir_contribution();
    init_flow9_contribution();
    init_fsharp_contribution();
    init_go_contribution();
    init_graphql_contribution();
    init_handlebars_contribution();
    init_hcl_contribution();
    init_html_contribution();
    init_ini_contribution();
    init_java_contribution();
    init_javascript_contribution();
    init_julia_contribution();
    init_kotlin_contribution();
    init_less_contribution();
    init_lexon_contribution();
    init_lua_contribution();
    init_liquid_contribution();
    init_m3_contribution();
    init_markdown_contribution();
    init_mips_contribution();
    init_msdax_contribution();
    init_mysql_contribution();
    init_objective_c_contribution();
    init_pascal_contribution();
    init_pascaligo_contribution();
    init_perl_contribution();
    init_pgsql_contribution();
    init_php_contribution();
    init_postiats_contribution();
    init_powerquery_contribution();
    init_powershell_contribution();
    init_pug_contribution();
    init_python_contribution();
    init_qsharp_contribution();
    init_r_contribution();
    init_razor_contribution();
    init_redis_contribution();
    init_redshift_contribution();
    init_restructuredtext_contribution();
    init_ruby_contribution();
    init_rust_contribution();
    init_sb_contribution();
    init_scala_contribution();
    init_scheme_contribution();
    init_scss_contribution();
    init_shell_contribution();
    init_solidity_contribution();
    init_sophia_contribution();
    init_sparql_contribution();
    init_sql_contribution();
    init_st_contribution();
    init_swift_contribution();
    init_systemverilog_contribution();
    init_tcl_contribution();
    init_twig_contribution();
    init_typescript_contribution();
    init_vb_contribution();
    init_xml_contribution();
    init_yaml_contribution();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/anchorSelect.js
var __decorate, __param, __awaiter2, SelectionAnchorSet, SelectionAnchorController, SetSelectionAnchor, GoToSelectionAnchor, SelectFromAnchorToCursor, CancelSelectionAnchor;
var init_anchorSelect = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/anchorSelect.js"() {
    init_aria();
    init_htmlContent();
    init_keyCodes();
    init_editorExtensions();
    init_selection();
    init_editorContextKeys();
    init_nls();
    init_contextkey();
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
    SelectionAnchorController = class SelectionAnchorController2 {
      constructor(editor2, contextKeyService) {
        this.editor = editor2;
        this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
        this.modelChangeListener = editor2.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
      }
      static get(editor2) {
        return editor2.getContribution(SelectionAnchorController2.ID);
      }
      setSelectionAnchor() {
        if (this.editor.hasModel()) {
          const position = this.editor.getPosition();
          const previousDecorations = this.decorationId ? [this.decorationId] : [];
          const newDecorationId = this.editor.deltaDecorations(previousDecorations, [{
            range: Selection.fromPositions(position, position),
            options: {
              description: "selection-anchor",
              stickiness: 1,
              hoverMessage: new MarkdownString().appendText(localize("selectionAnchor", "Selection Anchor")),
              className: "selection-anchor"
            }
          }]);
          this.decorationId = newDecorationId[0];
          this.selectionAnchorSetContextKey.set(!!this.decorationId);
          alert(localize("anchorSet", "Anchor set at {0}:{1}", position.lineNumber, position.column));
        }
      }
      goToSelectionAnchor() {
        if (this.editor.hasModel() && this.decorationId) {
          const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
          if (anchorPosition) {
            this.editor.setPosition(anchorPosition.getStartPosition());
          }
        }
      }
      selectFromAnchorToCursor() {
        if (this.editor.hasModel() && this.decorationId) {
          const start = this.editor.getModel().getDecorationRange(this.decorationId);
          if (start) {
            const end = this.editor.getPosition();
            this.editor.setSelection(Selection.fromPositions(start.getStartPosition(), end));
            this.cancelSelectionAnchor();
          }
        }
      }
      cancelSelectionAnchor() {
        if (this.decorationId) {
          this.editor.deltaDecorations([this.decorationId], []);
          this.decorationId = void 0;
          this.selectionAnchorSetContextKey.set(false);
        }
      }
      dispose() {
        this.cancelSelectionAnchor();
        this.modelChangeListener.dispose();
      }
    };
    SelectionAnchorController.ID = "editor.contrib.selectionAnchorController";
    SelectionAnchorController = __decorate([
      __param(1, IContextKeyService)
    ], SelectionAnchorController);
    SetSelectionAnchor = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.setSelectionAnchor",
          label: localize("setSelectionAnchor", "Set Selection Anchor"),
          alias: "Set Selection Anchor",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 32
              /* KEY_B */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const controller = SelectionAnchorController.get(editor2);
          controller.setSelectionAnchor();
        });
      }
    };
    GoToSelectionAnchor = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.goToSelectionAnchor",
          label: localize("goToSelectionAnchor", "Go to Selection Anchor"),
          alias: "Go to Selection Anchor",
          precondition: SelectionAnchorSet
        });
      }
      run(_accessor, editor2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const controller = SelectionAnchorController.get(editor2);
          controller.goToSelectionAnchor();
        });
      }
    };
    SelectFromAnchorToCursor = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.selectFromAnchorToCursor",
          label: localize("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
          alias: "Select from Anchor to Cursor",
          precondition: SelectionAnchorSet,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 41
              /* KEY_K */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const controller = SelectionAnchorController.get(editor2);
          controller.selectFromAnchorToCursor();
        });
      }
    };
    CancelSelectionAnchor = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.cancelSelectionAnchor",
          label: localize("cancelSelectionAnchor", "Cancel Selection Anchor"),
          alias: "Cancel Selection Anchor",
          precondition: SelectionAnchorSet,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 9,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        return __awaiter2(this, void 0, void 0, function* () {
          const controller = SelectionAnchorController.get(editor2);
          controller.cancelSelectionAnchor();
        });
      }
    };
    registerEditorContribution(SelectionAnchorController.ID, SelectionAnchorController);
    registerEditorAction(SetSelectionAnchor);
    registerEditorAction(GoToSelectionAnchor);
    registerEditorAction(SelectFromAnchorToCursor);
    registerEditorAction(CancelSelectionAnchor);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/bracketMatching.js
var overviewRulerBracketMatchForeground, JumpToBracketAction, SelectToBracketAction, BracketsData, BracketMatchingController;
var init_bracketMatching = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/bracketMatching.js"() {
    init_async();
    init_lifecycle();
    init_editorExtensions();
    init_position();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_model();
    init_textModel();
    init_editorColorRegistry();
    init_nls();
    init_actions2();
    init_colorRegistry();
    init_themeService();
    overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hc: "#A0A0A0" }, localize("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
    JumpToBracketAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.jumpToBracket",
          label: localize("smartSelect.jumpBracket", "Go to Bracket"),
          alias: "Go to Bracket",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 88,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        let controller = BracketMatchingController.get(editor2);
        if (!controller) {
          return;
        }
        controller.jumpToBracket();
      }
    };
    SelectToBracketAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.selectToBracket",
          label: localize("smartSelect.selectToBracket", "Select to Bracket"),
          alias: "Select to Bracket",
          precondition: void 0,
          description: {
            description: `Select to Bracket`,
            args: [{
              name: "args",
              schema: {
                type: "object",
                properties: {
                  "selectBrackets": {
                    type: "boolean",
                    default: true
                  }
                }
              }
            }]
          }
        });
      }
      run(accessor, editor2, args) {
        const controller = BracketMatchingController.get(editor2);
        if (!controller) {
          return;
        }
        let selectBrackets = true;
        if (args && args.selectBrackets === false) {
          selectBrackets = false;
        }
        controller.selectToBracket(selectBrackets);
      }
    };
    BracketsData = class {
      constructor(position, brackets, options) {
        this.position = position;
        this.brackets = brackets;
        this.options = options;
      }
    };
    BracketMatchingController = class _BracketMatchingController extends Disposable {
      constructor(editor2) {
        super();
        this._editor = editor2;
        this._lastBracketsData = [];
        this._lastVersionId = 0;
        this._decorations = [];
        this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
        this._matchBrackets = this._editor.getOption(
          63
          /* matchBrackets */
        );
        this._updateBracketsSoon.schedule();
        this._register(editor2.onDidChangeCursorPosition((e) => {
          if (this._matchBrackets === "never") {
            return;
          }
          this._updateBracketsSoon.schedule();
        }));
        this._register(editor2.onDidChangeModelContent((e) => {
          this._updateBracketsSoon.schedule();
        }));
        this._register(editor2.onDidChangeModel((e) => {
          this._lastBracketsData = [];
          this._decorations = [];
          this._updateBracketsSoon.schedule();
        }));
        this._register(editor2.onDidChangeModelLanguageConfiguration((e) => {
          this._lastBracketsData = [];
          this._updateBracketsSoon.schedule();
        }));
        this._register(editor2.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            63
            /* matchBrackets */
          )) {
            this._matchBrackets = this._editor.getOption(
              63
              /* matchBrackets */
            );
            this._decorations = this._editor.deltaDecorations(this._decorations, []);
            this._lastBracketsData = [];
            this._lastVersionId = 0;
            this._updateBracketsSoon.schedule();
          }
        }));
      }
      static get(editor2) {
        return editor2.getContribution(_BracketMatchingController.ID);
      }
      jumpToBracket() {
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        const newSelections = this._editor.getSelections().map((selection) => {
          const position = selection.getStartPosition();
          const brackets = model.matchBracket(position);
          let newCursorPosition = null;
          if (brackets) {
            if (brackets[0].containsPosition(position)) {
              newCursorPosition = brackets[1].getStartPosition();
            } else if (brackets[1].containsPosition(position)) {
              newCursorPosition = brackets[0].getStartPosition();
            }
          } else {
            const enclosingBrackets = model.findEnclosingBrackets(position);
            if (enclosingBrackets) {
              newCursorPosition = enclosingBrackets[0].getStartPosition();
            } else {
              const nextBracket = model.findNextBracket(position);
              if (nextBracket && nextBracket.range) {
                newCursorPosition = nextBracket.range.getStartPosition();
              }
            }
          }
          if (newCursorPosition) {
            return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
          }
          return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
        });
        this._editor.setSelections(newSelections);
        this._editor.revealRange(newSelections[0]);
      }
      selectToBracket(selectBrackets) {
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        const newSelections = [];
        this._editor.getSelections().forEach((selection) => {
          const position = selection.getStartPosition();
          let brackets = model.matchBracket(position);
          if (!brackets) {
            brackets = model.findEnclosingBrackets(position);
            if (!brackets) {
              const nextBracket = model.findNextBracket(position);
              if (nextBracket && nextBracket.range) {
                brackets = model.matchBracket(nextBracket.range.getStartPosition());
              }
            }
          }
          let selectFrom = null;
          let selectTo = null;
          if (brackets) {
            brackets.sort(Range.compareRangesUsingStarts);
            const [open, close] = brackets;
            selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
            selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
            if (close.containsPosition(position)) {
              const tmp = selectFrom;
              selectFrom = selectTo;
              selectTo = tmp;
            }
          }
          if (selectFrom && selectTo) {
            newSelections.push(new Selection(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
          }
        });
        if (newSelections.length > 0) {
          this._editor.setSelections(newSelections);
          this._editor.revealRange(newSelections[0]);
        }
      }
      _updateBrackets() {
        if (this._matchBrackets === "never") {
          return;
        }
        this._recomputeBrackets();
        let newDecorations = [], newDecorationsLen = 0;
        for (const bracketData of this._lastBracketsData) {
          let brackets = bracketData.brackets;
          if (brackets) {
            newDecorations[newDecorationsLen++] = { range: brackets[0], options: bracketData.options };
            newDecorations[newDecorationsLen++] = { range: brackets[1], options: bracketData.options };
          }
        }
        this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);
      }
      _recomputeBrackets() {
        if (!this._editor.hasModel()) {
          this._lastBracketsData = [];
          this._lastVersionId = 0;
          return;
        }
        const selections = this._editor.getSelections();
        if (selections.length > 100) {
          this._lastBracketsData = [];
          this._lastVersionId = 0;
          return;
        }
        const model = this._editor.getModel();
        const versionId = model.getVersionId();
        let previousData = [];
        if (this._lastVersionId === versionId) {
          previousData = this._lastBracketsData;
        }
        let positions = [], positionsLen = 0;
        for (let i = 0, len = selections.length; i < len; i++) {
          let selection = selections[i];
          if (selection.isEmpty()) {
            positions[positionsLen++] = selection.getStartPosition();
          }
        }
        if (positions.length > 1) {
          positions.sort(Position.compare);
        }
        let newData = [], newDataLen = 0;
        let previousIndex = 0, previousLen = previousData.length;
        for (let i = 0, len = positions.length; i < len; i++) {
          let position = positions[i];
          while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
            previousIndex++;
          }
          if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
            newData[newDataLen++] = previousData[previousIndex];
          } else {
            let brackets = model.matchBracket(position);
            let options = _BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
            if (!brackets && this._matchBrackets === "always") {
              brackets = model.findEnclosingBrackets(
                position,
                20
                /* give at most 20ms to compute */
              );
              options = _BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
            }
            newData[newDataLen++] = new BracketsData(position, brackets, options);
          }
        }
        this._lastBracketsData = newData;
        this._lastVersionId = versionId;
      }
    };
    BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
    BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
      description: "bracket-match-overview",
      stickiness: 1,
      className: "bracket-match",
      overviewRuler: {
        color: themeColorFromId(overviewRulerBracketMatchForeground),
        position: OverviewRulerLane.Center
      }
    });
    BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
      description: "bracket-match-no-overview",
      stickiness: 1,
      className: "bracket-match"
    });
    registerEditorContribution(BracketMatchingController.ID, BracketMatchingController);
    registerEditorAction(SelectToBracketAction);
    registerEditorAction(JumpToBracketAction);
    registerThemingParticipant((theme, collector) => {
      const bracketMatchBackground = theme.getColor(editorBracketMatchBackground);
      if (bracketMatchBackground) {
        collector.addRule(`.monaco-editor .bracket-match { background-color: ${bracketMatchBackground}; }`);
      }
      const bracketMatchBorder = theme.getColor(editorBracketMatchBorder);
      if (bracketMatchBorder) {
        collector.addRule(`.monaco-editor .bracket-match { border: 1px solid ${bracketMatchBorder}; }`);
      }
    });
    MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
      group: "5_infile_nav",
      command: {
        id: "editor.action.jumpToBracket",
        title: localize({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
      },
      order: 2
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/moveCaretCommand.js
var MoveCaretCommand;
var init_moveCaretCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/moveCaretCommand.js"() {
    init_range();
    init_selection();
    MoveCaretCommand = class {
      constructor(selection, isMovingLeft) {
        this._selection = selection;
        this._isMovingLeft = isMovingLeft;
      }
      getEditOperations(model, builder) {
        if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) {
          return;
        }
        const lineNumber = this._selection.startLineNumber;
        const startColumn = this._selection.startColumn;
        const endColumn = this._selection.endColumn;
        if (this._isMovingLeft && startColumn === 1) {
          return;
        }
        if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) {
          return;
        }
        if (this._isMovingLeft) {
          const rangeBefore = new Range(lineNumber, startColumn - 1, lineNumber, startColumn);
          const charBefore = model.getValueInRange(rangeBefore);
          builder.addEditOperation(rangeBefore, null);
          builder.addEditOperation(new Range(lineNumber, endColumn, lineNumber, endColumn), charBefore);
        } else {
          const rangeAfter = new Range(lineNumber, endColumn, lineNumber, endColumn + 1);
          const charAfter = model.getValueInRange(rangeAfter);
          builder.addEditOperation(rangeAfter, null);
          builder.addEditOperation(new Range(lineNumber, startColumn, lineNumber, startColumn), charAfter);
        }
      }
      computeCursorState(model, helper) {
        if (this._isMovingLeft) {
          return new Selection(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
        } else {
          return new Selection(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/caretOperations.js
var MoveCaretAction, MoveCaretLeftAction, MoveCaretRightAction;
var init_caretOperations = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/caretOperations.js"() {
    init_editorExtensions();
    init_editorContextKeys();
    init_moveCaretCommand();
    init_nls();
    MoveCaretAction = class extends EditorAction {
      constructor(left, opts) {
        super(opts);
        this.left = left;
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        let commands = [];
        let selections = editor2.getSelections();
        for (const selection of selections) {
          commands.push(new MoveCaretCommand(selection, this.left));
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    MoveCaretLeftAction = class extends MoveCaretAction {
      constructor() {
        super(true, {
          id: "editor.action.moveCarretLeftAction",
          label: localize("caret.moveLeft", "Move Selected Text Left"),
          alias: "Move Selected Text Left",
          precondition: EditorContextKeys.writable
        });
      }
    };
    MoveCaretRightAction = class extends MoveCaretAction {
      constructor() {
        super(false, {
          id: "editor.action.moveCarretRightAction",
          label: localize("caret.moveRight", "Move Selected Text Right"),
          alias: "Move Selected Text Right",
          precondition: EditorContextKeys.writable
        });
      }
    };
    registerEditorAction(MoveCaretLeftAction);
    registerEditorAction(MoveCaretRightAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/transpose.js
var TransposeLettersAction;
var init_transpose = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/transpose.js"() {
    init_editorExtensions();
    init_replaceCommand();
    init_cursorMoveOperations();
    init_range();
    init_editorContextKeys();
    init_nls();
    TransposeLettersAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.transposeLetters",
          label: localize("transposeLetters.label", "Transpose Letters"),
          alias: "Transpose Letters",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 256 | 50
              /* KEY_T */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        let model = editor2.getModel();
        let commands = [];
        let selections = editor2.getSelections();
        for (let selection of selections) {
          if (!selection.isEmpty()) {
            continue;
          }
          let lineNumber = selection.startLineNumber;
          let column = selection.startColumn;
          let lastColumn = model.getLineMaxColumn(lineNumber);
          if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) {
            continue;
          }
          let endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
          let middlePosition = MoveOperations.leftPosition(model, endPosition);
          let beginPosition = MoveOperations.leftPosition(model, middlePosition);
          let leftChar = model.getValueInRange(Range.fromPositions(beginPosition, middlePosition));
          let rightChar = model.getValueInRange(Range.fromPositions(middlePosition, endPosition));
          let replaceRange = Range.fromPositions(beginPosition, endPosition);
          commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
        }
        if (commands.length > 0) {
          editor2.pushUndoStop();
          editor2.executeCommands(this.id, commands);
          editor2.pushUndoStop();
        }
      }
    };
    registerEditorAction(TransposeLettersAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/clipboard.js
function registerCommand(command) {
  command.register();
  return command;
}
function registerExecCommandImpl(target, browserCommand) {
  if (!target) {
    return;
  }
  target.addImplementation(1e4, "code-editor", (accessor, args) => {
    const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const emptySelectionClipboard = focusedEditor.getOption(
        32
        /* emptySelectionClipboard */
      );
      const selection = focusedEditor.getSelection();
      if (selection && selection.isEmpty() && !emptySelectionClipboard) {
        return true;
      }
      document.execCommand(browserCommand);
      return true;
    }
    return false;
  });
  target.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand(browserCommand);
    return true;
  });
}
var __awaiter3, CLIPBOARD_CONTEXT_MENU_GROUP, supportsCut, supportsCopy, supportsPaste, CutAction, CopyAction, PasteAction, ExecCommandCopyWithSyntaxHighlightingAction;
var init_clipboard = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/clipboard.js"() {
    init_browser();
    init_platform();
    init_textAreaInput();
    init_editorExtensions();
    init_codeEditorService();
    init_editorContextKeys();
    init_nls();
    init_actions2();
    init_clipboardService();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
    supportsCut = isNative || document.queryCommandSupported("cut");
    supportsCopy = isNative || document.queryCommandSupported("copy");
    supportsPaste = typeof navigator.clipboard === "undefined" || isFirefox ? document.queryCommandSupported("paste") : true;
    CutAction = supportsCut ? registerCommand(new MultiCommand({
      id: "editor.action.clipboardCutAction",
      precondition: void 0,
      kbOpts: (
        // Do not bind cut keybindings in the browser,
        // since browsers do that for us and it avoids security prompts
        isNative ? {
          primary: 2048 | 54,
          win: { primary: 2048 | 54, secondary: [
            1024 | 20
            /* Delete */
          ] },
          weight: 100
          /* EditorContrib */
        } : void 0
      ),
      menuOpts: [{
        menuId: MenuId.MenubarEditMenu,
        group: "2_ccp",
        title: localize({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
        order: 1
      }, {
        menuId: MenuId.EditorContext,
        group: CLIPBOARD_CONTEXT_MENU_GROUP,
        title: localize("actions.clipboard.cutLabel", "Cut"),
        when: EditorContextKeys.writable,
        order: 1
      }, {
        menuId: MenuId.CommandPalette,
        group: "",
        title: localize("actions.clipboard.cutLabel", "Cut"),
        order: 1
      }, {
        menuId: MenuId.SimpleEditorContext,
        group: CLIPBOARD_CONTEXT_MENU_GROUP,
        title: localize("actions.clipboard.cutLabel", "Cut"),
        when: EditorContextKeys.writable,
        order: 1
      }]
    })) : void 0;
    CopyAction = supportsCopy ? registerCommand(new MultiCommand({
      id: "editor.action.clipboardCopyAction",
      precondition: void 0,
      kbOpts: (
        // Do not bind copy keybindings in the browser,
        // since browsers do that for us and it avoids security prompts
        isNative ? {
          primary: 2048 | 33,
          win: { primary: 2048 | 33, secondary: [
            2048 | 19
            /* Insert */
          ] },
          weight: 100
          /* EditorContrib */
        } : void 0
      ),
      menuOpts: [{
        menuId: MenuId.MenubarEditMenu,
        group: "2_ccp",
        title: localize({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
        order: 2
      }, {
        menuId: MenuId.EditorContext,
        group: CLIPBOARD_CONTEXT_MENU_GROUP,
        title: localize("actions.clipboard.copyLabel", "Copy"),
        order: 2
      }, {
        menuId: MenuId.CommandPalette,
        group: "",
        title: localize("actions.clipboard.copyLabel", "Copy"),
        order: 1
      }, {
        menuId: MenuId.SimpleEditorContext,
        group: CLIPBOARD_CONTEXT_MENU_GROUP,
        title: localize("actions.clipboard.copyLabel", "Copy"),
        order: 2
      }]
    })) : void 0;
    MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: "2_ccp", order: 3 });
    MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
    PasteAction = supportsPaste ? registerCommand(new MultiCommand({
      id: "editor.action.clipboardPasteAction",
      precondition: void 0,
      kbOpts: (
        // Do not bind paste keybindings in the browser,
        // since browsers do that for us and it avoids security prompts
        isNative ? {
          primary: 2048 | 52,
          win: { primary: 2048 | 52, secondary: [
            1024 | 19
            /* Insert */
          ] },
          linux: { primary: 2048 | 52, secondary: [
            1024 | 19
            /* Insert */
          ] },
          weight: 100
          /* EditorContrib */
        } : void 0
      ),
      menuOpts: [{
        menuId: MenuId.MenubarEditMenu,
        group: "2_ccp",
        title: localize({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
        order: 4
      }, {
        menuId: MenuId.EditorContext,
        group: CLIPBOARD_CONTEXT_MENU_GROUP,
        title: localize("actions.clipboard.pasteLabel", "Paste"),
        when: EditorContextKeys.writable,
        order: 4
      }, {
        menuId: MenuId.CommandPalette,
        group: "",
        title: localize("actions.clipboard.pasteLabel", "Paste"),
        order: 1
      }, {
        menuId: MenuId.SimpleEditorContext,
        group: CLIPBOARD_CONTEXT_MENU_GROUP,
        title: localize("actions.clipboard.pasteLabel", "Paste"),
        when: EditorContextKeys.writable,
        order: 4
      }]
    })) : void 0;
    ExecCommandCopyWithSyntaxHighlightingAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
          label: localize("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
          alias: "Copy With Syntax Highlighting",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const emptySelectionClipboard = editor2.getOption(
          32
          /* emptySelectionClipboard */
        );
        if (!emptySelectionClipboard && editor2.getSelection().isEmpty()) {
          return;
        }
        CopyOptions.forceCopyWithSyntaxHighlighting = true;
        editor2.focus();
        document.execCommand("copy");
        CopyOptions.forceCopyWithSyntaxHighlighting = false;
      }
    };
    registerExecCommandImpl(CutAction, "cut");
    registerExecCommandImpl(CopyAction, "copy");
    if (PasteAction) {
      PasteAction.addImplementation(1e4, "code-editor", (accessor, args) => {
        const codeEditorService = accessor.get(ICodeEditorService);
        const clipboardService = accessor.get(IClipboardService);
        const focusedEditor = codeEditorService.getFocusedCodeEditor();
        if (focusedEditor && focusedEditor.hasTextFocus()) {
          const result = document.execCommand("paste");
          if (!result && isWeb) {
            return (() => __awaiter3(void 0, void 0, void 0, function* () {
              const clipboardText = yield clipboardService.readText();
              if (clipboardText !== "") {
                const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
                let pasteOnNewLine = false;
                let multicursorText = null;
                let mode = null;
                if (metadata) {
                  pasteOnNewLine = focusedEditor.getOption(
                    32
                    /* emptySelectionClipboard */
                  ) && !!metadata.isFromEmptySelection;
                  multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
                  mode = metadata.mode;
                }
                focusedEditor.trigger("keyboard", "paste", {
                  text: clipboardText,
                  pasteOnNewLine,
                  multicursorText,
                  mode
                });
              }
            }))();
          }
          return true;
        }
        return false;
      });
      PasteAction.addImplementation(0, "generic-dom", (accessor, args) => {
        document.execCommand("paste");
        return true;
      });
    }
    if (supportsCopy) {
      registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
    }
  }
});

// node_modules/monaco-editor/esm/vs/base/common/lazy.js
var Lazy;
var init_lazy = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/lazy.js"() {
    Lazy = class {
      constructor(executor) {
        this.executor = executor;
        this._didRun = false;
      }
      /**
       * Get the wrapped value.
       *
       * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
       * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
       */
      getValue() {
        if (!this._didRun) {
          try {
            this._value = this.executor();
          } catch (err) {
            this._error = err;
          } finally {
            this._didRun = true;
          }
        }
        if (this._error) {
          throw this._error;
        }
        return this._value;
      }
      /**
       * Get the wrapped value without forcing evaluation.
       */
      get rawValue() {
        return this._value;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/types.js
function mayIncludeActionsOfKind(filter, providedKind) {
  if (filter.include && !filter.include.intersects(providedKind)) {
    return false;
  }
  if (filter.excludes) {
    if (filter.excludes.some((exclude) => excludesAction(providedKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions && CodeActionKind.Source.contains(providedKind)) {
    return false;
  }
  return true;
}
function filtersAction(filter, action) {
  const actionKind = action.kind ? new CodeActionKind(action.kind) : void 0;
  if (filter.include) {
    if (!actionKind || !filter.include.contains(actionKind)) {
      return false;
    }
  }
  if (filter.excludes) {
    if (actionKind && filter.excludes.some((exclude) => excludesAction(actionKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions) {
    if (actionKind && CodeActionKind.Source.contains(actionKind)) {
      return false;
    }
  }
  if (filter.onlyIncludePreferredActions) {
    if (!action.isPreferred) {
      return false;
    }
  }
  return true;
}
function excludesAction(providedKind, exclude, include) {
  if (!exclude.contains(providedKind)) {
    return false;
  }
  if (include && exclude.contains(include)) {
    return false;
  }
  return true;
}
var CodeActionKind, CodeActionCommandArgs;
var init_types2 = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/types.js"() {
    CodeActionKind = class _CodeActionKind {
      constructor(value) {
        this.value = value;
      }
      equals(other) {
        return this.value === other.value;
      }
      contains(other) {
        return this.equals(other) || this.value === "" || other.value.startsWith(this.value + _CodeActionKind.sep);
      }
      intersects(other) {
        return this.contains(other) || other.contains(this);
      }
      append(part) {
        return new _CodeActionKind(this.value + _CodeActionKind.sep + part);
      }
    };
    CodeActionKind.sep = ".";
    CodeActionKind.None = new CodeActionKind("@@none@@");
    CodeActionKind.Empty = new CodeActionKind("");
    CodeActionKind.QuickFix = new CodeActionKind("quickfix");
    CodeActionKind.Refactor = new CodeActionKind("refactor");
    CodeActionKind.Source = new CodeActionKind("source");
    CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
    CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
    CodeActionCommandArgs = class _CodeActionCommandArgs {
      constructor(kind, apply2, preferred) {
        this.kind = kind;
        this.apply = apply2;
        this.preferred = preferred;
      }
      static fromUser(arg, defaults) {
        if (!arg || typeof arg !== "object") {
          return new _CodeActionCommandArgs(defaults.kind, defaults.apply, false);
        }
        return new _CodeActionCommandArgs(_CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), _CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), _CodeActionCommandArgs.getPreferredUser(arg));
      }
      static getApplyFromUser(arg, defaultAutoApply) {
        switch (typeof arg.apply === "string" ? arg.apply.toLowerCase() : "") {
          case "first":
            return "first";
          case "never":
            return "never";
          case "ifsingle":
            return "ifSingle";
          default:
            return defaultAutoApply;
        }
      }
      static getKindFromUser(arg, defaultKind) {
        return typeof arg.kind === "string" ? new CodeActionKind(arg.kind) : defaultKind;
      }
      static getPreferredUser(arg) {
        return typeof arg.preferred === "boolean" ? arg.preferred : false;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeAction.js
function getCodeActions(model, rangeOrSelection, trigger, progress, token) {
  var _a5;
  const filter = trigger.filter || {};
  const codeActionContext = {
    only: (_a5 = filter.include) === null || _a5 === void 0 ? void 0 : _a5.value,
    trigger: trigger.type
  };
  const cts = new TextModelCancellationTokenSource(model, token);
  const providers = getCodeActionProviders(model, filter);
  const disposables = new DisposableStore();
  const promises = providers.map((provider) => __awaiter4(this, void 0, void 0, function* () {
    try {
      progress.report(provider);
      const providedCodeActions = yield provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
      if (providedCodeActions) {
        disposables.add(providedCodeActions);
      }
      if (cts.token.isCancellationRequested) {
        return emptyCodeActionsResponse;
      }
      const filteredActions = ((providedCodeActions === null || providedCodeActions === void 0 ? void 0 : providedCodeActions.actions) || []).filter((action) => action && filtersAction(filter, action));
      const documentation = getDocumentation(provider, filteredActions, filter.include);
      return {
        actions: filteredActions.map((action) => new CodeActionItem(action, provider)),
        documentation
      };
    } catch (err) {
      if (isPromiseCanceledError(err)) {
        throw err;
      }
      onUnexpectedExternalError(err);
      return emptyCodeActionsResponse;
    }
  }));
  const listener = CodeActionProviderRegistry.onDidChange(() => {
    const newProviders = CodeActionProviderRegistry.all(model);
    if (!equals(newProviders, providers)) {
      cts.cancel();
    }
  });
  return Promise.all(promises).then((actions) => {
    const allActions = flatten(actions.map((x) => x.actions));
    const allDocumentation = coalesce(actions.map((x) => x.documentation));
    return new ManagedCodeActionSet(allActions, allDocumentation, disposables);
  }).finally(() => {
    listener.dispose();
    cts.dispose();
  });
}
function getCodeActionProviders(model, filter) {
  return CodeActionProviderRegistry.all(model).filter((provider) => {
    if (!provider.providedCodeActionKinds) {
      return true;
    }
    return provider.providedCodeActionKinds.some((kind) => mayIncludeActionsOfKind(filter, new CodeActionKind(kind)));
  });
}
function getDocumentation(provider, providedCodeActions, only) {
  if (!provider.documentation) {
    return void 0;
  }
  const documentation = provider.documentation.map((entry) => ({ kind: new CodeActionKind(entry.kind), command: entry.command }));
  if (only) {
    let currentBest;
    for (const entry of documentation) {
      if (entry.kind.contains(only)) {
        if (!currentBest) {
          currentBest = entry;
        } else {
          if (currentBest.kind.contains(entry.kind)) {
            currentBest = entry;
          }
        }
      }
    }
    if (currentBest) {
      return currentBest === null || currentBest === void 0 ? void 0 : currentBest.command;
    }
  }
  for (const action of providedCodeActions) {
    if (!action.kind) {
      continue;
    }
    for (const entry of documentation) {
      if (entry.kind.contains(new CodeActionKind(action.kind))) {
        return entry.command;
      }
    }
  }
  return void 0;
}
var __awaiter4, codeActionCommandId, refactorCommandId, sourceActionCommandId, organizeImportsCommandId, fixAllCommandId, CodeActionItem, ManagedCodeActionSet, emptyCodeActionsResponse;
var init_codeAction = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeAction.js"() {
    init_arrays();
    init_cancellation();
    init_errors();
    init_lifecycle();
    init_uri();
    init_editorState();
    init_range();
    init_selection();
    init_modes();
    init_modelService();
    init_commands();
    init_progress();
    init_types2();
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    codeActionCommandId = "editor.action.codeAction";
    refactorCommandId = "editor.action.refactor";
    sourceActionCommandId = "editor.action.sourceAction";
    organizeImportsCommandId = "editor.action.organizeImports";
    fixAllCommandId = "editor.action.fixAll";
    CodeActionItem = class {
      constructor(action, provider) {
        this.action = action;
        this.provider = provider;
      }
      resolve(token) {
        var _a5;
        return __awaiter4(this, void 0, void 0, function* () {
          if (((_a5 = this.provider) === null || _a5 === void 0 ? void 0 : _a5.resolveCodeAction) && !this.action.edit) {
            let action;
            try {
              action = yield this.provider.resolveCodeAction(this.action, token);
            } catch (err) {
              onUnexpectedExternalError(err);
            }
            if (action) {
              this.action.edit = action.edit;
            }
          }
          return this;
        });
      }
    };
    ManagedCodeActionSet = class _ManagedCodeActionSet extends Disposable {
      constructor(actions, documentation, disposables) {
        super();
        this.documentation = documentation;
        this._register(disposables);
        this.allActions = [...actions].sort(_ManagedCodeActionSet.codeActionsComparator);
        this.validActions = this.allActions.filter(({ action }) => !action.disabled);
      }
      static codeActionsComparator({ action: a }, { action: b }) {
        if (a.isPreferred && !b.isPreferred) {
          return -1;
        } else if (!a.isPreferred && b.isPreferred) {
          return 1;
        }
        if (isNonEmptyArray(a.diagnostics)) {
          if (isNonEmptyArray(b.diagnostics)) {
            return a.diagnostics[0].message.localeCompare(b.diagnostics[0].message);
          } else {
            return -1;
          }
        } else if (isNonEmptyArray(b.diagnostics)) {
          return 1;
        } else {
          return 0;
        }
      }
      get hasAutoFix() {
        return this.validActions.some(({ action: fix }) => !!fix.kind && CodeActionKind.QuickFix.contains(new CodeActionKind(fix.kind)) && !!fix.isPreferred);
      }
    };
    emptyCodeActionsResponse = { actions: [], documentation: void 0 };
    CommandsRegistry.registerCommand("_executeCodeActionProvider", function(accessor, resource, rangeOrSelection, kind, itemResolveCount) {
      return __awaiter4(this, void 0, void 0, function* () {
        if (!(resource instanceof URI)) {
          throw illegalArgument();
        }
        const model = accessor.get(IModelService).getModel(resource);
        if (!model) {
          throw illegalArgument();
        }
        const validatedRangeOrSelection = Selection.isISelection(rangeOrSelection) ? Selection.liftSelection(rangeOrSelection) : Range.isIRange(rangeOrSelection) ? model.validateRange(rangeOrSelection) : void 0;
        if (!validatedRangeOrSelection) {
          throw illegalArgument();
        }
        const include = typeof kind === "string" ? new CodeActionKind(kind) : void 0;
        const codeActionSet = yield getCodeActions(model, validatedRangeOrSelection, { type: 1, filter: { includeSourceActions: true, include } }, Progress.None, CancellationToken.None);
        const resolving = [];
        const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === "number" ? itemResolveCount : 0);
        for (let i = 0; i < resolveCount; i++) {
          resolving.push(codeActionSet.validActions[i].resolve(CancellationToken.None));
        }
        try {
          yield Promise.all(resolving);
          return codeActionSet.validActions.map((item) => item.action);
        } finally {
          setTimeout(() => codeActionSet.dispose(), 100);
        }
      });
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.js
var __decorate2, __param2, MessageController, MessageCommand, MessageWidget;
var init_messageController = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.js"() {
    init_aria();
    init_async();
    init_lifecycle();
    init_editorExtensions();
    init_range();
    init_nls();
    init_contextkey();
    init_colorRegistry();
    init_theme();
    init_themeService();
    __decorate2 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param2 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    MessageController = class MessageController2 {
      constructor(editor2, contextKeyService) {
        this._messageWidget = new MutableDisposable();
        this._messageListeners = new DisposableStore();
        this._editor = editor2;
        this._visible = MessageController2.MESSAGE_VISIBLE.bindTo(contextKeyService);
        this._editorListener = this._editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit());
      }
      static get(editor2) {
        return editor2.getContribution(MessageController2.ID);
      }
      dispose() {
        this._editorListener.dispose();
        this._messageListeners.dispose();
        this._messageWidget.dispose();
        this._visible.reset();
      }
      showMessage(message, position) {
        alert(message);
        this._visible.set(true);
        this._messageWidget.clear();
        this._messageListeners.clear();
        this._messageWidget.value = new MessageWidget(this._editor, position, message);
        this._messageListeners.add(this._editor.onDidBlurEditorText(() => this.closeMessage()));
        this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));
        this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));
        this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));
        this._messageListeners.add(new TimeoutTimer(() => this.closeMessage(), 3e3));
        let bounds;
        this._messageListeners.add(this._editor.onMouseMove((e) => {
          if (!e.target.position) {
            return;
          }
          if (!bounds) {
            bounds = new Range(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);
          } else if (!bounds.containsPosition(e.target.position)) {
            this.closeMessage();
          }
        }));
      }
      closeMessage() {
        this._visible.reset();
        this._messageListeners.clear();
        if (this._messageWidget.value) {
          this._messageListeners.add(MessageWidget.fadeOut(this._messageWidget.value));
        }
      }
      _onDidAttemptReadOnlyEdit() {
        if (this._editor.hasModel()) {
          this.showMessage(localize("editor.readonly", "Cannot edit in read-only editor"), this._editor.getPosition());
        }
      }
    };
    MessageController.ID = "editor.contrib.messageController";
    MessageController.MESSAGE_VISIBLE = new RawContextKey("messageVisible", false, localize("messageVisible", "Whether the editor is currently showing an inline message"));
    MessageController = __decorate2([
      __param2(1, IContextKeyService)
    ], MessageController);
    MessageCommand = EditorCommand.bindToContribution(MessageController.get);
    registerEditorCommand(new MessageCommand({
      id: "leaveEditorMessage",
      precondition: MessageController.MESSAGE_VISIBLE,
      handler: (c) => c.closeMessage(),
      kbOpts: {
        weight: 100 + 30,
        primary: 9
        /* Escape */
      }
    }));
    MessageWidget = class {
      constructor(editor2, { lineNumber, column }, text2) {
        this.allowEditorOverflow = true;
        this.suppressMouseDown = false;
        this._editor = editor2;
        this._editor.revealLinesInCenterIfOutsideViewport(
          lineNumber,
          lineNumber,
          0
          /* Smooth */
        );
        this._position = { lineNumber, column: column - 1 };
        this._domNode = document.createElement("div");
        this._domNode.classList.add("monaco-editor-overlaymessage");
        const anchorTop = document.createElement("div");
        anchorTop.classList.add("anchor", "top");
        this._domNode.appendChild(anchorTop);
        const message = document.createElement("div");
        message.classList.add("message");
        message.textContent = text2;
        this._domNode.appendChild(message);
        const anchorBottom = document.createElement("div");
        anchorBottom.classList.add("anchor", "below");
        this._domNode.appendChild(anchorBottom);
        this._editor.addContentWidget(this);
        this._domNode.classList.add("fadeIn");
      }
      static fadeOut(messageWidget) {
        let handle;
        const dispose2 = () => {
          messageWidget.dispose();
          clearTimeout(handle);
          messageWidget.getDomNode().removeEventListener("animationend", dispose2);
        };
        handle = setTimeout(dispose2, 110);
        messageWidget.getDomNode().addEventListener("animationend", dispose2);
        messageWidget.getDomNode().classList.add("fadeOut");
        return { dispose: dispose2 };
      }
      dispose() {
        this._editor.removeContentWidget(this);
      }
      getId() {
        return "messageoverlay";
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        return { position: this._position, preference: [
          1,
          2
          /* BELOW */
        ] };
      }
      afterRender(position) {
        this._domNode.classList.toggle(
          "below",
          position === 2
          /* BELOW */
        );
      }
    };
    registerEditorContribution(MessageController.ID, MessageController);
    registerThemingParticipant((theme, collector) => {
      const border = theme.getColor(inputValidationInfoBorder);
      if (border) {
        let borderWidth = theme.type === ColorScheme.HIGH_CONTRAST ? 2 : 1;
        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .anchor.below { border-top-color: ${border}; }`);
        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .anchor.top { border-bottom-color: ${border}; }`);
        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { border: ${borderWidth}px solid ${border}; }`);
      }
      const background = theme.getColor(inputValidationInfoBackground);
      if (background) {
        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { background-color: ${background}; }`);
      }
      const foreground2 = theme.getColor(inputValidationInfoForeground);
      if (foreground2) {
        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { color: ${foreground2}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionMenu.js
function stripNewlines(str) {
  return str.replace(/\r\n|\r|\n/g, " ");
}
var __decorate3, __param3, __awaiter5, CodeActionAction, CodeActionMenu, CodeActionKeybindingResolver;
var init_codeActionMenu = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionMenu.js"() {
    init_dom();
    init_actions();
    init_errors();
    init_lazy();
    init_lifecycle();
    init_position();
    init_modes();
    init_codeAction();
    init_types2();
    init_contextView();
    init_keybinding();
    __decorate3 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param3 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter5 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CodeActionAction = class extends Action {
      constructor(action, callback) {
        super(action.command ? action.command.id : action.title, stripNewlines(action.title), void 0, !action.disabled, callback);
        this.action = action;
      }
    };
    CodeActionMenu = class CodeActionMenu2 extends Disposable {
      constructor(_editor2, _delegate, _contextMenuService, keybindingService) {
        super();
        this._editor = _editor2;
        this._delegate = _delegate;
        this._contextMenuService = _contextMenuService;
        this._visible = false;
        this._showingActions = this._register(new MutableDisposable());
        this._keybindingResolver = new CodeActionKeybindingResolver({
          getKeybindings: () => keybindingService.getKeybindings()
        });
      }
      get isVisible() {
        return this._visible;
      }
      show(trigger, codeActions, at, options) {
        return __awaiter5(this, void 0, void 0, function* () {
          const actionsToShow = options.includeDisabledActions ? codeActions.allActions : codeActions.validActions;
          if (!actionsToShow.length) {
            this._visible = false;
            return;
          }
          if (!this._editor.getDomNode()) {
            this._visible = false;
            throw canceled();
          }
          this._visible = true;
          this._showingActions.value = codeActions;
          const menuActions = this.getMenuActions(trigger, actionsToShow, codeActions.documentation);
          const anchor = Position.isIPosition(at) ? this._toCoords(at) : at || { x: 0, y: 0 };
          const resolver = this._keybindingResolver.getResolver();
          const useShadowDOM = this._editor.getOption(
            113
            /* useShadowDOM */
          );
          this._contextMenuService.showContextMenu({
            domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
            getAnchor: () => anchor,
            getActions: () => menuActions,
            onHide: () => {
              this._visible = false;
              this._editor.focus();
            },
            autoSelectFirstItem: true,
            getKeyBinding: (action) => action instanceof CodeActionAction ? resolver(action.action) : void 0
          });
        });
      }
      getMenuActions(trigger, actionsToShow, documentation) {
        var _a5, _b2;
        const toCodeActionAction = (item) => new CodeActionAction(item.action, () => this._delegate.onSelectCodeAction(item));
        const result = actionsToShow.map(toCodeActionAction);
        const allDocumentation = [...documentation];
        const model = this._editor.getModel();
        if (model && result.length) {
          for (const provider of CodeActionProviderRegistry.all(model)) {
            if (provider._getAdditionalMenuItems) {
              allDocumentation.push(...provider._getAdditionalMenuItems({ trigger: trigger.type, only: (_b2 = (_a5 = trigger.filter) === null || _a5 === void 0 ? void 0 : _a5.include) === null || _b2 === void 0 ? void 0 : _b2.value }, actionsToShow.map((item) => item.action)));
            }
          }
        }
        if (allDocumentation.length) {
          result.push(new Separator(), ...allDocumentation.map((command) => toCodeActionAction(new CodeActionItem({
            title: command.title,
            command
          }, void 0))));
        }
        return result;
      }
      _toCoords(position) {
        if (!this._editor.hasModel()) {
          return { x: 0, y: 0 };
        }
        this._editor.revealPosition(
          position,
          1
          /* Immediate */
        );
        this._editor.render();
        const cursorCoords = this._editor.getScrolledVisiblePosition(position);
        const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
        const x = editorCoords.left + cursorCoords.left;
        const y = editorCoords.top + cursorCoords.top + cursorCoords.height;
        return { x, y };
      }
    };
    CodeActionMenu = __decorate3([
      __param3(2, IContextMenuService),
      __param3(3, IKeybindingService)
    ], CodeActionMenu);
    CodeActionKeybindingResolver = class _CodeActionKeybindingResolver {
      constructor(_keybindingProvider) {
        this._keybindingProvider = _keybindingProvider;
      }
      getResolver() {
        const allCodeActionBindings = new Lazy(() => this._keybindingProvider.getKeybindings().filter((item) => _CodeActionKeybindingResolver.codeActionCommands.indexOf(item.command) >= 0).filter((item) => item.resolvedKeybinding).map((item) => {
          let commandArgs = item.commandArgs;
          if (item.command === organizeImportsCommandId) {
            commandArgs = { kind: CodeActionKind.SourceOrganizeImports.value };
          } else if (item.command === fixAllCommandId) {
            commandArgs = { kind: CodeActionKind.SourceFixAll.value };
          }
          return Object.assign({ resolvedKeybinding: item.resolvedKeybinding }, CodeActionCommandArgs.fromUser(commandArgs, {
            kind: CodeActionKind.None,
            apply: "never"
            /* Never */
          }));
        }));
        return (action) => {
          if (action.kind) {
            const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.getValue());
            return binding === null || binding === void 0 ? void 0 : binding.resolvedKeybinding;
          }
          return void 0;
        };
      }
      bestKeybindingForCodeAction(action, candidates) {
        if (!action.kind) {
          return void 0;
        }
        const kind = new CodeActionKind(action.kind);
        return candidates.filter((candidate) => candidate.kind.contains(kind)).filter((candidate) => {
          if (candidate.preferred) {
            return action.isPreferred;
          }
          return true;
        }).reduceRight((currentBest, candidate) => {
          if (!currentBest) {
            return candidate;
          }
          return currentBest.kind.contains(candidate.kind) ? candidate : currentBest;
        }, void 0);
      }
    };
    CodeActionKeybindingResolver.codeActionCommands = [
      refactorCommandId,
      codeActionCommandId,
      sourceActionCommandId,
      organizeImportsCommandId,
      fixAllCommandId
    ];
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.js
var __decorate4, __param4, LightBulbState, LightBulbWidget;
var init_lightBulbWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.js"() {
    init_dom();
    init_globalMouseMoveMonitor();
    init_touch();
    init_codicons();
    init_event();
    init_lifecycle();
    init_textModel();
    init_nls();
    init_keybinding();
    init_colorRegistry();
    init_themeService();
    __decorate4 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param4 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    (function(LightBulbState2) {
      LightBulbState2.Hidden = {
        type: 0
        /* Hidden */
      };
      class Showing {
        constructor(actions, trigger, editorPosition, widgetPosition) {
          this.actions = actions;
          this.trigger = trigger;
          this.editorPosition = editorPosition;
          this.widgetPosition = widgetPosition;
          this.type = 1;
        }
      }
      LightBulbState2.Showing = Showing;
    })(LightBulbState || (LightBulbState = {}));
    LightBulbWidget = class LightBulbWidget2 extends Disposable {
      constructor(_editor2, _quickFixActionId, _preferredFixActionId, _keybindingService) {
        super();
        this._editor = _editor2;
        this._quickFixActionId = _quickFixActionId;
        this._preferredFixActionId = _preferredFixActionId;
        this._keybindingService = _keybindingService;
        this._onClick = this._register(new Emitter());
        this.onClick = this._onClick.event;
        this._state = LightBulbState.Hidden;
        this._domNode = document.createElement("div");
        this._domNode.className = Codicon.lightBulb.classNames;
        this._editor.addContentWidget(this);
        this._register(this._editor.onDidChangeModelContent((_) => {
          const editorModel = this._editor.getModel();
          if (this.state.type !== 1 || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) {
            this.hide();
          }
        }));
        Gesture.ignoreTarget(this._domNode);
        this._register(addStandardDisposableGenericMouseDownListner(this._domNode, (e) => {
          if (this.state.type !== 1) {
            return;
          }
          this._editor.focus();
          e.preventDefault();
          const { top, height } = getDomNodePagePosition(this._domNode);
          const lineHeight = this._editor.getOption(
            58
            /* lineHeight */
          );
          let pad = Math.floor(lineHeight / 3);
          if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) {
            pad += lineHeight;
          }
          this._onClick.fire({
            x: e.posx,
            y: top + height + pad,
            actions: this.state.actions,
            trigger: this.state.trigger
          });
        }));
        this._register(addDisposableListener(this._domNode, "mouseenter", (e) => {
          if ((e.buttons & 1) !== 1) {
            return;
          }
          this.hide();
          const monitor = new GlobalMouseMoveMonitor();
          monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, () => {
          }, () => {
            monitor.dispose();
          });
        }));
        this._register(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            56
            /* lightbulb */
          ) && !this._editor.getOption(
            56
            /* lightbulb */
          ).enabled) {
            this.hide();
          }
        }));
        this._updateLightBulbTitleAndIcon();
        this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitleAndIcon, this));
      }
      dispose() {
        super.dispose();
        this._editor.removeContentWidget(this);
      }
      getId() {
        return "LightBulbWidget";
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        return this._state.type === 1 ? this._state.widgetPosition : null;
      }
      update(actions, trigger, atPosition) {
        if (actions.validActions.length <= 0) {
          return this.hide();
        }
        const options = this._editor.getOptions();
        if (!options.get(
          56
          /* lightbulb */
        ).enabled) {
          return this.hide();
        }
        const model = this._editor.getModel();
        if (!model) {
          return this.hide();
        }
        const { lineNumber, column } = model.validatePosition(atPosition);
        const tabSize = model.getOptions().tabSize;
        const fontInfo = options.get(
          43
          /* fontInfo */
        );
        const lineContent = model.getLineContent(lineNumber);
        const indent = TextModel.computeIndentLevel(lineContent, tabSize);
        const lineHasSpace = fontInfo.spaceWidth * indent > 22;
        const isFolded = (lineNumber2) => {
          return lineNumber2 > 2 && this._editor.getTopForLineNumber(lineNumber2) === this._editor.getTopForLineNumber(lineNumber2 - 1);
        };
        let effectiveLineNumber = lineNumber;
        if (!lineHasSpace) {
          if (lineNumber > 1 && !isFolded(lineNumber - 1)) {
            effectiveLineNumber -= 1;
          } else if (!isFolded(lineNumber + 1)) {
            effectiveLineNumber += 1;
          } else if (column * fontInfo.spaceWidth < 22) {
            return this.hide();
          }
        }
        this.state = new LightBulbState.Showing(actions, trigger, atPosition, {
          position: { lineNumber: effectiveLineNumber, column: 1 },
          preference: LightBulbWidget2._posPref
        });
        this._editor.layoutContentWidget(this);
      }
      hide() {
        this.state = LightBulbState.Hidden;
        this._editor.layoutContentWidget(this);
      }
      get state() {
        return this._state;
      }
      set state(value) {
        this._state = value;
        this._updateLightBulbTitleAndIcon();
      }
      _updateLightBulbTitleAndIcon() {
        if (this.state.type === 1 && this.state.actions.hasAutoFix) {
          this._domNode.classList.remove(...Codicon.lightBulb.classNamesArray);
          this._domNode.classList.add(...Codicon.lightbulbAutofix.classNamesArray);
          const preferredKb = this._keybindingService.lookupKeybinding(this._preferredFixActionId);
          if (preferredKb) {
            this.title = localize("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", preferredKb.getLabel());
            return;
          }
        }
        this._domNode.classList.remove(...Codicon.lightbulbAutofix.classNamesArray);
        this._domNode.classList.add(...Codicon.lightBulb.classNamesArray);
        const kb = this._keybindingService.lookupKeybinding(this._quickFixActionId);
        if (kb) {
          this.title = localize("codeActionWithKb", "Show Code Actions ({0})", kb.getLabel());
        } else {
          this.title = localize("codeAction", "Show Code Actions");
        }
      }
      set title(value) {
        this._domNode.title = value;
      }
    };
    LightBulbWidget._posPref = [
      0
      /* EXACT */
    ];
    LightBulbWidget = __decorate4([
      __param4(3, IKeybindingService)
    ], LightBulbWidget);
    registerThemingParticipant((theme, collector) => {
      var _a5;
      const editorBackgroundColor = (_a5 = theme.getColor(editorBackground)) === null || _a5 === void 0 ? void 0 : _a5.transparent(0.7);
      const editorLightBulbForegroundColor = theme.getColor(editorLightBulbForeground);
      if (editorLightBulbForegroundColor) {
        collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightBulb.cssSelector} {
			color: ${editorLightBulbForegroundColor};
			background-color: ${editorBackgroundColor};
		}`);
      }
      const editorLightBulbAutoFixForegroundColor = theme.getColor(editorLightBulbAutoFixForeground);
      if (editorLightBulbAutoFixForegroundColor) {
        collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightbulbAutofix.cssSelector} {
			color: ${editorLightBulbAutoFixForegroundColor};
			background-color: ${editorBackgroundColor};
		}`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionUi.js
var __decorate5, __param5, __awaiter6, __classPrivateFieldSet, __classPrivateFieldGet, _CodeActionUi_disposed, CodeActionUi;
var init_codeActionUi = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionUi.js"() {
    init_errors();
    init_lazy();
    init_lifecycle();
    init_messageController();
    init_instantiation();
    init_codeActionMenu();
    init_lightBulbWidget();
    __decorate5 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param5 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter6 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    CodeActionUi = class CodeActionUi2 extends Disposable {
      constructor(_editor2, quickFixActionId, preferredFixActionId, delegate, instantiationService) {
        super();
        this._editor = _editor2;
        this.delegate = delegate;
        this._activeCodeActions = this._register(new MutableDisposable());
        _CodeActionUi_disposed.set(this, false);
        this._codeActionWidget = new Lazy(() => {
          return this._register(instantiationService.createInstance(CodeActionMenu, this._editor, {
            onSelectCodeAction: (action) => __awaiter6(this, void 0, void 0, function* () {
              this.delegate.applyCodeAction(
                action,
                /* retrigger */
                true
              );
            })
          }));
        });
        this._lightBulbWidget = new Lazy(() => {
          const widget = this._register(instantiationService.createInstance(LightBulbWidget, this._editor, quickFixActionId, preferredFixActionId));
          this._register(widget.onClick((e) => this.showCodeActionList(e.trigger, e.actions, e, { includeDisabledActions: false })));
          return widget;
        });
      }
      dispose() {
        __classPrivateFieldSet(this, _CodeActionUi_disposed, true, "f");
        super.dispose();
      }
      update(newState) {
        var _a5, _b2, _c2;
        return __awaiter6(this, void 0, void 0, function* () {
          if (newState.type !== 1) {
            (_a5 = this._lightBulbWidget.rawValue) === null || _a5 === void 0 ? void 0 : _a5.hide();
            return;
          }
          let actions;
          try {
            actions = yield newState.actions;
          } catch (e) {
            onUnexpectedError(e);
            return;
          }
          if (__classPrivateFieldGet(this, _CodeActionUi_disposed, "f")) {
            return;
          }
          this._lightBulbWidget.getValue().update(actions, newState.trigger, newState.position);
          if (newState.trigger.type === 1) {
            if ((_b2 = newState.trigger.filter) === null || _b2 === void 0 ? void 0 : _b2.include) {
              const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
              if (validActionToApply) {
                try {
                  this._lightBulbWidget.getValue().hide();
                  yield this.delegate.applyCodeAction(validActionToApply, false);
                } finally {
                  actions.dispose();
                }
                return;
              }
              if (newState.trigger.context) {
                const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
                if (invalidAction && invalidAction.action.disabled) {
                  MessageController.get(this._editor).showMessage(invalidAction.action.disabled, newState.trigger.context.position);
                  actions.dispose();
                  return;
                }
              }
            }
            const includeDisabledActions = !!((_c2 = newState.trigger.filter) === null || _c2 === void 0 ? void 0 : _c2.include);
            if (newState.trigger.context) {
              if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
                MessageController.get(this._editor).showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
                this._activeCodeActions.value = actions;
                actions.dispose();
                return;
              }
            }
            this._activeCodeActions.value = actions;
            this._codeActionWidget.getValue().show(newState.trigger, actions, newState.position, { includeDisabledActions });
          } else {
            if (this._codeActionWidget.getValue().isVisible) {
              actions.dispose();
            } else {
              this._activeCodeActions.value = actions;
            }
          }
        });
      }
      getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {
        if (!actions.allActions.length) {
          return void 0;
        }
        if (trigger.autoApply === "first" && actions.validActions.length === 0 || trigger.autoApply === "ifSingle" && actions.allActions.length === 1) {
          return actions.allActions.find(({ action }) => action.disabled);
        }
        return void 0;
      }
      tryGetValidActionToApply(trigger, actions) {
        if (!actions.validActions.length) {
          return void 0;
        }
        if (trigger.autoApply === "first" && actions.validActions.length > 0 || trigger.autoApply === "ifSingle" && actions.validActions.length === 1) {
          return actions.validActions[0];
        }
        return void 0;
      }
      showCodeActionList(trigger, actions, at, options) {
        return __awaiter6(this, void 0, void 0, function* () {
          this._codeActionWidget.getValue().show(trigger, actions, at, options);
        });
      }
    };
    _CodeActionUi_disposed = /* @__PURE__ */ new WeakMap();
    CodeActionUi = __decorate5([
      __param5(4, IInstantiationService)
    ], CodeActionUi);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionModel.js
var __classPrivateFieldGet2, __classPrivateFieldSet2, _CodeActionModel_isDisposed, SUPPORTED_CODE_ACTIONS, CodeActionOracle, CodeActionsState, emptyCodeActionSet, CodeActionModel;
var init_codeActionModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionModel.js"() {
    init_async();
    init_errors();
    init_event();
    init_lifecycle();
    init_resources();
    init_range();
    init_modes();
    init_contextkey();
    init_progress();
    init_codeAction();
    __classPrivateFieldGet2 = function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    SUPPORTED_CODE_ACTIONS = new RawContextKey("supportedCodeAction", "");
    CodeActionOracle = class extends Disposable {
      constructor(_editor2, _markerService, _signalChange, _delay = 250) {
        super();
        this._editor = _editor2;
        this._markerService = _markerService;
        this._signalChange = _signalChange;
        this._delay = _delay;
        this._autoTriggerTimer = this._register(new TimeoutTimer());
        this._register(this._markerService.onMarkerChanged((e) => this._onMarkerChanges(e)));
        this._register(this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));
      }
      trigger(trigger) {
        const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);
        return this._createEventAndSignalChange(trigger, selection);
      }
      _onMarkerChanges(resources) {
        const model = this._editor.getModel();
        if (!model) {
          return;
        }
        if (resources.some((resource) => isEqual(resource, model.uri))) {
          this._autoTriggerTimer.cancelAndSet(() => {
            this.trigger({
              type: 2
              /* Auto */
            });
          }, this._delay);
        }
      }
      _onCursorChange() {
        this._autoTriggerTimer.cancelAndSet(() => {
          this.trigger({
            type: 2
            /* Auto */
          });
        }, this._delay);
      }
      _getRangeOfMarker(selection) {
        const model = this._editor.getModel();
        if (!model) {
          return void 0;
        }
        for (const marker of this._markerService.read({ resource: model.uri })) {
          const markerRange = model.validateRange(marker);
          if (Range.intersectRanges(markerRange, selection)) {
            return Range.lift(markerRange);
          }
        }
        return void 0;
      }
      _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {
        if (!this._editor.hasModel()) {
          return void 0;
        }
        const model = this._editor.getModel();
        const selection = this._editor.getSelection();
        if (selection.isEmpty() && trigger.type === 2) {
          const { lineNumber, column } = selection.getPosition();
          const line = model.getLineContent(lineNumber);
          if (line.length === 0) {
            return void 0;
          } else if (column === 1) {
            if (/\s/.test(line[0])) {
              return void 0;
            }
          } else if (column === model.getLineMaxColumn(lineNumber)) {
            if (/\s/.test(line[line.length - 1])) {
              return void 0;
            }
          } else {
            if (/\s/.test(line[column - 2]) && /\s/.test(line[column - 1])) {
              return void 0;
            }
          }
        }
        return selection;
      }
      _createEventAndSignalChange(trigger, selection) {
        const model = this._editor.getModel();
        if (!selection || !model) {
          this._signalChange(void 0);
          return void 0;
        }
        const markerRange = this._getRangeOfMarker(selection);
        const position = markerRange ? markerRange.getStartPosition() : selection.getStartPosition();
        const e = {
          trigger,
          selection,
          position
        };
        this._signalChange(e);
        return e;
      }
    };
    (function(CodeActionsState2) {
      CodeActionsState2.Empty = {
        type: 0
        /* Empty */
      };
      class Triggered {
        constructor(trigger, rangeOrSelection, position, _cancellablePromise) {
          this.trigger = trigger;
          this.rangeOrSelection = rangeOrSelection;
          this.position = position;
          this._cancellablePromise = _cancellablePromise;
          this.type = 1;
          this.actions = _cancellablePromise.catch((e) => {
            if (isPromiseCanceledError(e)) {
              return emptyCodeActionSet;
            }
            throw e;
          });
        }
        cancel() {
          this._cancellablePromise.cancel();
        }
      }
      CodeActionsState2.Triggered = Triggered;
    })(CodeActionsState || (CodeActionsState = {}));
    emptyCodeActionSet = {
      allActions: [],
      validActions: [],
      dispose: () => {
      },
      documentation: [],
      hasAutoFix: false
    };
    CodeActionModel = class extends Disposable {
      constructor(_editor2, _markerService, contextKeyService, _progressService) {
        super();
        this._editor = _editor2;
        this._markerService = _markerService;
        this._progressService = _progressService;
        this._codeActionOracle = this._register(new MutableDisposable());
        this._state = CodeActionsState.Empty;
        this._onDidChangeState = this._register(new Emitter());
        this.onDidChangeState = this._onDidChangeState.event;
        _CodeActionModel_isDisposed.set(this, false);
        this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);
        this._register(this._editor.onDidChangeModel(() => this._update()));
        this._register(this._editor.onDidChangeModelLanguage(() => this._update()));
        this._register(CodeActionProviderRegistry.onDidChange(() => this._update()));
        this._update();
      }
      dispose() {
        if (__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
          return;
        }
        __classPrivateFieldSet2(this, _CodeActionModel_isDisposed, true, "f");
        super.dispose();
        this.setState(CodeActionsState.Empty, true);
      }
      _update() {
        if (__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
          return;
        }
        this._codeActionOracle.value = void 0;
        this.setState(CodeActionsState.Empty);
        const model = this._editor.getModel();
        if (model && CodeActionProviderRegistry.has(model) && !this._editor.getOption(
          80
          /* readOnly */
        )) {
          const supportedActions = [];
          for (const provider of CodeActionProviderRegistry.all(model)) {
            if (Array.isArray(provider.providedCodeActionKinds)) {
              supportedActions.push(...provider.providedCodeActionKinds);
            }
          }
          this._supportedCodeActions.set(supportedActions.join(" "));
          this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, (trigger) => {
            var _a5;
            if (!trigger) {
              this.setState(CodeActionsState.Empty);
              return;
            }
            const actions = createCancelablePromise((token) => getCodeActions(model, trigger.selection, trigger.trigger, Progress.None, token));
            if (trigger.trigger.type === 1) {
              (_a5 = this._progressService) === null || _a5 === void 0 ? void 0 : _a5.showWhile(actions, 250);
            }
            this.setState(new CodeActionsState.Triggered(trigger.trigger, trigger.selection, trigger.position, actions));
          }, void 0);
          this._codeActionOracle.value.trigger({
            type: 2
            /* Auto */
          });
        } else {
          this._supportedCodeActions.reset();
        }
      }
      trigger(trigger) {
        if (this._codeActionOracle.value) {
          this._codeActionOracle.value.trigger(trigger);
        }
      }
      setState(newState, skipNotify) {
        if (newState === this._state) {
          return;
        }
        if (this._state.type === 1) {
          this._state.cancel();
        }
        this._state = newState;
        if (!skipNotify && !__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
          this._onDidChangeState.fire(newState);
        }
      }
    };
    _CodeActionModel_isDisposed = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionCommands.js
function contextKeyForSupportedActions(kind) {
  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
function applyCodeAction(accessor, item, editor2) {
  return __awaiter7(this, void 0, void 0, function* () {
    const bulkEditService = accessor.get(IBulkEditService);
    const commandService = accessor.get(ICommandService);
    const telemetryService = accessor.get(ITelemetryService);
    const notificationService = accessor.get(INotificationService);
    telemetryService.publicLog2("codeAction.applyCodeAction", {
      codeActionTitle: item.action.title,
      codeActionKind: item.action.kind,
      codeActionIsPreferred: !!item.action.isPreferred
    });
    yield item.resolve(CancellationToken.None);
    if (item.action.edit) {
      yield bulkEditService.apply(ResourceEdit.convert(item.action.edit), { editor: editor2, label: item.action.title });
    }
    if (item.action.command) {
      try {
        yield commandService.executeCommand(item.action.command.id, ...item.action.command.arguments || []);
      } catch (err) {
        const message = asMessage(err);
        notificationService.error(typeof message === "string" ? message : localize("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
      }
    }
  });
}
function asMessage(err) {
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error && typeof err.message === "string") {
    return err.message;
  } else {
    return void 0;
  }
}
function triggerCodeActionsForEditorSelection(editor2, notAvailableMessage, filter, autoApply) {
  if (editor2.hasModel()) {
    const controller = QuickFixController.get(editor2);
    if (controller) {
      controller.manualTriggerAtCurrentPosition(notAvailableMessage, filter, autoApply);
    }
  }
}
var __decorate6, __param6, __awaiter7, argsSchema, QuickFixController, QuickFixAction, CodeActionCommand, RefactorAction, SourceAction, OrganizeImportsAction, FixAllAction, AutoFixAction;
var init_codeActionCommands = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionCommands.js"() {
    init_cancellation();
    init_lazy();
    init_lifecycle();
    init_strings();
    init_editorExtensions();
    init_bulkEditService();
    init_editorContextKeys();
    init_codeAction();
    init_codeActionUi();
    init_messageController();
    init_nls();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_markers();
    init_notification();
    init_progress();
    init_telemetry();
    init_codeActionModel();
    init_types2();
    __decorate6 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param6 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter7 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    argsSchema = {
      type: "object",
      defaultSnippets: [{ body: { kind: "" } }],
      properties: {
        "kind": {
          type: "string",
          description: localize("args.schema.kind", "Kind of the code action to run.")
        },
        "apply": {
          type: "string",
          description: localize("args.schema.apply", "Controls when the returned actions are applied."),
          default: "ifSingle",
          enum: [
            "first",
            "ifSingle",
            "never"
            /* Never */
          ],
          enumDescriptions: [
            localize("args.schema.apply.first", "Always apply the first returned code action."),
            localize("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
            localize("args.schema.apply.never", "Do not apply the returned code actions.")
          ]
        },
        "preferred": {
          type: "boolean",
          default: false,
          description: localize("args.schema.preferred", "Controls if only preferred code actions should be returned.")
        }
      }
    };
    QuickFixController = class QuickFixController2 extends Disposable {
      constructor(editor2, markerService, contextKeyService, progressService, _instantiationService) {
        super();
        this._instantiationService = _instantiationService;
        this._editor = editor2;
        this._model = this._register(new CodeActionModel(this._editor, markerService, contextKeyService, progressService));
        this._register(this._model.onDidChangeState((newState) => this.update(newState)));
        this._ui = new Lazy(() => this._register(new CodeActionUi(editor2, QuickFixAction.Id, AutoFixAction.Id, {
          applyCodeAction: (action, retrigger) => __awaiter7(this, void 0, void 0, function* () {
            try {
              yield this._applyCodeAction(action);
            } finally {
              if (retrigger) {
                this._trigger({ type: 2, filter: {} });
              }
            }
          })
        }, this._instantiationService)));
      }
      static get(editor2) {
        return editor2.getContribution(QuickFixController2.ID);
      }
      update(newState) {
        this._ui.getValue().update(newState);
      }
      showCodeActions(trigger, actions, at) {
        return this._ui.getValue().showCodeActionList(trigger, actions, at, { includeDisabledActions: false });
      }
      manualTriggerAtCurrentPosition(notAvailableMessage, filter, autoApply) {
        if (!this._editor.hasModel()) {
          return;
        }
        MessageController.get(this._editor).closeMessage();
        const triggerPosition = this._editor.getPosition();
        this._trigger({ type: 1, filter, autoApply, context: { notAvailableMessage, position: triggerPosition } });
      }
      _trigger(trigger) {
        return this._model.trigger(trigger);
      }
      _applyCodeAction(action) {
        return this._instantiationService.invokeFunction(applyCodeAction, action, this._editor);
      }
    };
    QuickFixController.ID = "editor.contrib.quickFixController";
    QuickFixController = __decorate6([
      __param6(1, IMarkerService),
      __param6(2, IContextKeyService),
      __param6(3, IEditorProgressService),
      __param6(4, IInstantiationService)
    ], QuickFixController);
    QuickFixAction = class _QuickFixAction extends EditorAction {
      constructor() {
        super({
          id: _QuickFixAction.Id,
          label: localize("quickfix.trigger.label", "Quick Fix..."),
          alias: "Quick Fix...",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 84,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0);
      }
    };
    QuickFixAction.Id = "editor.action.quickFix";
    CodeActionCommand = class extends EditorCommand {
      constructor() {
        super({
          id: codeActionCommandId,
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
          description: {
            description: "Trigger a code action",
            args: [{ name: "args", schema: argsSchema }]
          }
        });
      }
      runEditorCommand(_accessor, editor2, userArgs) {
        const args = CodeActionCommandArgs.fromUser(userArgs, {
          kind: CodeActionKind.Empty,
          apply: "ifSingle"
        });
        return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", userArgs.kind) : localize("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : localize("editor.action.codeAction.noneMessage", "No code actions available"), {
          include: args.kind,
          includeSourceActions: true,
          onlyIncludePreferredActions: args.preferred
        }, args.apply);
      }
    };
    RefactorAction = class extends EditorAction {
      constructor() {
        super({
          id: refactorCommandId,
          label: localize("refactor.label", "Refactor..."),
          alias: "Refactor...",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 48,
            mac: {
              primary: 256 | 1024 | 48
              /* KEY_R */
            },
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "1_modification",
            order: 2,
            when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))
          },
          description: {
            description: "Refactor...",
            args: [{ name: "args", schema: argsSchema }]
          }
        });
      }
      run(_accessor, editor2, userArgs) {
        const args = CodeActionCommandArgs.fromUser(userArgs, {
          kind: CodeActionKind.Refactor,
          apply: "never"
          /* Never */
        });
        return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", userArgs.kind) : localize("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : localize("editor.action.refactor.noneMessage", "No refactorings available"), {
          include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,
          onlyIncludePreferredActions: args.preferred
        }, args.apply);
      }
    };
    SourceAction = class extends EditorAction {
      constructor() {
        super({
          id: sourceActionCommandId,
          label: localize("source.label", "Source Action..."),
          alias: "Source Action...",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
          contextMenuOpts: {
            group: "1_modification",
            order: 2.1,
            when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))
          },
          description: {
            description: "Source Action...",
            args: [{ name: "args", schema: argsSchema }]
          }
        });
      }
      run(_accessor, editor2, userArgs) {
        const args = CodeActionCommandArgs.fromUser(userArgs, {
          kind: CodeActionKind.Source,
          apply: "never"
          /* Never */
        });
        return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", userArgs.kind) : localize("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.source.noneMessage.preferred", "No preferred source actions available") : localize("editor.action.source.noneMessage", "No source actions available"), {
          include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,
          includeSourceActions: true,
          onlyIncludePreferredActions: args.preferred
        }, args.apply);
      }
    };
    OrganizeImportsAction = class extends EditorAction {
      constructor() {
        super({
          id: organizeImportsCommandId,
          label: localize("organizeImports.label", "Organize Imports"),
          alias: "Organize Imports",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 45,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        return triggerCodeActionsForEditorSelection(
          editor2,
          localize("editor.action.organize.noneMessage", "No organize imports action available"),
          { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true },
          "ifSingle"
          /* IfSingle */
        );
      }
    };
    FixAllAction = class extends EditorAction {
      constructor() {
        super({
          id: fixAllCommandId,
          label: localize("fixAll.label", "Fix All"),
          alias: "Fix All",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
        });
      }
      run(_accessor, editor2) {
        return triggerCodeActionsForEditorSelection(
          editor2,
          localize("fixAll.noneMessage", "No fix all action available"),
          { include: CodeActionKind.SourceFixAll, includeSourceActions: true },
          "ifSingle"
          /* IfSingle */
        );
      }
    };
    AutoFixAction = class _AutoFixAction extends EditorAction {
      constructor() {
        super({
          id: _AutoFixAction.Id,
          label: localize("autoFix.label", "Auto Fix..."),
          alias: "Auto Fix...",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 512 | 1024 | 84,
            mac: {
              primary: 2048 | 512 | 84
              /* US_DOT */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        return triggerCodeActionsForEditorSelection(
          editor2,
          localize("editor.action.autoFix.noneMessage", "No auto fixes available"),
          {
            include: CodeActionKind.QuickFix,
            onlyIncludePreferredActions: true
          },
          "ifSingle"
          /* IfSingle */
        );
      }
    };
    AutoFixAction.Id = "editor.action.autoFix";
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionContributions.js
var init_codeActionContributions = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionContributions.js"() {
    init_editorExtensions();
    init_codeActionCommands();
    registerEditorContribution(QuickFixController.ID, QuickFixController);
    registerEditorAction(QuickFixAction);
    registerEditorAction(RefactorAction);
    registerEditorAction(SourceAction);
    registerEditorAction(OrganizeImportsAction);
    registerEditorAction(AutoFixAction);
    registerEditorAction(FixAllAction);
    registerEditorCommand(new CodeActionCommand());
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelens.js
function getCodeLensModel(model, token) {
  return __awaiter8(this, void 0, void 0, function* () {
    const provider = CodeLensProviderRegistry.ordered(model);
    const providerRanks = /* @__PURE__ */ new Map();
    const result = new CodeLensModel();
    const promises = provider.map((provider2, i) => __awaiter8(this, void 0, void 0, function* () {
      providerRanks.set(provider2, i);
      try {
        const list = yield Promise.resolve(provider2.provideCodeLenses(model, token));
        if (list) {
          result.add(list, provider2);
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }));
    yield Promise.all(promises);
    result.lenses = result.lenses.sort((a, b) => {
      if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
        return -1;
      } else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
        return 1;
      } else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) {
        return -1;
      } else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) {
        return 1;
      } else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
        return -1;
      } else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
        return 1;
      } else {
        return 0;
      }
    });
    return result;
  });
}
var __awaiter8, CodeLensModel;
var init_codelens = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelens.js"() {
    init_cancellation();
    init_errors();
    init_lifecycle();
    init_types();
    init_uri();
    init_modes();
    init_modelService();
    init_commands();
    __awaiter8 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CodeLensModel = class {
      constructor() {
        this.lenses = [];
        this._disposables = new DisposableStore();
      }
      dispose() {
        this._disposables.dispose();
      }
      add(list, provider) {
        this._disposables.add(list);
        for (const symbol of list.lenses) {
          this.lenses.push({ symbol, provider });
        }
      }
    };
    CommandsRegistry.registerCommand("_executeCodeLensProvider", function(accessor, ...args) {
      let [uri, itemResolveCount] = args;
      assertType(URI.isUri(uri));
      assertType(typeof itemResolveCount === "number" || !itemResolveCount);
      const model = accessor.get(IModelService).getModel(uri);
      if (!model) {
        throw illegalArgument();
      }
      const result = [];
      const disposables = new DisposableStore();
      return getCodeLensModel(model, CancellationToken.None).then((value) => {
        disposables.add(value);
        let resolve = [];
        for (const item of value.lenses) {
          if (itemResolveCount === void 0 || itemResolveCount === null || Boolean(item.symbol.command)) {
            result.push(item.symbol);
          } else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) {
            resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol) => result.push(symbol || item.symbol)));
          }
        }
        return Promise.all(resolve);
      }).then(() => {
        return result;
      }).finally(() => {
        setTimeout(() => disposables.dispose(), 100);
      });
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codeLensCache.js
var __decorate7, __param7, ICodeLensCache, CacheItem, CodeLensCache;
var init_codeLensCache = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codeLensCache.js"() {
    init_async();
    init_functional();
    init_map();
    init_range();
    init_codelens();
    init_extensions();
    init_instantiation();
    init_storage();
    __decorate7 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param7 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    ICodeLensCache = createDecorator("ICodeLensCache");
    CacheItem = class {
      constructor(lineCount, data) {
        this.lineCount = lineCount;
        this.data = data;
      }
    };
    CodeLensCache = class CodeLensCache2 {
      constructor(storageService) {
        this._fakeProvider = new class {
          provideCodeLenses() {
            throw new Error("not supported");
          }
        }();
        this._cache = new LRUCache(20, 0.75);
        const oldkey = "codelens/cache";
        runWhenIdle(() => storageService.remove(
          oldkey,
          1
          /* WORKSPACE */
        ));
        const key = "codelens/cache2";
        const raw = storageService.get(key, 1, "{}");
        this._deserialize(raw);
        once(storageService.onWillSaveState)((e) => {
          if (e.reason === WillSaveStateReason.SHUTDOWN) {
            storageService.store(
              key,
              this._serialize(),
              1,
              1
              /* MACHINE */
            );
          }
        });
      }
      put(model, data) {
        const copyItems = data.lenses.map((item2) => {
          var _a5;
          return {
            range: item2.symbol.range,
            command: item2.symbol.command && { id: "", title: (_a5 = item2.symbol.command) === null || _a5 === void 0 ? void 0 : _a5.title }
          };
        });
        const copyModel = new CodeLensModel();
        copyModel.add({ lenses: copyItems, dispose: () => {
        } }, this._fakeProvider);
        const item = new CacheItem(model.getLineCount(), copyModel);
        this._cache.set(model.uri.toString(), item);
      }
      get(model) {
        const item = this._cache.get(model.uri.toString());
        return item && item.lineCount === model.getLineCount() ? item.data : void 0;
      }
      delete(model) {
        this._cache.delete(model.uri.toString());
      }
      // --- persistence
      _serialize() {
        const data = /* @__PURE__ */ Object.create(null);
        for (const [key, value] of this._cache) {
          const lines = /* @__PURE__ */ new Set();
          for (const d of value.data.lenses) {
            lines.add(d.symbol.range.startLineNumber);
          }
          data[key] = {
            lineCount: value.lineCount,
            lines: [...lines.values()]
          };
        }
        return JSON.stringify(data);
      }
      _deserialize(raw) {
        try {
          const data = JSON.parse(raw);
          for (const key in data) {
            const element = data[key];
            const lenses = [];
            for (const line of element.lines) {
              lenses.push({ range: new Range(line, 1, line, 11) });
            }
            const model = new CodeLensModel();
            model.add({ lenses, dispose() {
            } }, this._fakeProvider);
            this._cache.set(key, new CacheItem(element.lineCount, model));
          }
        } catch (_a5) {
        }
      }
    };
    CodeLensCache = __decorate7([
      __param7(0, IStorageService)
    ], CodeLensCache);
    registerSingleton(ICodeLensCache, CodeLensCache);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensWidget.js
var CodeLensViewZone, CodeLensContentWidget, CodeLensHelper, CodeLensWidget;
var init_codelensWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensWidget.js"() {
    init_dom();
    init_iconLabels2();
    init_range();
    init_textModel();
    init_editorColorRegistry();
    init_colorRegistry();
    init_themeService();
    CodeLensViewZone = class {
      constructor(afterLineNumber, heightInPx, onHeight) {
        this.afterLineNumber = afterLineNumber;
        this.heightInPx = heightInPx;
        this._onHeight = onHeight;
        this.suppressMouseDown = true;
        this.domNode = document.createElement("div");
      }
      onComputedHeight(height) {
        if (this._lastHeight === void 0) {
          this._lastHeight = height;
        } else if (this._lastHeight !== height) {
          this._lastHeight = height;
          this._onHeight();
        }
      }
    };
    CodeLensContentWidget = class _CodeLensContentWidget {
      constructor(editor2, className, line) {
        this.allowEditorOverflow = false;
        this.suppressMouseDown = true;
        this._commands = /* @__PURE__ */ new Map();
        this._isEmpty = true;
        this._editor = editor2;
        this._id = `codelens.widget-${_CodeLensContentWidget._idPool++}`;
        this.updatePosition(line);
        this._domNode = document.createElement("span");
        this._domNode.className = `codelens-decoration ${className}`;
      }
      withCommands(lenses, animate) {
        this._commands.clear();
        let children = [];
        let hasSymbol = false;
        for (let i = 0; i < lenses.length; i++) {
          const lens = lenses[i];
          if (!lens) {
            continue;
          }
          hasSymbol = true;
          if (lens.command) {
            const title = renderLabelWithIcons(lens.command.title.trim());
            if (lens.command.id) {
              children.push($("a", { id: String(i), title: lens.command.tooltip }, ...title));
              this._commands.set(String(i), lens.command);
            } else {
              children.push($("span", { title: lens.command.tooltip }, ...title));
            }
            if (i + 1 < lenses.length) {
              children.push($("span", void 0, "\xA0|\xA0"));
            }
          }
        }
        if (!hasSymbol) {
          reset(this._domNode, $("span", void 0, "no commands"));
        } else {
          reset(this._domNode, ...children);
          if (this._isEmpty && animate) {
            this._domNode.classList.add("fadein");
          }
          this._isEmpty = false;
        }
      }
      getCommand(link) {
        return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
      }
      getId() {
        return this._id;
      }
      getDomNode() {
        return this._domNode;
      }
      updatePosition(line) {
        const column = this._editor.getModel().getLineFirstNonWhitespaceColumn(line);
        this._widgetPosition = {
          position: { lineNumber: line, column },
          preference: [
            1
            /* ABOVE */
          ]
        };
      }
      getPosition() {
        return this._widgetPosition || null;
      }
    };
    CodeLensContentWidget._idPool = 0;
    CodeLensHelper = class {
      constructor() {
        this._removeDecorations = [];
        this._addDecorations = [];
        this._addDecorationsCallbacks = [];
      }
      addDecoration(decoration2, callback) {
        this._addDecorations.push(decoration2);
        this._addDecorationsCallbacks.push(callback);
      }
      removeDecoration(decorationId) {
        this._removeDecorations.push(decorationId);
      }
      commit(changeAccessor) {
        let resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
        for (let i = 0, len = resultingDecorations.length; i < len; i++) {
          this._addDecorationsCallbacks[i](resultingDecorations[i]);
        }
      }
    };
    CodeLensWidget = class {
      constructor(data, editor2, className, helper, viewZoneChangeAccessor, heightInPx, updateCallback) {
        this._isDisposed = false;
        this._editor = editor2;
        this._className = className;
        this._data = data;
        this._decorationIds = [];
        let range;
        let lenses = [];
        this._data.forEach((codeLensData, i) => {
          if (codeLensData.symbol.command) {
            lenses.push(codeLensData.symbol);
          }
          helper.addDecoration({
            range: codeLensData.symbol.range,
            options: ModelDecorationOptions.EMPTY
          }, (id) => this._decorationIds[i] = id);
          if (!range) {
            range = Range.lift(codeLensData.symbol.range);
          } else {
            range = Range.plusRange(range, codeLensData.symbol.range);
          }
        });
        this._viewZone = new CodeLensViewZone(range.startLineNumber - 1, heightInPx, updateCallback);
        this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
        if (lenses.length > 0) {
          this._createContentWidgetIfNecessary();
          this._contentWidget.withCommands(lenses, false);
        }
      }
      _createContentWidgetIfNecessary() {
        if (!this._contentWidget) {
          this._contentWidget = new CodeLensContentWidget(this._editor, this._className, this._viewZone.afterLineNumber + 1);
          this._editor.addContentWidget(this._contentWidget);
        } else {
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
      dispose(helper, viewZoneChangeAccessor) {
        this._decorationIds.forEach(helper.removeDecoration, helper);
        this._decorationIds = [];
        if (viewZoneChangeAccessor) {
          viewZoneChangeAccessor.removeZone(this._viewZoneId);
        }
        if (this._contentWidget) {
          this._editor.removeContentWidget(this._contentWidget);
          this._contentWidget = void 0;
        }
        this._isDisposed = true;
      }
      isDisposed() {
        return this._isDisposed;
      }
      isValid() {
        return this._decorationIds.some((id, i) => {
          const range = this._editor.getModel().getDecorationRange(id);
          const symbol = this._data[i].symbol;
          return !!(range && Range.isEmpty(symbol.range) === range.isEmpty());
        });
      }
      updateCodeLensSymbols(data, helper) {
        this._decorationIds.forEach(helper.removeDecoration, helper);
        this._decorationIds = [];
        this._data = data;
        this._data.forEach((codeLensData, i) => {
          helper.addDecoration({
            range: codeLensData.symbol.range,
            options: ModelDecorationOptions.EMPTY
          }, (id) => this._decorationIds[i] = id);
        });
      }
      updateHeight(height, viewZoneChangeAccessor) {
        this._viewZone.heightInPx = height;
        viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        if (this._contentWidget) {
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
      computeIfNecessary(model) {
        if (!this._viewZone.domNode.hasAttribute("monaco-visible-view-zone")) {
          return null;
        }
        for (let i = 0; i < this._decorationIds.length; i++) {
          const range = model.getDecorationRange(this._decorationIds[i]);
          if (range) {
            this._data[i].symbol.range = range;
          }
        }
        return this._data;
      }
      updateCommands(symbols) {
        this._createContentWidgetIfNecessary();
        this._contentWidget.withCommands(symbols, true);
        for (let i = 0; i < this._data.length; i++) {
          const resolved = symbols[i];
          if (resolved) {
            const { symbol } = this._data[i];
            symbol.command = resolved.command || symbol.command;
          }
        }
      }
      getCommand(link) {
        var _a5;
        return (_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.getCommand(link);
      }
      getLineNumber() {
        const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
        if (range) {
          return range.startLineNumber;
        }
        return -1;
      }
      update(viewZoneChangeAccessor) {
        if (this.isValid()) {
          const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
          if (range) {
            this._viewZone.afterLineNumber = range.startLineNumber - 1;
            viewZoneChangeAccessor.layoutZone(this._viewZoneId);
            if (this._contentWidget) {
              this._contentWidget.updatePosition(range.startLineNumber);
              this._editor.layoutContentWidget(this._contentWidget);
            }
          }
        }
      }
      getItems() {
        return this._data;
      }
    };
    registerThemingParticipant((theme, collector) => {
      const codeLensForeground = theme.getColor(editorCodeLensForeground);
      if (codeLensForeground) {
        collector.addRule(`.monaco-editor .codelens-decoration { color: ${codeLensForeground}; }`);
        collector.addRule(`.monaco-editor .codelens-decoration .codicon { color: ${codeLensForeground}; }`);
      }
      const activeLinkForeground = theme.getColor(editorActiveLinkForeground);
      if (activeLinkForeground) {
        collector.addRule(`.monaco-editor .codelens-decoration > a:hover { color: ${activeLinkForeground} !important; }`);
        collector.addRule(`.monaco-editor .codelens-decoration > a:hover .codicon { color: ${activeLinkForeground} !important; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensController.js
var __decorate8, __param8, __awaiter9, CodeLensContribution;
var init_codelensController = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensController.js"() {
    init_dom();
    init_async();
    init_errors();
    init_hash();
    init_lifecycle();
    init_editorState();
    init_editorExtensions();
    init_editorContextKeys();
    init_modes();
    init_languageFeatureRegistry();
    init_codelens();
    init_codeLensCache();
    init_codelensWidget();
    init_nls();
    init_commands();
    init_notification();
    init_quickInput();
    __decorate8 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param8 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter9 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CodeLensContribution = class CodeLensContribution2 {
      constructor(_editor2, _commandService, _notificationService, _codeLensCache) {
        this._editor = _editor2;
        this._commandService = _commandService;
        this._notificationService = _notificationService;
        this._codeLensCache = _codeLensCache;
        this._disposables = new DisposableStore();
        this._localToDispose = new DisposableStore();
        this._lenses = [];
        this._getCodeLensModelDelays = new LanguageFeatureRequestDelays(CodeLensProviderRegistry, 250, 2500);
        this._oldCodeLensModels = new DisposableStore();
        this._resolveCodeLensesDelays = new LanguageFeatureRequestDelays(CodeLensProviderRegistry, 250, 2500);
        this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDelays.min);
        this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));
        this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
        this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            43
            /* fontInfo */
          ) || e.hasChanged(
            16
            /* codeLensFontSize */
          ) || e.hasChanged(
            15
            /* codeLensFontFamily */
          )) {
            this._updateLensStyle();
          }
          if (e.hasChanged(
            14
            /* codeLens */
          )) {
            this._onModelChange();
          }
        }));
        this._disposables.add(CodeLensProviderRegistry.onDidChange(this._onModelChange, this));
        this._onModelChange();
        this._styleClassName = "_" + hash(this._editor.getId()).toString(16);
        this._styleElement = createStyleSheet(isInShadowDOM(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0);
        this._updateLensStyle();
      }
      dispose() {
        var _a5;
        this._localDispose();
        this._disposables.dispose();
        this._oldCodeLensModels.dispose();
        (_a5 = this._currentCodeLensModel) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._styleElement.remove();
      }
      _getLayoutInfo() {
        let fontSize = this._editor.getOption(
          16
          /* codeLensFontSize */
        );
        let codeLensHeight;
        if (!fontSize || fontSize < 5) {
          fontSize = this._editor.getOption(
            45
            /* fontSize */
          ) * 0.9 | 0;
          codeLensHeight = this._editor.getOption(
            58
            /* lineHeight */
          );
        } else {
          codeLensHeight = fontSize * Math.max(1.3, this._editor.getOption(
            58
            /* lineHeight */
          ) / this._editor.getOption(
            45
            /* fontSize */
          )) | 0;
        }
        return { codeLensHeight, fontSize };
      }
      _updateLensStyle() {
        const { codeLensHeight, fontSize } = this._getLayoutInfo();
        const fontFamily = this._editor.getOption(
          15
          /* codeLensFontFamily */
        );
        const editorFontInfo = this._editor.getOption(
          43
          /* fontInfo */
        );
        const fontFamilyVar = `--codelens-font-family${this._styleClassName}`;
        const fontFeaturesVar = `--codelens-font-features${this._styleClassName}`;
        let newStyle = `
		.monaco-editor .codelens-decoration.${this._styleClassName} { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; padding-right: ${Math.round(fontSize * 0.5)}px; font-feature-settings: var(${fontFeaturesVar}) }
		.monaco-editor .codelens-decoration.${this._styleClassName} span.codicon { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; }
		`;
        if (fontFamily) {
          newStyle += `.monaco-editor .codelens-decoration.${this._styleClassName} { font-family: var(${fontFamilyVar})}`;
        }
        this._styleElement.textContent = newStyle;
        this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily !== null && fontFamily !== void 0 ? fontFamily : "inherit");
        this._editor.getContainerDomNode().style.setProperty(fontFeaturesVar, editorFontInfo.fontFeatureSettings);
        this._editor.changeViewZones((accessor) => {
          for (let lens of this._lenses) {
            lens.updateHeight(codeLensHeight, accessor);
          }
        });
      }
      _localDispose() {
        var _a5, _b2, _c2;
        (_a5 = this._getCodeLensModelPromise) === null || _a5 === void 0 ? void 0 : _a5.cancel();
        this._getCodeLensModelPromise = void 0;
        (_b2 = this._resolveCodeLensesPromise) === null || _b2 === void 0 ? void 0 : _b2.cancel();
        this._resolveCodeLensesPromise = void 0;
        this._localToDispose.clear();
        this._oldCodeLensModels.clear();
        (_c2 = this._currentCodeLensModel) === null || _c2 === void 0 ? void 0 : _c2.dispose();
      }
      _onModelChange() {
        this._localDispose();
        const model = this._editor.getModel();
        if (!model) {
          return;
        }
        if (!this._editor.getOption(
          14
          /* codeLens */
        )) {
          return;
        }
        const cachedLenses = this._codeLensCache.get(model);
        if (cachedLenses) {
          this._renderCodeLensSymbols(cachedLenses);
        }
        if (!CodeLensProviderRegistry.has(model)) {
          if (cachedLenses) {
            this._localToDispose.add(disposableTimeout(() => {
              const cachedLensesNow = this._codeLensCache.get(model);
              if (cachedLenses === cachedLensesNow) {
                this._codeLensCache.delete(model);
                this._onModelChange();
              }
            }, 30 * 1e3));
          }
          return;
        }
        for (const provider of CodeLensProviderRegistry.all(model)) {
          if (typeof provider.onDidChange === "function") {
            let registration = provider.onDidChange(() => scheduler.schedule());
            this._localToDispose.add(registration);
          }
        }
        const scheduler = new RunOnceScheduler(() => {
          var _a5;
          const t1 = Date.now();
          (_a5 = this._getCodeLensModelPromise) === null || _a5 === void 0 ? void 0 : _a5.cancel();
          this._getCodeLensModelPromise = createCancelablePromise((token) => getCodeLensModel(model, token));
          this._getCodeLensModelPromise.then((result) => {
            if (this._currentCodeLensModel) {
              this._oldCodeLensModels.add(this._currentCodeLensModel);
            }
            this._currentCodeLensModel = result;
            this._codeLensCache.put(model, result);
            const newDelay = this._getCodeLensModelDelays.update(model, Date.now() - t1);
            scheduler.delay = newDelay;
            this._renderCodeLensSymbols(result);
            this._resolveCodeLensesInViewportSoon();
          }, onUnexpectedError);
        }, this._getCodeLensModelDelays.get(model));
        this._localToDispose.add(scheduler);
        this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
        this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
          this._editor.changeDecorations((decorationsAccessor) => {
            this._editor.changeViewZones((viewZonesAccessor) => {
              let toDispose = [];
              let lastLensLineNumber = -1;
              this._lenses.forEach((lens) => {
                if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
                  toDispose.push(lens);
                } else {
                  lens.update(viewZonesAccessor);
                  lastLensLineNumber = lens.getLineNumber();
                }
              });
              let helper = new CodeLensHelper();
              toDispose.forEach((l) => {
                l.dispose(helper, viewZonesAccessor);
                this._lenses.splice(this._lenses.indexOf(l), 1);
              });
              helper.commit(decorationsAccessor);
            });
          });
          scheduler.schedule();
        }));
        this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
          scheduler.schedule();
        }));
        this._localToDispose.add(this._editor.onDidScrollChange((e) => {
          if (e.scrollTopChanged && this._lenses.length > 0) {
            this._resolveCodeLensesInViewportSoon();
          }
        }));
        this._localToDispose.add(this._editor.onDidLayoutChange(() => {
          this._resolveCodeLensesInViewportSoon();
        }));
        this._localToDispose.add(toDisposable(() => {
          if (this._editor.getModel()) {
            const scrollState = StableEditorScrollState.capture(this._editor);
            this._editor.changeDecorations((decorationsAccessor) => {
              this._editor.changeViewZones((viewZonesAccessor) => {
                this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
              });
            });
            scrollState.restore(this._editor);
          } else {
            this._disposeAllLenses(void 0, void 0);
          }
        }));
        this._localToDispose.add(this._editor.onMouseDown((e) => {
          if (e.target.type !== 9) {
            return;
          }
          let target = e.target.element;
          if ((target === null || target === void 0 ? void 0 : target.tagName) === "SPAN") {
            target = target.parentElement;
          }
          if ((target === null || target === void 0 ? void 0 : target.tagName) === "A") {
            for (const lens of this._lenses) {
              let command = lens.getCommand(target);
              if (command) {
                this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
                break;
              }
            }
          }
        }));
        scheduler.schedule();
      }
      _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
        const helper = new CodeLensHelper();
        for (const lens of this._lenses) {
          lens.dispose(helper, viewZoneChangeAccessor);
        }
        if (decChangeAccessor) {
          helper.commit(decChangeAccessor);
        }
        this._lenses.length = 0;
      }
      _renderCodeLensSymbols(symbols) {
        if (!this._editor.hasModel()) {
          return;
        }
        let maxLineNumber = this._editor.getModel().getLineCount();
        let groups = [];
        let lastGroup;
        for (let symbol of symbols.lenses) {
          let line = symbol.symbol.range.startLineNumber;
          if (line < 1 || line > maxLineNumber) {
            continue;
          } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
            lastGroup.push(symbol);
          } else {
            lastGroup = [symbol];
            groups.push(lastGroup);
          }
        }
        const scrollState = StableEditorScrollState.capture(this._editor);
        const layoutInfo = this._getLayoutInfo();
        this._editor.changeDecorations((decorationsAccessor) => {
          this._editor.changeViewZones((viewZoneAccessor) => {
            const helper = new CodeLensHelper();
            let codeLensIndex = 0;
            let groupsIndex = 0;
            while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
              let symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
              let codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
              if (codeLensLineNumber < symbolsLineNumber) {
                this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
                this._lenses.splice(codeLensIndex, 1);
              } else if (codeLensLineNumber === symbolsLineNumber) {
                this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
                groupsIndex++;
                codeLensIndex++;
              } else {
                this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
                codeLensIndex++;
                groupsIndex++;
              }
            }
            while (codeLensIndex < this._lenses.length) {
              this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
              this._lenses.splice(codeLensIndex, 1);
            }
            while (groupsIndex < groups.length) {
              this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
              groupsIndex++;
            }
            helper.commit(decorationsAccessor);
          });
        });
        scrollState.restore(this._editor);
      }
      _resolveCodeLensesInViewportSoon() {
        const model = this._editor.getModel();
        if (model) {
          this._resolveCodeLensesScheduler.schedule();
        }
      }
      _resolveCodeLensesInViewport() {
        var _a5;
        (_a5 = this._resolveCodeLensesPromise) === null || _a5 === void 0 ? void 0 : _a5.cancel();
        this._resolveCodeLensesPromise = void 0;
        const model = this._editor.getModel();
        if (!model) {
          return;
        }
        const toResolve = [];
        const lenses = [];
        this._lenses.forEach((lens) => {
          const request = lens.computeIfNecessary(model);
          if (request) {
            toResolve.push(request);
            lenses.push(lens);
          }
        });
        if (toResolve.length === 0) {
          return;
        }
        const t1 = Date.now();
        const resolvePromise = createCancelablePromise((token) => {
          const promises = toResolve.map((request, i) => {
            const resolvedSymbols = new Array(request.length);
            const promises2 = request.map((request2, i2) => {
              if (!request2.symbol.command && typeof request2.provider.resolveCodeLens === "function") {
                return Promise.resolve(request2.provider.resolveCodeLens(model, request2.symbol, token)).then((symbol) => {
                  resolvedSymbols[i2] = symbol;
                }, onUnexpectedExternalError);
              } else {
                resolvedSymbols[i2] = request2.symbol;
                return Promise.resolve(void 0);
              }
            });
            return Promise.all(promises2).then(() => {
              if (!token.isCancellationRequested && !lenses[i].isDisposed()) {
                lenses[i].updateCommands(resolvedSymbols);
              }
            });
          });
          return Promise.all(promises);
        });
        this._resolveCodeLensesPromise = resolvePromise;
        this._resolveCodeLensesPromise.then(() => {
          const newDelay = this._resolveCodeLensesDelays.update(model, Date.now() - t1);
          this._resolveCodeLensesScheduler.delay = newDelay;
          if (this._currentCodeLensModel) {
            this._codeLensCache.put(model, this._currentCodeLensModel);
          }
          this._oldCodeLensModels.clear();
          if (resolvePromise === this._resolveCodeLensesPromise) {
            this._resolveCodeLensesPromise = void 0;
          }
        }, (err) => {
          onUnexpectedError(err);
          if (resolvePromise === this._resolveCodeLensesPromise) {
            this._resolveCodeLensesPromise = void 0;
          }
        });
      }
      getLenses() {
        return this._lenses;
      }
    };
    CodeLensContribution.ID = "css.editor.codeLens";
    CodeLensContribution = __decorate8([
      __param8(1, ICommandService),
      __param8(2, INotificationService),
      __param8(3, ICodeLensCache)
    ], CodeLensContribution);
    registerEditorContribution(CodeLensContribution.ID, CodeLensContribution);
    registerEditorAction(class ShowLensesInCurrentLine extends EditorAction {
      constructor() {
        super({
          id: "codelens.showLensesInCurrentLine",
          precondition: EditorContextKeys.hasCodeLensProvider,
          label: localize("showLensOnLine", "Show CodeLens Commands For Current Line"),
          alias: "Show CodeLens Commands For Current Line"
        });
      }
      run(accessor, editor2) {
        return __awaiter9(this, void 0, void 0, function* () {
          if (!editor2.hasModel()) {
            return;
          }
          const quickInputService = accessor.get(IQuickInputService);
          const commandService = accessor.get(ICommandService);
          const notificationService = accessor.get(INotificationService);
          const lineNumber = editor2.getSelection().positionLineNumber;
          const codelensController = editor2.getContribution(CodeLensContribution.ID);
          const items = [];
          for (let lens of codelensController.getLenses()) {
            if (lens.getLineNumber() === lineNumber) {
              for (let item2 of lens.getItems()) {
                const { command } = item2.symbol;
                if (command) {
                  items.push({
                    label: command.title,
                    command
                  });
                }
              }
            }
          }
          if (items.length === 0) {
            return;
          }
          const item = yield quickInputService.pick(items, { canPickMany: false });
          if (!item) {
            return;
          }
          try {
            yield commandService.executeCommand(item.command.id, ...item.command.arguments || []);
          } catch (err) {
            notificationService.error(err);
          }
        });
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/color.js
function getColors(model, token) {
  const colors = [];
  const providers = ColorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, token)).then((result) => {
    if (Array.isArray(result)) {
      for (let colorInfo of result) {
        colors.push({ colorInfo, provider });
      }
    }
  }));
  return Promise.all(promises).then(() => colors);
}
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
var init_color2 = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/color.js"() {
    init_cancellation();
    init_errors();
    init_uri();
    init_range();
    init_modes();
    init_modelService();
    init_commands();
    CommandsRegistry.registerCommand("_executeDocumentColorProvider", function(accessor, ...args) {
      const [resource] = args;
      if (!(resource instanceof URI)) {
        throw illegalArgument();
      }
      const model = accessor.get(IModelService).getModel(resource);
      if (!model) {
        throw illegalArgument();
      }
      const rawCIs = [];
      const providers = ColorProviderRegistry.ordered(model).reverse();
      const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, CancellationToken.None)).then((result) => {
        if (Array.isArray(result)) {
          for (let ci of result) {
            rawCIs.push({ range: ci.range, color: [ci.color.red, ci.color.green, ci.color.blue, ci.color.alpha] });
          }
        }
      }));
      return Promise.all(promises).then(() => rawCIs);
    });
    CommandsRegistry.registerCommand("_executeColorPresentationProvider", function(accessor, ...args) {
      const [color, context] = args;
      const { uri, range } = context;
      if (!(uri instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range.isIRange(range)) {
        throw illegalArgument();
      }
      const [red, green, blue, alpha] = color;
      const model = accessor.get(IModelService).getModel(uri);
      if (!model) {
        throw illegalArgument();
      }
      const colorInfo = {
        range,
        color: { red, green, blue, alpha }
      };
      const presentations = [];
      const providers = ColorProviderRegistry.ordered(model).reverse();
      const promises = providers.map((provider) => Promise.resolve(provider.provideColorPresentations(model, colorInfo, CancellationToken.None)).then((result) => {
        if (Array.isArray(result)) {
          presentations.push(...result);
        }
      }));
      return Promise.all(promises).then(() => presentations);
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorDetector.js
var __decorate9, __param9, MAX_DECORATORS, ColorDetector;
var init_colorDetector = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorDetector.js"() {
    init_async();
    init_color();
    init_errors();
    init_hash();
    init_lifecycle();
    init_editorExtensions();
    init_codeEditorService();
    init_range();
    init_textModel();
    init_modes();
    init_color2();
    init_configuration();
    __decorate9 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param9 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    MAX_DECORATORS = 500;
    ColorDetector = class ColorDetector2 extends Disposable {
      constructor(_editor2, _codeEditorService, _configurationService) {
        super();
        this._editor = _editor2;
        this._codeEditorService = _codeEditorService;
        this._configurationService = _configurationService;
        this._localToDispose = this._register(new DisposableStore());
        this._decorationsIds = [];
        this._colorDatas = /* @__PURE__ */ new Map();
        this._colorDecoratorIds = [];
        this._decorationsTypes = /* @__PURE__ */ new Set();
        this._register(_editor2.onDidChangeModel(() => {
          this._isEnabled = this.isEnabled();
          this.onModelChanged();
        }));
        this._register(_editor2.onDidChangeModelLanguage(() => this.onModelChanged()));
        this._register(ColorProviderRegistry.onDidChange(() => this.onModelChanged()));
        this._register(_editor2.onDidChangeConfiguration(() => {
          let prevIsEnabled = this._isEnabled;
          this._isEnabled = this.isEnabled();
          if (prevIsEnabled !== this._isEnabled) {
            if (this._isEnabled) {
              this.onModelChanged();
            } else {
              this.removeAllDecorations();
            }
          }
        }));
        this._timeoutTimer = null;
        this._computePromise = null;
        this._isEnabled = this.isEnabled();
        this.onModelChanged();
      }
      isEnabled() {
        const model = this._editor.getModel();
        if (!model) {
          return false;
        }
        const languageId = model.getLanguageIdentifier();
        const deprecatedConfig = this._configurationService.getValue(languageId.language);
        if (deprecatedConfig && typeof deprecatedConfig === "object") {
          const colorDecorators = deprecatedConfig["colorDecorators"];
          if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) {
            return colorDecorators["enable"];
          }
        }
        return this._editor.getOption(
          17
          /* colorDecorators */
        );
      }
      static get(editor2) {
        return editor2.getContribution(this.ID);
      }
      dispose() {
        this.stop();
        this.removeAllDecorations();
        super.dispose();
      }
      onModelChanged() {
        this.stop();
        if (!this._isEnabled) {
          return;
        }
        const model = this._editor.getModel();
        if (!model || !ColorProviderRegistry.has(model)) {
          return;
        }
        this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
          if (!this._timeoutTimer) {
            this._timeoutTimer = new TimeoutTimer();
            this._timeoutTimer.cancelAndSet(() => {
              this._timeoutTimer = null;
              this.beginCompute();
            }, ColorDetector2.RECOMPUTE_TIME);
          }
        }));
        this.beginCompute();
      }
      beginCompute() {
        this._computePromise = createCancelablePromise((token) => {
          const model = this._editor.getModel();
          if (!model) {
            return Promise.resolve([]);
          }
          return getColors(model, token);
        });
        this._computePromise.then((colorInfos) => {
          this.updateDecorations(colorInfos);
          this.updateColorDecorators(colorInfos);
          this._computePromise = null;
        }, onUnexpectedError);
      }
      stop() {
        if (this._timeoutTimer) {
          this._timeoutTimer.cancel();
          this._timeoutTimer = null;
        }
        if (this._computePromise) {
          this._computePromise.cancel();
          this._computePromise = null;
        }
        this._localToDispose.clear();
      }
      updateDecorations(colorDatas) {
        const decorations = colorDatas.map((c) => ({
          range: {
            startLineNumber: c.colorInfo.range.startLineNumber,
            startColumn: c.colorInfo.range.startColumn,
            endLineNumber: c.colorInfo.range.endLineNumber,
            endColumn: c.colorInfo.range.endColumn
          },
          options: ModelDecorationOptions.EMPTY
        }));
        this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, decorations);
        this._colorDatas = /* @__PURE__ */ new Map();
        this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));
      }
      updateColorDecorators(colorData) {
        let decorations = [];
        let newDecorationsTypes = {};
        for (let i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {
          const { red, green, blue, alpha } = colorData[i].colorInfo.color;
          const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
          let subKey = hash(`rgba(${rgba.r},${rgba.g},${rgba.b},${rgba.a})`).toString(16);
          let color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
          let key = "colorBox-" + subKey;
          if (!this._decorationsTypes.has(key) && !newDecorationsTypes[key]) {
            this._codeEditorService.registerDecorationType("color-detector-color", key, {
              before: {
                contentText: " ",
                border: "solid 0.1em #000",
                margin: "0.1em 0.2em 0 0.2em",
                width: "0.8em",
                height: "0.8em",
                backgroundColor: color
              },
              dark: {
                before: {
                  border: "solid 0.1em #eee"
                }
              }
            }, void 0, this._editor);
          }
          newDecorationsTypes[key] = true;
          decorations.push({
            range: {
              startLineNumber: colorData[i].colorInfo.range.startLineNumber,
              startColumn: colorData[i].colorInfo.range.startColumn,
              endLineNumber: colorData[i].colorInfo.range.endLineNumber,
              endColumn: colorData[i].colorInfo.range.endColumn
            },
            options: this._codeEditorService.resolveDecorationOptions(key, true)
          });
        }
        this._decorationsTypes.forEach((subType) => {
          if (!newDecorationsTypes[subType]) {
            this._codeEditorService.removeDecorationType(subType);
          }
        });
        this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, decorations);
      }
      removeAllDecorations() {
        this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, []);
        this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, []);
        this._decorationsTypes.forEach((subType) => {
          this._codeEditorService.removeDecorationType(subType);
        });
      }
      getColorData(position) {
        const model = this._editor.getModel();
        if (!model) {
          return null;
        }
        const decorations = model.getDecorationsInRange(Range.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
        if (decorations.length === 0) {
          return null;
        }
        return this._colorDatas.get(decorations[0].id);
      }
    };
    ColorDetector.ID = "editor.contrib.colorDetector";
    ColorDetector.RECOMPUTE_TIME = 1e3;
    ColorDetector = __decorate9([
      __param9(1, ICodeEditorService),
      __param9(2, IConfigurationService)
    ], ColorDetector);
    registerEditorContribution(ColorDetector.ID, ColorDetector);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/clickLinkGesture.js
function hasModifier(e, modifier) {
  return !!e[modifier];
}
function createOptions(multiCursorModifier) {
  if (multiCursorModifier === "altKey") {
    if (isMacintosh) {
      return new ClickLinkOptions(57, "metaKey", 6, "altKey");
    }
    return new ClickLinkOptions(5, "ctrlKey", 6, "altKey");
  }
  if (isMacintosh) {
    return new ClickLinkOptions(6, "altKey", 57, "metaKey");
  }
  return new ClickLinkOptions(6, "altKey", 5, "ctrlKey");
}
var ClickLinkMouseEvent, ClickLinkKeyboardEvent, ClickLinkOptions, ClickLinkGesture;
var init_clickLinkGesture = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/clickLinkGesture.js"() {
    init_event();
    init_lifecycle();
    init_platform();
    ClickLinkMouseEvent = class {
      constructor(source, opts) {
        this.target = source.target;
        this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
        this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
        this.isNoneOrSingleMouseDown = source.event.detail <= 1;
      }
    };
    ClickLinkKeyboardEvent = class {
      constructor(source, opts) {
        this.keyCodeIsTriggerKey = source.keyCode === opts.triggerKey;
        this.keyCodeIsSideBySideKey = source.keyCode === opts.triggerSideBySideKey;
        this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
      }
    };
    ClickLinkOptions = class {
      constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {
        this.triggerKey = triggerKey;
        this.triggerModifier = triggerModifier;
        this.triggerSideBySideKey = triggerSideBySideKey;
        this.triggerSideBySideModifier = triggerSideBySideModifier;
      }
      equals(other) {
        return this.triggerKey === other.triggerKey && this.triggerModifier === other.triggerModifier && this.triggerSideBySideKey === other.triggerSideBySideKey && this.triggerSideBySideModifier === other.triggerSideBySideModifier;
      }
    };
    ClickLinkGesture = class extends Disposable {
      constructor(editor2) {
        super();
        this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter());
        this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
        this._onExecute = this._register(new Emitter());
        this.onExecute = this._onExecute.event;
        this._onCancel = this._register(new Emitter());
        this.onCancel = this._onCancel.event;
        this._editor = editor2;
        this._opts = createOptions(this._editor.getOption(
          69
          /* multiCursorModifier */
        ));
        this._lastMouseMoveEvent = null;
        this._hasTriggerKeyOnMouseDown = false;
        this._lineNumberOnMouseDown = 0;
        this._register(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            69
            /* multiCursorModifier */
          )) {
            const newOpts = createOptions(this._editor.getOption(
              69
              /* multiCursorModifier */
            ));
            if (this._opts.equals(newOpts)) {
              return;
            }
            this._opts = newOpts;
            this._lastMouseMoveEvent = null;
            this._hasTriggerKeyOnMouseDown = false;
            this._lineNumberOnMouseDown = 0;
            this._onCancel.fire();
          }
        }));
        this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));
        this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));
        this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));
        this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));
        this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));
        this._register(this._editor.onMouseDrag(() => this._resetHandler()));
        this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));
        this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));
        this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));
        this._register(this._editor.onDidScrollChange((e) => {
          if (e.scrollTopChanged || e.scrollLeftChanged) {
            this._resetHandler();
          }
        }));
      }
      _onDidChangeCursorSelection(e) {
        if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
          this._resetHandler();
        }
      }
      _onEditorMouseMove(mouseEvent) {
        this._lastMouseMoveEvent = mouseEvent;
        this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
      }
      _onEditorMouseDown(mouseEvent) {
        this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
        this._lineNumberOnMouseDown = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
      }
      _onEditorMouseUp(mouseEvent) {
        const currentLineNumber = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
        if (this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber) {
          this._onExecute.fire(mouseEvent);
        }
      }
      _onEditorKeyDown(e) {
        if (this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier)) {
          this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);
        } else if (e.hasTriggerModifier) {
          this._onCancel.fire();
        }
      }
      _onEditorKeyUp(e) {
        if (e.keyCodeIsTriggerKey) {
          this._onCancel.fire();
        }
      }
      _resetHandler() {
        this._lastMouseMoveEvent = null;
        this._hasTriggerKeyOnMouseDown = false;
        this._onCancel.fire();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js
var __decorate10, __param10, EmbeddedCodeEditorWidget;
var init_embeddedCodeEditorWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js"() {
    init_objects();
    init_codeEditorService();
    init_codeEditorWidget();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_notification();
    init_themeService();
    init_accessibility();
    __decorate10 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param10 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget2 extends CodeEditorWidget {
      constructor(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService) {
        super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), { overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }), {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService);
        this._parentEditor = parentEditor;
        this._overwriteOptions = options;
        super.updateOptions(this._overwriteOptions);
        this._register(parentEditor.onDidChangeConfiguration((e) => this._onParentConfigurationChanged(e)));
      }
      getParentEditor() {
        return this._parentEditor;
      }
      _onParentConfigurationChanged(e) {
        super.updateOptions(this._parentEditor.getRawOptions());
        super.updateOptions(this._overwriteOptions);
      }
      updateOptions(newOptions) {
        mixin(this._overwriteOptions, newOptions, true);
        super.updateOptions(this._overwriteOptions);
      }
    };
    EmbeddedCodeEditorWidget = __decorate10([
      __param10(3, IInstantiationService),
      __param10(4, ICodeEditorService),
      __param10(5, ICommandService),
      __param10(6, IContextKeyService),
      __param10(7, IThemeService),
      __param10(8, INotificationService),
      __param10(9, IAccessibilityService)
    ], EmbeddedCodeEditorWidget);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.js
var defaultColor, defaultOptions, WIDGET_ID, ViewZoneDelegate, OverlayWidgetDelegate, Arrow, ZoneWidget;
var init_zoneWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.js"() {
    init_dom();
    init_sash();
    init_color();
    init_idGenerator();
    init_lifecycle();
    init_objects();
    init_range();
    init_textModel();
    defaultColor = new Color(new RGBA(0, 122, 204));
    defaultOptions = {
      showArrow: true,
      showFrame: true,
      className: "",
      frameColor: defaultColor,
      arrowColor: defaultColor,
      keepEditorSelection: false
    };
    WIDGET_ID = "vs.editor.contrib.zoneWidget";
    ViewZoneDelegate = class {
      constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
        this.id = "";
        this.domNode = domNode;
        this.afterLineNumber = afterLineNumber;
        this.afterColumn = afterColumn;
        this.heightInLines = heightInLines;
        this._onDomNodeTop = onDomNodeTop;
        this._onComputedHeight = onComputedHeight;
      }
      onDomNodeTop(top) {
        this._onDomNodeTop(top);
      }
      onComputedHeight(height) {
        this._onComputedHeight(height);
      }
    };
    OverlayWidgetDelegate = class {
      constructor(id, domNode) {
        this._id = id;
        this._domNode = domNode;
      }
      getId() {
        return this._id;
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        return null;
      }
    };
    Arrow = class _Arrow {
      constructor(_editor2) {
        this._editor = _editor2;
        this._ruleName = _Arrow._IdGenerator.nextId();
        this._decorations = [];
        this._color = null;
        this._height = -1;
      }
      dispose() {
        this.hide();
        removeCSSRulesContainingSelector(this._ruleName);
      }
      set color(value) {
        if (this._color !== value) {
          this._color = value;
          this._updateStyle();
        }
      }
      set height(value) {
        if (this._height !== value) {
          this._height = value;
          this._updateStyle();
        }
      }
      _updateStyle() {
        removeCSSRulesContainingSelector(this._ruleName);
        createCSSRule(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);
      }
      show(where) {
        this._decorations = this._editor.deltaDecorations(this._decorations, [{ range: Range.fromPositions(where), options: {
          description: "zone-widget-arrow",
          className: this._ruleName,
          stickiness: 1
          /* NeverGrowsWhenTypingAtEdges */
        } }]);
      }
      hide() {
        this._editor.deltaDecorations(this._decorations, []);
      }
    };
    Arrow._IdGenerator = new IdGenerator(".arrow-decoration-");
    ZoneWidget = class {
      constructor(editor2, options = {}) {
        this._arrow = null;
        this._overlayWidget = null;
        this._resizeSash = null;
        this._positionMarkerId = [];
        this._viewZone = null;
        this._disposables = new DisposableStore();
        this.container = null;
        this._isShowing = false;
        this.editor = editor2;
        this.options = deepClone(options);
        mixin(this.options, defaultOptions, false);
        this.domNode = document.createElement("div");
        if (!this.options.isAccessible) {
          this.domNode.setAttribute("aria-hidden", "true");
          this.domNode.setAttribute("role", "presentation");
        }
        this._disposables.add(this.editor.onDidLayoutChange((info) => {
          const width = this._getWidth(info);
          this.domNode.style.width = width + "px";
          this.domNode.style.left = this._getLeft(info) + "px";
          this._onWidth(width);
        }));
      }
      dispose() {
        if (this._overlayWidget) {
          this.editor.removeOverlayWidget(this._overlayWidget);
          this._overlayWidget = null;
        }
        if (this._viewZone) {
          this.editor.changeViewZones((accessor) => {
            if (this._viewZone) {
              accessor.removeZone(this._viewZone.id);
            }
            this._viewZone = null;
          });
        }
        this.editor.deltaDecorations(this._positionMarkerId, []);
        this._positionMarkerId = [];
        this._disposables.dispose();
      }
      create() {
        this.domNode.classList.add("zone-widget");
        if (this.options.className) {
          this.domNode.classList.add(this.options.className);
        }
        this.container = document.createElement("div");
        this.container.classList.add("zone-widget-container");
        this.domNode.appendChild(this.container);
        if (this.options.showArrow) {
          this._arrow = new Arrow(this.editor);
          this._disposables.add(this._arrow);
        }
        this._fillContainer(this.container);
        this._initSash();
        this._applyStyles();
      }
      style(styles) {
        if (styles.frameColor) {
          this.options.frameColor = styles.frameColor;
        }
        if (styles.arrowColor) {
          this.options.arrowColor = styles.arrowColor;
        }
        this._applyStyles();
      }
      _applyStyles() {
        if (this.container && this.options.frameColor) {
          let frameColor = this.options.frameColor.toString();
          this.container.style.borderTopColor = frameColor;
          this.container.style.borderBottomColor = frameColor;
        }
        if (this._arrow && this.options.arrowColor) {
          let arrowColor = this.options.arrowColor.toString();
          this._arrow.color = arrowColor;
        }
      }
      _getWidth(info) {
        return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;
      }
      _getLeft(info) {
        if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) {
          return info.minimap.minimapWidth;
        }
        return 0;
      }
      _onViewZoneTop(top) {
        this.domNode.style.top = top + "px";
      }
      _onViewZoneHeight(height) {
        this.domNode.style.height = `${height}px`;
        if (this.container) {
          let containerHeight = height - this._decoratingElementsHeight();
          this.container.style.height = `${containerHeight}px`;
          const layoutInfo = this.editor.getLayoutInfo();
          this._doLayout(containerHeight, this._getWidth(layoutInfo));
        }
        if (this._resizeSash) {
          this._resizeSash.layout();
        }
      }
      get position() {
        const [id] = this._positionMarkerId;
        if (!id) {
          return void 0;
        }
        const model = this.editor.getModel();
        if (!model) {
          return void 0;
        }
        const range = model.getDecorationRange(id);
        if (!range) {
          return void 0;
        }
        return range.getStartPosition();
      }
      show(rangeOrPos, heightInLines) {
        const range = Range.isIRange(rangeOrPos) ? Range.lift(rangeOrPos) : Range.fromPositions(rangeOrPos);
        this._isShowing = true;
        this._showImpl(range, heightInLines);
        this._isShowing = false;
        this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{ range, options: ModelDecorationOptions.EMPTY }]);
      }
      hide() {
        if (this._viewZone) {
          this.editor.changeViewZones((accessor) => {
            if (this._viewZone) {
              accessor.removeZone(this._viewZone.id);
            }
          });
          this._viewZone = null;
        }
        if (this._overlayWidget) {
          this.editor.removeOverlayWidget(this._overlayWidget);
          this._overlayWidget = null;
        }
        if (this._arrow) {
          this._arrow.hide();
        }
      }
      _decoratingElementsHeight() {
        let lineHeight = this.editor.getOption(
          58
          /* lineHeight */
        );
        let result = 0;
        if (this.options.showArrow) {
          let arrowHeight = Math.round(lineHeight / 3);
          result += 2 * arrowHeight;
        }
        if (this.options.showFrame) {
          let frameThickness = Math.round(lineHeight / 9);
          result += 2 * frameThickness;
        }
        return result;
      }
      _showImpl(where, heightInLines) {
        const position = where.getStartPosition();
        const layoutInfo = this.editor.getLayoutInfo();
        const width = this._getWidth(layoutInfo);
        this.domNode.style.width = `${width}px`;
        this.domNode.style.left = this._getLeft(layoutInfo) + "px";
        const viewZoneDomNode = document.createElement("div");
        viewZoneDomNode.style.overflow = "hidden";
        const lineHeight = this.editor.getOption(
          58
          /* lineHeight */
        );
        const maxHeightInLines = Math.max(12, this.editor.getLayoutInfo().height / lineHeight * 0.8);
        heightInLines = Math.min(heightInLines, maxHeightInLines);
        let arrowHeight = 0;
        let frameThickness = 0;
        if (this._arrow && this.options.showArrow) {
          arrowHeight = Math.round(lineHeight / 3);
          this._arrow.height = arrowHeight;
          this._arrow.show(position);
        }
        if (this.options.showFrame) {
          frameThickness = Math.round(lineHeight / 9);
        }
        this.editor.changeViewZones((accessor) => {
          if (this._viewZone) {
            accessor.removeZone(this._viewZone.id);
          }
          if (this._overlayWidget) {
            this.editor.removeOverlayWidget(this._overlayWidget);
            this._overlayWidget = null;
          }
          this.domNode.style.top = "-1000px";
          this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height));
          this._viewZone.id = accessor.addZone(this._viewZone);
          this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);
          this.editor.addOverlayWidget(this._overlayWidget);
        });
        if (this.container && this.options.showFrame) {
          const width2 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
          this.container.style.borderTopWidth = width2 + "px";
          this.container.style.borderBottomWidth = width2 + "px";
        }
        let containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
        if (this.container) {
          this.container.style.top = arrowHeight + "px";
          this.container.style.height = containerHeight + "px";
          this.container.style.overflow = "hidden";
        }
        this._doLayout(containerHeight, width);
        if (!this.options.keepEditorSelection) {
          this.editor.setSelection(where);
        }
        const model = this.editor.getModel();
        if (model) {
          const revealLine = where.endLineNumber + 1;
          if (revealLine <= model.getLineCount()) {
            this.revealLine(revealLine, false);
          } else {
            this.revealLine(model.getLineCount(), true);
          }
        }
      }
      revealLine(lineNumber, isLastLine) {
        if (isLastLine) {
          this.editor.revealLineInCenter(
            lineNumber,
            0
            /* Smooth */
          );
        } else {
          this.editor.revealLine(
            lineNumber,
            0
            /* Smooth */
          );
        }
      }
      setCssClass(className, classToReplace) {
        if (!this.container) {
          return;
        }
        if (classToReplace) {
          this.container.classList.remove(classToReplace);
        }
        this.container.classList.add(className);
      }
      _onWidth(widthInPixel) {
      }
      _doLayout(heightInPixel, widthInPixel) {
      }
      _relayout(newHeightInLines) {
        if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) {
          this.editor.changeViewZones((accessor) => {
            if (this._viewZone) {
              this._viewZone.heightInLines = newHeightInLines;
              accessor.layoutZone(this._viewZone.id);
            }
          });
        }
      }
      // --- sash
      _initSash() {
        if (this._resizeSash) {
          return;
        }
        this._resizeSash = this._disposables.add(new Sash(this.domNode, this, {
          orientation: 1
          /* HORIZONTAL */
        }));
        if (!this.options.isResizeable) {
          this._resizeSash.hide();
          this._resizeSash.state = 0;
        }
        let data;
        this._disposables.add(this._resizeSash.onDidStart((e) => {
          if (this._viewZone) {
            data = {
              startY: e.startY,
              heightInLines: this._viewZone.heightInLines
            };
          }
        }));
        this._disposables.add(this._resizeSash.onDidEnd(() => {
          data = void 0;
        }));
        this._disposables.add(this._resizeSash.onDidChange((evt) => {
          if (data) {
            let lineDelta = (evt.currentY - data.startY) / this.editor.getOption(
              58
              /* lineHeight */
            );
            let roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
            let newHeightInLines = data.heightInLines + roundedLineDelta;
            if (newHeightInLines > 5 && newHeightInLines < 35) {
              this._relayout(newHeightInLines);
            }
          }
        }));
      }
      getHorizontalSashLeft() {
        return 0;
      }
      getHorizontalSashTop() {
        return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
      }
      getHorizontalSashWidth() {
        const layoutInfo = this.editor.getLayoutInfo();
        return layoutInfo.width - layoutInfo.minimap.minimapWidth;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.js
var BaseDropdown, DropdownMenu;
var init_dropdown = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.js"() {
    init_dom();
    init_keyboardEvent();
    init_touch();
    init_actions();
    init_event();
    BaseDropdown = class extends ActionRunner {
      constructor(container, options) {
        super();
        this._onDidChangeVisibility = this._register(new Emitter());
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this._element = append(container, $(".monaco-dropdown"));
        this._label = append(this._element, $(".dropdown-label"));
        let labelRenderer = options.labelRenderer;
        if (!labelRenderer) {
          labelRenderer = (container2) => {
            container2.textContent = options.label || "";
            return null;
          };
        }
        for (const event of [EventType.CLICK, EventType.MOUSE_DOWN, EventType2.Tap]) {
          this._register(addDisposableListener(this.element, event, (e) => EventHelper.stop(e, true)));
        }
        for (const event of [EventType.MOUSE_DOWN, EventType2.Tap]) {
          this._register(addDisposableListener(this._label, event, (e) => {
            if (e instanceof MouseEvent && e.detail > 1) {
              return;
            }
            if (this.visible) {
              this.hide();
            } else {
              this.show();
            }
          }));
        }
        this._register(addDisposableListener(this._label, EventType.KEY_UP, (e) => {
          const event = new StandardKeyboardEvent(e);
          if (event.equals(
            3
            /* Enter */
          ) || event.equals(
            10
            /* Space */
          )) {
            EventHelper.stop(e, true);
            if (this.visible) {
              this.hide();
            } else {
              this.show();
            }
          }
        }));
        const cleanupFn = labelRenderer(this._label);
        if (cleanupFn) {
          this._register(cleanupFn);
        }
        this._register(Gesture.addTarget(this._label));
      }
      get element() {
        return this._element;
      }
      show() {
        if (!this.visible) {
          this.visible = true;
          this._onDidChangeVisibility.fire(true);
        }
      }
      hide() {
        if (this.visible) {
          this.visible = false;
          this._onDidChangeVisibility.fire(false);
        }
      }
      dispose() {
        super.dispose();
        this.hide();
        if (this.boxContainer) {
          this.boxContainer.remove();
          this.boxContainer = void 0;
        }
        if (this.contents) {
          this.contents.remove();
          this.contents = void 0;
        }
        if (this._label) {
          this._label.remove();
          this._label = void 0;
        }
      }
    };
    DropdownMenu = class extends BaseDropdown {
      constructor(container, options) {
        super(container, options);
        this._actions = [];
        this._contextMenuProvider = options.contextMenuProvider;
        this.actions = options.actions || [];
        this.actionProvider = options.actionProvider;
        this.menuClassName = options.menuClassName || "";
        this.menuAsChild = !!options.menuAsChild;
      }
      set menuOptions(options) {
        this._menuOptions = options;
      }
      get menuOptions() {
        return this._menuOptions;
      }
      get actions() {
        if (this.actionProvider) {
          return this.actionProvider.getActions();
        }
        return this._actions;
      }
      set actions(actions) {
        this._actions = actions;
      }
      show() {
        super.show();
        this.element.classList.add("active");
        this._contextMenuProvider.showContextMenu({
          getAnchor: () => this.element,
          getActions: () => this.actions,
          getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
          getActionViewItem: (action) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(action) : void 0,
          getKeyBinding: (action) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(action) : void 0,
          getMenuClassName: () => this.menuClassName,
          onHide: () => this.onHide(),
          actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
          anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
          domForShadowRoot: this.menuAsChild ? this.element : void 0
        });
      }
      hide() {
        super.hide();
      }
      onHide() {
        this.hide();
        this.element.classList.remove("active");
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
var DropdownMenuActionViewItem;
var init_dropdownActionViewItem = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js"() {
    init_dom();
    init_actionViewItems();
    init_dropdown();
    init_event();
    DropdownMenuActionViewItem = class extends BaseActionViewItem {
      constructor(action, menuActionsOrProvider, contextMenuProvider, options = /* @__PURE__ */ Object.create(null)) {
        super(null, action, options);
        this.actionItem = null;
        this._onDidChangeVisibility = this._register(new Emitter());
        this.menuActionsOrProvider = menuActionsOrProvider;
        this.contextMenuProvider = contextMenuProvider;
        this.options = options;
        if (this.options.actionRunner) {
          this.actionRunner = this.options.actionRunner;
        }
      }
      render(container) {
        this.actionItem = container;
        const labelRenderer = (el) => {
          this.element = append(el, $("a.action-label"));
          let classNames = [];
          if (typeof this.options.classNames === "string") {
            classNames = this.options.classNames.split(/\s+/g).filter((s) => !!s);
          } else if (this.options.classNames) {
            classNames = this.options.classNames;
          }
          if (!classNames.find((c) => c === "icon")) {
            classNames.push("codicon");
          }
          this.element.classList.add(...classNames);
          this.element.setAttribute("role", "button");
          this.element.setAttribute("aria-haspopup", "true");
          this.element.setAttribute("aria-expanded", "false");
          this.element.title = this._action.label || "";
          return null;
        };
        const isActionsArray = Array.isArray(this.menuActionsOrProvider);
        const options = {
          contextMenuProvider: this.contextMenuProvider,
          labelRenderer,
          menuAsChild: this.options.menuAsChild,
          actions: isActionsArray ? this.menuActionsOrProvider : void 0,
          actionProvider: isActionsArray ? void 0 : this.menuActionsOrProvider
        };
        this.dropdownMenu = this._register(new DropdownMenu(container, options));
        this._register(this.dropdownMenu.onDidChangeVisibility((visible) => {
          var _a5;
          (_a5 = this.element) === null || _a5 === void 0 ? void 0 : _a5.setAttribute("aria-expanded", `${visible}`);
          this._onDidChangeVisibility.fire(visible);
        }));
        this.dropdownMenu.menuOptions = {
          actionViewItemProvider: this.options.actionViewItemProvider,
          actionRunner: this.actionRunner,
          getKeyBinding: this.options.keybindingProvider,
          context: this._context
        };
        if (this.options.anchorAlignmentProvider) {
          const that = this;
          this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), { get anchorAlignment() {
            return that.options.anchorAlignmentProvider();
          } });
        }
        this.updateEnabled();
      }
      setActionContext(newContext) {
        super.setActionContext(newContext);
        if (this.dropdownMenu) {
          if (this.dropdownMenu.menuOptions) {
            this.dropdownMenu.menuOptions.context = newContext;
          } else {
            this.dropdownMenu.menuOptions = { context: newContext };
          }
        }
      }
      updateEnabled() {
        var _a5, _b2;
        const disabled = !this.getAction().enabled;
        (_a5 = this.actionItem) === null || _a5 === void 0 ? void 0 : _a5.classList.toggle("disabled", disabled);
        (_b2 = this.element) === null || _b2 === void 0 ? void 0 : _b2.classList.toggle("disabled", disabled);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
function createAndFillInActionBarActions(menu, options, target, primaryGroup, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions) {
  const groups = menu.getActions(options);
  const isPrimaryAction = typeof primaryGroup === "string" ? (actionGroup) => actionGroup === primaryGroup : primaryGroup;
  fillInActions(groups, target, false, isPrimaryAction, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions);
  return asDisposable(groups);
}
function asDisposable(groups) {
  const disposables = new DisposableStore();
  for (const [, actions] of groups) {
    for (const action of actions) {
      disposables.add(action);
    }
  }
  return disposables;
}
function fillInActions(groups, target, useAlternativeActions, isPrimaryAction = (actionGroup) => actionGroup === "navigation", primaryMaxCount = Number.MAX_SAFE_INTEGER, shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {
  let primaryBucket;
  let secondaryBucket;
  if (Array.isArray(target)) {
    primaryBucket = target;
    secondaryBucket = target;
  } else {
    primaryBucket = target.primary;
    secondaryBucket = target.secondary;
  }
  const submenuInfo = /* @__PURE__ */ new Set();
  for (const [group, actions] of groups) {
    let target2;
    if (isPrimaryAction(group)) {
      target2 = primaryBucket;
      if (target2.length > 0 && useSeparatorsInPrimaryActions) {
        target2.push(new Separator());
      }
    } else {
      target2 = secondaryBucket;
      if (target2.length > 0) {
        target2.push(new Separator());
      }
    }
    for (let action of actions) {
      if (useAlternativeActions) {
        action = action instanceof MenuItemAction && action.alt ? action.alt : action;
      }
      const newLen = target2.push(action);
      if (action instanceof SubmenuAction) {
        submenuInfo.add({ group, action, index: newLen - 1 });
      }
    }
  }
  for (const { group, action, index } of submenuInfo) {
    const target2 = isPrimaryAction(group) ? primaryBucket : secondaryBucket;
    const submenuActions = action.actions;
    if ((submenuActions.length <= 1 || target2.length + submenuActions.length - 2 <= primaryMaxCount) && shouldInlineSubmenu(action, group, target2.length)) {
      target2.splice(index, 1, ...submenuActions);
    }
  }
  if (primaryBucket !== secondaryBucket && primaryBucket.length > primaryMaxCount) {
    const overflow = primaryBucket.splice(primaryMaxCount, primaryBucket.length - primaryMaxCount);
    secondaryBucket.unshift(...overflow, new Separator());
  }
}
function createActionViewItem(instaService, action, options) {
  if (action instanceof MenuItemAction) {
    return instaService.createInstance(MenuEntryActionViewItem, action, void 0);
  } else if (action instanceof SubmenuItemAction) {
    if (action.item.rememberDefaultAction) {
      return instaService.createInstance(DropdownWithDefaultActionViewItem, action, options);
    } else {
      return instaService.createInstance(SubmenuEntryActionViewItem, action, options);
    }
  } else {
    return void 0;
  }
}
var __decorate11, __param11, __awaiter10, MenuEntryActionViewItem, SubmenuEntryActionViewItem, DropdownWithDefaultActionViewItem;
var init_menuEntryActionViewItem = __esm({
  "node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js"() {
    init_dom();
    init_keyboardEvent();
    init_actionViewItems();
    init_dropdownActionViewItem();
    init_actions();
    init_keybindingLabels();
    init_lifecycle();
    init_platform();
    init_nls();
    init_actions2();
    init_contextkey();
    init_contextView();
    init_instantiation();
    init_keybinding();
    init_notification();
    init_storage();
    init_themeService();
    __decorate11 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param11 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter10 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MenuEntryActionViewItem = class MenuEntryActionViewItem2 extends ActionViewItem {
      constructor(_action, options, _keybindingService, _notificationService, _contextKeyService) {
        super(void 0, _action, { icon: !!(_action.class || _action.item.icon), label: !_action.class && !_action.item.icon, draggable: options === null || options === void 0 ? void 0 : options.draggable });
        this._keybindingService = _keybindingService;
        this._notificationService = _notificationService;
        this._contextKeyService = _contextKeyService;
        this._wantsAltCommand = false;
        this._itemClassDispose = this._register(new MutableDisposable());
        this._altKey = ModifierKeyEmitter.getInstance();
      }
      get _menuItemAction() {
        return this._action;
      }
      get _commandAction() {
        return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
      }
      onClick(event) {
        return __awaiter10(this, void 0, void 0, function* () {
          event.preventDefault();
          event.stopPropagation();
          try {
            yield this.actionRunner.run(this._commandAction, this._context);
          } catch (err) {
            this._notificationService.error(err);
          }
        });
      }
      render(container) {
        super.render(container);
        container.classList.add("menu-entry");
        this._updateItemClass(this._menuItemAction.item);
        let mouseOver = false;
        let alternativeKeyDown = this._altKey.keyStatus.altKey || (isWindows || isLinux) && this._altKey.keyStatus.shiftKey;
        const updateAltState = () => {
          const wantsAltCommand = mouseOver && alternativeKeyDown;
          if (wantsAltCommand !== this._wantsAltCommand) {
            this._wantsAltCommand = wantsAltCommand;
            this.updateLabel();
            this.updateTooltip();
            this.updateClass();
          }
        };
        if (this._menuItemAction.alt) {
          this._register(this._altKey.event((value) => {
            alternativeKeyDown = value.altKey || (isWindows || isLinux) && value.shiftKey;
            updateAltState();
          }));
        }
        this._register(addDisposableListener(container, "mouseleave", (_) => {
          mouseOver = false;
          updateAltState();
        }));
        this._register(addDisposableListener(container, "mouseenter", (_) => {
          mouseOver = true;
          updateAltState();
        }));
      }
      updateLabel() {
        if (this.options.label && this.label) {
          this.label.textContent = this._commandAction.label;
        }
      }
      updateTooltip() {
        if (this.label) {
          const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);
          const keybindingLabel = keybinding && keybinding.getLabel();
          const tooltip = this._commandAction.tooltip || this._commandAction.label;
          let title = keybindingLabel ? localize("titleAndKb", "{0} ({1})", tooltip, keybindingLabel) : tooltip;
          if (!this._wantsAltCommand && this._menuItemAction.alt) {
            const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;
            const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);
            const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();
            const altTitleSection = altKeybindingLabel ? localize("titleAndKb", "{0} ({1})", altTooltip, altKeybindingLabel) : altTooltip;
            title += `
[${UILabelProvider.modifierLabels[OS].altKey}] ${altTitleSection}`;
          }
          this.label.title = title;
        }
      }
      updateClass() {
        if (this.options.icon) {
          if (this._commandAction !== this._menuItemAction) {
            if (this._menuItemAction.alt) {
              this._updateItemClass(this._menuItemAction.alt.item);
            }
          } else if (this._menuItemAction.alt) {
            this._updateItemClass(this._menuItemAction.item);
          }
        }
      }
      _updateItemClass(item) {
        var _a5;
        this._itemClassDispose.value = void 0;
        const { element, label } = this;
        if (!element || !label) {
          return;
        }
        const icon = this._commandAction.checked && ((_a5 = item.toggled) === null || _a5 === void 0 ? void 0 : _a5.icon) ? item.toggled.icon : item.icon;
        if (!icon) {
          return;
        }
        if (ThemeIcon.isThemeIcon(icon)) {
          const iconClasses = ThemeIcon.asClassNameArray(icon);
          label.classList.add(...iconClasses);
          this._itemClassDispose.value = toDisposable(() => {
            label.classList.remove(...iconClasses);
          });
        } else {
          if (icon.light) {
            label.style.setProperty("--menu-entry-icon-light", asCSSUrl(icon.light));
          }
          if (icon.dark) {
            label.style.setProperty("--menu-entry-icon-dark", asCSSUrl(icon.dark));
          }
          label.classList.add("icon");
          this._itemClassDispose.value = toDisposable(() => {
            label.classList.remove("icon");
            label.style.removeProperty("--menu-entry-icon-light");
            label.style.removeProperty("--menu-entry-icon-dark");
          });
        }
      }
    };
    MenuEntryActionViewItem = __decorate11([
      __param11(2, IKeybindingService),
      __param11(3, INotificationService),
      __param11(4, IContextKeyService)
    ], MenuEntryActionViewItem);
    SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem2 extends DropdownMenuActionViewItem {
      constructor(action, options, contextMenuService) {
        var _a5, _b2;
        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : /* @__PURE__ */ Object.create(null), {
          menuAsChild: (_a5 = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a5 !== void 0 ? _a5 : true,
          classNames: (_b2 = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b2 !== void 0 ? _b2 : ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : void 0
        });
        super(action, { getActions: () => action.actions }, contextMenuService, dropdownOptions);
      }
      render(container) {
        super.render(container);
        if (this.element) {
          container.classList.add("menu-entry");
          const { icon } = this._action.item;
          if (icon && !ThemeIcon.isThemeIcon(icon)) {
            this.element.classList.add("icon");
            if (icon.light) {
              this.element.style.setProperty("--menu-entry-icon-light", asCSSUrl(icon.light));
            }
            if (icon.dark) {
              this.element.style.setProperty("--menu-entry-icon-dark", asCSSUrl(icon.dark));
            }
          }
        }
      }
    };
    SubmenuEntryActionViewItem = __decorate11([
      __param11(2, IContextMenuService)
    ], SubmenuEntryActionViewItem);
    DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem2 extends BaseActionViewItem {
      constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {
        var _a5, _b2, _c2;
        super(null, submenuAction);
        this._keybindingService = _keybindingService;
        this._notificationService = _notificationService;
        this._contextMenuService = _contextMenuService;
        this._menuService = _menuService;
        this._instaService = _instaService;
        this._storageService = _storageService;
        this._container = null;
        this._storageKey = `${submenuAction.item.submenu._debugName}_lastActionId`;
        let defaultAction;
        let defaultActionId = _storageService.get(
          this._storageKey,
          1
          /* WORKSPACE */
        );
        if (defaultActionId) {
          defaultAction = submenuAction.actions.find((a) => defaultActionId === a.id);
        }
        if (!defaultAction) {
          defaultAction = submenuAction.actions[0];
        }
        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, void 0);
        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : /* @__PURE__ */ Object.create(null), {
          menuAsChild: (_a5 = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a5 !== void 0 ? _a5 : true,
          classNames: (_b2 = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b2 !== void 0 ? _b2 : ["codicon", "codicon-chevron-down"],
          actionRunner: (_c2 = options === null || options === void 0 ? void 0 : options.actionRunner) !== null && _c2 !== void 0 ? _c2 : new ActionRunner()
        });
        this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);
        this._dropdown.actionRunner.onDidRun((e) => {
          if (e.action instanceof MenuItemAction) {
            this.update(e.action);
          }
        });
      }
      update(lastAction) {
        this._storageService.store(
          this._storageKey,
          lastAction.id,
          1,
          0
          /* USER */
        );
        this._defaultAction.dispose();
        this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, void 0);
        this._defaultAction.actionRunner = new class extends ActionRunner {
          runAction(action, context) {
            return __awaiter10(this, void 0, void 0, function* () {
              yield action.run(void 0);
            });
          }
        }();
        if (this._container) {
          this._defaultAction.render(prepend(this._container, $(".action-container")));
        }
      }
      setActionContext(newContext) {
        super.setActionContext(newContext);
        this._defaultAction.setActionContext(newContext);
        this._dropdown.setActionContext(newContext);
      }
      render(container) {
        this._container = container;
        super.render(this._container);
        this._container.classList.add("monaco-dropdown-with-default");
        const primaryContainer = $(".action-container");
        this._defaultAction.render(append(this._container, primaryContainer));
        this._register(addDisposableListener(primaryContainer, EventType.KEY_DOWN, (e) => {
          const event = new StandardKeyboardEvent(e);
          if (event.equals(
            17
            /* RightArrow */
          )) {
            this._defaultAction.element.tabIndex = -1;
            this._dropdown.focus();
            event.stopPropagation();
          }
        }));
        const dropdownContainer = $(".dropdown-action-container");
        this._dropdown.render(append(this._container, dropdownContainer));
        this._register(addDisposableListener(dropdownContainer, EventType.KEY_DOWN, (e) => {
          var _a5;
          const event = new StandardKeyboardEvent(e);
          if (event.equals(
            15
            /* LeftArrow */
          )) {
            this._defaultAction.element.tabIndex = 0;
            this._dropdown.setFocusable(false);
            (_a5 = this._defaultAction.element) === null || _a5 === void 0 ? void 0 : _a5.focus();
            event.stopPropagation();
          }
        }));
      }
      focus(fromRight) {
        if (fromRight) {
          this._dropdown.focus();
        } else {
          this._defaultAction.element.tabIndex = 0;
          this._defaultAction.element.focus();
        }
      }
      blur() {
        this._defaultAction.element.tabIndex = -1;
        this._dropdown.blur();
        this._container.blur();
      }
      setFocusable(focusable) {
        if (focusable) {
          this._defaultAction.element.tabIndex = 0;
        } else {
          this._defaultAction.element.tabIndex = -1;
          this._dropdown.setFocusable(false);
        }
      }
      dispose() {
        this._defaultAction.dispose();
        this._dropdown.dispose();
        super.dispose();
      }
    };
    DropdownWithDefaultActionViewItem = __decorate11([
      __param11(2, IKeybindingService),
      __param11(3, INotificationService),
      __param11(4, IContextMenuService),
      __param11(5, IMenuService),
      __param11(6, IInstantiationService),
      __param11(7, IStorageService)
    ], DropdownWithDefaultActionViewItem);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/peekView/peekView.js
function getOuterEditor(accessor) {
  let editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (editor2 instanceof EmbeddedCodeEditorWidget) {
    return editor2.getParentEditor();
  }
  return editor2;
}
var __decorate12, __param12, IPeekViewService, PeekContext, PeekContextController, defaultOptions2, PeekViewWidget, peekViewTitleBackground, peekViewTitleForeground, peekViewTitleInfoForeground, peekViewBorder, peekViewResultsBackground, peekViewResultsMatchForeground, peekViewResultsFileForeground, peekViewResultsSelectionBackground, peekViewResultsSelectionForeground, peekViewEditorBackground, peekViewEditorGutterBackground, peekViewResultsMatchHighlight, peekViewEditorMatchHighlight, peekViewEditorMatchHighlightBorder;
var init_peekView = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/peekView/peekView.js"() {
    init_dom();
    init_actionbar();
    init_actions();
    init_codicons();
    init_color();
    init_event();
    init_objects();
    init_editorExtensions();
    init_codeEditorService();
    init_embeddedCodeEditorWidget();
    init_zoneWidget();
    init_nls();
    init_menuEntryActionViewItem();
    init_contextkey();
    init_extensions();
    init_instantiation();
    init_colorRegistry();
    __decorate12 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param12 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    IPeekViewService = createDecorator("IPeekViewService");
    registerSingleton(IPeekViewService, class {
      constructor() {
        this._widgets = /* @__PURE__ */ new Map();
      }
      addExclusiveWidget(editor2, widget) {
        const existing = this._widgets.get(editor2);
        if (existing) {
          existing.listener.dispose();
          existing.widget.dispose();
        }
        const remove = () => {
          const data = this._widgets.get(editor2);
          if (data && data.widget === widget) {
            data.listener.dispose();
            this._widgets.delete(editor2);
          }
        };
        this._widgets.set(editor2, { widget, listener: widget.onDidClose(remove) });
      }
    });
    (function(PeekContext2) {
      PeekContext2.inPeekEditor = new RawContextKey("inReferenceSearchEditor", true, localize("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek"));
      PeekContext2.notInPeekEditor = PeekContext2.inPeekEditor.toNegated();
    })(PeekContext || (PeekContext = {}));
    PeekContextController = class PeekContextController2 {
      constructor(editor2, contextKeyService) {
        if (editor2 instanceof EmbeddedCodeEditorWidget) {
          PeekContext.inPeekEditor.bindTo(contextKeyService);
        }
      }
      dispose() {
      }
    };
    PeekContextController.ID = "editor.contrib.referenceController";
    PeekContextController = __decorate12([
      __param12(1, IContextKeyService)
    ], PeekContextController);
    registerEditorContribution(PeekContextController.ID, PeekContextController);
    defaultOptions2 = {
      headerBackgroundColor: Color.white,
      primaryHeadingColor: Color.fromHex("#333333"),
      secondaryHeadingColor: Color.fromHex("#6c6c6cb3")
    };
    PeekViewWidget = class PeekViewWidget2 extends ZoneWidget {
      constructor(editor2, options, instantiationService) {
        super(editor2, options);
        this.instantiationService = instantiationService;
        this._onDidClose = new Emitter();
        this.onDidClose = this._onDidClose.event;
        mixin(this.options, defaultOptions2, false);
      }
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          super.dispose();
          this._onDidClose.fire(this);
        }
      }
      style(styles) {
        let options = this.options;
        if (styles.headerBackgroundColor) {
          options.headerBackgroundColor = styles.headerBackgroundColor;
        }
        if (styles.primaryHeadingColor) {
          options.primaryHeadingColor = styles.primaryHeadingColor;
        }
        if (styles.secondaryHeadingColor) {
          options.secondaryHeadingColor = styles.secondaryHeadingColor;
        }
        super.style(styles);
      }
      _applyStyles() {
        super._applyStyles();
        let options = this.options;
        if (this._headElement && options.headerBackgroundColor) {
          this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();
        }
        if (this._primaryHeading && options.primaryHeadingColor) {
          this._primaryHeading.style.color = options.primaryHeadingColor.toString();
        }
        if (this._secondaryHeading && options.secondaryHeadingColor) {
          this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();
        }
        if (this._bodyElement && options.frameColor) {
          this._bodyElement.style.borderColor = options.frameColor.toString();
        }
      }
      _fillContainer(container) {
        this.setCssClass("peekview-widget");
        this._headElement = $(".head");
        this._bodyElement = $(".body");
        this._fillHead(this._headElement);
        this._fillBody(this._bodyElement);
        container.appendChild(this._headElement);
        container.appendChild(this._bodyElement);
      }
      _fillHead(container, noCloseAction) {
        const titleElement = $(".peekview-title");
        if (this.options.supportOnTitleClick) {
          titleElement.classList.add("clickable");
          addStandardDisposableListener(titleElement, "click", (event) => this._onTitleClick(event));
        }
        append(this._headElement, titleElement);
        this._fillTitleIcon(titleElement);
        this._primaryHeading = $("span.filename");
        this._secondaryHeading = $("span.dirname");
        this._metaHeading = $("span.meta");
        append(titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
        const actionsContainer = $(".peekview-actions");
        append(this._headElement, actionsContainer);
        const actionBarOptions = this._getActionBarOptions();
        this._actionbarWidget = new ActionBar(actionsContainer, actionBarOptions);
        this._disposables.add(this._actionbarWidget);
        if (!noCloseAction) {
          this._actionbarWidget.push(new Action("peekview.close", localize("label.close", "Close"), Codicon.close.classNames, true, () => {
            this.dispose();
            return Promise.resolve();
          }), { label: false, icon: true });
        }
      }
      _fillTitleIcon(container) {
      }
      _getActionBarOptions() {
        return {
          actionViewItemProvider: createActionViewItem.bind(void 0, this.instantiationService),
          orientation: 0
          /* HORIZONTAL */
        };
      }
      _onTitleClick(event) {
      }
      setTitle(primaryHeading, secondaryHeading) {
        if (this._primaryHeading && this._secondaryHeading) {
          this._primaryHeading.innerText = primaryHeading;
          this._primaryHeading.setAttribute("title", primaryHeading);
          if (secondaryHeading) {
            this._secondaryHeading.innerText = secondaryHeading;
          } else {
            clearNode(this._secondaryHeading);
          }
        }
      }
      setMetaTitle(value) {
        if (this._metaHeading) {
          if (value) {
            this._metaHeading.innerText = value;
            show(this._metaHeading);
          } else {
            hide(this._metaHeading);
          }
        }
      }
      _doLayout(heightInPixel, widthInPixel) {
        if (!this._isShowing && heightInPixel < 0) {
          this.dispose();
          return;
        }
        const headHeight = Math.ceil(this.editor.getOption(
          58
          /* lineHeight */
        ) * 1.2);
        const bodyHeight = Math.round(heightInPixel - (headHeight + 2));
        this._doLayoutHead(headHeight, widthInPixel);
        this._doLayoutBody(bodyHeight, widthInPixel);
      }
      _doLayoutHead(heightInPixel, widthInPixel) {
        if (this._headElement) {
          this._headElement.style.height = `${heightInPixel}px`;
          this._headElement.style.lineHeight = this._headElement.style.height;
        }
      }
      _doLayoutBody(heightInPixel, widthInPixel) {
        if (this._bodyElement) {
          this._bodyElement.style.height = `${heightInPixel}px`;
        }
      }
    };
    PeekViewWidget = __decorate12([
      __param12(2, IInstantiationService)
    ], PeekViewWidget);
    peekViewTitleBackground = registerColor("peekViewTitle.background", { dark: transparent(editorInfoForeground, 0.1), light: transparent(editorInfoForeground, 0.1), hc: null }, localize("peekViewTitleBackground", "Background color of the peek view title area."));
    peekViewTitleForeground = registerColor("peekViewTitleLabel.foreground", { dark: Color.white, light: Color.black, hc: Color.white }, localize("peekViewTitleForeground", "Color of the peek view title."));
    peekViewTitleInfoForeground = registerColor("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161e6", hc: "#FFFFFF99" }, localize("peekViewTitleInfoForeground", "Color of the peek view title info."));
    peekViewBorder = registerColor("peekView.border", { dark: editorInfoForeground, light: editorInfoForeground, hc: contrastBorder }, localize("peekViewBorder", "Color of the peek view borders and arrow."));
    peekViewResultsBackground = registerColor("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hc: Color.black }, localize("peekViewResultsBackground", "Background color of the peek view result list."));
    peekViewResultsMatchForeground = registerColor("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hc: Color.white }, localize("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
    peekViewResultsFileForeground = registerColor("peekViewResult.fileForeground", { dark: Color.white, light: "#1E1E1E", hc: Color.white }, localize("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
    peekViewResultsSelectionBackground = registerColor("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hc: null }, localize("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
    peekViewResultsSelectionForeground = registerColor("peekViewResult.selectionForeground", { dark: Color.white, light: "#6C6C6C", hc: Color.white }, localize("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
    peekViewEditorBackground = registerColor("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hc: Color.black }, localize("peekViewEditorBackground", "Background color of the peek view editor."));
    peekViewEditorGutterBackground = registerColor("peekViewEditorGutter.background", { dark: peekViewEditorBackground, light: peekViewEditorBackground, hc: peekViewEditorBackground }, localize("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
    peekViewResultsMatchHighlight = registerColor("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hc: null }, localize("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
    peekViewEditorMatchHighlight = registerColor("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hc: null }, localize("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
    peekViewEditorMatchHighlightBorder = registerColor("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hc: activeContrastBorder }, localize("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/referencesModel.js
var __awaiter11, OneReference, FilePreview, FileReferences, ReferencesModel;
var init_referencesModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/referencesModel.js"() {
    init_errors();
    init_event();
    init_idGenerator();
    init_lifecycle();
    init_map();
    init_resources();
    init_strings();
    init_range();
    init_nls();
    __awaiter11 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    OneReference = class {
      constructor(isProviderFirst, parent, link, _rangeCallback) {
        this.isProviderFirst = isProviderFirst;
        this.parent = parent;
        this.link = link;
        this._rangeCallback = _rangeCallback;
        this.id = defaultGenerator.nextId();
      }
      get uri() {
        return this.link.uri;
      }
      get range() {
        var _a5, _b2;
        return (_b2 = (_a5 = this._range) !== null && _a5 !== void 0 ? _a5 : this.link.targetSelectionRange) !== null && _b2 !== void 0 ? _b2 : this.link.range;
      }
      set range(value) {
        this._range = value;
        this._rangeCallback(this);
      }
      get ariaMessage() {
        var _a5;
        const preview = (_a5 = this.parent.getPreview(this)) === null || _a5 === void 0 ? void 0 : _a5.preview(this.range);
        if (!preview) {
          return localize("aria.oneReference", "symbol in {0} on line {1} at column {2}", basename2(this.uri), this.range.startLineNumber, this.range.startColumn);
        } else {
          return localize({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "symbol in {0} on line {1} at column {2}, {3}", basename2(this.uri), this.range.startLineNumber, this.range.startColumn, preview.value);
        }
      }
    };
    FilePreview = class {
      constructor(_modelReference) {
        this._modelReference = _modelReference;
      }
      dispose() {
        this._modelReference.dispose();
      }
      preview(range, n = 8) {
        const model = this._modelReference.object.textEditorModel;
        if (!model) {
          return void 0;
        }
        const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
        const word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });
        const beforeRange = new Range(startLineNumber, word.startColumn, startLineNumber, startColumn);
        const afterRange = new Range(
          endLineNumber,
          endColumn,
          endLineNumber,
          1073741824
          /* MAX_SAFE_SMALL_INTEGER */
        );
        const before = model.getValueInRange(beforeRange).replace(/^\s+/, "");
        const inside = model.getValueInRange(range);
        const after = model.getValueInRange(afterRange).replace(/\s+$/, "");
        return {
          value: before + inside + after,
          highlight: { start: before.length, end: before.length + inside.length }
        };
      }
    };
    FileReferences = class {
      constructor(parent, uri) {
        this.parent = parent;
        this.uri = uri;
        this.children = [];
        this._previews = new ResourceMap();
      }
      dispose() {
        dispose(this._previews.values());
        this._previews.clear();
      }
      getPreview(child) {
        return this._previews.get(child.uri);
      }
      get ariaMessage() {
        const len = this.children.length;
        if (len === 1) {
          return localize("aria.fileReferences.1", "1 symbol in {0}, full path {1}", basename2(this.uri), this.uri.fsPath);
        } else {
          return localize("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", len, basename2(this.uri), this.uri.fsPath);
        }
      }
      resolve(textModelResolverService) {
        return __awaiter11(this, void 0, void 0, function* () {
          if (this._previews.size !== 0) {
            return this;
          }
          for (let child of this.children) {
            if (this._previews.has(child.uri)) {
              continue;
            }
            try {
              const ref = yield textModelResolverService.createModelReference(child.uri);
              this._previews.set(child.uri, new FilePreview(ref));
            } catch (err) {
              onUnexpectedError(err);
            }
          }
          return this;
        });
      }
    };
    ReferencesModel = class _ReferencesModel {
      constructor(links, title) {
        this.groups = [];
        this.references = [];
        this._onDidChangeReferenceRange = new Emitter();
        this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
        this._links = links;
        this._title = title;
        const [providersFirst] = links;
        links.sort(_ReferencesModel._compareReferences);
        let current;
        for (let link of links) {
          if (!current || !extUri.isEqual(current.uri, link.uri, true)) {
            current = new FileReferences(this, link.uri);
            this.groups.push(current);
          }
          if (current.children.length === 0 || _ReferencesModel._compareReferences(link, current.children[current.children.length - 1]) !== 0) {
            const oneRef = new OneReference(providersFirst === link, current, link, (ref) => this._onDidChangeReferenceRange.fire(ref));
            this.references.push(oneRef);
            current.children.push(oneRef);
          }
        }
      }
      dispose() {
        dispose(this.groups);
        this._onDidChangeReferenceRange.dispose();
        this.groups.length = 0;
      }
      clone() {
        return new _ReferencesModel(this._links, this._title);
      }
      get title() {
        return this._title;
      }
      get isEmpty() {
        return this.groups.length === 0;
      }
      get ariaMessage() {
        if (this.isEmpty) {
          return localize("aria.result.0", "No results found");
        } else if (this.references.length === 1) {
          return localize("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath);
        } else if (this.groups.length === 1) {
          return localize("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
        } else {
          return localize("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
        }
      }
      nextOrPreviousReference(reference, next) {
        let { parent } = reference;
        let idx = parent.children.indexOf(reference);
        let childCount = parent.children.length;
        let groupCount = parent.parent.groups.length;
        if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
          if (next) {
            idx = (idx + 1) % childCount;
          } else {
            idx = (idx + childCount - 1) % childCount;
          }
          return parent.children[idx];
        }
        idx = parent.parent.groups.indexOf(parent);
        if (next) {
          idx = (idx + 1) % groupCount;
          return parent.parent.groups[idx].children[0];
        } else {
          idx = (idx + groupCount - 1) % groupCount;
          return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];
        }
      }
      nearestReference(resource, position) {
        const nearest = this.references.map((ref, idx) => {
          return {
            idx,
            prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
            offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
          };
        }).sort((a, b) => {
          if (a.prefixLen > b.prefixLen) {
            return -1;
          } else if (a.prefixLen < b.prefixLen) {
            return 1;
          } else if (a.offsetDist < b.offsetDist) {
            return -1;
          } else if (a.offsetDist > b.offsetDist) {
            return 1;
          } else {
            return 0;
          }
        })[0];
        if (nearest) {
          return this.references[nearest.idx];
        }
        return void 0;
      }
      referenceAt(resource, position) {
        for (const ref of this.references) {
          if (ref.uri.toString() === resource.toString()) {
            if (Range.containsPosition(ref.range, position)) {
              return ref;
            }
          }
        }
        return void 0;
      }
      firstReference() {
        for (const ref of this.references) {
          if (ref.isProviderFirst) {
            return ref;
          }
        }
        return this.references[0];
      }
      static _compareReferences(a, b) {
        return extUri.compare(a.uri, b.uri) || Range.compareRangesUsingStarts(a.range, b.range);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/labels.js
function getBaseLabel(resource) {
  if (!resource) {
    return void 0;
  }
  if (typeof resource === "string") {
    resource = URI.file(resource);
  }
  const base = basename2(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path);
  if (isWindows && isRootOrDriveLetter(base)) {
    return normalizeDriveLetter(base);
  }
  return base;
}
function normalizeDriveLetter(path) {
  if (hasDriveLetter(path)) {
    return path.charAt(0).toUpperCase() + path.slice(1);
  }
  return path;
}
var init_labels = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/labels.js"() {
    init_extpath();
    init_network();
    init_platform();
    init_resources();
    init_uri();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesTree.js
var __decorate13, __param13, DataSource, Delegate, StringRepresentationProvider, IdentityProvider, FileReferencesTemplate, FileReferencesRenderer, OneReferenceTemplate, OneReferenceRenderer, AccessibilityProvider;
var init_referencesTree = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesTree.js"() {
    init_dom();
    init_countBadge();
    init_highlightedLabel();
    init_iconLabel();
    init_filters();
    init_labels();
    init_lifecycle();
    init_resources();
    init_resolverService();
    init_nls();
    init_instantiation();
    init_keybinding();
    init_label();
    init_styler();
    init_themeService();
    init_referencesModel();
    __decorate13 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param13 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    DataSource = class DataSource2 {
      constructor(_resolverService) {
        this._resolverService = _resolverService;
      }
      hasChildren(element) {
        if (element instanceof ReferencesModel) {
          return true;
        }
        if (element instanceof FileReferences) {
          return true;
        }
        return false;
      }
      getChildren(element) {
        if (element instanceof ReferencesModel) {
          return element.groups;
        }
        if (element instanceof FileReferences) {
          return element.resolve(this._resolverService).then((val) => {
            return val.children;
          });
        }
        throw new Error("bad tree");
      }
    };
    DataSource = __decorate13([
      __param13(0, ITextModelService)
    ], DataSource);
    Delegate = class {
      getHeight() {
        return 23;
      }
      getTemplateId(element) {
        if (element instanceof FileReferences) {
          return FileReferencesRenderer.id;
        } else {
          return OneReferenceRenderer.id;
        }
      }
    };
    StringRepresentationProvider = class StringRepresentationProvider2 {
      constructor(_keybindingService) {
        this._keybindingService = _keybindingService;
      }
      getKeyboardNavigationLabel(element) {
        var _a5;
        if (element instanceof OneReference) {
          const parts = (_a5 = element.parent.getPreview(element)) === null || _a5 === void 0 ? void 0 : _a5.preview(element.range);
          if (parts) {
            return parts.value;
          }
        }
        return basename2(element.uri);
      }
    };
    StringRepresentationProvider = __decorate13([
      __param13(0, IKeybindingService)
    ], StringRepresentationProvider);
    IdentityProvider = class {
      getId(element) {
        return element instanceof OneReference ? element.id : element.uri;
      }
    };
    FileReferencesTemplate = class FileReferencesTemplate2 extends Disposable {
      constructor(container, _uriLabel, themeService) {
        super();
        this._uriLabel = _uriLabel;
        const parent = document.createElement("div");
        parent.classList.add("reference-file");
        this.file = this._register(new IconLabel(parent, { supportHighlights: true }));
        this.badge = new CountBadge(append(parent, $(".count")));
        this._register(attachBadgeStyler(this.badge, themeService));
        container.appendChild(parent);
      }
      set(element, matches) {
        let parent = dirname2(element.uri);
        this.file.setLabel(getBaseLabel(element.uri), this._uriLabel.getUriLabel(parent, { relative: true }), { title: this._uriLabel.getUriLabel(element.uri), matches });
        const len = element.children.length;
        this.badge.setCount(len);
        if (len > 1) {
          this.badge.setTitleFormat(localize("referencesCount", "{0} references", len));
        } else {
          this.badge.setTitleFormat(localize("referenceCount", "{0} reference", len));
        }
      }
    };
    FileReferencesTemplate = __decorate13([
      __param13(1, ILabelService),
      __param13(2, IThemeService)
    ], FileReferencesTemplate);
    FileReferencesRenderer = class FileReferencesRenderer2 {
      constructor(_instantiationService) {
        this._instantiationService = _instantiationService;
        this.templateId = FileReferencesRenderer2.id;
      }
      renderTemplate(container) {
        return this._instantiationService.createInstance(FileReferencesTemplate, container);
      }
      renderElement(node, index, template) {
        template.set(node.element, createMatches(node.filterData));
      }
      disposeTemplate(templateData) {
        templateData.dispose();
      }
    };
    FileReferencesRenderer.id = "FileReferencesRenderer";
    FileReferencesRenderer = __decorate13([
      __param13(0, IInstantiationService)
    ], FileReferencesRenderer);
    OneReferenceTemplate = class {
      constructor(container) {
        this.label = new HighlightedLabel(container, false);
      }
      set(element, score) {
        var _a5;
        const preview = (_a5 = element.parent.getPreview(element)) === null || _a5 === void 0 ? void 0 : _a5.preview(element.range);
        if (!preview || !preview.value) {
          this.label.set(`${basename2(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
        } else {
          const { value, highlight } = preview;
          if (score && !FuzzyScore.isDefault(score)) {
            this.label.element.classList.toggle("referenceMatch", false);
            this.label.set(value, createMatches(score));
          } else {
            this.label.element.classList.toggle("referenceMatch", true);
            this.label.set(value, [highlight]);
          }
        }
      }
    };
    OneReferenceRenderer = class _OneReferenceRenderer {
      constructor() {
        this.templateId = _OneReferenceRenderer.id;
      }
      renderTemplate(container) {
        return new OneReferenceTemplate(container);
      }
      renderElement(node, index, templateData) {
        templateData.set(node.element, node.filterData);
      }
      disposeTemplate() {
      }
    };
    OneReferenceRenderer.id = "OneReferenceRenderer";
    AccessibilityProvider = class {
      getWidgetAriaLabel() {
        return localize("treeAriaLabel", "References");
      }
      getAriaLabel(element) {
        return element.ariaMessage;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.js
var __decorate14, __param14, __awaiter12, DecorationsManager, LayoutData, ReferencesTree, ReferenceWidget;
var init_referencesWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.js"() {
    init_dom();
    init_splitview();
    init_color();
    init_event();
    init_lifecycle();
    init_network();
    init_resources();
    init_embeddedCodeEditorWidget();
    init_range();
    init_textModel();
    init_resolverService();
    init_referencesTree();
    init_peekView();
    init_nls();
    init_instantiation();
    init_keybinding();
    init_label();
    init_listService();
    init_colorRegistry();
    init_themeService();
    init_undoRedo();
    init_referencesModel();
    __decorate14 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param14 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter12 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    DecorationsManager = class _DecorationsManager {
      constructor(_editor2, _model) {
        this._editor = _editor2;
        this._model = _model;
        this._decorations = /* @__PURE__ */ new Map();
        this._decorationIgnoreSet = /* @__PURE__ */ new Set();
        this._callOnDispose = new DisposableStore();
        this._callOnModelChange = new DisposableStore();
        this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));
        this._onModelChanged();
      }
      dispose() {
        this._callOnModelChange.dispose();
        this._callOnDispose.dispose();
        this.removeDecorations();
      }
      _onModelChanged() {
        this._callOnModelChange.clear();
        const model = this._editor.getModel();
        if (!model) {
          return;
        }
        for (let ref of this._model.references) {
          if (ref.uri.toString() === model.uri.toString()) {
            this._addDecorations(ref.parent);
            return;
          }
        }
      }
      _addDecorations(reference) {
        if (!this._editor.hasModel()) {
          return;
        }
        this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
        const newDecorations = [];
        const newDecorationsActualIndex = [];
        for (let i = 0, len = reference.children.length; i < len; i++) {
          let oneReference = reference.children[i];
          if (this._decorationIgnoreSet.has(oneReference.id)) {
            continue;
          }
          if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) {
            continue;
          }
          newDecorations.push({
            range: oneReference.range,
            options: _DecorationsManager.DecorationOptions
          });
          newDecorationsActualIndex.push(i);
        }
        const decorations = this._editor.deltaDecorations([], newDecorations);
        for (let i = 0; i < decorations.length; i++) {
          this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);
        }
      }
      _onDecorationChanged() {
        const toRemove = [];
        const model = this._editor.getModel();
        if (!model) {
          return;
        }
        for (let [decorationId, reference] of this._decorations) {
          const newRange = model.getDecorationRange(decorationId);
          if (!newRange) {
            continue;
          }
          let ignore = false;
          if (Range.equalsRange(newRange, reference.range)) {
            continue;
          }
          if (Range.spansMultipleLines(newRange)) {
            ignore = true;
          } else {
            const lineLength = reference.range.endColumn - reference.range.startColumn;
            const newLineLength = newRange.endColumn - newRange.startColumn;
            if (lineLength !== newLineLength) {
              ignore = true;
            }
          }
          if (ignore) {
            this._decorationIgnoreSet.add(reference.id);
            toRemove.push(decorationId);
          } else {
            reference.range = newRange;
          }
        }
        for (let i = 0, len = toRemove.length; i < len; i++) {
          this._decorations.delete(toRemove[i]);
        }
        this._editor.deltaDecorations(toRemove, []);
      }
      removeDecorations() {
        this._editor.deltaDecorations([...this._decorations.keys()], []);
        this._decorations.clear();
      }
    };
    DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
      description: "reference-decoration",
      stickiness: 1,
      className: "reference-decoration"
    });
    LayoutData = class {
      constructor() {
        this.ratio = 0.7;
        this.heightInLines = 18;
      }
      static fromJSON(raw) {
        let ratio;
        let heightInLines;
        try {
          const data = JSON.parse(raw);
          ratio = data.ratio;
          heightInLines = data.heightInLines;
        } catch (_a5) {
        }
        return {
          ratio: ratio || 0.7,
          heightInLines: heightInLines || 18
        };
      }
    };
    ReferencesTree = class extends WorkbenchAsyncDataTree {
    };
    ReferenceWidget = class ReferenceWidget2 extends PeekViewWidget {
      constructor(editor2, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _undoRedoService, _keybindingService) {
        super(editor2, { showFrame: false, showArrow: true, isResizeable: true, isAccessible: true, supportOnTitleClick: true }, _instantiationService);
        this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
        this.layoutData = layoutData;
        this._textModelResolverService = _textModelResolverService;
        this._instantiationService = _instantiationService;
        this._peekViewService = _peekViewService;
        this._uriLabel = _uriLabel;
        this._undoRedoService = _undoRedoService;
        this._keybindingService = _keybindingService;
        this._disposeOnNewModel = new DisposableStore();
        this._callOnDispose = new DisposableStore();
        this._onDidSelectReference = new Emitter();
        this.onDidSelectReference = this._onDidSelectReference.event;
        this._dim = new Dimension(0, 0);
        this._applyTheme(themeService.getColorTheme());
        this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
        this._peekViewService.addExclusiveWidget(editor2, this);
        this.create();
      }
      dispose() {
        this.setModel(void 0);
        this._callOnDispose.dispose();
        this._disposeOnNewModel.dispose();
        dispose(this._preview);
        dispose(this._previewNotAvailableMessage);
        dispose(this._tree);
        dispose(this._previewModelReference);
        this._splitView.dispose();
        super.dispose();
      }
      _applyTheme(theme) {
        const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
        this.style({
          arrowColor: borderColor,
          frameColor: borderColor,
          headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
          primaryHeadingColor: theme.getColor(peekViewTitleForeground),
          secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
        });
      }
      show(where) {
        this.editor.revealRangeInCenterIfOutsideViewport(
          where,
          0
          /* Smooth */
        );
        super.show(where, this.layoutData.heightInLines || 18);
      }
      focusOnReferenceTree() {
        this._tree.domFocus();
      }
      focusOnPreviewEditor() {
        this._preview.focus();
      }
      isPreviewEditorFocused() {
        return this._preview.hasTextFocus();
      }
      _onTitleClick(e) {
        if (this._preview && this._preview.getModel()) {
          this._onDidSelectReference.fire({
            element: this._getFocusedReference(),
            kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
            source: "title"
          });
        }
      }
      _fillBody(containerElement) {
        this.setCssClass("reference-zone-widget");
        this._messageContainer = append(containerElement, $("div.messages"));
        hide(this._messageContainer);
        this._splitView = new SplitView(containerElement, {
          orientation: 1
          /* HORIZONTAL */
        });
        this._previewContainer = append(containerElement, $("div.preview.inline"));
        let options = {
          scrollBeyondLastLine: false,
          scrollbar: {
            verticalScrollbarSize: 14,
            horizontal: "auto",
            useShadows: true,
            verticalHasArrows: false,
            horizontalHasArrows: false,
            alwaysConsumeMouseWheel: false
          },
          overviewRulerLanes: 2,
          fixedOverflowWidgets: true,
          minimap: {
            enabled: false
          }
        };
        this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, options, this.editor);
        hide(this._previewContainer);
        this._previewNotAvailableMessage = new TextModel(localize("missingPreviewMessage", "no preview available"), TextModel.DEFAULT_CREATION_OPTIONS, null, null, this._undoRedoService);
        this._treeContainer = append(containerElement, $("div.ref-tree.inline"));
        const treeOptions = {
          keyboardSupport: this._defaultTreeKeyboardSupport,
          accessibilityProvider: new AccessibilityProvider(),
          keyboardNavigationLabelProvider: this._instantiationService.createInstance(StringRepresentationProvider),
          identityProvider: new IdentityProvider(),
          openOnSingleClick: true,
          selectionNavigation: true,
          overrideStyles: {
            listBackground: peekViewResultsBackground
          }
        };
        if (this._defaultTreeKeyboardSupport) {
          this._callOnDispose.add(addStandardDisposableListener(this._treeContainer, "keydown", (e) => {
            if (e.equals(
              9
              /* Escape */
            )) {
              this._keybindingService.dispatchEvent(e, e.target);
              e.stopPropagation();
            }
          }, true));
        }
        this._tree = this._instantiationService.createInstance(ReferencesTree, "ReferencesWidget", this._treeContainer, new Delegate(), [
          this._instantiationService.createInstance(FileReferencesRenderer),
          this._instantiationService.createInstance(OneReferenceRenderer)
        ], this._instantiationService.createInstance(DataSource), treeOptions);
        this._splitView.addView({
          onDidChange: Event.None,
          element: this._previewContainer,
          minimumSize: 200,
          maximumSize: Number.MAX_VALUE,
          layout: (width) => {
            this._preview.layout({ height: this._dim.height, width });
          }
        }, Sizing.Distribute);
        this._splitView.addView({
          onDidChange: Event.None,
          element: this._treeContainer,
          minimumSize: 100,
          maximumSize: Number.MAX_VALUE,
          layout: (width) => {
            this._treeContainer.style.height = `${this._dim.height}px`;
            this._treeContainer.style.width = `${width}px`;
            this._tree.layout(this._dim.height, width);
          }
        }, Sizing.Distribute);
        this._disposables.add(this._splitView.onDidSashChange(() => {
          if (this._dim.width) {
            this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;
          }
        }, void 0));
        let onEvent = (element, kind) => {
          if (element instanceof OneReference) {
            if (kind === "show") {
              this._revealReference(element, false);
            }
            this._onDidSelectReference.fire({ element, kind, source: "tree" });
          }
        };
        this._tree.onDidOpen((e) => {
          if (e.sideBySide) {
            onEvent(e.element, "side");
          } else if (e.editorOptions.pinned) {
            onEvent(e.element, "goto");
          } else {
            onEvent(e.element, "show");
          }
        });
        hide(this._treeContainer);
      }
      _onWidth(width) {
        if (this._dim) {
          this._doLayoutBody(this._dim.height, width);
        }
      }
      _doLayoutBody(heightInPixel, widthInPixel) {
        super._doLayoutBody(heightInPixel, widthInPixel);
        this._dim = new Dimension(widthInPixel, heightInPixel);
        this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;
        this._splitView.layout(widthInPixel);
        this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);
      }
      setSelection(selection) {
        return this._revealReference(selection, true).then(() => {
          if (!this._model) {
            return;
          }
          this._tree.setSelection([selection]);
          this._tree.setFocus([selection]);
        });
      }
      setModel(newModel) {
        this._disposeOnNewModel.clear();
        this._model = newModel;
        if (this._model) {
          return this._onNewModel();
        }
        return Promise.resolve();
      }
      _onNewModel() {
        if (!this._model) {
          return Promise.resolve(void 0);
        }
        if (this._model.isEmpty) {
          this.setTitle("");
          this._messageContainer.innerText = localize("noResults", "No results");
          show(this._messageContainer);
          return Promise.resolve(void 0);
        }
        hide(this._messageContainer);
        this._decorationsManager = new DecorationsManager(this._preview, this._model);
        this._disposeOnNewModel.add(this._decorationsManager);
        this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((reference) => this._tree.rerender(reference)));
        this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
          const { event, target } = e;
          if (event.detail !== 2) {
            return;
          }
          const element = this._getFocusedReference();
          if (!element) {
            return;
          }
          this._onDidSelectReference.fire({
            element: { uri: element.uri, range: target.range },
            kind: event.ctrlKey || event.metaKey || event.altKey ? "side" : "open",
            source: "editor"
          });
        }));
        this.container.classList.add("results-loaded");
        show(this._treeContainer);
        show(this._previewContainer);
        this._splitView.layout(this._dim.width);
        this.focusOnReferenceTree();
        return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);
      }
      _getFocusedReference() {
        const [element] = this._tree.getFocus();
        if (element instanceof OneReference) {
          return element;
        } else if (element instanceof FileReferences) {
          if (element.children.length > 0) {
            return element.children[0];
          }
        }
        return void 0;
      }
      revealReference(reference) {
        return __awaiter12(this, void 0, void 0, function* () {
          yield this._revealReference(reference, false);
          this._onDidSelectReference.fire({ element: reference, kind: "goto", source: "tree" });
        });
      }
      _revealReference(reference, revealParent) {
        return __awaiter12(this, void 0, void 0, function* () {
          if (this._revealedReference === reference) {
            return;
          }
          this._revealedReference = reference;
          if (reference.uri.scheme !== Schemas.inMemory) {
            this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname2(reference.uri)));
          } else {
            this.setTitle(localize("peekView.alternateTitle", "References"));
          }
          const promise = this._textModelResolverService.createModelReference(reference.uri);
          if (this._tree.getInput() === reference.parent) {
            this._tree.reveal(reference);
          } else {
            if (revealParent) {
              this._tree.reveal(reference.parent);
            }
            yield this._tree.expand(reference.parent);
            this._tree.reveal(reference);
          }
          const ref = yield promise;
          if (!this._model) {
            ref.dispose();
            return;
          }
          dispose(this._previewModelReference);
          const model = ref.object;
          if (model) {
            const scrollType = this._preview.getModel() === model.textEditorModel ? 0 : 1;
            const sel = Range.lift(reference.range).collapseToStart();
            this._previewModelReference = ref;
            this._preview.setModel(model.textEditorModel);
            this._preview.setSelection(sel);
            this._preview.revealRangeInCenter(sel, scrollType);
          } else {
            this._preview.setModel(this._previewNotAvailableMessage);
            ref.dispose();
          }
        });
      }
    };
    ReferenceWidget = __decorate14([
      __param14(3, IThemeService),
      __param14(4, ITextModelService),
      __param14(5, IInstantiationService),
      __param14(6, IPeekViewService),
      __param14(7, ILabelService),
      __param14(8, IUndoRedoService),
      __param14(9, IKeybindingService)
    ], ReferenceWidget);
    registerThemingParticipant((theme, collector) => {
      const findMatchHighlightColor = theme.getColor(peekViewResultsMatchHighlight);
      if (findMatchHighlightColor) {
        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .referenceMatch .highlight { background-color: ${findMatchHighlightColor}; }`);
      }
      const referenceHighlightColor = theme.getColor(peekViewEditorMatchHighlight);
      if (referenceHighlightColor) {
        collector.addRule(`.monaco-editor .reference-zone-widget .preview .reference-decoration { background-color: ${referenceHighlightColor}; }`);
      }
      const referenceHighlightBorder = theme.getColor(peekViewEditorMatchHighlightBorder);
      if (referenceHighlightBorder) {
        collector.addRule(`.monaco-editor .reference-zone-widget .preview .reference-decoration { border: 2px solid ${referenceHighlightBorder}; box-sizing: border-box; }`);
      }
      const hcOutline = theme.getColor(activeContrastBorder);
      if (hcOutline) {
        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .referenceMatch .highlight { border: 1px dotted ${hcOutline}; box-sizing: border-box; }`);
      }
      const resultsBackground = theme.getColor(peekViewResultsBackground);
      if (resultsBackground) {
        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree { background-color: ${resultsBackground}; }`);
      }
      const resultsMatchForeground = theme.getColor(peekViewResultsMatchForeground);
      if (resultsMatchForeground) {
        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree { color: ${resultsMatchForeground}; }`);
      }
      const resultsFileForeground = theme.getColor(peekViewResultsFileForeground);
      if (resultsFileForeground) {
        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .reference-file { color: ${resultsFileForeground}; }`);
      }
      const resultsSelectedBackground = theme.getColor(peekViewResultsSelectionBackground);
      if (resultsSelectedBackground) {
        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .monaco-list-rows > .monaco-list-row.selected:not(.highlighted) { background-color: ${resultsSelectedBackground}; }`);
      }
      const resultsSelectedForeground = theme.getColor(peekViewResultsSelectionForeground);
      if (resultsSelectedForeground) {
        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .monaco-list-rows > .monaco-list-row.selected:not(.highlighted) { color: ${resultsSelectedForeground} !important; }`);
      }
      const editorBackground2 = theme.getColor(peekViewEditorBackground);
      if (editorBackground2) {
        collector.addRule(`.monaco-editor .reference-zone-widget .preview .monaco-editor .monaco-editor-background,.monaco-editor .reference-zone-widget .preview .monaco-editor .inputarea.ime-input {	background-color: ${editorBackground2};}`);
      }
      const editorGutterBackground = theme.getColor(peekViewEditorGutterBackground);
      if (editorGutterBackground) {
        collector.addRule(`.monaco-editor .reference-zone-widget .preview .monaco-editor .margin {	background-color: ${editorGutterBackground};}`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesController.js
function withController(accessor, fn) {
  const outerEditor = getOuterEditor(accessor);
  if (!outerEditor) {
    return;
  }
  let controller = ReferencesController.get(outerEditor);
  if (controller) {
    fn(controller);
  }
}
var __decorate15, __param15, __awaiter13, ctxReferenceSearchVisible, ReferencesController;
var init_referencesController = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesController.js"() {
    init_async();
    init_errors();
    init_keyCodes();
    init_lifecycle();
    init_codeEditorService();
    init_position();
    init_range();
    init_peekView();
    init_nls();
    init_commands();
    init_configuration();
    init_contextkey();
    init_instantiation();
    init_keybindingsRegistry();
    init_listService();
    init_notification();
    init_storage();
    init_referencesModel();
    init_referencesWidget();
    __decorate15 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param15 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter13 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ctxReferenceSearchVisible = new RawContextKey("referenceSearchVisible", false, localize("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
    ReferencesController = class ReferencesController2 {
      constructor(_defaultTreeKeyboardSupport, _editor2, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {
        this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
        this._editor = _editor2;
        this._editorService = _editorService;
        this._notificationService = _notificationService;
        this._instantiationService = _instantiationService;
        this._storageService = _storageService;
        this._configurationService = _configurationService;
        this._disposables = new DisposableStore();
        this._requestIdPool = 0;
        this._ignoreModelChangeEvent = false;
        this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
      }
      static get(editor2) {
        return editor2.getContribution(ReferencesController2.ID);
      }
      dispose() {
        var _a5, _b2;
        this._referenceSearchVisible.reset();
        this._disposables.dispose();
        (_a5 = this._widget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        (_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.dispose();
        this._widget = void 0;
        this._model = void 0;
      }
      toggleWidget(range, modelPromise, peekMode) {
        let widgetPosition;
        if (this._widget) {
          widgetPosition = this._widget.position;
        }
        this.closeWidget();
        if (!!widgetPosition && range.containsPosition(widgetPosition)) {
          return;
        }
        this._peekMode = peekMode;
        this._referenceSearchVisible.set(true);
        this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
          this.closeWidget();
        }));
        this._disposables.add(this._editor.onDidChangeModel(() => {
          if (!this._ignoreModelChangeEvent) {
            this.closeWidget();
          }
        }));
        const storageKey = "peekViewLayout";
        const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0, "{}"));
        this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
        this._widget.setTitle(localize("labelLoading", "Loading..."));
        this._widget.show(range);
        this._disposables.add(this._widget.onDidClose(() => {
          modelPromise.cancel();
          if (this._widget) {
            this._storageService.store(
              storageKey,
              JSON.stringify(this._widget.layoutData),
              0,
              1
              /* MACHINE */
            );
            this._widget = void 0;
          }
          this.closeWidget();
        }));
        this._disposables.add(this._widget.onDidSelectReference((event) => {
          let { element, kind } = event;
          if (!element) {
            return;
          }
          switch (kind) {
            case "open":
              if (event.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) {
                this.openReference(element, false, false);
              }
              break;
            case "side":
              this.openReference(element, true, false);
              break;
            case "goto":
              if (peekMode) {
                this._gotoReference(element);
              } else {
                this.openReference(element, false, true);
              }
              break;
          }
        }));
        const requestId = ++this._requestIdPool;
        modelPromise.then((model) => {
          var _a5;
          if (requestId !== this._requestIdPool || !this._widget) {
            model.dispose();
            return void 0;
          }
          (_a5 = this._model) === null || _a5 === void 0 ? void 0 : _a5.dispose();
          this._model = model;
          return this._widget.setModel(this._model).then(() => {
            if (this._widget && this._model && this._editor.hasModel()) {
              if (!this._model.isEmpty) {
                this._widget.setMetaTitle(localize("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
              } else {
                this._widget.setMetaTitle("");
              }
              let uri = this._editor.getModel().uri;
              let pos = new Position(range.startLineNumber, range.startColumn);
              let selection = this._model.nearestReference(uri, pos);
              if (selection) {
                return this._widget.setSelection(selection).then(() => {
                  if (this._widget && this._editor.getOption(
                    76
                    /* peekWidgetDefaultFocus */
                  ) === "editor") {
                    this._widget.focusOnPreviewEditor();
                  }
                });
              }
            }
            return void 0;
          });
        }, (error) => {
          this._notificationService.error(error);
        });
      }
      changeFocusBetweenPreviewAndReferences() {
        if (!this._widget) {
          return;
        }
        if (this._widget.isPreviewEditorFocused()) {
          this._widget.focusOnReferenceTree();
        } else {
          this._widget.focusOnPreviewEditor();
        }
      }
      goToNextOrPreviousReference(fwd) {
        return __awaiter13(this, void 0, void 0, function* () {
          if (!this._editor.hasModel() || !this._model || !this._widget) {
            return;
          }
          const currentPosition = this._widget.position;
          if (!currentPosition) {
            return;
          }
          const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
          if (!source) {
            return;
          }
          const target = this._model.nextOrPreviousReference(source, fwd);
          const editorFocus = this._editor.hasTextFocus();
          const previewEditorFocus = this._widget.isPreviewEditorFocused();
          yield this._widget.setSelection(target);
          yield this._gotoReference(target);
          if (editorFocus) {
            this._editor.focus();
          } else if (this._widget && previewEditorFocus) {
            this._widget.focusOnPreviewEditor();
          }
        });
      }
      revealReference(reference) {
        return __awaiter13(this, void 0, void 0, function* () {
          if (!this._editor.hasModel() || !this._model || !this._widget) {
            return;
          }
          yield this._widget.revealReference(reference);
        });
      }
      closeWidget(focusEditor = true) {
        var _a5, _b2;
        (_a5 = this._widget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        (_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.dispose();
        this._referenceSearchVisible.reset();
        this._disposables.clear();
        this._widget = void 0;
        this._model = void 0;
        if (focusEditor) {
          this._editor.focus();
        }
        this._requestIdPool += 1;
      }
      _gotoReference(ref) {
        if (this._widget) {
          this._widget.hide();
        }
        this._ignoreModelChangeEvent = true;
        const range = Range.lift(ref.range).collapseToStart();
        return this._editorService.openCodeEditor({
          resource: ref.uri,
          options: { selection: range }
        }, this._editor).then((openedEditor) => {
          var _a5;
          this._ignoreModelChangeEvent = false;
          if (!openedEditor || !this._widget) {
            this.closeWidget();
            return;
          }
          if (this._editor === openedEditor) {
            this._widget.show(range);
            this._widget.focusOnReferenceTree();
          } else {
            const other = ReferencesController2.get(openedEditor);
            const model = this._model.clone();
            this.closeWidget();
            openedEditor.focus();
            other.toggleWidget(range, createCancelablePromise((_) => Promise.resolve(model)), (_a5 = this._peekMode) !== null && _a5 !== void 0 ? _a5 : false);
          }
        }, (err) => {
          this._ignoreModelChangeEvent = false;
          onUnexpectedError(err);
        });
      }
      openReference(ref, sideBySide, pinned) {
        if (!sideBySide) {
          this.closeWidget();
        }
        const { uri, range } = ref;
        this._editorService.openCodeEditor({
          resource: uri,
          options: { selection: range, pinned }
        }, this._editor, sideBySide);
      }
    };
    ReferencesController.ID = "editor.contrib.referencesController";
    ReferencesController = __decorate15([
      __param15(2, IContextKeyService),
      __param15(3, ICodeEditorService),
      __param15(4, INotificationService),
      __param15(5, IInstantiationService),
      __param15(6, IStorageService),
      __param15(7, IConfigurationService)
    ], ReferencesController);
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "togglePeekWidgetFocus",
      weight: 100,
      primary: KeyChord(
        2048 | 41,
        60
        /* F2 */
      ),
      when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
      handler(accessor) {
        withController(accessor, (controller) => {
          controller.changeFocusBetweenPreviewAndReferences();
        });
      }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "goToNextReference",
      weight: 100 - 10,
      primary: 62,
      secondary: [
        70
        /* F12 */
      ],
      when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
      handler(accessor) {
        withController(accessor, (controller) => {
          controller.goToNextOrPreviousReference(true);
        });
      }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "goToPreviousReference",
      weight: 100 - 10,
      primary: 1024 | 62,
      secondary: [
        1024 | 70
        /* F12 */
      ],
      when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
      handler(accessor) {
        withController(accessor, (controller) => {
          controller.goToNextOrPreviousReference(false);
        });
      }
    });
    CommandsRegistry.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
    CommandsRegistry.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
    CommandsRegistry.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
    CommandsRegistry.registerCommand("closeReferenceSearch", (accessor) => withController(accessor, (controller) => controller.closeWidget()));
    KeybindingsRegistry.registerKeybindingRule({
      id: "closeReferenceSearch",
      weight: 100 - 101,
      primary: 9,
      secondary: [
        1024 | 9
        /* Escape */
      ],
      when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not("config.editor.stablePeek"))
    });
    KeybindingsRegistry.registerKeybindingRule({
      id: "closeReferenceSearch",
      weight: 200 + 50,
      primary: 9,
      secondary: [
        1024 | 9
        /* Escape */
      ],
      when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not("config.editor.stablePeek"))
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "revealReference",
      weight: 200,
      primary: 3,
      mac: {
        primary: 3,
        secondary: [
          2048 | 18
          /* DownArrow */
        ]
      },
      when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey),
      handler(accessor) {
        var _a5;
        const listService = accessor.get(IListService);
        const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
        if (Array.isArray(focus) && focus[0] instanceof OneReference) {
          withController(accessor, (controller) => controller.revealReference(focus[0]));
        }
      }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "openReferenceToSide",
      weight: 100,
      primary: 2048 | 3,
      mac: {
        primary: 256 | 3
        /* Enter */
      },
      when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey),
      handler(accessor) {
        var _a5;
        const listService = accessor.get(IListService);
        const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
        if (Array.isArray(focus) && focus[0] instanceof OneReference) {
          withController(accessor, (controller) => controller.openReference(focus[0], true, true));
        }
      }
    });
    CommandsRegistry.registerCommand("openReference", (accessor) => {
      var _a5;
      const listService = accessor.get(IListService);
      const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
      if (Array.isArray(focus) && focus[0] instanceof OneReference) {
        withController(accessor, (controller) => controller.openReference(focus[0], false, true));
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/symbolNavigation.js
var __decorate16, __param16, ctxHasSymbols, ISymbolNavigationService, SymbolNavigationService, EditorState2;
var init_symbolNavigation = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/symbolNavigation.js"() {
    init_event();
    init_lifecycle();
    init_resources();
    init_editorExtensions();
    init_codeEditorService();
    init_range();
    init_nls();
    init_contextkey();
    init_extensions();
    init_instantiation();
    init_keybinding();
    init_keybindingsRegistry();
    init_notification();
    __decorate16 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param16 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    ctxHasSymbols = new RawContextKey("hasSymbols", false, localize("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only."));
    ISymbolNavigationService = createDecorator("ISymbolNavigationService");
    SymbolNavigationService = class SymbolNavigationService2 {
      constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
        this._editorService = _editorService;
        this._notificationService = _notificationService;
        this._keybindingService = _keybindingService;
        this._currentModel = void 0;
        this._currentIdx = -1;
        this._ignoreEditorChange = false;
        this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
      }
      reset() {
        var _a5, _b2;
        this._ctxHasSymbols.reset();
        (_a5 = this._currentState) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        (_b2 = this._currentMessage) === null || _b2 === void 0 ? void 0 : _b2.dispose();
        this._currentModel = void 0;
        this._currentIdx = -1;
      }
      put(anchor) {
        const refModel = anchor.parent.parent;
        if (refModel.references.length <= 1) {
          this.reset();
          return;
        }
        this._currentModel = refModel;
        this._currentIdx = refModel.references.indexOf(anchor);
        this._ctxHasSymbols.set(true);
        this._showMessage();
        const editorState = new EditorState2(this._editorService);
        const listener = editorState.onDidChange((_) => {
          if (this._ignoreEditorChange) {
            return;
          }
          const editor2 = this._editorService.getActiveCodeEditor();
          if (!editor2) {
            return;
          }
          const model = editor2.getModel();
          const position = editor2.getPosition();
          if (!model || !position) {
            return;
          }
          let seenUri = false;
          let seenPosition = false;
          for (const reference of refModel.references) {
            if (isEqual(reference.uri, model.uri)) {
              seenUri = true;
              seenPosition = seenPosition || Range.containsPosition(reference.range, position);
            } else if (seenUri) {
              break;
            }
          }
          if (!seenUri || !seenPosition) {
            this.reset();
          }
        });
        this._currentState = combinedDisposable(editorState, listener);
      }
      revealNext(source) {
        if (!this._currentModel) {
          return Promise.resolve();
        }
        this._currentIdx += 1;
        this._currentIdx %= this._currentModel.references.length;
        const reference = this._currentModel.references[this._currentIdx];
        this._showMessage();
        this._ignoreEditorChange = true;
        return this._editorService.openCodeEditor({
          resource: reference.uri,
          options: {
            selection: Range.collapseToStart(reference.range),
            selectionRevealType: 3
            /* NearTopIfOutsideViewport */
          }
        }, source).finally(() => {
          this._ignoreEditorChange = false;
        });
      }
      _showMessage() {
        var _a5;
        (_a5 = this._currentMessage) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        const kb = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult");
        const message = kb ? localize("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel()) : localize("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
        this._currentMessage = this._notificationService.status(message);
      }
    };
    SymbolNavigationService = __decorate16([
      __param16(0, IContextKeyService),
      __param16(1, ICodeEditorService),
      __param16(2, INotificationService),
      __param16(3, IKeybindingService)
    ], SymbolNavigationService);
    registerSingleton(ISymbolNavigationService, SymbolNavigationService, true);
    registerEditorCommand(new class extends EditorCommand {
      constructor() {
        super({
          id: "editor.gotoNextSymbolFromResult",
          precondition: ctxHasSymbols,
          kbOpts: {
            weight: 100,
            primary: 70
            /* F12 */
          }
        });
      }
      runEditorCommand(accessor, editor2) {
        return accessor.get(ISymbolNavigationService).revealNext(editor2);
      }
    }());
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "editor.gotoNextSymbolFromResult.cancel",
      weight: 100,
      when: ctxHasSymbols,
      primary: 9,
      handler(accessor) {
        accessor.get(ISymbolNavigationService).reset();
      }
    });
    EditorState2 = class EditorState3 {
      constructor(editorService) {
        this._listener = /* @__PURE__ */ new Map();
        this._disposables = new DisposableStore();
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));
        this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));
        editorService.listCodeEditors().forEach(this._onDidAddEditor, this);
      }
      dispose() {
        this._disposables.dispose();
        this._onDidChange.dispose();
        dispose(this._listener.values());
      }
      _onDidAddEditor(editor2) {
        this._listener.set(editor2, combinedDisposable(editor2.onDidChangeCursorPosition((_) => this._onDidChange.fire({ editor: editor2 })), editor2.onDidChangeModelContent((_) => this._onDidChange.fire({ editor: editor2 }))));
      }
      _onDidRemoveEditor(editor2) {
        var _a5;
        (_a5 = this._listener.get(editor2)) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._listener.delete(editor2);
      }
    };
    EditorState2 = __decorate16([
      __param16(0, ICodeEditorService)
    ], EditorState2);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToSymbol.js
function getLocationLinks(model, position, registry, provide) {
  const provider = registry.ordered(model);
  const promises = provider.map((provider2) => {
    return Promise.resolve(provide(provider2, model, position)).then(void 0, (err) => {
      onUnexpectedExternalError(err);
      return void 0;
    });
  });
  return Promise.all(promises).then((values) => {
    const result = [];
    for (let value of values) {
      if (Array.isArray(value)) {
        result.push(...value);
      } else if (value) {
        result.push(value);
      }
    }
    return result;
  });
}
function getDefinitionsAtPosition(model, position, token) {
  return getLocationLinks(model, position, DefinitionProviderRegistry, (provider, model2, position2) => {
    return provider.provideDefinition(model2, position2, token);
  });
}
function getDeclarationsAtPosition(model, position, token) {
  return getLocationLinks(model, position, DeclarationProviderRegistry, (provider, model2, position2) => {
    return provider.provideDeclaration(model2, position2, token);
  });
}
function getImplementationsAtPosition(model, position, token) {
  return getLocationLinks(model, position, ImplementationProviderRegistry, (provider, model2, position2) => {
    return provider.provideImplementation(model2, position2, token);
  });
}
function getTypeDefinitionsAtPosition(model, position, token) {
  return getLocationLinks(model, position, TypeDefinitionProviderRegistry, (provider, model2, position2) => {
    return provider.provideTypeDefinition(model2, position2, token);
  });
}
function getReferencesAtPosition(model, position, compact, token) {
  return getLocationLinks(model, position, ReferenceProviderRegistry, (provider, model2, position2) => __awaiter14(this, void 0, void 0, function* () {
    const result = yield provider.provideReferences(model2, position2, { includeDeclaration: true }, token);
    if (!compact || !result || result.length !== 2) {
      return result;
    }
    const resultWithoutDeclaration = yield provider.provideReferences(model2, position2, { includeDeclaration: false }, token);
    if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {
      return resultWithoutDeclaration;
    }
    return result;
  }));
}
function _sortedAndDeduped(callback) {
  return __awaiter14(this, void 0, void 0, function* () {
    const rawLinks = yield callback();
    const model = new ReferencesModel(rawLinks, "");
    const modelLinks = model.references.map((ref) => ref.link);
    model.dispose();
    return modelLinks;
  });
}
var __awaiter14;
var init_goToSymbol = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToSymbol.js"() {
    init_cancellation();
    init_errors();
    init_editorExtensions();
    init_modes();
    init_referencesModel();
    __awaiter14 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    registerModelAndPositionCommand("_executeDefinitionProvider", (model, position) => _sortedAndDeduped(() => getDefinitionsAtPosition(model, position, CancellationToken.None)));
    registerModelAndPositionCommand("_executeDeclarationProvider", (model, position) => _sortedAndDeduped(() => getDeclarationsAtPosition(model, position, CancellationToken.None)));
    registerModelAndPositionCommand("_executeImplementationProvider", (model, position) => _sortedAndDeduped(() => getImplementationsAtPosition(model, position, CancellationToken.None)));
    registerModelAndPositionCommand("_executeTypeDefinitionProvider", (model, position) => _sortedAndDeduped(() => getTypeDefinitionsAtPosition(model, position, CancellationToken.None)));
    registerModelAndPositionCommand("_executeReferenceProvider", (model, position) => _sortedAndDeduped(() => getReferencesAtPosition(model, position, false, CancellationToken.None)));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToCommands.js
function registerGoToAction(ctor) {
  const result = new ctor();
  registerInstantiatedEditorAction(result);
  _goToActionIds.add(result.id);
  return result;
}
var __awaiter15, _a, _b, _c, _d, _e, _f, _g, _h, _goToActionIds, SymbolNavigationAction, DefinitionAction, goToDefinitionKb, DeclarationAction, TypeDefinitionAction, ImplementationAction, ReferencesAction, GenericGoToLocationAction;
var init_goToCommands = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToCommands.js"() {
    init_browser();
    init_aria();
    init_async();
    init_keyCodes();
    init_platform();
    init_types();
    init_uri();
    init_editorState();
    init_editorBrowser();
    init_editorExtensions();
    init_codeEditorService();
    init_embeddedCodeEditorWidget();
    init_position();
    init_range();
    init_editorContextKeys();
    init_modes();
    init_referencesController();
    init_referencesModel();
    init_symbolNavigation();
    init_messageController();
    init_peekView();
    init_nls();
    init_actions2();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_notification();
    init_progress();
    init_goToSymbol();
    __awaiter15 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MenuRegistry.appendMenuItem(MenuId.EditorContext, {
      submenu: MenuId.EditorContextPeek,
      title: localize("peek.submenu", "Peek"),
      group: "navigation",
      order: 100
    });
    _goToActionIds = /* @__PURE__ */ new Set();
    SymbolNavigationAction = class extends EditorAction {
      constructor(configuration, opts) {
        super(opts);
        this._configuration = configuration;
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return Promise.resolve(void 0);
        }
        const notificationService = accessor.get(INotificationService);
        const editorService = accessor.get(ICodeEditorService);
        const progressService = accessor.get(IEditorProgressService);
        const symbolNavService = accessor.get(ISymbolNavigationService);
        const model = editor2.getModel();
        const pos = editor2.getPosition();
        const cts = new EditorStateCancellationTokenSource(
          editor2,
          1 | 4
          /* Position */
        );
        const promise = raceCancellation(this._getLocationModel(model, pos, cts.token), cts.token).then((references) => __awaiter15(this, void 0, void 0, function* () {
          if (!references || cts.token.isCancellationRequested) {
            return;
          }
          alert(references.ariaMessage);
          let altAction;
          if (references.referenceAt(model.uri, pos)) {
            const altActionId = this._getAlternativeCommand(editor2);
            if (altActionId !== this.id && _goToActionIds.has(altActionId)) {
              altAction = editor2.getAction(altActionId);
            }
          }
          const referenceCount = references.references.length;
          if (referenceCount === 0) {
            if (!this._configuration.muteMessage) {
              const info = model.getWordAtPosition(pos);
              MessageController.get(editor2).showMessage(this._getNoResultFoundMessage(info), pos);
            }
          } else if (referenceCount === 1 && altAction) {
            altAction.run();
          } else {
            return this._onResult(editorService, symbolNavService, editor2, references);
          }
        }), (err) => {
          notificationService.error(err);
        }).finally(() => {
          cts.dispose();
        });
        progressService.showWhile(promise, 250);
        return promise;
      }
      _onResult(editorService, symbolNavService, editor2, model) {
        return __awaiter15(this, void 0, void 0, function* () {
          const gotoLocation = this._getGoToPreference(editor2);
          if (!(editor2 instanceof EmbeddedCodeEditorWidget) && (this._configuration.openInPeek || gotoLocation === "peek" && model.references.length > 1)) {
            this._openInPeek(editor2, model);
          } else {
            const next = model.firstReference();
            const peek = model.references.length > 1 && gotoLocation === "gotoAndPeek";
            const targetEditor = yield this._openReference(editor2, editorService, next, this._configuration.openToSide, !peek);
            if (peek && targetEditor) {
              this._openInPeek(targetEditor, model);
            } else {
              model.dispose();
            }
            if (gotoLocation === "goto") {
              symbolNavService.put(next);
            }
          }
        });
      }
      _openReference(editor2, editorService, reference, sideBySide, highlight) {
        return __awaiter15(this, void 0, void 0, function* () {
          let range = void 0;
          if (isLocationLink(reference)) {
            range = reference.targetSelectionRange;
          }
          if (!range) {
            range = reference.range;
          }
          if (!range) {
            return void 0;
          }
          const targetEditor = yield editorService.openCodeEditor({
            resource: reference.uri,
            options: {
              selection: Range.collapseToStart(range),
              selectionRevealType: 3
              /* NearTopIfOutsideViewport */
            }
          }, editor2, sideBySide);
          if (!targetEditor) {
            return void 0;
          }
          if (highlight) {
            const modelNow = targetEditor.getModel();
            const ids = targetEditor.deltaDecorations([], [{ range, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
            setTimeout(() => {
              if (targetEditor.getModel() === modelNow) {
                targetEditor.deltaDecorations(ids, []);
              }
            }, 350);
          }
          return targetEditor;
        });
      }
      _openInPeek(target, model) {
        let controller = ReferencesController.get(target);
        if (controller && target.hasModel()) {
          controller.toggleWidget(target.getSelection(), createCancelablePromise((_) => Promise.resolve(model)), this._configuration.openInPeek);
        } else {
          model.dispose();
        }
      }
    };
    DefinitionAction = class extends SymbolNavigationAction {
      _getLocationModel(model, position, token) {
        return __awaiter15(this, void 0, void 0, function* () {
          return new ReferencesModel(yield getDefinitionsAtPosition(model, position, token), localize("def.title", "Definitions"));
        });
      }
      _getNoResultFoundMessage(info) {
        return info && info.word ? localize("noResultWord", "No definition found for '{0}'", info.word) : localize("generic.noResults", "No definition found");
      }
      _getAlternativeCommand(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).alternativeDefinitionCommand;
      }
      _getGoToPreference(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).multipleDefinitions;
      }
    };
    goToDefinitionKb = isWeb && !isStandalone ? 2048 | 70 : 70;
    registerGoToAction((_a = class GoToDefinitionAction extends DefinitionAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: false,
          muteMessage: false
        }, {
          id: GoToDefinitionAction.id,
          label: localize("actions.goToDecl.label", "Go to Definition"),
          alias: "Go to Definition",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: goToDefinitionKb,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "navigation",
            order: 1.1
          }
        });
        CommandsRegistry.registerCommandAlias("editor.action.goToDeclaration", GoToDefinitionAction.id);
      }
    }, _a.id = "editor.action.revealDefinition", _a));
    registerGoToAction((_b = class OpenDefinitionToSideAction extends DefinitionAction {
      constructor() {
        super({
          openToSide: true,
          openInPeek: false,
          muteMessage: false
        }, {
          id: OpenDefinitionToSideAction.id,
          label: localize("actions.goToDeclToSide.label", "Open Definition to the Side"),
          alias: "Open Definition to the Side",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(2048 | 41, goToDefinitionKb),
            weight: 100
            /* EditorContrib */
          }
        });
        CommandsRegistry.registerCommandAlias("editor.action.openDeclarationToTheSide", OpenDefinitionToSideAction.id);
      }
    }, _b.id = "editor.action.revealDefinitionAside", _b));
    registerGoToAction((_c = class PeekDefinitionAction extends DefinitionAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: true,
          muteMessage: false
        }, {
          id: PeekDefinitionAction.id,
          label: localize("actions.previewDecl.label", "Peek Definition"),
          alias: "Peek Definition",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 512 | 70,
            linux: {
              primary: 2048 | 1024 | 68
              /* F10 */
            },
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            menuId: MenuId.EditorContextPeek,
            group: "peek",
            order: 2
          }
        });
        CommandsRegistry.registerCommandAlias("editor.action.previewDeclaration", PeekDefinitionAction.id);
      }
    }, _c.id = "editor.action.peekDefinition", _c));
    DeclarationAction = class extends SymbolNavigationAction {
      _getLocationModel(model, position, token) {
        return __awaiter15(this, void 0, void 0, function* () {
          return new ReferencesModel(yield getDeclarationsAtPosition(model, position, token), localize("decl.title", "Declarations"));
        });
      }
      _getNoResultFoundMessage(info) {
        return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
      }
      _getAlternativeCommand(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).alternativeDeclarationCommand;
      }
      _getGoToPreference(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).multipleDeclarations;
      }
    };
    registerGoToAction((_d = class GoToDeclarationAction extends DeclarationAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: false,
          muteMessage: false
        }, {
          id: GoToDeclarationAction.id,
          label: localize("actions.goToDeclaration.label", "Go to Declaration"),
          alias: "Go to Declaration",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          contextMenuOpts: {
            group: "navigation",
            order: 1.3
          }
        });
      }
      _getNoResultFoundMessage(info) {
        return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
      }
    }, _d.id = "editor.action.revealDeclaration", _d));
    registerGoToAction(class PeekDeclarationAction extends DeclarationAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: true,
          muteMessage: false
        }, {
          id: "editor.action.peekDeclaration",
          label: localize("actions.peekDecl.label", "Peek Declaration"),
          alias: "Peek Declaration",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          contextMenuOpts: {
            menuId: MenuId.EditorContextPeek,
            group: "peek",
            order: 3
          }
        });
      }
    });
    TypeDefinitionAction = class extends SymbolNavigationAction {
      _getLocationModel(model, position, token) {
        return __awaiter15(this, void 0, void 0, function* () {
          return new ReferencesModel(yield getTypeDefinitionsAtPosition(model, position, token), localize("typedef.title", "Type Definitions"));
        });
      }
      _getNoResultFoundMessage(info) {
        return info && info.word ? localize("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", info.word) : localize("goToTypeDefinition.generic.noResults", "No type definition found");
      }
      _getAlternativeCommand(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).alternativeTypeDefinitionCommand;
      }
      _getGoToPreference(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).multipleTypeDefinitions;
      }
    };
    registerGoToAction((_e = class GoToTypeDefinitionAction extends TypeDefinitionAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: false,
          muteMessage: false
        }, {
          id: GoToTypeDefinitionAction.ID,
          label: localize("actions.goToTypeDefinition.label", "Go to Type Definition"),
          alias: "Go to Type Definition",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 0,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "navigation",
            order: 1.4
          }
        });
      }
    }, _e.ID = "editor.action.goToTypeDefinition", _e));
    registerGoToAction((_f = class PeekTypeDefinitionAction extends TypeDefinitionAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: true,
          muteMessage: false
        }, {
          id: PeekTypeDefinitionAction.ID,
          label: localize("actions.peekTypeDefinition.label", "Peek Type Definition"),
          alias: "Peek Type Definition",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          contextMenuOpts: {
            menuId: MenuId.EditorContextPeek,
            group: "peek",
            order: 4
          }
        });
      }
    }, _f.ID = "editor.action.peekTypeDefinition", _f));
    ImplementationAction = class extends SymbolNavigationAction {
      _getLocationModel(model, position, token) {
        return __awaiter15(this, void 0, void 0, function* () {
          return new ReferencesModel(yield getImplementationsAtPosition(model, position, token), localize("impl.title", "Implementations"));
        });
      }
      _getNoResultFoundMessage(info) {
        return info && info.word ? localize("goToImplementation.noResultWord", "No implementation found for '{0}'", info.word) : localize("goToImplementation.generic.noResults", "No implementation found");
      }
      _getAlternativeCommand(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).alternativeImplementationCommand;
      }
      _getGoToPreference(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).multipleImplementations;
      }
    };
    registerGoToAction((_g = class GoToImplementationAction extends ImplementationAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: false,
          muteMessage: false
        }, {
          id: GoToImplementationAction.ID,
          label: localize("actions.goToImplementation.label", "Go to Implementations"),
          alias: "Go to Implementations",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 70,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "navigation",
            order: 1.45
          }
        });
      }
    }, _g.ID = "editor.action.goToImplementation", _g));
    registerGoToAction((_h = class PeekImplementationAction extends ImplementationAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: true,
          muteMessage: false
        }, {
          id: PeekImplementationAction.ID,
          label: localize("actions.peekImplementation.label", "Peek Implementations"),
          alias: "Peek Implementations",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 70,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            menuId: MenuId.EditorContextPeek,
            group: "peek",
            order: 5
          }
        });
      }
    }, _h.ID = "editor.action.peekImplementation", _h));
    ReferencesAction = class extends SymbolNavigationAction {
      _getNoResultFoundMessage(info) {
        return info ? localize("references.no", "No references found for '{0}'", info.word) : localize("references.noGeneric", "No references found");
      }
      _getAlternativeCommand(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).alternativeReferenceCommand;
      }
      _getGoToPreference(editor2) {
        return editor2.getOption(
          50
          /* gotoLocation */
        ).multipleReferences;
      }
    };
    registerGoToAction(class GoToReferencesAction extends ReferencesAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: false,
          muteMessage: false
        }, {
          id: "editor.action.goToReferences",
          label: localize("goToReferences.label", "Go to References"),
          alias: "Go to References",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 70,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "navigation",
            order: 1.45
          }
        });
      }
      _getLocationModel(model, position, token) {
        return __awaiter15(this, void 0, void 0, function* () {
          return new ReferencesModel(yield getReferencesAtPosition(model, position, true, token), localize("ref.title", "References"));
        });
      }
    });
    registerGoToAction(class PeekReferencesAction extends ReferencesAction {
      constructor() {
        super({
          openToSide: false,
          openInPeek: true,
          muteMessage: false
        }, {
          id: "editor.action.referenceSearch.trigger",
          label: localize("references.action.label", "Peek References"),
          alias: "Peek References",
          precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
          contextMenuOpts: {
            menuId: MenuId.EditorContextPeek,
            group: "peek",
            order: 6
          }
        });
      }
      _getLocationModel(model, position, token) {
        return __awaiter15(this, void 0, void 0, function* () {
          return new ReferencesModel(yield getReferencesAtPosition(model, position, false, token), localize("ref.title", "References"));
        });
      }
    });
    GenericGoToLocationAction = class extends SymbolNavigationAction {
      constructor(config, _references, _gotoMultipleBehaviour) {
        super(config, {
          id: "editor.action.goToLocation",
          label: localize("label.generic", "Go To Any Symbol"),
          alias: "Go To Any Symbol",
          precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated())
        });
        this._references = _references;
        this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
      }
      _getLocationModel(_model, _position, _token) {
        return __awaiter15(this, void 0, void 0, function* () {
          return new ReferencesModel(this._references, localize("generic.title", "Locations"));
        });
      }
      _getNoResultFoundMessage(info) {
        return info && localize("generic.noResult", "No results for '{0}'", info.word) || "";
      }
      _getGoToPreference(editor2) {
        var _a5;
        return (_a5 = this._gotoMultipleBehaviour) !== null && _a5 !== void 0 ? _a5 : editor2.getOption(
          50
          /* gotoLocation */
        ).multipleReferences;
      }
      _getAlternativeCommand() {
        return "";
      }
    };
    CommandsRegistry.registerCommand({
      id: "editor.action.goToLocations",
      description: {
        description: "Go to locations from a position in a file",
        args: [
          { name: "uri", description: "The text document in which to start", constraint: URI },
          { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
          { name: "locations", description: "An array of locations.", constraint: Array },
          { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" },
          { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
        ]
      },
      handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => __awaiter15(void 0, void 0, void 0, function* () {
        assertType(URI.isUri(resource));
        assertType(Position.isIPosition(position));
        assertType(Array.isArray(references));
        assertType(typeof multiple === "undefined" || typeof multiple === "string");
        assertType(typeof openInPeek === "undefined" || typeof openInPeek === "boolean");
        const editorService = accessor.get(ICodeEditorService);
        const editor2 = yield editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
        if (isCodeEditor(editor2)) {
          editor2.setPosition(position);
          editor2.revealPositionInCenterIfOutsideViewport(
            position,
            0
            /* Smooth */
          );
          return editor2.invokeWithinContext((accessor2) => {
            const command = new class extends GenericGoToLocationAction {
              _getNoResultFoundMessage(info) {
                return noResultsMessage || super._getNoResultFoundMessage(info);
              }
            }({
              muteMessage: !Boolean(noResultsMessage),
              openInPeek: Boolean(openInPeek),
              openToSide: false
            }, references, multiple);
            accessor2.get(IInstantiationService).invokeFunction(command.run.bind(command), editor2);
          });
        }
      })
    });
    CommandsRegistry.registerCommand({
      id: "editor.action.peekLocations",
      description: {
        description: "Peek locations from a position in a file",
        args: [
          { name: "uri", description: "The text document in which to start", constraint: URI },
          { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
          { name: "locations", description: "An array of locations.", constraint: Array },
          { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" }
        ]
      },
      handler: (accessor, resource, position, references, multiple) => __awaiter15(void 0, void 0, void 0, function* () {
        accessor.get(ICommandService).executeCommand("editor.action.goToLocations", resource, position, references, multiple, void 0, true);
      })
    });
    CommandsRegistry.registerCommand({
      id: "editor.action.findReferences",
      handler: (accessor, resource, position) => {
        assertType(URI.isUri(resource));
        assertType(Position.isIPosition(position));
        const codeEditorService = accessor.get(ICodeEditorService);
        return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then((control) => {
          if (!isCodeEditor(control) || !control.hasModel()) {
            return void 0;
          }
          const controller = ReferencesController.get(control);
          if (!controller) {
            return void 0;
          }
          const references = createCancelablePromise((token) => getReferencesAtPosition(control.getModel(), Position.lift(position), false, token).then((references2) => new ReferencesModel(references2, localize("ref.title", "References"))));
          const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
          return Promise.resolve(controller.toggleWidget(range, references, false));
        });
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
    MenuRegistry.appendMenuItems([
      {
        id: MenuId.MenubarGoMenu,
        item: {
          command: {
            id: "editor.action.revealDefinition",
            title: localize({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
          },
          group: "4_symbol_nav",
          order: 2
        }
      },
      {
        id: MenuId.MenubarGoMenu,
        item: {
          command: {
            id: "editor.action.revealDeclaration",
            title: localize({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
          },
          group: "4_symbol_nav",
          order: 3
        }
      },
      {
        id: MenuId.MenubarGoMenu,
        item: {
          command: {
            id: "editor.action.goToTypeDefinition",
            title: localize({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
          },
          group: "4_symbol_nav",
          order: 3
        }
      },
      {
        id: MenuId.MenubarGoMenu,
        item: {
          command: {
            id: "editor.action.goToImplementation",
            title: localize({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
          },
          group: "4_symbol_nav",
          order: 4
        }
      },
      {
        id: MenuId.MenubarGoMenu,
        item: {
          command: {
            id: "editor.action.goToReferences",
            title: localize({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
          },
          group: "4_symbol_nav",
          order: 5
        }
      }
    ]);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.js
var __decorate17, __param17, GotoDefinitionAtPositionEditorContribution;
var init_goToDefinitionAtPosition = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.js"() {
    init_async();
    init_errors();
    init_htmlContent();
    init_lifecycle();
    init_types();
    init_editorState();
    init_editorExtensions();
    init_position();
    init_range();
    init_modes();
    init_modeService();
    init_resolverService();
    init_clickLinkGesture();
    init_peekView();
    init_nls();
    init_contextkey();
    init_colorRegistry();
    init_themeService();
    init_goToCommands();
    init_goToSymbol();
    __decorate17 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param17 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    GotoDefinitionAtPositionEditorContribution = class GotoDefinitionAtPositionEditorContribution2 {
      constructor(editor2, textModelResolverService, modeService) {
        this.textModelResolverService = textModelResolverService;
        this.modeService = modeService;
        this.toUnhook = new DisposableStore();
        this.toUnhookForKeyboard = new DisposableStore();
        this.linkDecorations = [];
        this.currentWordAtPosition = null;
        this.previousPromise = null;
        this.editor = editor2;
        let linkGesture = new ClickLinkGesture(editor2);
        this.toUnhook.add(linkGesture);
        this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
          this.startFindDefinitionFromMouse(mouseEvent, withNullAsUndefined(keyboardEvent));
        }));
        this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
          if (this.isEnabled(mouseEvent)) {
            this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).then(() => {
              this.removeLinkDecorations();
            }, (error) => {
              this.removeLinkDecorations();
              onUnexpectedError(error);
            });
          }
        }));
        this.toUnhook.add(linkGesture.onCancel(() => {
          this.removeLinkDecorations();
          this.currentWordAtPosition = null;
        }));
      }
      static get(editor2) {
        return editor2.getContribution(GotoDefinitionAtPositionEditorContribution2.ID);
      }
      startFindDefinitionFromCursor(position) {
        return this.startFindDefinition(position).then(() => {
          this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
            this.currentWordAtPosition = null;
            this.removeLinkDecorations();
            this.toUnhookForKeyboard.clear();
          }));
          this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
            if (e) {
              this.currentWordAtPosition = null;
              this.removeLinkDecorations();
              this.toUnhookForKeyboard.clear();
            }
          }));
        });
      }
      startFindDefinitionFromMouse(mouseEvent, withKey) {
        if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) {
          return;
        }
        if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
          this.currentWordAtPosition = null;
          this.removeLinkDecorations();
          return;
        }
        const position = mouseEvent.target.position;
        this.startFindDefinition(position);
      }
      startFindDefinition(position) {
        var _a5;
        this.toUnhookForKeyboard.clear();
        const word = position ? (_a5 = this.editor.getModel()) === null || _a5 === void 0 ? void 0 : _a5.getWordAtPosition(position) : null;
        if (!word) {
          this.currentWordAtPosition = null;
          this.removeLinkDecorations();
          return Promise.resolve(0);
        }
        if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
          return Promise.resolve(0);
        }
        this.currentWordAtPosition = word;
        let state = new EditorState(
          this.editor,
          4 | 1 | 2 | 8
          /* Scroll */
        );
        if (this.previousPromise) {
          this.previousPromise.cancel();
          this.previousPromise = null;
        }
        this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
        return this.previousPromise.then((results) => {
          if (!results || !results.length || !state.validate(this.editor)) {
            this.removeLinkDecorations();
            return;
          }
          if (results.length > 1) {
            this.addDecoration(new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn), new MarkdownString().appendText(localize("multipleResults", "Click to show {0} definitions.", results.length)));
          } else {
            let result = results[0];
            if (!result.uri) {
              return;
            }
            this.textModelResolverService.createModelReference(result.uri).then((ref) => {
              if (!ref.object || !ref.object.textEditorModel) {
                ref.dispose();
                return;
              }
              const { object: { textEditorModel } } = ref;
              const { startLineNumber } = result.range;
              if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
                ref.dispose();
                return;
              }
              const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
              let wordRange;
              if (result.originSelectionRange) {
                wordRange = Range.lift(result.originSelectionRange);
              } else {
                wordRange = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
              }
              const modeId = this.modeService.getModeIdByFilepathOrFirstLine(textEditorModel.uri);
              this.addDecoration(wordRange, new MarkdownString().appendCodeblock(modeId ? modeId : "", previewValue));
              ref.dispose();
            });
          }
        }).then(void 0, onUnexpectedError);
      }
      getPreviewValue(textEditorModel, startLineNumber, result) {
        let rangeToUse = result.targetSelectionRange ? result.range : this.getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber);
        const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;
        if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES) {
          rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
        }
        const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
        return previewValue;
      }
      stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
        const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
        let minIndent = startIndent;
        for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
          const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
          minIndent = Math.min(minIndent, endIndent);
        }
        const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
        return previewValue;
      }
      getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
        const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
        const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
        let endLineNumber = startLineNumber + 1;
        for (; endLineNumber < maxLineNumber; endLineNumber++) {
          let endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
          if (startIndent === endIndent) {
            break;
          }
        }
        return new Range(startLineNumber, 1, endLineNumber + 1, 1);
      }
      getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber) {
        const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
        const brackets = [];
        let ignoreFirstEmpty = true;
        let currentBracket = textEditorModel.findNextBracket(new Position(startLineNumber, 1));
        while (currentBracket !== null) {
          if (brackets.length === 0) {
            brackets.push(currentBracket);
          } else {
            const lastBracket = brackets[brackets.length - 1];
            if (lastBracket.open[0] === currentBracket.open[0] && lastBracket.isOpen && !currentBracket.isOpen) {
              brackets.pop();
            } else {
              brackets.push(currentBracket);
            }
            if (brackets.length === 0) {
              if (ignoreFirstEmpty) {
                ignoreFirstEmpty = false;
              } else {
                return new Range(startLineNumber, 1, currentBracket.range.endLineNumber + 1, 1);
              }
            }
          }
          const maxColumn = textEditorModel.getLineMaxColumn(startLineNumber);
          let nextLineNumber = currentBracket.range.endLineNumber;
          let nextColumn = currentBracket.range.endColumn;
          if (maxColumn === currentBracket.range.endColumn) {
            nextLineNumber++;
            nextColumn = 1;
          }
          if (nextLineNumber > maxLineNumber) {
            return new Range(startLineNumber, 1, maxLineNumber + 1, 1);
          }
          currentBracket = textEditorModel.findNextBracket(new Position(nextLineNumber, nextColumn));
        }
        return new Range(startLineNumber, 1, maxLineNumber + 1, 1);
      }
      addDecoration(range, hoverMessage) {
        const newDecorations = {
          range,
          options: {
            description: "goto-definition-link",
            inlineClassName: "goto-definition-link",
            hoverMessage
          }
        };
        this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, [newDecorations]);
      }
      removeLinkDecorations() {
        if (this.linkDecorations.length > 0) {
          this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, []);
        }
      }
      isEnabled(mouseEvent, withKey) {
        return this.editor.hasModel() && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && DefinitionProviderRegistry.has(this.editor.getModel());
      }
      findDefinition(position, token) {
        const model = this.editor.getModel();
        if (!model) {
          return Promise.resolve(null);
        }
        return getDefinitionsAtPosition(model, position, token);
      }
      gotoDefinition(position, openToSide) {
        this.editor.setPosition(position);
        return this.editor.invokeWithinContext((accessor) => {
          const canPeek = !openToSide && this.editor.getOption(
            77
            /* definitionLinkOpensInPeek */
          ) && !this.isInPeekEditor(accessor);
          const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { alias: "", label: "", id: "", precondition: void 0 });
          return action.run(accessor, this.editor);
        });
      }
      isInPeekEditor(accessor) {
        const contextKeyService = accessor.get(IContextKeyService);
        return PeekContext.inPeekEditor.getValue(contextKeyService);
      }
      dispose() {
        this.toUnhook.dispose();
      }
    };
    GotoDefinitionAtPositionEditorContribution.ID = "editor.contrib.gotodefinitionatposition";
    GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
    GotoDefinitionAtPositionEditorContribution = __decorate17([
      __param17(1, ITextModelService),
      __param17(2, IModeService)
    ], GotoDefinitionAtPositionEditorContribution);
    registerEditorContribution(GotoDefinitionAtPositionEditorContribution.ID, GotoDefinitionAtPositionEditorContribution);
    registerThemingParticipant((theme, collector) => {
      const activeLinkForeground = theme.getColor(editorActiveLinkForeground);
      if (activeLinkForeground) {
        collector.addRule(`.monaco-editor .goto-definition-link { color: ${activeLinkForeground} !important; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
var $2, HoverWidget, HoverAction;
var init_hoverWidget = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js"() {
    init_dom();
    init_scrollableElement();
    init_lifecycle();
    $2 = $;
    HoverWidget = class extends Disposable {
      constructor() {
        super();
        this.containerDomNode = document.createElement("div");
        this.containerDomNode.className = "monaco-hover";
        this.containerDomNode.tabIndex = 0;
        this.containerDomNode.setAttribute("role", "tooltip");
        this.contentsDomNode = document.createElement("div");
        this.contentsDomNode.className = "monaco-hover-content";
        this._scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, {
          consumeMouseWheelIfScrollbarIsNeeded: true
        }));
        this.containerDomNode.appendChild(this._scrollbar.getDomNode());
      }
      onContentsChanged() {
        this._scrollbar.scanDomNode();
      }
    };
    HoverAction = class _HoverAction extends Disposable {
      constructor(parent, actionOptions, keybindingLabel) {
        super();
        this.actionContainer = append(parent, $2("div.action-container"));
        this.action = append(this.actionContainer, $2("a.action"));
        this.action.setAttribute("href", "#");
        this.action.setAttribute("role", "button");
        if (actionOptions.iconClass) {
          append(this.action, $2(`span.icon.${actionOptions.iconClass}`));
        }
        const label = append(this.action, $2("span"));
        label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
        this._register(addDisposableListener(this.actionContainer, EventType.CLICK, (e) => {
          e.stopPropagation();
          e.preventDefault();
          actionOptions.run(this.actionContainer);
        }));
        this.setEnabled(true);
      }
      static render(parent, actionOptions, keybindingLabel) {
        return new _HoverAction(parent, actionOptions, keybindingLabel);
      }
      setEnabled(enabled) {
        if (enabled) {
          this.actionContainer.classList.remove("disabled");
          this.actionContainer.removeAttribute("aria-disabled");
        } else {
          this.actionContainer.classList.add("disabled");
          this.actionContainer.setAttribute("aria-disabled", "true");
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerModel.js
var ColorPickerModel;
var init_colorPickerModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerModel.js"() {
    init_event();
    ColorPickerModel = class {
      constructor(color, availableColorPresentations, presentationIndex) {
        this.presentationIndex = presentationIndex;
        this._onColorFlushed = new Emitter();
        this.onColorFlushed = this._onColorFlushed.event;
        this._onDidChangeColor = new Emitter();
        this.onDidChangeColor = this._onDidChangeColor.event;
        this._onDidChangePresentation = new Emitter();
        this.onDidChangePresentation = this._onDidChangePresentation.event;
        this.originalColor = color;
        this._color = color;
        this._colorPresentations = availableColorPresentations;
      }
      get color() {
        return this._color;
      }
      set color(color) {
        if (this._color.equals(color)) {
          return;
        }
        this._color = color;
        this._onDidChangeColor.fire(color);
      }
      get presentation() {
        return this.colorPresentations[this.presentationIndex];
      }
      get colorPresentations() {
        return this._colorPresentations;
      }
      set colorPresentations(colorPresentations) {
        this._colorPresentations = colorPresentations;
        if (this.presentationIndex > colorPresentations.length - 1) {
          this.presentationIndex = 0;
        }
        this._onDidChangePresentation.fire(this.presentation);
      }
      selectNextColorPresentation() {
        this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
        this.flushColor();
        this._onDidChangePresentation.fire(this.presentation);
      }
      guessColorPresentation(color, originalText) {
        for (let i = 0; i < this.colorPresentations.length; i++) {
          if (originalText.toLowerCase() === this.colorPresentations[i].label) {
            this.presentationIndex = i;
            this._onDidChangePresentation.fire(this.presentation);
            break;
          }
        }
      }
      flushColor() {
        this._onColorFlushed.fire(this._color);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerWidget.js
var $3, ColorPickerHeader, ColorPickerBody, SaturationBox, Strip, OpacityStrip, HueStrip, ColorPickerWidget;
var init_colorPickerWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerWidget.js"() {
    init_browser();
    init_dom();
    init_globalMouseMoveMonitor();
    init_widget();
    init_color();
    init_event();
    init_lifecycle();
    init_colorRegistry();
    init_themeService();
    $3 = $;
    ColorPickerHeader = class extends Disposable {
      constructor(container, model, themeService) {
        super();
        this.model = model;
        this.domNode = $3(".colorpicker-header");
        append(container, this.domNode);
        this.pickedColorNode = append(this.domNode, $3(".picked-color"));
        const colorBox = append(this.domNode, $3(".original-color"));
        colorBox.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || "";
        this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color.white;
        this._register(registerThemingParticipant((theme, collector) => {
          this.backgroundColor = theme.getColor(editorHoverBackground) || Color.white;
        }));
        this._register(addDisposableListener(this.pickedColorNode, EventType.CLICK, () => this.model.selectNextColorPresentation()));
        this._register(addDisposableListener(colorBox, EventType.CLICK, () => {
          this.model.color = this.model.originalColor;
          this.model.flushColor();
        }));
        this._register(model.onDidChangeColor(this.onDidChangeColor, this));
        this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
        this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color) || "";
        this.pickedColorNode.classList.toggle("light", model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());
      }
      onDidChangeColor(color) {
        this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color) || "";
        this.pickedColorNode.classList.toggle("light", color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
        this.onDidChangePresentation();
      }
      onDidChangePresentation() {
        this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : "";
      }
    };
    ColorPickerBody = class extends Disposable {
      constructor(container, model, pixelRatio) {
        super();
        this.model = model;
        this.pixelRatio = pixelRatio;
        this.domNode = $3(".colorpicker-body");
        append(container, this.domNode);
        this.saturationBox = new SaturationBox(this.domNode, this.model, this.pixelRatio);
        this._register(this.saturationBox);
        this._register(this.saturationBox.onDidChange(this.onDidSaturationValueChange, this));
        this._register(this.saturationBox.onColorFlushed(this.flushColor, this));
        this.opacityStrip = new OpacityStrip(this.domNode, this.model);
        this._register(this.opacityStrip);
        this._register(this.opacityStrip.onDidChange(this.onDidOpacityChange, this));
        this._register(this.opacityStrip.onColorFlushed(this.flushColor, this));
        this.hueStrip = new HueStrip(this.domNode, this.model);
        this._register(this.hueStrip);
        this._register(this.hueStrip.onDidChange(this.onDidHueChange, this));
        this._register(this.hueStrip.onColorFlushed(this.flushColor, this));
      }
      flushColor() {
        this.model.flushColor();
      }
      onDidSaturationValueChange({ s, v }) {
        const hsva = this.model.color.hsva;
        this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
      }
      onDidOpacityChange(a) {
        const hsva = this.model.color.hsva;
        this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
      }
      onDidHueChange(value) {
        const hsva = this.model.color.hsva;
        const h = (1 - value) * 360;
        this.model.color = new Color(new HSVA(h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));
      }
      layout() {
        this.saturationBox.layout();
        this.opacityStrip.layout();
        this.hueStrip.layout();
      }
    };
    SaturationBox = class extends Disposable {
      constructor(container, model, pixelRatio) {
        super();
        this.model = model;
        this.pixelRatio = pixelRatio;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onColorFlushed = new Emitter();
        this.onColorFlushed = this._onColorFlushed.event;
        this.domNode = $3(".saturation-wrap");
        append(container, this.domNode);
        this.canvas = document.createElement("canvas");
        this.canvas.className = "saturation-box";
        append(this.domNode, this.canvas);
        this.selection = $3(".saturation-selection");
        append(this.domNode, this.selection);
        this.layout();
        this._register(addDisposableGenericMouseDownListner(this.domNode, (e) => this.onMouseDown(e)));
        this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
        this.monitor = null;
      }
      onMouseDown(e) {
        this.monitor = this._register(new GlobalMouseMoveMonitor());
        const origin = getDomNodePagePosition(this.domNode);
        if (e.target !== this.selection) {
          this.onDidChangePosition(e.offsetX, e.offsetY);
        }
        this.monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (event) => this.onDidChangePosition(event.posx - origin.left, event.posy - origin.top), () => null);
        const mouseUpListener = addDisposableGenericMouseUpListner(document, () => {
          this._onColorFlushed.fire();
          mouseUpListener.dispose();
          if (this.monitor) {
            this.monitor.stopMonitoring(true);
            this.monitor = null;
          }
        }, true);
      }
      onDidChangePosition(left, top) {
        const s = Math.max(0, Math.min(1, left / this.width));
        const v = Math.max(0, Math.min(1, 1 - top / this.height));
        this.paintSelection(s, v);
        this._onDidChange.fire({ s, v });
      }
      layout() {
        this.width = this.domNode.offsetWidth;
        this.height = this.domNode.offsetHeight;
        this.canvas.width = this.width * this.pixelRatio;
        this.canvas.height = this.height * this.pixelRatio;
        this.paint();
        const hsva = this.model.color.hsva;
        this.paintSelection(hsva.s, hsva.v);
      }
      paint() {
        const hsva = this.model.color.hsva;
        const saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
        const ctx = this.canvas.getContext("2d");
        const whiteGradient = ctx.createLinearGradient(0, 0, this.canvas.width, 0);
        whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        whiteGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
        whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
        const blackGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
        blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
        ctx.rect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
        ctx.fill();
        ctx.fillStyle = whiteGradient;
        ctx.fill();
        ctx.fillStyle = blackGradient;
        ctx.fill();
      }
      paintSelection(s, v) {
        this.selection.style.left = `${s * this.width}px`;
        this.selection.style.top = `${this.height - v * this.height}px`;
      }
      onDidChangeColor() {
        if (this.monitor && this.monitor.isMonitoring()) {
          return;
        }
        this.paint();
      }
    };
    Strip = class extends Disposable {
      constructor(container, model) {
        super();
        this.model = model;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onColorFlushed = new Emitter();
        this.onColorFlushed = this._onColorFlushed.event;
        this.domNode = append(container, $3(".strip"));
        this.overlay = append(this.domNode, $3(".overlay"));
        this.slider = append(this.domNode, $3(".slider"));
        this.slider.style.top = `0px`;
        this._register(addDisposableGenericMouseDownListner(this.domNode, (e) => this.onMouseDown(e)));
        this.layout();
      }
      layout() {
        this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
        const value = this.getValue(this.model.color);
        this.updateSliderPosition(value);
      }
      onMouseDown(e) {
        const monitor = this._register(new GlobalMouseMoveMonitor());
        const origin = getDomNodePagePosition(this.domNode);
        this.domNode.classList.add("grabbing");
        if (e.target !== this.slider) {
          this.onDidChangeTop(e.offsetY);
        }
        monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (event) => this.onDidChangeTop(event.posy - origin.top), () => null);
        const mouseUpListener = addDisposableGenericMouseUpListner(document, () => {
          this._onColorFlushed.fire();
          mouseUpListener.dispose();
          monitor.stopMonitoring(true);
          this.domNode.classList.remove("grabbing");
        }, true);
      }
      onDidChangeTop(top) {
        const value = Math.max(0, Math.min(1, 1 - top / this.height));
        this.updateSliderPosition(value);
        this._onDidChange.fire(value);
      }
      updateSliderPosition(value) {
        this.slider.style.top = `${(1 - value) * this.height}px`;
      }
    };
    OpacityStrip = class extends Strip {
      constructor(container, model) {
        super(container, model);
        this.domNode.classList.add("opacity-strip");
        this._register(model.onDidChangeColor(this.onDidChangeColor, this));
        this.onDidChangeColor(this.model.color);
      }
      onDidChangeColor(color) {
        const { r, g, b } = color.rgba;
        const opaque2 = new Color(new RGBA(r, g, b, 1));
        const transparent2 = new Color(new RGBA(r, g, b, 0));
        this.overlay.style.background = `linear-gradient(to bottom, ${opaque2} 0%, ${transparent2} 100%)`;
      }
      getValue(color) {
        return color.hsva.a;
      }
    };
    HueStrip = class extends Strip {
      constructor(container, model) {
        super(container, model);
        this.domNode.classList.add("hue-strip");
      }
      getValue(color) {
        return 1 - color.hsva.h / 360;
      }
    };
    ColorPickerWidget = class extends Widget {
      constructor(container, model, pixelRatio, themeService) {
        super();
        this.model = model;
        this.pixelRatio = pixelRatio;
        this._register(onDidChangeZoomLevel(() => this.layout()));
        const element = $3(".colorpicker-widget");
        container.appendChild(element);
        const header = new ColorPickerHeader(element, this.model, themeService);
        this.body = new ColorPickerBody(element, this.model, this.pixelRatio);
        this._register(header);
        this._register(this.body);
      }
      layout() {
        this.body.layout();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/colorHoverParticipant.js
var __decorate18, __param18, __awaiter16, ColorHover, ColorHoverParticipant;
var init_colorHoverParticipant = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/colorHoverParticipant.js"() {
    init_cancellation();
    init_color();
    init_lifecycle();
    init_range();
    init_color2();
    init_colorDetector();
    init_colorPickerModel();
    init_colorPickerWidget();
    init_themeService();
    __decorate18 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param18 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter16 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ColorHover = class {
      constructor(owner, range, model, provider) {
        this.owner = owner;
        this.range = range;
        this.model = model;
        this.provider = provider;
        this.forceShowAtRange = true;
      }
      isValidForHoverAnchor(anchor) {
        return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
      }
    };
    ColorHoverParticipant = class ColorHoverParticipant2 {
      constructor(_editor2, _hover, _themeService) {
        this._editor = _editor2;
        this._hover = _hover;
        this._themeService = _themeService;
      }
      computeSync(anchor, lineDecorations) {
        return [];
      }
      computeAsync(anchor, lineDecorations, token) {
        return __awaiter16(this, void 0, void 0, function* () {
          if (!this._editor.hasModel()) {
            return [];
          }
          const colorDetector = ColorDetector.get(this._editor);
          for (const d of lineDecorations) {
            const colorData = colorDetector.getColorData(d.range.getStartPosition());
            if (colorData) {
              const colorHover = yield this._createColorHover(this._editor.getModel(), colorData.colorInfo, colorData.provider);
              return [colorHover];
            }
          }
          return [];
        });
      }
      _createColorHover(editorModel, colorInfo, provider) {
        return __awaiter16(this, void 0, void 0, function* () {
          const originalText = editorModel.getValueInRange(colorInfo.range);
          const { red, green, blue, alpha } = colorInfo.color;
          const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
          const color = new Color(rgba);
          const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
          const model = new ColorPickerModel(color, [], 0);
          model.colorPresentations = colorPresentations || [];
          model.guessColorPresentation(color, originalText);
          return new ColorHover(this, Range.lift(colorInfo.range), model, provider);
        });
      }
      renderHoverParts(hoverParts, fragment, statusBar) {
        if (hoverParts.length === 0 || !this._editor.hasModel()) {
          return Disposable.None;
        }
        const disposables = new DisposableStore();
        const colorHover = hoverParts[0];
        const editorModel = this._editor.getModel();
        const model = colorHover.model;
        const widget = disposables.add(new ColorPickerWidget(fragment, model, this._editor.getOption(
          127
          /* pixelRatio */
        ), this._themeService));
        let range = new Range(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
        const updateEditorModel = () => {
          let textEdits;
          let newRange;
          if (model.presentation.textEdit) {
            textEdits = [model.presentation.textEdit];
            newRange = new Range(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);
            const trackedRange = this._editor.getModel()._setTrackedRange(
              null,
              newRange,
              3
              /* GrowsOnlyWhenTypingAfter */
            );
            this._editor.pushUndoStop();
            this._editor.executeEdits("colorpicker", textEdits);
            newRange = this._editor.getModel()._getTrackedRange(trackedRange) || newRange;
          } else {
            textEdits = [{ identifier: null, range, text: model.presentation.label, forceMoveMarkers: false }];
            newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);
            this._editor.pushUndoStop();
            this._editor.executeEdits("colorpicker", textEdits);
          }
          if (model.presentation.additionalTextEdits) {
            textEdits = [...model.presentation.additionalTextEdits];
            this._editor.executeEdits("colorpicker", textEdits);
            this._hover.hide();
          }
          this._editor.pushUndoStop();
          range = newRange;
        };
        const updateColorPresentations = (color) => {
          return getColorPresentations(editorModel, {
            range,
            color: {
              red: color.rgba.r / 255,
              green: color.rgba.g / 255,
              blue: color.rgba.b / 255,
              alpha: color.rgba.a
            }
          }, colorHover.provider, CancellationToken.None).then((colorPresentations) => {
            model.colorPresentations = colorPresentations || [];
          });
        };
        disposables.add(model.onColorFlushed((color) => {
          updateColorPresentations(color).then(updateEditorModel);
        }));
        disposables.add(model.onDidChangeColor(updateColorPresentations));
        this._hover.setColorPicker(widget);
        return disposables;
      }
    };
    ColorHoverParticipant = __decorate18([
      __param18(2, IThemeService)
    ], ColorHoverParticipant);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverOperation.js
var HoverOperation;
var init_hoverOperation = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverOperation.js"() {
    init_async();
    init_errors();
    HoverOperation = class {
      constructor(computer, success, error, progress, hoverTime) {
        this._computer = computer;
        this._state = 0;
        this._hoverTime = hoverTime;
        this._firstWaitScheduler = new RunOnceScheduler(() => this._triggerAsyncComputation(), 0);
        this._secondWaitScheduler = new RunOnceScheduler(() => this._triggerSyncComputation(), 0);
        this._loadingMessageScheduler = new RunOnceScheduler(() => this._showLoadingMessage(), 0);
        this._asyncComputationPromise = null;
        this._asyncComputationPromiseDone = false;
        this._completeCallback = success;
        this._errorCallback = error;
        this._progressCallback = progress;
      }
      setHoverTime(hoverTime) {
        this._hoverTime = hoverTime;
      }
      _firstWaitTime() {
        return this._hoverTime / 2;
      }
      _secondWaitTime() {
        return this._hoverTime / 2;
      }
      _loadingMessageTime() {
        return 3 * this._hoverTime;
      }
      _triggerAsyncComputation() {
        this._state = 2;
        this._secondWaitScheduler.schedule(this._secondWaitTime());
        if (this._computer.computeAsync) {
          this._asyncComputationPromiseDone = false;
          this._asyncComputationPromise = createCancelablePromise((token) => this._computer.computeAsync(token));
          this._asyncComputationPromise.then((asyncResult) => {
            this._asyncComputationPromiseDone = true;
            this._withAsyncResult(asyncResult);
          }, (e) => this._onError(e));
        } else {
          this._asyncComputationPromiseDone = true;
        }
      }
      _triggerSyncComputation() {
        if (this._computer.computeSync) {
          this._computer.onResult(this._computer.computeSync(), true);
        }
        if (this._asyncComputationPromiseDone) {
          this._state = 0;
          this._onComplete(this._computer.getResult());
        } else {
          this._state = 3;
          this._onProgress(this._computer.getResult());
        }
      }
      _showLoadingMessage() {
        if (this._state === 3) {
          this._onProgress(this._computer.getResultWithLoadingMessage());
        }
      }
      _withAsyncResult(asyncResult) {
        if (asyncResult) {
          this._computer.onResult(asyncResult, false);
        }
        if (this._state === 3) {
          this._state = 0;
          this._onComplete(this._computer.getResult());
        }
      }
      _onComplete(value) {
        this._completeCallback(value);
      }
      _onError(error) {
        if (this._errorCallback) {
          this._errorCallback(error);
        } else {
          onUnexpectedError(error);
        }
      }
      _onProgress(value) {
        this._progressCallback(value);
      }
      start(mode) {
        if (mode === 0) {
          if (this._state === 0) {
            this._state = 1;
            this._firstWaitScheduler.schedule(this._firstWaitTime());
            this._loadingMessageScheduler.schedule(this._loadingMessageTime());
          }
        } else {
          switch (this._state) {
            case 0:
              this._triggerAsyncComputation();
              this._secondWaitScheduler.cancel();
              this._triggerSyncComputation();
              break;
            case 2:
              this._secondWaitScheduler.cancel();
              this._triggerSyncComputation();
              break;
          }
        }
      }
      cancel() {
        this._loadingMessageScheduler.cancel();
        if (this._state === 1) {
          this._firstWaitScheduler.cancel();
        }
        if (this._state === 2) {
          this._secondWaitScheduler.cancel();
          if (this._asyncComputationPromise) {
            this._asyncComputationPromise.cancel();
            this._asyncComputationPromise = null;
          }
        }
        if (this._state === 3) {
          if (this._asyncComputationPromise) {
            this._asyncComputationPromise.cancel();
            this._asyncComputationPromise = null;
          }
        }
        this._state = 0;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverTypes.js
var HoverRangeAnchor, HoverForeignElementAnchor;
var init_hoverTypes = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverTypes.js"() {
    HoverRangeAnchor = class {
      constructor(priority, range) {
        this.priority = priority;
        this.range = range;
        this.type = 1;
      }
      equals(other) {
        return other.type === 1 && this.range.equalsRange(other.range);
      }
      canAdoptVisibleHover(lastAnchor, showAtPosition) {
        return lastAnchor.type === 1 && showAtPosition.lineNumber === this.range.startLineNumber;
      }
    };
    HoverForeignElementAnchor = class {
      constructor(priority, owner, range) {
        this.priority = priority;
        this.owner = owner;
        this.range = range;
        this.type = 2;
      }
      equals(other) {
        return other.type === 2 && this.owner === other.owner;
      }
      canAdoptVisibleHover(lastAnchor, showAtPosition) {
        return lastAnchor.type === 2 && this.owner === lastAnchor.owner;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/dompurify/dompurify.js
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array) {
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === "string") {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function clone(object) {
  var newObject = create(null);
  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
function _toConsumableArray$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root) {
    return createDOMPurify(root);
  };
  DOMPurify.version = "2.3.1";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node = window2.Node, Element = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, Text2 = window2.Text, Comment = window2.Comment, DOMParser = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_DOM_IMPORT = true;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_2) {
        node.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc = void 0;
    var leadingWhitespace = void 0;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, "text/html");
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  var _isClobbered = function _isClobbered2(elm) {
    if (elm instanceof Text2 || elm instanceof Comment) {
      return false;
    }
    if (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function") {
      return true;
    }
    return false;
  };
  var _isNode = function _isNode2(object) {
    return (typeof Node === "undefined" ? "undefined" : _typeof(Node)) === "object" ? object instanceof Node : object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content = void 0;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = stringToLowerCase(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, " ");
      content = stringReplace(content, ERB_EXPR$$1, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      return false;
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ""))) ;
    else if (!value) ;
    else {
      return false;
    }
    return true;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = stringTrim(attr.value);
      lcName = stringToLowerCase(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
        value = stringReplace(value, ERB_EXPR$$1, " ");
      }
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) ;
    else if (dirty instanceof Node) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : emptyHTML;
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (RETURN_DOM_IMPORT) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = stringToLowerCase(tag);
    var lcName = stringToLowerCase(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var hasOwnProperty, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor, freeze, seal, create, _ref, apply, construct, arrayForEach, arrayPop, arrayPush, stringToLowerCase, stringMatch, stringReplace, stringIndexOf, stringTrim, regExpTest, typeErrorCreate, html, svg, svgFilters, svgDisallowed, mathMl, mathMlDisallowed, text, html$1, svg$1, mathMl$1, xml, MUSTACHE_EXPR, ERB_EXPR, DATA_ATTR, ARIA_ATTR, IS_ALLOWED_URI, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, _typeof, getGlobal, _createTrustedTypesPolicy, purify;
var init_dompurify = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/dompurify/dompurify.js"() {
    hasOwnProperty = Object.hasOwnProperty;
    setPrototypeOf = Object.setPrototypeOf;
    isFrozen = Object.isFrozen;
    getPrototypeOf = Object.getPrototypeOf;
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    freeze = Object.freeze;
    seal = Object.seal;
    create = Object.create;
    _ref = typeof Reflect !== "undefined" && Reflect;
    apply = _ref.apply;
    construct = _ref.construct;
    if (!apply) {
      apply = function apply2(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!freeze) {
      freeze = function freeze2(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal2(x) {
        return x;
      };
    }
    if (!construct) {
      construct = function construct2(Func, args) {
        return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
      };
    }
    arrayForEach = unapply(Array.prototype.forEach);
    arrayPop = unapply(Array.prototype.pop);
    arrayPush = unapply(Array.prototype.push);
    stringToLowerCase = unapply(String.prototype.toLowerCase);
    stringMatch = unapply(String.prototype.match);
    stringReplace = unapply(String.prototype.replace);
    stringIndexOf = unapply(String.prototype.indexOf);
    stringTrim = unapply(String.prototype.trim);
    regExpTest = unapply(RegExp.prototype.test);
    typeErrorCreate = unconstruct(TypeError);
    html = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
    svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
    svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
    svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
    mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
    mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
    text = freeze(["#text"]);
    html$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
    svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
    mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
    xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
    MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
    ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
    DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
    ARIA_ATTR = seal(/^aria-[\-\w]+$/);
    IS_ALLOWED_URI = seal(
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      // eslint-disable-line no-useless-escape
    );
    IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    ATTR_WHITESPACE = seal(
      /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      // eslint-disable-line no-control-regex
    );
    _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    getGlobal = function getGlobal2() {
      return typeof window === "undefined" ? null : window;
    };
    _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
      if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
        return null;
      }
      var suffix = null;
      var ATTR_NAME = "data-tt-policy-suffix";
      if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document2.currentScript.getAttribute(ATTR_NAME);
      }
      var policyName = "dompurify" + (suffix ? "#" + suffix : "");
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html$$1) {
            return html$$1;
          }
        });
      } catch (_) {
        console.warn("TrustedTypes policy " + policyName + " could not be created.");
        return null;
      }
    };
    purify = createDOMPurify();
  }
});

// node_modules/monaco-editor/esm/vs/base/common/marked/marked.js
var __marked_exports, Parser, parser, Renderer, TextRenderer, Lexer, lexer, Tokenizer, Slugger, parse2;
var init_marked = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/marked/marked.js"() {
    (function() {
      function define2(factory) {
        __marked_exports = factory();
      }
      define2.amd = true;
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define2 === "function" && define2.amd ? define2(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.marked = factory());
      })(this, (function() {
        "use strict";
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === "string") return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor) n = o.constructor.name;
          if (n === "Map" || n === "Set") return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
          return arr2;
        }
        function _createForOfIteratorHelperLoose(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (it) return (it = it.call(o)).next.bind(it);
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            return function() {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var defaults$5 = { exports: {} };
        function getDefaults$1() {
          return {
            baseUrl: null,
            breaks: false,
            extensions: null,
            gfm: true,
            headerIds: true,
            headerPrefix: "",
            highlight: null,
            langPrefix: "language-",
            mangle: true,
            pedantic: false,
            renderer: null,
            sanitize: false,
            sanitizer: null,
            silent: false,
            smartLists: false,
            smartypants: false,
            tokenizer: null,
            walkTokens: null,
            xhtml: false
          };
        }
        function changeDefaults$1(newDefaults) {
          defaults$5.exports.defaults = newDefaults;
        }
        defaults$5.exports = {
          defaults: getDefaults$1(),
          getDefaults: getDefaults$1,
          changeDefaults: changeDefaults$1
        };
        var escapeTest = /[&<>"']/;
        var escapeReplace = /[&<>"']/g;
        var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
        var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
        var escapeReplacements = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var getEscapeReplacement = function getEscapeReplacement2(ch) {
          return escapeReplacements[ch];
        };
        function escape$2(html2, encode) {
          if (encode) {
            if (escapeTest.test(html2)) {
              return html2.replace(escapeReplace, getEscapeReplacement);
            }
          } else {
            if (escapeTestNoEncode.test(html2)) {
              return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
            }
          }
          return html2;
        }
        var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
        function unescape$1(html2) {
          return html2.replace(unescapeTest, function(_, n) {
            n = n.toLowerCase();
            if (n === "colon") return ":";
            if (n.charAt(0) === "#") {
              return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
            }
            return "";
          });
        }
        var caret = /(^|[^\[])\^/g;
        function edit$1(regex, opt) {
          regex = regex.source || regex;
          opt = opt || "";
          var obj = {
            replace: function replace(name, val) {
              val = val.source || val;
              val = val.replace(caret, "$1");
              regex = regex.replace(name, val);
              return obj;
            },
            getRegex: function getRegex() {
              return new RegExp(regex, opt);
            }
          };
          return obj;
        }
        var nonWordAndColonTest = /[^\w:]/g;
        var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
        function cleanUrl$1(sanitize2, base, href) {
          if (sanitize2) {
            var prot;
            try {
              prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
            } catch (e) {
              return null;
            }
            if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
              return null;
            }
          }
          if (base && !originIndependentUrl.test(href)) {
            href = resolveUrl(base, href);
          }
          try {
            href = encodeURI(href).replace(/%25/g, "%");
          } catch (e) {
            return null;
          }
          return href;
        }
        var baseUrls = {};
        var justDomain = /^[^:]+:\/*[^/]*$/;
        var protocol = /^([^:]+:)[\s\S]*$/;
        var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
        function resolveUrl(base, href) {
          if (!baseUrls[" " + base]) {
            if (justDomain.test(base)) {
              baseUrls[" " + base] = base + "/";
            } else {
              baseUrls[" " + base] = rtrim$1(base, "/", true);
            }
          }
          base = baseUrls[" " + base];
          var relativeBase = base.indexOf(":") === -1;
          if (href.substring(0, 2) === "//") {
            if (relativeBase) {
              return href;
            }
            return base.replace(protocol, "$1") + href;
          } else if (href.charAt(0) === "/") {
            if (relativeBase) {
              return href;
            }
            return base.replace(domain, "$1") + href;
          } else {
            return base + href;
          }
        }
        var noopTest$1 = {
          exec: function noopTest2() {
          }
        };
        function merge$2(obj) {
          var i = 1, target, key;
          for (; i < arguments.length; i++) {
            target = arguments[i];
            for (key in target) {
              if (Object.prototype.hasOwnProperty.call(target, key)) {
                obj[key] = target[key];
              }
            }
          }
          return obj;
        }
        function splitCells$1(tableRow, count) {
          var row = tableRow.replace(/\|/g, function(match, offset, str) {
            var escaped = false, curr = offset;
            while (--curr >= 0 && str[curr] === "\\") {
              escaped = !escaped;
            }
            if (escaped) {
              return "|";
            } else {
              return " |";
            }
          }), cells = row.split(/ \|/);
          var i = 0;
          if (!cells[0].trim()) {
            cells.shift();
          }
          if (!cells[cells.length - 1].trim()) {
            cells.pop();
          }
          if (cells.length > count) {
            cells.splice(count);
          } else {
            while (cells.length < count) {
              cells.push("");
            }
          }
          for (; i < cells.length; i++) {
            cells[i] = cells[i].trim().replace(/\\\|/g, "|");
          }
          return cells;
        }
        function rtrim$1(str, c, invert) {
          var l = str.length;
          if (l === 0) {
            return "";
          }
          var suffLen = 0;
          while (suffLen < l) {
            var currChar = str.charAt(l - suffLen - 1);
            if (currChar === c && !invert) {
              suffLen++;
            } else if (currChar !== c && invert) {
              suffLen++;
            } else {
              break;
            }
          }
          return str.substr(0, l - suffLen);
        }
        function findClosingBracket$1(str, b) {
          if (str.indexOf(b[1]) === -1) {
            return -1;
          }
          var l = str.length;
          var level = 0, i = 0;
          for (; i < l; i++) {
            if (str[i] === "\\") {
              i++;
            } else if (str[i] === b[0]) {
              level++;
            } else if (str[i] === b[1]) {
              level--;
              if (level < 0) {
                return i;
              }
            }
          }
          return -1;
        }
        function checkSanitizeDeprecation$1(opt) {
          if (opt && opt.sanitize && !opt.silent) {
            console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
          }
        }
        function repeatString$1(pattern, count) {
          if (count < 1) {
            return "";
          }
          var result = "";
          while (count > 1) {
            if (count & 1) {
              result += pattern;
            }
            count >>= 1;
            pattern += pattern;
          }
          return result + pattern;
        }
        var helpers = {
          escape: escape$2,
          unescape: unescape$1,
          edit: edit$1,
          cleanUrl: cleanUrl$1,
          resolveUrl,
          noopTest: noopTest$1,
          merge: merge$2,
          splitCells: splitCells$1,
          rtrim: rtrim$1,
          findClosingBracket: findClosingBracket$1,
          checkSanitizeDeprecation: checkSanitizeDeprecation$1,
          repeatString: repeatString$1
        };
        var defaults$4 = defaults$5.exports.defaults;
        var rtrim = helpers.rtrim, splitCells = helpers.splitCells, _escape = helpers.escape, findClosingBracket = helpers.findClosingBracket;
        function outputLink(cap, link, raw, lexer2) {
          var href = link.href;
          var title = link.title ? _escape(link.title) : null;
          var text2 = cap[1].replace(/\\([\[\]])/g, "$1");
          if (cap[0].charAt(0) !== "!") {
            lexer2.state.inLink = true;
            var token = {
              type: "link",
              raw,
              href,
              title,
              text: text2,
              tokens: lexer2.inlineTokens(text2, [])
            };
            lexer2.state.inLink = false;
            return token;
          } else {
            return {
              type: "image",
              raw,
              href,
              title,
              text: _escape(text2)
            };
          }
        }
        function indentCodeCompensation(raw, text2) {
          var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
          if (matchIndentToCode === null) {
            return text2;
          }
          var indentToCode = matchIndentToCode[1];
          return text2.split("\n").map(function(node) {
            var matchIndentInNode = node.match(/^\s+/);
            if (matchIndentInNode === null) {
              return node;
            }
            var indentInNode = matchIndentInNode[0];
            if (indentInNode.length >= indentToCode.length) {
              return node.slice(indentToCode.length);
            }
            return node;
          }).join("\n");
        }
        var Tokenizer_1 = /* @__PURE__ */ (function() {
          function Tokenizer3(options) {
            this.options = options || defaults$4;
          }
          var _proto = Tokenizer3.prototype;
          _proto.space = function space(src) {
            var cap = this.rules.block.newline.exec(src);
            if (cap) {
              if (cap[0].length > 1) {
                return {
                  type: "space",
                  raw: cap[0]
                };
              }
              return {
                raw: "\n"
              };
            }
          };
          _proto.code = function code(src) {
            var cap = this.rules.block.code.exec(src);
            if (cap) {
              var text2 = cap[0].replace(/^ {1,4}/gm, "");
              return {
                type: "code",
                raw: cap[0],
                codeBlockStyle: "indented",
                text: !this.options.pedantic ? rtrim(text2, "\n") : text2
              };
            }
          };
          _proto.fences = function fences(src) {
            var cap = this.rules.block.fences.exec(src);
            if (cap) {
              var raw = cap[0];
              var text2 = indentCodeCompensation(raw, cap[3] || "");
              return {
                type: "code",
                raw,
                lang: cap[2] ? cap[2].trim() : cap[2],
                text: text2
              };
            }
          };
          _proto.heading = function heading(src) {
            var cap = this.rules.block.heading.exec(src);
            if (cap) {
              var text2 = cap[2].trim();
              if (/#$/.test(text2)) {
                var trimmed = rtrim(text2, "#");
                if (this.options.pedantic) {
                  text2 = trimmed.trim();
                } else if (!trimmed || / $/.test(trimmed)) {
                  text2 = trimmed.trim();
                }
              }
              var token = {
                type: "heading",
                raw: cap[0],
                depth: cap[1].length,
                text: text2,
                tokens: []
              };
              this.lexer.inline(token.text, token.tokens);
              return token;
            }
          };
          _proto.hr = function hr(src) {
            var cap = this.rules.block.hr.exec(src);
            if (cap) {
              return {
                type: "hr",
                raw: cap[0]
              };
            }
          };
          _proto.blockquote = function blockquote(src) {
            var cap = this.rules.block.blockquote.exec(src);
            if (cap) {
              var text2 = cap[0].replace(/^ *> ?/gm, "");
              return {
                type: "blockquote",
                raw: cap[0],
                tokens: this.lexer.blockTokens(text2, []),
                text: text2
              };
            }
          };
          _proto.list = function list(src) {
            var cap = this.rules.block.list.exec(src);
            if (cap) {
              var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, lines, itemContents;
              var bull = cap[1].trim();
              var isordered = bull.length > 1;
              var list2 = {
                type: "list",
                raw: "",
                ordered: isordered,
                start: isordered ? +bull.slice(0, -1) : "",
                loose: false,
                items: []
              };
              bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
              if (this.options.pedantic) {
                bull = isordered ? bull : "[*+-]";
              }
              var itemRegex = new RegExp("^( {0,3}" + bull + ")((?: [^\\n]*| *)(?:\\n[^\\n]*)*(?:\\n|$))");
              while (src) {
                if (this.rules.block.hr.test(src)) {
                  break;
                }
                if (!(cap = itemRegex.exec(src))) {
                  break;
                }
                lines = cap[2].split("\n");
                if (this.options.pedantic) {
                  indent = 2;
                  itemContents = lines[0].trimLeft();
                } else {
                  indent = cap[2].search(/[^ ]/);
                  indent = cap[1].length + (indent > 4 ? 1 : indent);
                  itemContents = lines[0].slice(indent - cap[1].length);
                }
                blankLine = false;
                raw = cap[0];
                if (!lines[0] && /^ *$/.test(lines[1])) {
                  raw = cap[1] + lines.slice(0, 2).join("\n") + "\n";
                  list2.loose = true;
                  lines = [];
                }
                var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])");
                for (i = 1; i < lines.length; i++) {
                  line = lines[i];
                  if (this.options.pedantic) {
                    line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                  }
                  if (nextBulletRegex.test(line)) {
                    raw = cap[1] + lines.slice(0, i).join("\n") + "\n";
                    break;
                  }
                  if (!blankLine) {
                    if (!line.trim()) {
                      blankLine = true;
                    }
                    if (line.search(/[^ ]/) >= indent) {
                      itemContents += "\n" + line.slice(indent);
                    } else {
                      itemContents += "\n" + line;
                    }
                    continue;
                  }
                  if (line.search(/[^ ]/) >= indent || !line.trim()) {
                    itemContents += "\n" + line.slice(indent);
                    continue;
                  } else {
                    raw = cap[1] + lines.slice(0, i).join("\n") + "\n";
                    break;
                  }
                }
                if (!list2.loose) {
                  if (endsWithBlankLine) {
                    list2.loose = true;
                  } else if (/\n *\n *$/.test(raw)) {
                    endsWithBlankLine = true;
                  }
                }
                if (this.options.gfm) {
                  istask = /^\[[ xX]\] /.exec(itemContents);
                  if (istask) {
                    ischecked = istask[0] !== "[ ] ";
                    itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
                  }
                }
                list2.items.push({
                  type: "list_item",
                  raw,
                  task: !!istask,
                  checked: ischecked,
                  loose: false,
                  text: itemContents
                });
                list2.raw += raw;
                src = src.slice(raw.length);
              }
              list2.items[list2.items.length - 1].raw = raw.trimRight();
              list2.items[list2.items.length - 1].text = itemContents.trimRight();
              list2.raw = list2.raw.trimRight();
              var l = list2.items.length;
              for (i = 0; i < l; i++) {
                this.lexer.state.top = false;
                list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
                if (list2.items[i].tokens.some(function(t) {
                  return t.type === "space";
                })) {
                  list2.loose = true;
                  list2.items[i].loose = true;
                }
              }
              return list2;
            }
          };
          _proto.html = function html2(src) {
            var cap = this.rules.block.html.exec(src);
            if (cap) {
              var token = {
                type: "html",
                raw: cap[0],
                pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
                text: cap[0]
              };
              if (this.options.sanitize) {
                token.type = "paragraph";
                token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]);
                token.tokens = [];
                this.lexer.inline(token.text, token.tokens);
              }
              return token;
            }
          };
          _proto.def = function def(src) {
            var cap = this.rules.block.def.exec(src);
            if (cap) {
              if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
              var tag = cap[1].toLowerCase().replace(/\s+/g, " ");
              return {
                type: "def",
                tag,
                raw: cap[0],
                href: cap[2],
                title: cap[3]
              };
            }
          };
          _proto.table = function table(src) {
            var cap = this.rules.block.table.exec(src);
            if (cap) {
              var item = {
                type: "table",
                header: splitCells(cap[1]).map(function(c) {
                  return {
                    text: c
                  };
                }),
                align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                rows: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
              };
              if (item.header.length === item.align.length) {
                item.raw = cap[0];
                var l = item.align.length;
                var i, j, k, row;
                for (i = 0; i < l; i++) {
                  if (/^ *-+: *$/.test(item.align[i])) {
                    item.align[i] = "right";
                  } else if (/^ *:-+: *$/.test(item.align[i])) {
                    item.align[i] = "center";
                  } else if (/^ *:-+ *$/.test(item.align[i])) {
                    item.align[i] = "left";
                  } else {
                    item.align[i] = null;
                  }
                }
                l = item.rows.length;
                for (i = 0; i < l; i++) {
                  item.rows[i] = splitCells(item.rows[i], item.header.length).map(function(c) {
                    return {
                      text: c
                    };
                  });
                }
                l = item.header.length;
                for (j = 0; j < l; j++) {
                  item.header[j].tokens = [];
                  this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
                }
                l = item.rows.length;
                for (j = 0; j < l; j++) {
                  row = item.rows[j];
                  for (k = 0; k < row.length; k++) {
                    row[k].tokens = [];
                    this.lexer.inlineTokens(row[k].text, row[k].tokens);
                  }
                }
                return item;
              }
            }
          };
          _proto.lheading = function lheading(src) {
            var cap = this.rules.block.lheading.exec(src);
            if (cap) {
              var token = {
                type: "heading",
                raw: cap[0],
                depth: cap[2].charAt(0) === "=" ? 1 : 2,
                text: cap[1],
                tokens: []
              };
              this.lexer.inline(token.text, token.tokens);
              return token;
            }
          };
          _proto.paragraph = function paragraph(src) {
            var cap = this.rules.block.paragraph.exec(src);
            if (cap) {
              var token = {
                type: "paragraph",
                raw: cap[0],
                text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
                tokens: []
              };
              this.lexer.inline(token.text, token.tokens);
              return token;
            }
          };
          _proto.text = function text2(src) {
            var cap = this.rules.block.text.exec(src);
            if (cap) {
              var token = {
                type: "text",
                raw: cap[0],
                text: cap[0],
                tokens: []
              };
              this.lexer.inline(token.text, token.tokens);
              return token;
            }
          };
          _proto.escape = function escape3(src) {
            var cap = this.rules.inline.escape.exec(src);
            if (cap) {
              return {
                type: "escape",
                raw: cap[0],
                text: _escape(cap[1])
              };
            }
          };
          _proto.tag = function tag(src) {
            var cap = this.rules.inline.tag.exec(src);
            if (cap) {
              if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
                this.lexer.state.inLink = true;
              } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
                this.lexer.state.inLink = false;
              }
              if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                this.lexer.state.inRawBlock = true;
              } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                this.lexer.state.inRawBlock = false;
              }
              return {
                type: this.options.sanitize ? "text" : "html",
                raw: cap[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
              };
            }
          };
          _proto.link = function link(src) {
            var cap = this.rules.inline.link.exec(src);
            if (cap) {
              var trimmedUrl = cap[2].trim();
              if (!this.options.pedantic && /^</.test(trimmedUrl)) {
                if (!/>$/.test(trimmedUrl)) {
                  return;
                }
                var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                  return;
                }
              } else {
                var lastParenIndex = findClosingBracket(cap[2], "()");
                if (lastParenIndex > -1) {
                  var start = cap[0].indexOf("!") === 0 ? 5 : 4;
                  var linkLen = start + cap[1].length + lastParenIndex;
                  cap[2] = cap[2].substring(0, lastParenIndex);
                  cap[0] = cap[0].substring(0, linkLen).trim();
                  cap[3] = "";
                }
              }
              var href = cap[2];
              var title = "";
              if (this.options.pedantic) {
                var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
                if (link2) {
                  href = link2[1];
                  title = link2[3];
                }
              } else {
                title = cap[3] ? cap[3].slice(1, -1) : "";
              }
              href = href.trim();
              if (/^</.test(href)) {
                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
                  href = href.slice(1);
                } else {
                  href = href.slice(1, -1);
                }
              }
              return outputLink(cap, {
                href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
                title: title ? title.replace(this.rules.inline._escapes, "$1") : title
              }, cap[0], this.lexer);
            }
          };
          _proto.reflink = function reflink(src, links) {
            var cap;
            if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
              var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
              link = links[link.toLowerCase()];
              if (!link || !link.href) {
                var text2 = cap[0].charAt(0);
                return {
                  type: "text",
                  raw: text2,
                  text: text2
                };
              }
              return outputLink(cap, link, cap[0], this.lexer);
            }
          };
          _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
            if (prevChar === void 0) {
              prevChar = "";
            }
            var match = this.rules.inline.emStrong.lDelim.exec(src);
            if (!match) return;
            if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/)) return;
            var nextChar = match[1] || match[2] || "";
            if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
              var lLength = match[0].length - 1;
              var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
              var endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
              endReg.lastIndex = 0;
              maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
              while ((match = endReg.exec(maskedSrc)) != null) {
                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                if (!rDelim) continue;
                rLength = rDelim.length;
                if (match[3] || match[4]) {
                  delimTotal += rLength;
                  continue;
                } else if (match[5] || match[6]) {
                  if (lLength % 3 && !((lLength + rLength) % 3)) {
                    midDelimTotal += rLength;
                    continue;
                  }
                }
                delimTotal -= rLength;
                if (delimTotal > 0) continue;
                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
                if (Math.min(lLength, rLength) % 2) {
                  var _text = src.slice(1, lLength + match.index + rLength);
                  return {
                    type: "em",
                    raw: src.slice(0, lLength + match.index + rLength + 1),
                    text: _text,
                    tokens: this.lexer.inlineTokens(_text, [])
                  };
                }
                var text2 = src.slice(2, lLength + match.index + rLength - 1);
                return {
                  type: "strong",
                  raw: src.slice(0, lLength + match.index + rLength + 1),
                  text: text2,
                  tokens: this.lexer.inlineTokens(text2, [])
                };
              }
            }
          };
          _proto.codespan = function codespan(src) {
            var cap = this.rules.inline.code.exec(src);
            if (cap) {
              var text2 = cap[2].replace(/\n/g, " ");
              var hasNonSpaceChars = /[^ ]/.test(text2);
              var hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
              if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                text2 = text2.substring(1, text2.length - 1);
              }
              text2 = _escape(text2, true);
              return {
                type: "codespan",
                raw: cap[0],
                text: text2
              };
            }
          };
          _proto.br = function br(src) {
            var cap = this.rules.inline.br.exec(src);
            if (cap) {
              return {
                type: "br",
                raw: cap[0]
              };
            }
          };
          _proto.del = function del(src) {
            var cap = this.rules.inline.del.exec(src);
            if (cap) {
              return {
                type: "del",
                raw: cap[0],
                text: cap[2],
                tokens: this.lexer.inlineTokens(cap[2], [])
              };
            }
          };
          _proto.autolink = function autolink(src, mangle2) {
            var cap = this.rules.inline.autolink.exec(src);
            if (cap) {
              var text2, href;
              if (cap[2] === "@") {
                text2 = _escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
                href = "mailto:" + text2;
              } else {
                text2 = _escape(cap[1]);
                href = text2;
              }
              return {
                type: "link",
                raw: cap[0],
                text: text2,
                href,
                tokens: [{
                  type: "text",
                  raw: text2,
                  text: text2
                }]
              };
            }
          };
          _proto.url = function url(src, mangle2) {
            var cap;
            if (cap = this.rules.inline.url.exec(src)) {
              var text2, href;
              if (cap[2] === "@") {
                text2 = _escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
                href = "mailto:" + text2;
              } else {
                var prevCapZero;
                do {
                  prevCapZero = cap[0];
                  cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
                } while (prevCapZero !== cap[0]);
                text2 = _escape(cap[0]);
                if (cap[1] === "www.") {
                  href = "http://" + text2;
                } else {
                  href = text2;
                }
              }
              return {
                type: "link",
                raw: cap[0],
                text: text2,
                href,
                tokens: [{
                  type: "text",
                  raw: text2,
                  text: text2
                }]
              };
            }
          };
          _proto.inlineText = function inlineText(src, smartypants2) {
            var cap = this.rules.inline.text.exec(src);
            if (cap) {
              var text2;
              if (this.lexer.state.inRawBlock) {
                text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
              } else {
                text2 = _escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
              }
              return {
                type: "text",
                raw: cap[0],
                text: text2
              };
            }
          };
          return Tokenizer3;
        })();
        var noopTest = helpers.noopTest, edit = helpers.edit, merge$1 = helpers.merge;
        var block$1 = {
          newline: /^(?: *(?:\n|$))+/,
          code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
          fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
          hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
          heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
          blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
          list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
          html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
          def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
          table: noopTest,
          lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
          // regex template, placeholders will be replaced according to different paragraph
          // interruption rules of commonmark and the original markdown spec:
          _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
          text: /^[^\n]+/
        };
        block$1._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
        block$1._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
        block$1.def = edit(block$1.def).replace("label", block$1._label).replace("title", block$1._title).getRegex();
        block$1.bullet = /(?:[*+-]|\d{1,9}[.)])/;
        block$1.listItemStart = edit(/^( *)(bull) */).replace("bull", block$1.bullet).getRegex();
        block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block$1.def.source + ")").getRegex();
        block$1._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
        block$1._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
        block$1.html = edit(block$1.html, "i").replace("comment", block$1._comment).replace("tag", block$1._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
        block$1.paragraph = edit(block$1._paragraph).replace("hr", block$1.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block$1._tag).getRegex();
        block$1.blockquote = edit(block$1.blockquote).replace("paragraph", block$1.paragraph).getRegex();
        block$1.normal = merge$1({}, block$1);
        block$1.gfm = merge$1({}, block$1.normal, {
          table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)\\|?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
          // Cells
        });
        block$1.gfm.table = edit(block$1.gfm.table).replace("hr", block$1.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block$1._tag).getRegex();
        block$1.pedantic = merge$1({}, block$1.normal, {
          html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block$1._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
          heading: /^(#{1,6})(.*)(?:\n+|$)/,
          fences: noopTest,
          // fences not supported
          paragraph: edit(block$1.normal._paragraph).replace("hr", block$1.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block$1.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
        });
        var inline$1 = {
          escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
          autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
          url: noopTest,
          tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
          // CDATA section
          link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
          reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
          nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
          reflinkSearch: "reflink|nolink(?!\\()",
          emStrong: {
            lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
            //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
            //        () Skip other delimiter (1) #***                   (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
            rDelimAst: /\_\_[^_*]*?\*[^_*]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
            rDelimUnd: /\*\*[^_*]*?\_[^_*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
            // ^- Not allowed for _
          },
          code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
          br: /^( {2,}|\\)\n(?!\s*$)/,
          del: noopTest,
          text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
          punctuation: /^([\spunctuation])/
        };
        inline$1._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
        inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex();
        inline$1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
        inline$1.escapedEmSt = /\\\*|\\_/g;
        inline$1._comment = edit(block$1._comment).replace("(?:-->|$)", "-->").getRegex();
        inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();
        inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, "g").replace(/punct/g, inline$1._punctuation).getRegex();
        inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, "g").replace(/punct/g, inline$1._punctuation).getRegex();
        inline$1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
        inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
        inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
        inline$1.autolink = edit(inline$1.autolink).replace("scheme", inline$1._scheme).replace("email", inline$1._email).getRegex();
        inline$1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
        inline$1.tag = edit(inline$1.tag).replace("comment", inline$1._comment).replace("attribute", inline$1._attribute).getRegex();
        inline$1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
        inline$1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
        inline$1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
        inline$1.link = edit(inline$1.link).replace("label", inline$1._label).replace("href", inline$1._href).replace("title", inline$1._title).getRegex();
        inline$1.reflink = edit(inline$1.reflink).replace("label", inline$1._label).getRegex();
        inline$1.reflinkSearch = edit(inline$1.reflinkSearch, "g").replace("reflink", inline$1.reflink).replace("nolink", inline$1.nolink).getRegex();
        inline$1.normal = merge$1({}, inline$1);
        inline$1.pedantic = merge$1({}, inline$1.normal, {
          strong: {
            start: /^__|\*\*/,
            middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
            endAst: /\*\*(?!\*)/g,
            endUnd: /__(?!_)/g
          },
          em: {
            start: /^_|\*/,
            middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
            endAst: /\*(?!\*)/g,
            endUnd: /_(?!_)/g
          },
          link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline$1._label).getRegex(),
          reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline$1._label).getRegex()
        });
        inline$1.gfm = merge$1({}, inline$1.normal, {
          escape: edit(inline$1.escape).replace("])", "~|])").getRegex(),
          _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
          url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
          _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
          del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
          text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
        });
        inline$1.gfm.url = edit(inline$1.gfm.url, "i").replace("email", inline$1.gfm._extended_email).getRegex();
        inline$1.breaks = merge$1({}, inline$1.gfm, {
          br: edit(inline$1.br).replace("{2,}", "*").getRegex(),
          text: edit(inline$1.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
        });
        var rules = {
          block: block$1,
          inline: inline$1
        };
        var Tokenizer$1 = Tokenizer_1;
        var defaults$3 = defaults$5.exports.defaults;
        var block = rules.block, inline = rules.inline;
        var repeatString = helpers.repeatString;
        function smartypants(text2) {
          return text2.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
        }
        function mangle(text2) {
          var out = "", i, ch;
          var l = text2.length;
          for (i = 0; i < l; i++) {
            ch = text2.charCodeAt(i);
            if (Math.random() > 0.5) {
              ch = "x" + ch.toString(16);
            }
            out += "&#" + ch + ";";
          }
          return out;
        }
        var Lexer_1 = /* @__PURE__ */ (function() {
          function Lexer3(options) {
            this.tokens = [];
            this.tokens.links = /* @__PURE__ */ Object.create(null);
            this.options = options || defaults$3;
            this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();
            this.tokenizer = this.options.tokenizer;
            this.tokenizer.options = this.options;
            this.tokenizer.lexer = this;
            this.inlineQueue = [];
            this.state = {
              inLink: false,
              inRawBlock: false,
              top: true
            };
            var rules2 = {
              block: block.normal,
              inline: inline.normal
            };
            if (this.options.pedantic) {
              rules2.block = block.pedantic;
              rules2.inline = inline.pedantic;
            } else if (this.options.gfm) {
              rules2.block = block.gfm;
              if (this.options.breaks) {
                rules2.inline = inline.breaks;
              } else {
                rules2.inline = inline.gfm;
              }
            }
            this.tokenizer.rules = rules2;
          }
          Lexer3.lex = function lex(src, options) {
            var lexer2 = new Lexer3(options);
            return lexer2.lex(src);
          };
          Lexer3.lexInline = function lexInline(src, options) {
            var lexer2 = new Lexer3(options);
            return lexer2.inlineTokens(src);
          };
          var _proto = Lexer3.prototype;
          _proto.lex = function lex(src) {
            src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
            this.blockTokens(src, this.tokens);
            var next;
            while (next = this.inlineQueue.shift()) {
              this.inlineTokens(next.src, next.tokens);
            }
            return this.tokens;
          };
          _proto.blockTokens = function blockTokens(src, tokens) {
            var _this = this;
            if (tokens === void 0) {
              tokens = [];
            }
            if (this.options.pedantic) {
              src = src.replace(/^ +$/gm, "");
            }
            var token, lastToken, cutSrc, lastParagraphClipped;
            while (src) {
              if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
                if (token = extTokenizer.call({
                  lexer: _this
                }, src, tokens)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  return true;
                }
                return false;
              })) {
                continue;
              }
              if (token = this.tokenizer.space(src)) {
                src = src.substring(token.raw.length);
                if (token.type) {
                  tokens.push(token);
                }
                continue;
              }
              if (token = this.tokenizer.code(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
                  lastToken.raw += "\n" + token.raw;
                  lastToken.text += "\n" + token.text;
                  this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              if (token = this.tokenizer.fences(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.heading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.hr(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.blockquote(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.list(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.html(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.def(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
                  lastToken.raw += "\n" + token.raw;
                  lastToken.text += "\n" + token.raw;
                  this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                } else if (!this.tokens.links[token.tag]) {
                  this.tokens.links[token.tag] = {
                    href: token.href,
                    title: token.title
                  };
                }
                continue;
              }
              if (token = this.tokenizer.table(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.lheading(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              cutSrc = src;
              if (this.options.extensions && this.options.extensions.startBlock) {
                (function() {
                  var startIndex = Infinity;
                  var tempSrc = src.slice(1);
                  var tempStart = void 0;
                  _this.options.extensions.startBlock.forEach(function(getStartIndex) {
                    tempStart = getStartIndex.call({
                      lexer: this
                    }, tempSrc);
                    if (typeof tempStart === "number" && tempStart >= 0) {
                      startIndex = Math.min(startIndex, tempStart);
                    }
                  });
                  if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                  }
                })();
              }
              if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
                lastToken = tokens[tokens.length - 1];
                if (lastParagraphClipped && lastToken.type === "paragraph") {
                  lastToken.raw += "\n" + token.raw;
                  lastToken.text += "\n" + token.text;
                  this.inlineQueue.pop();
                  this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                } else {
                  tokens.push(token);
                }
                lastParagraphClipped = cutSrc.length !== src.length;
                src = src.substring(token.raw.length);
                continue;
              }
              if (token = this.tokenizer.text(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && lastToken.type === "text") {
                  lastToken.raw += "\n" + token.raw;
                  lastToken.text += "\n" + token.text;
                  this.inlineQueue.pop();
                  this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              if (src) {
                var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
                if (this.options.silent) {
                  console.error(errMsg);
                  break;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
            this.state.top = true;
            return tokens;
          };
          _proto.inline = function inline2(src, tokens) {
            this.inlineQueue.push({
              src,
              tokens
            });
          };
          _proto.inlineTokens = function inlineTokens(src, tokens) {
            var _this2 = this;
            if (tokens === void 0) {
              tokens = [];
            }
            var token, lastToken, cutSrc;
            var maskedSrc = src;
            var match;
            var keepPrevChar, prevChar;
            if (this.tokens.links) {
              var links = Object.keys(this.tokens.links);
              if (links.length > 0) {
                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                  if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                    maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                  }
                }
              }
            }
            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            }
            while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
            }
            while (src) {
              if (!keepPrevChar) {
                prevChar = "";
              }
              keepPrevChar = false;
              if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
                if (token = extTokenizer.call({
                  lexer: _this2
                }, src, tokens)) {
                  src = src.substring(token.raw.length);
                  tokens.push(token);
                  return true;
                }
                return false;
              })) {
                continue;
              }
              if (token = this.tokenizer.escape(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.tag(src)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && token.type === "text" && lastToken.type === "text") {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              if (token = this.tokenizer.link(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.reflink(src, this.tokens.links)) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];
                if (lastToken && token.type === "text" && lastToken.type === "text") {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.codespan(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.br(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.del(src)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (token = this.tokenizer.autolink(src, mangle)) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              }
              cutSrc = src;
              if (this.options.extensions && this.options.extensions.startInline) {
                (function() {
                  var startIndex = Infinity;
                  var tempSrc = src.slice(1);
                  var tempStart = void 0;
                  _this2.options.extensions.startInline.forEach(function(getStartIndex) {
                    tempStart = getStartIndex.call({
                      lexer: this
                    }, tempSrc);
                    if (typeof tempStart === "number" && tempStart >= 0) {
                      startIndex = Math.min(startIndex, tempStart);
                    }
                  });
                  if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                  }
                })();
              }
              if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
                src = src.substring(token.raw.length);
                if (token.raw.slice(-1) !== "_") {
                  prevChar = token.raw.slice(-1);
                }
                keepPrevChar = true;
                lastToken = tokens[tokens.length - 1];
                if (lastToken && lastToken.type === "text") {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }
                continue;
              }
              if (src) {
                var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
                if (this.options.silent) {
                  console.error(errMsg);
                  break;
                } else {
                  throw new Error(errMsg);
                }
              }
            }
            return tokens;
          };
          _createClass(Lexer3, null, [{
            key: "rules",
            get: function get() {
              return {
                block,
                inline
              };
            }
          }]);
          return Lexer3;
        })();
        var defaults$2 = defaults$5.exports.defaults;
        var cleanUrl = helpers.cleanUrl, escape$1 = helpers.escape;
        var Renderer_1 = /* @__PURE__ */ (function() {
          function Renderer3(options) {
            this.options = options || defaults$2;
          }
          var _proto = Renderer3.prototype;
          _proto.code = function code(_code, infostring, escaped) {
            var lang = (infostring || "").match(/\S*/)[0];
            if (this.options.highlight) {
              var out = this.options.highlight(_code, lang);
              if (out != null && out !== _code) {
                escaped = true;
                _code = out;
              }
            }
            _code = _code.replace(/\n$/, "") + "\n";
            if (!lang) {
              return "<pre><code>" + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
            }
            return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
          };
          _proto.blockquote = function blockquote(quote) {
            return "<blockquote>\n" + quote + "</blockquote>\n";
          };
          _proto.html = function html2(_html) {
            return _html;
          };
          _proto.heading = function heading(text2, level, raw, slugger) {
            if (this.options.headerIds) {
              return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text2 + "</h" + level + ">\n";
            }
            return "<h" + level + ">" + text2 + "</h" + level + ">\n";
          };
          _proto.hr = function hr() {
            return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
          };
          _proto.list = function list(body, ordered, start) {
            var type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
            return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
          };
          _proto.listitem = function listitem(text2) {
            return "<li>" + text2 + "</li>\n";
          };
          _proto.checkbox = function checkbox(checked) {
            return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
          };
          _proto.paragraph = function paragraph(text2) {
            return "<p>" + text2 + "</p>\n";
          };
          _proto.table = function table(header, body) {
            if (body) body = "<tbody>" + body + "</tbody>";
            return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
          };
          _proto.tablerow = function tablerow(content) {
            return "<tr>\n" + content + "</tr>\n";
          };
          _proto.tablecell = function tablecell(content, flags) {
            var type = flags.header ? "th" : "td";
            var tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
            return tag + content + "</" + type + ">\n";
          };
          _proto.strong = function strong(text2) {
            return "<strong>" + text2 + "</strong>";
          };
          _proto.em = function em(text2) {
            return "<em>" + text2 + "</em>";
          };
          _proto.codespan = function codespan(text2) {
            return "<code>" + text2 + "</code>";
          };
          _proto.br = function br() {
            return this.options.xhtml ? "<br/>" : "<br>";
          };
          _proto.del = function del(text2) {
            return "<del>" + text2 + "</del>";
          };
          _proto.link = function link(href, title, text2) {
            href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
            if (href === null) {
              return text2;
            }
            var out = '<a href="' + escape$1(href) + '"';
            if (title) {
              out += ' title="' + title + '"';
            }
            out += ">" + text2 + "</a>";
            return out;
          };
          _proto.image = function image(href, title, text2) {
            href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
            if (href === null) {
              return text2;
            }
            var out = '<img src="' + href + '" alt="' + text2 + '"';
            if (title) {
              out += ' title="' + title + '"';
            }
            out += this.options.xhtml ? "/>" : ">";
            return out;
          };
          _proto.text = function text2(_text) {
            return _text;
          };
          return Renderer3;
        })();
        var TextRenderer_1 = /* @__PURE__ */ (function() {
          function TextRenderer3() {
          }
          var _proto = TextRenderer3.prototype;
          _proto.strong = function strong(text2) {
            return text2;
          };
          _proto.em = function em(text2) {
            return text2;
          };
          _proto.codespan = function codespan(text2) {
            return text2;
          };
          _proto.del = function del(text2) {
            return text2;
          };
          _proto.html = function html2(text2) {
            return text2;
          };
          _proto.text = function text2(_text) {
            return _text;
          };
          _proto.link = function link(href, title, text2) {
            return "" + text2;
          };
          _proto.image = function image(href, title, text2) {
            return "" + text2;
          };
          _proto.br = function br() {
            return "";
          };
          return TextRenderer3;
        })();
        var Slugger_1 = /* @__PURE__ */ (function() {
          function Slugger3() {
            this.seen = {};
          }
          var _proto = Slugger3.prototype;
          _proto.serialize = function serialize(value) {
            return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
          };
          _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
            var slug = originalSlug;
            var occurenceAccumulator = 0;
            if (this.seen.hasOwnProperty(slug)) {
              occurenceAccumulator = this.seen[originalSlug];
              do {
                occurenceAccumulator++;
                slug = originalSlug + "-" + occurenceAccumulator;
              } while (this.seen.hasOwnProperty(slug));
            }
            if (!isDryRun) {
              this.seen[originalSlug] = occurenceAccumulator;
              this.seen[slug] = 0;
            }
            return slug;
          };
          _proto.slug = function slug(value, options) {
            if (options === void 0) {
              options = {};
            }
            var slug2 = this.serialize(value);
            return this.getNextSafeSlug(slug2, options.dryrun);
          };
          return Slugger3;
        })();
        var Renderer$1 = Renderer_1;
        var TextRenderer$1 = TextRenderer_1;
        var Slugger$1 = Slugger_1;
        var defaults$1 = defaults$5.exports.defaults;
        var unescape = helpers.unescape;
        var Parser_1 = /* @__PURE__ */ (function() {
          function Parser3(options) {
            this.options = options || defaults$1;
            this.options.renderer = this.options.renderer || new Renderer$1();
            this.renderer = this.options.renderer;
            this.renderer.options = this.options;
            this.textRenderer = new TextRenderer$1();
            this.slugger = new Slugger$1();
          }
          Parser3.parse = function parse3(tokens, options) {
            var parser2 = new Parser3(options);
            return parser2.parse(tokens);
          };
          Parser3.parseInline = function parseInline(tokens, options) {
            var parser2 = new Parser3(options);
            return parser2.parseInline(tokens);
          };
          var _proto = Parser3.prototype;
          _proto.parse = function parse3(tokens, top) {
            if (top === void 0) {
              top = true;
            }
            var out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
            var l = tokens.length;
            for (i = 0; i < l; i++) {
              token = tokens[i];
              if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                ret = this.options.extensions.renderers[token.type].call({
                  parser: this
                }, token);
                if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
                  out += ret || "";
                  continue;
                }
              }
              switch (token.type) {
                case "space": {
                  continue;
                }
                case "hr": {
                  out += this.renderer.hr();
                  continue;
                }
                case "heading": {
                  out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
                  continue;
                }
                case "code": {
                  out += this.renderer.code(token.text, token.lang, token.escaped);
                  continue;
                }
                case "table": {
                  header = "";
                  cell = "";
                  l2 = token.header.length;
                  for (j = 0; j < l2; j++) {
                    cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                      header: true,
                      align: token.align[j]
                    });
                  }
                  header += this.renderer.tablerow(cell);
                  body = "";
                  l2 = token.rows.length;
                  for (j = 0; j < l2; j++) {
                    row = token.rows[j];
                    cell = "";
                    l3 = row.length;
                    for (k = 0; k < l3; k++) {
                      cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                        header: false,
                        align: token.align[k]
                      });
                    }
                    body += this.renderer.tablerow(cell);
                  }
                  out += this.renderer.table(header, body);
                  continue;
                }
                case "blockquote": {
                  body = this.parse(token.tokens);
                  out += this.renderer.blockquote(body);
                  continue;
                }
                case "list": {
                  ordered = token.ordered;
                  start = token.start;
                  loose = token.loose;
                  l2 = token.items.length;
                  body = "";
                  for (j = 0; j < l2; j++) {
                    item = token.items[j];
                    checked = item.checked;
                    task = item.task;
                    itemBody = "";
                    if (item.task) {
                      checkbox = this.renderer.checkbox(checked);
                      if (loose) {
                        if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                          item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                            item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                          }
                        } else {
                          item.tokens.unshift({
                            type: "text",
                            text: checkbox
                          });
                        }
                      } else {
                        itemBody += checkbox;
                      }
                    }
                    itemBody += this.parse(item.tokens, loose);
                    body += this.renderer.listitem(itemBody, task, checked);
                  }
                  out += this.renderer.list(body, ordered, start);
                  continue;
                }
                case "html": {
                  out += this.renderer.html(token.text);
                  continue;
                }
                case "paragraph": {
                  out += this.renderer.paragraph(this.parseInline(token.tokens));
                  continue;
                }
                case "text": {
                  body = token.tokens ? this.parseInline(token.tokens) : token.text;
                  while (i + 1 < l && tokens[i + 1].type === "text") {
                    token = tokens[++i];
                    body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
                  }
                  out += top ? this.renderer.paragraph(body) : body;
                  continue;
                }
                default: {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';
                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
              }
            }
            return out;
          };
          _proto.parseInline = function parseInline(tokens, renderer) {
            renderer = renderer || this.renderer;
            var out = "", i, token, ret;
            var l = tokens.length;
            for (i = 0; i < l; i++) {
              token = tokens[i];
              if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                ret = this.options.extensions.renderers[token.type].call({
                  parser: this
                }, token);
                if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
                  out += ret || "";
                  continue;
                }
              }
              switch (token.type) {
                case "escape": {
                  out += renderer.text(token.text);
                  break;
                }
                case "html": {
                  out += renderer.html(token.text);
                  break;
                }
                case "link": {
                  out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
                  break;
                }
                case "image": {
                  out += renderer.image(token.href, token.title, token.text);
                  break;
                }
                case "strong": {
                  out += renderer.strong(this.parseInline(token.tokens, renderer));
                  break;
                }
                case "em": {
                  out += renderer.em(this.parseInline(token.tokens, renderer));
                  break;
                }
                case "codespan": {
                  out += renderer.codespan(token.text);
                  break;
                }
                case "br": {
                  out += renderer.br();
                  break;
                }
                case "del": {
                  out += renderer.del(this.parseInline(token.tokens, renderer));
                  break;
                }
                case "text": {
                  out += renderer.text(token.text);
                  break;
                }
                default: {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';
                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
              }
            }
            return out;
          };
          return Parser3;
        })();
        var Lexer2 = Lexer_1;
        var Parser2 = Parser_1;
        var Tokenizer2 = Tokenizer_1;
        var Renderer2 = Renderer_1;
        var TextRenderer2 = TextRenderer_1;
        var Slugger2 = Slugger_1;
        var merge = helpers.merge, checkSanitizeDeprecation = helpers.checkSanitizeDeprecation, escape2 = helpers.escape;
        var getDefaults = defaults$5.exports.getDefaults, changeDefaults = defaults$5.exports.changeDefaults, defaults = defaults$5.exports.defaults;
        function marked(src, opt, callback) {
          if (typeof src === "undefined" || src === null) {
            throw new Error("marked(): input parameter is undefined or null");
          }
          if (typeof src !== "string") {
            throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
          }
          if (typeof opt === "function") {
            callback = opt;
            opt = null;
          }
          opt = merge({}, marked.defaults, opt || {});
          checkSanitizeDeprecation(opt);
          if (callback) {
            var highlight = opt.highlight;
            var tokens;
            try {
              tokens = Lexer2.lex(src, opt);
            } catch (e) {
              return callback(e);
            }
            var done = function done2(err) {
              var out;
              if (!err) {
                try {
                  if (opt.walkTokens) {
                    marked.walkTokens(tokens, opt.walkTokens);
                  }
                  out = Parser2.parse(tokens, opt);
                } catch (e) {
                  err = e;
                }
              }
              opt.highlight = highlight;
              return err ? callback(err) : callback(null, out);
            };
            if (!highlight || highlight.length < 3) {
              return done();
            }
            delete opt.highlight;
            if (!tokens.length) return done();
            var pending = 0;
            marked.walkTokens(tokens, function(token) {
              if (token.type === "code") {
                pending++;
                setTimeout(function() {
                  highlight(token.text, token.lang, function(err, code) {
                    if (err) {
                      return done(err);
                    }
                    if (code != null && code !== token.text) {
                      token.text = code;
                      token.escaped = true;
                    }
                    pending--;
                    if (pending === 0) {
                      done();
                    }
                  });
                }, 0);
              }
            });
            if (pending === 0) {
              done();
            }
            return;
          }
          try {
            var _tokens = Lexer2.lex(src, opt);
            if (opt.walkTokens) {
              marked.walkTokens(_tokens, opt.walkTokens);
            }
            return Parser2.parse(_tokens, opt);
          } catch (e) {
            e.message += "\nPlease report this to https://github.com/markedjs/marked.";
            if (opt.silent) {
              return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
            }
            throw e;
          }
        }
        marked.options = marked.setOptions = function(opt) {
          merge(marked.defaults, opt);
          changeDefaults(marked.defaults);
          return marked;
        };
        marked.getDefaults = getDefaults;
        marked.defaults = defaults;
        marked.use = function() {
          var _this = this;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var opts = merge.apply(void 0, [{}].concat(args));
          var extensions = marked.defaults.extensions || {
            renderers: {},
            childTokens: {}
          };
          var hasExtensions;
          args.forEach(function(pack) {
            if (pack.extensions) {
              hasExtensions = true;
              pack.extensions.forEach(function(ext) {
                if (!ext.name) {
                  throw new Error("extension name required");
                }
                if (ext.renderer) {
                  var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
                  if (prevRenderer) {
                    extensions.renderers[ext.name] = function() {
                      for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        args2[_key2] = arguments[_key2];
                      }
                      var ret = ext.renderer.apply(this, args2);
                      if (ret === false) {
                        ret = prevRenderer.apply(this, args2);
                      }
                      return ret;
                    };
                  } else {
                    extensions.renderers[ext.name] = ext.renderer;
                  }
                }
                if (ext.tokenizer) {
                  if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                    throw new Error("extension level must be 'block' or 'inline'");
                  }
                  if (extensions[ext.level]) {
                    extensions[ext.level].unshift(ext.tokenizer);
                  } else {
                    extensions[ext.level] = [ext.tokenizer];
                  }
                  if (ext.start) {
                    if (ext.level === "block") {
                      if (extensions.startBlock) {
                        extensions.startBlock.push(ext.start);
                      } else {
                        extensions.startBlock = [ext.start];
                      }
                    } else if (ext.level === "inline") {
                      if (extensions.startInline) {
                        extensions.startInline.push(ext.start);
                      } else {
                        extensions.startInline = [ext.start];
                      }
                    }
                  }
                }
                if (ext.childTokens) {
                  extensions.childTokens[ext.name] = ext.childTokens;
                }
              });
            }
            if (pack.renderer) {
              (function() {
                var renderer = marked.defaults.renderer || new Renderer2();
                var _loop = function _loop2(prop2) {
                  var prevRenderer = renderer[prop2];
                  renderer[prop2] = function() {
                    for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                      args2[_key3] = arguments[_key3];
                    }
                    var ret = pack.renderer[prop2].apply(renderer, args2);
                    if (ret === false) {
                      ret = prevRenderer.apply(renderer, args2);
                    }
                    return ret;
                  };
                };
                for (var prop in pack.renderer) {
                  _loop(prop);
                }
                opts.renderer = renderer;
              })();
            }
            if (pack.tokenizer) {
              (function() {
                var tokenizer = marked.defaults.tokenizer || new Tokenizer2();
                var _loop2 = function _loop22(prop2) {
                  var prevTokenizer = tokenizer[prop2];
                  tokenizer[prop2] = function() {
                    for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                      args2[_key4] = arguments[_key4];
                    }
                    var ret = pack.tokenizer[prop2].apply(tokenizer, args2);
                    if (ret === false) {
                      ret = prevTokenizer.apply(tokenizer, args2);
                    }
                    return ret;
                  };
                };
                for (var prop in pack.tokenizer) {
                  _loop2(prop);
                }
                opts.tokenizer = tokenizer;
              })();
            }
            if (pack.walkTokens) {
              var walkTokens = marked.defaults.walkTokens;
              opts.walkTokens = function(token) {
                pack.walkTokens.call(_this, token);
                if (walkTokens) {
                  walkTokens(token);
                }
              };
            }
            if (hasExtensions) {
              opts.extensions = extensions;
            }
            marked.setOptions(opts);
          });
        };
        marked.walkTokens = function(tokens, callback) {
          var _loop3 = function _loop32() {
            var token = _step.value;
            callback(token);
            switch (token.type) {
              case "table": {
                for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done; ) {
                  var cell = _step2.value;
                  marked.walkTokens(cell.tokens, callback);
                }
                for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done; ) {
                  var row = _step3.value;
                  for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                    var _cell = _step4.value;
                    marked.walkTokens(_cell.tokens, callback);
                  }
                }
                break;
              }
              case "list": {
                marked.walkTokens(token.items, callback);
                break;
              }
              default: {
                if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
                  marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                    marked.walkTokens(token[childTokens], callback);
                  });
                } else if (token.tokens) {
                  marked.walkTokens(token.tokens, callback);
                }
              }
            }
          };
          for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
            _loop3();
          }
        };
        marked.parseInline = function(src, opt) {
          if (typeof src === "undefined" || src === null) {
            throw new Error("marked.parseInline(): input parameter is undefined or null");
          }
          if (typeof src !== "string") {
            throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
          }
          opt = merge({}, marked.defaults, opt || {});
          checkSanitizeDeprecation(opt);
          try {
            var tokens = Lexer2.lexInline(src, opt);
            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }
            return Parser2.parseInline(tokens, opt);
          } catch (e) {
            e.message += "\nPlease report this to https://github.com/markedjs/marked.";
            if (opt.silent) {
              return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
            }
            throw e;
          }
        };
        marked.Parser = Parser2;
        marked.parser = Parser2.parse;
        marked.Renderer = Renderer2;
        marked.TextRenderer = TextRenderer2;
        marked.Lexer = Lexer2;
        marked.lexer = Lexer2.lex;
        marked.Tokenizer = Tokenizer2;
        marked.Slugger = Slugger2;
        marked.parse = marked;
        var marked_1 = marked;
        return marked_1;
      }));
    })();
    Parser = __marked_exports.Parser;
    parser = __marked_exports.parser;
    Renderer = __marked_exports.Renderer;
    TextRenderer = __marked_exports.TextRenderer;
    Lexer = __marked_exports.Lexer;
    lexer = __marked_exports.lexer;
    Tokenizer = __marked_exports.Tokenizer;
    Slugger = __marked_exports.Slugger;
    parse2 = __marked_exports.parse;
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
function renderMarkdown(markdown, options = {}, markedOptions = {}) {
  var _a5;
  const disposables = new DisposableStore();
  let isDisposed = false;
  const cts = disposables.add(new CancellationTokenSource());
  const element = createElement(options);
  const _uriMassage = function(part) {
    let data;
    try {
      data = parse(decodeURIComponent(part));
    } catch (e) {
    }
    if (!data) {
      return part;
    }
    data = cloneAndChange(data, (value2) => {
      if (markdown.uris && markdown.uris[value2]) {
        return URI.revive(markdown.uris[value2]);
      } else {
        return void 0;
      }
    });
    return encodeURIComponent(JSON.stringify(data));
  };
  const _href = function(href, isDomUri) {
    const data = markdown.uris && markdown.uris[href];
    if (!data) {
      return href;
    }
    let uri = URI.revive(data);
    if (isDomUri) {
      if (href.startsWith(Schemas.data + ":")) {
        return href;
      }
      return FileAccess.asBrowserUri(uri).toString(true);
    }
    if (URI.parse(href).toString() === uri.toString()) {
      return href;
    }
    if (uri.query) {
      uri = uri.with({ query: _uriMassage(uri.query) });
    }
    return uri.toString();
  };
  let signalInnerHTML;
  const withInnerHTML = new Promise((c) => signalInnerHTML = c);
  const renderer = new Renderer();
  renderer.image = (href, title, text2) => {
    let dimensions = [];
    let attributes = [];
    if (href) {
      ({ href, dimensions } = parseHrefAndDimensions(href));
      href = _href(href, true);
      try {
        const hrefAsUri = URI.parse(href);
        if (options.baseUrl && hrefAsUri.scheme === Schemas.file) {
          href = resolvePath(options.baseUrl, href).toString();
        }
      } catch (err) {
      }
      attributes.push(`src="${href}"`);
    }
    if (text2) {
      attributes.push(`alt="${text2}"`);
    }
    if (title) {
      attributes.push(`title="${title}"`);
    }
    if (dimensions.length) {
      attributes = attributes.concat(dimensions);
    }
    return "<img " + attributes.join(" ") + ">";
  };
  renderer.link = (href, title, text2) => {
    if (href === text2) {
      text2 = removeMarkdownEscapes(text2);
    }
    href = _href(href, false);
    if (options.baseUrl) {
      const hasScheme = /^\w[\w\d+.-]*:/.test(href);
      if (!hasScheme) {
        href = resolvePath(options.baseUrl, href).toString();
      }
    }
    title = removeMarkdownEscapes(title);
    href = removeMarkdownEscapes(href);
    if (!href || href.match(/^data:|javascript:/i) || href.match(/^command:/i) && !markdown.isTrusted || href.match(/^command:(\/\/\/)?_workbench\.downloadResource/i)) {
      return text2;
    } else {
      href = href.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<a href="#" data-href="${href}" title="${title || href}">${text2}</a>`;
    }
  };
  renderer.paragraph = (text2) => {
    if (markdown.supportThemeIcons) {
      const elements = renderLabelWithIcons(text2);
      text2 = elements.map((e) => typeof e === "string" ? e : e.outerHTML).join("");
    }
    return `<p>${text2}</p>`;
  };
  if (options.codeBlockRenderer) {
    renderer.code = (code, lang) => {
      const value2 = options.codeBlockRenderer(lang, code);
      const id = defaultGenerator.nextId();
      raceCancellation(Promise.all([value2, withInnerHTML]), cts.token).then((values) => {
        var _a6;
        if (!isDisposed && values) {
          const span = element.querySelector(`div[data-code="${id}"]`);
          if (span) {
            reset(span, values[0]);
          }
          (_a6 = options.asyncRenderCallback) === null || _a6 === void 0 ? void 0 : _a6.call(options);
        }
      }).catch(() => {
      });
      return `<div class="code" data-code="${id}">${escape(code)}</div>`;
    };
  }
  if (options.actionHandler) {
    const onClick = options.actionHandler.disposables.add(new DomEmitter(element, "click"));
    const onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, "auxclick"));
    options.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)((e) => {
      const mouseEvent = new StandardMouseEvent(e);
      if (!mouseEvent.leftButton && !mouseEvent.middleButton) {
        return;
      }
      let target = mouseEvent.target;
      if (target.tagName !== "A") {
        target = target.parentElement;
        if (!target || target.tagName !== "A") {
          return;
        }
      }
      try {
        const href = target.dataset["href"];
        if (href) {
          options.actionHandler.callback(href, mouseEvent);
        }
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        mouseEvent.preventDefault();
      }
    }));
  }
  if (!markdown.supportHtml) {
    markedOptions.sanitizer = (html2) => {
      const match = markdown.isTrusted ? html2.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0;
      return match ? html2 : "";
    };
    markedOptions.sanitize = true;
    markedOptions.silent = true;
  }
  markedOptions.renderer = renderer;
  let value = (_a5 = markdown.value) !== null && _a5 !== void 0 ? _a5 : "";
  if (value.length > 1e5) {
    value = `${value.substr(0, 1e5)}\u2026`;
  }
  if (markdown.supportThemeIcons) {
    value = markdownEscapeEscapedIcons(value);
  }
  const renderedMarkdown = parse2(value, markedOptions);
  element.innerHTML = sanitizeRenderedMarkdown(markdown, renderedMarkdown);
  signalInnerHTML();
  if (options.asyncRenderCallback) {
    for (const img of element.getElementsByTagName("img")) {
      const listener = disposables.add(addDisposableListener(img, "load", () => {
        listener.dispose();
        options.asyncRenderCallback();
      }));
    }
  }
  return {
    element,
    dispose: () => {
      isDisposed = true;
      cts.cancel();
      disposables.dispose();
    }
  };
}
function sanitizeRenderedMarkdown(options, renderedMarkdown) {
  const { config, allowedSchemes } = getSanitizerOptions(options);
  (void 0)("uponSanitizeAttribute", (element, e) => {
    if (e.attrName === "style" || e.attrName === "class") {
      if (element.tagName === "SPAN") {
        if (e.attrName === "style") {
          e.keepAttr = /^(color\:#[0-9a-fA-F]+;)?(background-color\:#[0-9a-fA-F]+;)?$/.test(e.attrValue);
          return;
        } else if (e.attrName === "class") {
          e.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(e.attrValue);
          return;
        }
      }
      e.keepAttr = false;
      return;
    }
  });
  const anchor = document.createElement("a");
  (void 0)("afterSanitizeAttributes", (node) => {
    for (const attr of ["href", "src"]) {
      if (node.hasAttribute(attr)) {
        anchor.href = node.getAttribute(attr);
        if (!allowedSchemes.includes(anchor.protocol.replace(/:$/, ""))) {
          node.removeAttribute(attr);
        }
      }
    }
  });
  try {
    return (void 0)(renderedMarkdown, Object.assign(Object.assign({}, config), { RETURN_TRUSTED_TYPE: true }));
  } finally {
    (void 0)("uponSanitizeAttribute");
    (void 0)("afterSanitizeAttributes");
  }
}
function getSanitizerOptions(options) {
  const allowedSchemes = [
    Schemas.http,
    Schemas.https,
    Schemas.mailto,
    Schemas.data,
    Schemas.file,
    Schemas.vscodeFileResource,
    Schemas.vscodeRemote,
    Schemas.vscodeRemoteResource
  ];
  if (options.isTrusted) {
    allowedSchemes.push(Schemas.command);
  }
  return {
    config: {
      // allowedTags should included everything that markdown renders to.
      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.
      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/
      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-
      ALLOWED_TAGS: ["ul", "li", "p", "b", "i", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"],
      ALLOWED_ATTR: ["href", "data-href", "target", "title", "src", "alt", "class", "style", "data-code", "width", "height", "align"],
      ALLOW_UNKNOWN_PROTOCOLS: true
    },
    allowedSchemes
  };
}
var init_markdownRenderer = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js"() {
    init_dom();
    init_dompurify();
    init_event2();
    init_formattedTextRenderer();
    init_mouseEvent();
    init_iconLabels2();
    init_async();
    init_cancellation();
    init_errors();
    init_event();
    init_htmlContent();
    init_iconLabels();
    init_idGenerator();
    init_lifecycle();
    init_marked();
    init_marshalling();
    init_network();
    init_objects();
    init_resources();
    init_strings();
    init_uri();
  }
});

// node_modules/monaco-editor/esm/vs/editor/browser/core/markdownRenderer.js
var __decorate19, __param19, __awaiter17, _a2, MarkdownRenderer;
var init_markdownRenderer2 = __esm({
  "node_modules/monaco-editor/esm/vs/editor/browser/core/markdownRenderer.js"() {
    init_markdownRenderer();
    init_opener();
    init_modeService();
    init_errors();
    init_textToHtmlTokenizer();
    init_event();
    init_lifecycle();
    init_modes();
    __decorate19 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param19 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter17 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MarkdownRenderer = class MarkdownRenderer2 {
      constructor(_options, _modeService, _openerService) {
        this._options = _options;
        this._modeService = _modeService;
        this._openerService = _openerService;
        this._onDidRenderAsync = new Emitter();
        this.onDidRenderAsync = this._onDidRenderAsync.event;
      }
      dispose() {
        this._onDidRenderAsync.dispose();
      }
      render(markdown, options, markedOptions) {
        if (!markdown) {
          const element = document.createElement("span");
          return { element, dispose: () => {
          } };
        }
        const disposables = new DisposableStore();
        const rendered = disposables.add(renderMarkdown(markdown, Object.assign(Object.assign({}, this._getRenderOptions(markdown, disposables)), options), markedOptions));
        return {
          element: rendered.element,
          dispose: () => disposables.dispose()
        };
      }
      _getRenderOptions(markdown, disposeables) {
        return {
          baseUrl: this._options.baseUrl,
          codeBlockRenderer: (languageAlias, value) => __awaiter17(this, void 0, void 0, function* () {
            var _a5, _b2, _c2, _d2;
            let modeId;
            if (languageAlias) {
              modeId = this._modeService.getModeIdForLanguageName(languageAlias);
            } else if (this._options.editor) {
              modeId = (_a5 = this._options.editor.getModel()) === null || _a5 === void 0 ? void 0 : _a5.getLanguageIdentifier().language;
            }
            if (!modeId) {
              modeId = "plaintext";
            }
            this._modeService.triggerMode(modeId);
            const tokenization = (_b2 = yield TokenizationRegistry.getPromise(modeId)) !== null && _b2 !== void 0 ? _b2 : void 0;
            const element = document.createElement("span");
            element.innerHTML = (_d2 = (_c2 = MarkdownRenderer2._ttpTokenizer) === null || _c2 === void 0 ? void 0 : _c2.createHTML(value, tokenization)) !== null && _d2 !== void 0 ? _d2 : tokenizeToString(value, tokenization);
            let fontFamily = this._options.codeBlockFontFamily;
            if (this._options.editor) {
              fontFamily = this._options.editor.getOption(
                43
                /* fontInfo */
              ).fontFamily;
            }
            if (fontFamily) {
              element.style.fontFamily = fontFamily;
            }
            return element;
          }),
          asyncRenderCallback: () => this._onDidRenderAsync.fire(),
          actionHandler: {
            callback: (content) => this._openerService.open(content, { fromUserGesture: true, allowContributedOpeners: true, allowCommands: markdown.isTrusted }).catch(onUnexpectedError),
            disposables: disposeables
          }
        };
      }
    };
    MarkdownRenderer._ttpTokenizer = (_a2 = window.trustedTypes) === null || _a2 === void 0 ? void 0 : _a2.createPolicy("tokenizeToString", {
      createHTML(value, tokenizer) {
        return tokenizeToString(value, tokenizer);
      }
    });
    MarkdownRenderer = __decorate19([
      __param19(1, IModeService),
      __param19(2, IOpenerService)
    ], MarkdownRenderer);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/getHover.js
function getHover(model, position, token) {
  const supports = HoverProviderRegistry.ordered(model);
  const promises = supports.map((support) => {
    return Promise.resolve(support.provideHover(model, position, token)).then((hover) => {
      return hover && isValid(hover) ? hover : void 0;
    }, (err) => {
      onUnexpectedExternalError(err);
      return void 0;
    });
  });
  return Promise.all(promises).then(coalesce);
}
function isValid(result) {
  const hasRange = typeof result.range !== "undefined";
  const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
  return hasRange && hasHtmlContent;
}
var init_getHover = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/getHover.js"() {
    init_arrays();
    init_cancellation();
    init_errors();
    init_editorExtensions();
    init_modes();
    registerModelAndPositionCommand("_executeHoverProvider", (model, position) => getHover(model, position, CancellationToken.None));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/markdownHoverParticipant.js
var __decorate20, __param20, __awaiter18, $4, MarkdownHover, MarkdownHoverParticipant;
var init_markdownHoverParticipant = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/markdownHoverParticipant.js"() {
    init_dom();
    init_arrays();
    init_htmlContent();
    init_lifecycle();
    init_markdownRenderer2();
    init_position();
    init_range();
    init_modes();
    init_modeService();
    init_getHover();
    init_nls();
    init_configuration();
    init_opener();
    __decorate20 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param20 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter18 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    $4 = $;
    MarkdownHover = class {
      constructor(owner, range, contents) {
        this.owner = owner;
        this.range = range;
        this.contents = contents;
      }
      isValidForHoverAnchor(anchor) {
        return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
      }
    };
    MarkdownHoverParticipant = class MarkdownHoverParticipant2 {
      constructor(_editor2, _hover, _modeService, _openerService, _configurationService) {
        this._editor = _editor2;
        this._hover = _hover;
        this._modeService = _modeService;
        this._openerService = _openerService;
        this._configurationService = _configurationService;
      }
      createLoadingMessage(anchor) {
        return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("modesContentHover.loading", "Loading..."))]);
      }
      computeSync(anchor, lineDecorations) {
        if (!this._editor.hasModel() || anchor.type !== 1) {
          return [];
        }
        const model = this._editor.getModel();
        const lineNumber = anchor.range.startLineNumber;
        const maxColumn = model.getLineMaxColumn(lineNumber);
        const result = [];
        for (const d of lineDecorations) {
          const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
          const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
          const hoverMessage = d.options.hoverMessage;
          if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
            continue;
          }
          const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
          result.push(new MarkdownHover(this, range, asArray(hoverMessage)));
        }
        const lineLength = this._editor.getModel().getLineLength(lineNumber);
        const maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength");
        if (typeof maxTokenizationLineLength === "number" && lineLength >= maxTokenizationLineLength) {
          result.push(new MarkdownHover(this, new Range(lineNumber, 1, lineNumber, lineLength + 1), [{
            value: localize("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
          }]));
        }
        return result;
      }
      computeAsync(anchor, lineDecorations, token) {
        return __awaiter18(this, void 0, void 0, function* () {
          if (!this._editor.hasModel() || anchor.type !== 1) {
            return Promise.resolve([]);
          }
          const model = this._editor.getModel();
          if (!HoverProviderRegistry.has(model)) {
            return Promise.resolve([]);
          }
          const hovers = yield getHover(model, new Position(anchor.range.startLineNumber, anchor.range.startColumn), token);
          const result = [];
          for (const hover of hovers) {
            if (isEmptyMarkdownString(hover.contents)) {
              continue;
            }
            const rng = hover.range ? Range.lift(hover.range) : anchor.range;
            result.push(new MarkdownHover(this, rng, hover.contents));
          }
          return result;
        });
      }
      renderHoverParts(hoverParts, fragment, statusBar) {
        const disposables = new DisposableStore();
        for (const hoverPart of hoverParts) {
          for (const contents of hoverPart.contents) {
            if (isEmptyMarkdownString(contents)) {
              continue;
            }
            const markdownHoverElement = $4("div.hover-row.markdown-hover");
            const hoverContentsElement = append(markdownHoverElement, $4("div.hover-contents"));
            const renderer = disposables.add(new MarkdownRenderer({ editor: this._editor }, this._modeService, this._openerService));
            disposables.add(renderer.onDidRenderAsync(() => {
              hoverContentsElement.className = "hover-contents code-hover-contents";
              this._hover.onContentsChanged();
            }));
            const renderedContents = disposables.add(renderer.render(contents));
            hoverContentsElement.appendChild(renderedContents.element);
            fragment.appendChild(markdownHoverElement);
          }
        }
        return disposables;
      }
    };
    MarkdownHoverParticipant = __decorate20([
      __param20(2, IModeService),
      __param20(3, IOpenerService),
      __param20(4, IConfigurationService)
    ], MarkdownHoverParticipant);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/markerNavigationService.js
var __decorate21, __param21, MarkerCoordinate, MarkerList, IMarkerNavigationService, MarkerNavigationService;
var init_markerNavigationService = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/markerNavigationService.js"() {
    init_arrays();
    init_event();
    init_lifecycle();
    init_linkedList();
    init_strings();
    init_uri();
    init_range();
    init_extensions();
    init_instantiation();
    init_markers();
    __decorate21 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param21 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    MarkerCoordinate = class {
      constructor(marker, index, total) {
        this.marker = marker;
        this.index = index;
        this.total = total;
      }
    };
    MarkerList = class MarkerList2 {
      constructor(resourceFilter, _markerService) {
        this._markerService = _markerService;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._dispoables = new DisposableStore();
        this._markers = [];
        this._nextIdx = -1;
        if (URI.isUri(resourceFilter)) {
          this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
        } else if (resourceFilter) {
          this._resourceFilter = resourceFilter;
        }
        const updateMarker = () => {
          this._markers = this._markerService.read({
            resource: URI.isUri(resourceFilter) ? resourceFilter : void 0,
            severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
          });
          if (typeof resourceFilter === "function") {
            this._markers = this._markers.filter((m) => this._resourceFilter(m.resource));
          }
          this._markers.sort(MarkerList2._compareMarker);
        };
        updateMarker();
        this._dispoables.add(_markerService.onMarkerChanged((uris) => {
          if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
            updateMarker();
            this._nextIdx = -1;
            this._onDidChange.fire();
          }
        }));
      }
      dispose() {
        this._dispoables.dispose();
        this._onDidChange.dispose();
      }
      matches(uri) {
        if (!this._resourceFilter && !uri) {
          return true;
        }
        if (!this._resourceFilter || !uri) {
          return false;
        }
        return this._resourceFilter(uri);
      }
      get selected() {
        const marker = this._markers[this._nextIdx];
        return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
      }
      _initIdx(model, position, fwd) {
        let found = false;
        let idx = this._markers.findIndex((marker) => marker.resource.toString() === model.uri.toString());
        if (idx < 0) {
          idx = binarySearch(this._markers, { resource: model.uri }, (a, b) => compare(a.resource.toString(), b.resource.toString()));
          if (idx < 0) {
            idx = ~idx;
          }
        }
        for (let i = idx; i < this._markers.length; i++) {
          let range = Range.lift(this._markers[i]);
          if (range.isEmpty()) {
            const word = model.getWordAtPosition(range.getStartPosition());
            if (word) {
              range = new Range(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);
            }
          }
          if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {
            this._nextIdx = i;
            found = true;
            break;
          }
          if (this._markers[i].resource.toString() !== model.uri.toString()) {
            break;
          }
        }
        if (!found) {
          this._nextIdx = fwd ? 0 : this._markers.length - 1;
        }
        if (this._nextIdx < 0) {
          this._nextIdx = this._markers.length - 1;
        }
      }
      resetIndex() {
        this._nextIdx = -1;
      }
      move(fwd, model, position) {
        if (this._markers.length === 0) {
          return false;
        }
        let oldIdx = this._nextIdx;
        if (this._nextIdx === -1) {
          this._initIdx(model, position, fwd);
        } else if (fwd) {
          this._nextIdx = (this._nextIdx + 1) % this._markers.length;
        } else if (!fwd) {
          this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
        }
        if (oldIdx !== this._nextIdx) {
          return true;
        }
        return false;
      }
      find(uri, position) {
        let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
        if (idx < 0) {
          return void 0;
        }
        for (; idx < this._markers.length; idx++) {
          if (Range.containsPosition(this._markers[idx], position)) {
            return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
          }
        }
        return void 0;
      }
      static _compareMarker(a, b) {
        let res = compare(a.resource.toString(), b.resource.toString());
        if (res === 0) {
          res = MarkerSeverity.compare(a.severity, b.severity);
        }
        if (res === 0) {
          res = Range.compareRangesUsingStarts(a, b);
        }
        return res;
      }
    };
    MarkerList = __decorate21([
      __param21(1, IMarkerService)
    ], MarkerList);
    IMarkerNavigationService = createDecorator("IMarkerNavigationService");
    MarkerNavigationService = class MarkerNavigationService2 {
      constructor(_markerService) {
        this._markerService = _markerService;
        this._provider = new LinkedList();
      }
      getMarkerList(resource) {
        for (let provider of this._provider) {
          const result = provider.getMarkerList(resource);
          if (result) {
            return result;
          }
        }
        return new MarkerList(resource, this._markerService);
      }
    };
    MarkerNavigationService = __decorate21([
      __param21(0, IMarkerService)
    ], MarkerNavigationService);
    registerSingleton(IMarkerNavigationService, MarkerNavigationService, true);
  }
});

// node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js
var SeverityIcon;
var init_severityIcon = __esm({
  "node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js"() {
    init_codicons();
    init_severity();
    init_colorRegistry();
    init_themeService();
    (function(SeverityIcon2) {
      function className(severity) {
        switch (severity) {
          case severity_default.Ignore:
            return "severity-ignore " + Codicon.info.classNames;
          case severity_default.Info:
            return Codicon.info.classNames;
          case severity_default.Warning:
            return Codicon.warning.classNames;
          case severity_default.Error:
            return Codicon.error.classNames;
          default:
            return "";
        }
      }
      SeverityIcon2.className = className;
    })(SeverityIcon || (SeverityIcon = {}));
    registerThemingParticipant((theme, collector) => {
      const errorIconForeground = theme.getColor(problemsErrorIconForeground);
      if (errorIconForeground) {
        const errorCodiconSelector = Codicon.error.cssSelector;
        collector.addRule(`
			.monaco-editor .zone-widget ${errorCodiconSelector},
			.markers-panel .marker-icon${errorCodiconSelector},
			.text-search-provider-messages .providerMessage ${errorCodiconSelector},
			.extensions-viewlet > .extensions ${errorCodiconSelector} {
				color: ${errorIconForeground};
			}
		`);
      }
      const warningIconForeground = theme.getColor(problemsWarningIconForeground);
      if (warningIconForeground) {
        const warningCodiconSelector = Codicon.warning.cssSelector;
        collector.addRule(`
			.monaco-editor .zone-widget ${warningCodiconSelector},
			.markers-panel .marker-icon${warningCodiconSelector},
			.extensions-viewlet > .extensions ${warningCodiconSelector},
			.extension-editor ${warningCodiconSelector},
			.text-search-provider-messages .providerMessage ${warningCodiconSelector},
			.preferences-editor ${warningCodiconSelector} {
				color: ${warningIconForeground};
			}
		`);
      }
      const infoIconForeground = theme.getColor(problemsInfoIconForeground);
      if (infoIconForeground) {
        const infoCodiconSelector = Codicon.info.cssSelector;
        collector.addRule(`
			.monaco-editor .zone-widget ${infoCodiconSelector},
			.markers-panel .marker-icon${infoCodiconSelector},
			.extensions-viewlet > .extensions ${infoCodiconSelector},
			.text-search-provider-messages .providerMessage ${infoCodiconSelector},
			.extension-editor ${infoCodiconSelector} {
				color: ${infoIconForeground};
			}
		`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.js
var __decorate22, __param22, MessageWidget2, MarkerNavigationWidget, errorDefault, warningDefault, infoDefault, editorMarkerNavigationError, editorMarkerNavigationErrorHeader, editorMarkerNavigationWarning, editorMarkerNavigationWarningHeader, editorMarkerNavigationInfo, editorMarkerNavigationInfoHeader, editorMarkerNavigationBackground;
var init_gotoErrorWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.js"() {
    init_dom();
    init_scrollableElement();
    init_arrays();
    init_color();
    init_event();
    init_labels();
    init_lifecycle();
    init_resources();
    init_strings();
    init_range();
    init_peekView();
    init_nls();
    init_menuEntryActionViewItem();
    init_actions2();
    init_contextkey();
    init_instantiation();
    init_label();
    init_markers();
    init_opener();
    init_severityIcon();
    init_colorRegistry();
    init_themeService();
    __decorate22 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param22 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    MessageWidget2 = class {
      constructor(parent, editor2, onRelatedInformation, _openerService, _labelService) {
        this._openerService = _openerService;
        this._labelService = _labelService;
        this._lines = 0;
        this._longestLineLength = 0;
        this._relatedDiagnostics = /* @__PURE__ */ new WeakMap();
        this._disposables = new DisposableStore();
        this._editor = editor2;
        const domNode = document.createElement("div");
        domNode.className = "descriptioncontainer";
        this._messageBlock = document.createElement("div");
        this._messageBlock.classList.add("message");
        this._messageBlock.setAttribute("aria-live", "assertive");
        this._messageBlock.setAttribute("role", "alert");
        domNode.appendChild(this._messageBlock);
        this._relatedBlock = document.createElement("div");
        domNode.appendChild(this._relatedBlock);
        this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
          event.preventDefault();
          const related = this._relatedDiagnostics.get(event.target);
          if (related) {
            onRelatedInformation(related);
          }
        }));
        this._scrollable = new ScrollableElement(domNode, {
          horizontal: 1,
          vertical: 1,
          useShadows: false,
          horizontalScrollbarSize: 3,
          verticalScrollbarSize: 3
        });
        parent.appendChild(this._scrollable.getDomNode());
        this._disposables.add(this._scrollable.onScroll((e) => {
          domNode.style.left = `-${e.scrollLeft}px`;
          domNode.style.top = `-${e.scrollTop}px`;
        }));
        this._disposables.add(this._scrollable);
      }
      dispose() {
        dispose(this._disposables);
      }
      update(marker) {
        const { source, message, relatedInformation, code } = marker;
        let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + "()".length;
        if (code) {
          if (typeof code === "string") {
            sourceAndCodeLength += code.length;
          } else {
            sourceAndCodeLength += code.value.length;
          }
        }
        const lines = splitLines(message);
        this._lines = lines.length;
        this._longestLineLength = 0;
        for (const line of lines) {
          this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
        }
        clearNode(this._messageBlock);
        this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
        this._editor.applyFontInfo(this._messageBlock);
        let lastLineElement = this._messageBlock;
        for (const line of lines) {
          lastLineElement = document.createElement("div");
          lastLineElement.innerText = line;
          if (line === "") {
            lastLineElement.style.height = this._messageBlock.style.lineHeight;
          }
          this._messageBlock.appendChild(lastLineElement);
        }
        if (source || code) {
          const detailsElement = document.createElement("span");
          detailsElement.classList.add("details");
          lastLineElement.appendChild(detailsElement);
          if (source) {
            const sourceElement = document.createElement("span");
            sourceElement.innerText = source;
            sourceElement.classList.add("source");
            detailsElement.appendChild(sourceElement);
          }
          if (code) {
            if (typeof code === "string") {
              const codeElement = document.createElement("span");
              codeElement.innerText = `(${code})`;
              codeElement.classList.add("code");
              detailsElement.appendChild(codeElement);
            } else {
              this._codeLink = $("a.code-link");
              this._codeLink.setAttribute("href", `${code.target.toString()}`);
              this._codeLink.onclick = (e) => {
                this._openerService.open(code.target, { allowCommands: true });
                e.preventDefault();
                e.stopPropagation();
              };
              const codeElement = append(this._codeLink, $("span"));
              codeElement.innerText = code.value;
              detailsElement.appendChild(this._codeLink);
            }
          }
        }
        clearNode(this._relatedBlock);
        this._editor.applyFontInfo(this._relatedBlock);
        if (isNonEmptyArray(relatedInformation)) {
          const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
          relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(
            58
            /* lineHeight */
          ) * 0.66)}px`;
          this._lines += 1;
          for (const related of relatedInformation) {
            let container = document.createElement("div");
            let relatedResource = document.createElement("a");
            relatedResource.classList.add("filename");
            relatedResource.innerText = `${getBaseLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
            relatedResource.title = this._labelService.getUriLabel(related.resource);
            this._relatedDiagnostics.set(relatedResource, related);
            let relatedMessage = document.createElement("span");
            relatedMessage.innerText = related.message;
            container.appendChild(relatedResource);
            container.appendChild(relatedMessage);
            this._lines += 1;
            relatedInformationNode.appendChild(container);
          }
        }
        const fontInfo = this._editor.getOption(
          43
          /* fontInfo */
        );
        const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);
        const scrollHeight = fontInfo.lineHeight * this._lines;
        this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });
      }
      layout(height, width) {
        this._scrollable.getDomNode().style.height = `${height}px`;
        this._scrollable.getDomNode().style.width = `${width}px`;
        this._scrollable.setScrollDimensions({ width, height });
      }
      getHeightInLines() {
        return Math.min(17, this._lines);
      }
      getAriaLabel(marker) {
        let severityLabel = "";
        switch (marker.severity) {
          case MarkerSeverity.Error:
            severityLabel = localize("Error", "Error");
            break;
          case MarkerSeverity.Warning:
            severityLabel = localize("Warning", "Warning");
            break;
          case MarkerSeverity.Info:
            severityLabel = localize("Info", "Info");
            break;
          case MarkerSeverity.Hint:
            severityLabel = localize("Hint", "Hint");
            break;
        }
        let ariaLabel = localize("marker aria", "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
        const model = this._editor.getModel();
        if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) {
          const lineContent = model.getLineContent(marker.startLineNumber);
          ariaLabel = `${lineContent}, ${ariaLabel}`;
        }
        return ariaLabel;
      }
    };
    MarkerNavigationWidget = class MarkerNavigationWidget2 extends PeekViewWidget {
      constructor(editor2, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {
        super(editor2, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);
        this._themeService = _themeService;
        this._openerService = _openerService;
        this._menuService = _menuService;
        this._contextKeyService = _contextKeyService;
        this._labelService = _labelService;
        this._callOnDispose = new DisposableStore();
        this._onDidSelectRelatedInformation = new Emitter();
        this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
        this._severity = MarkerSeverity.Warning;
        this._backgroundColor = Color.white;
        this._applyTheme(_themeService.getColorTheme());
        this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
        this.create();
      }
      _applyTheme(theme) {
        this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
        let colorId = editorMarkerNavigationError;
        let headerBackground = editorMarkerNavigationErrorHeader;
        if (this._severity === MarkerSeverity.Warning) {
          colorId = editorMarkerNavigationWarning;
          headerBackground = editorMarkerNavigationWarningHeader;
        } else if (this._severity === MarkerSeverity.Info) {
          colorId = editorMarkerNavigationInfo;
          headerBackground = editorMarkerNavigationInfoHeader;
        }
        const frameColor = theme.getColor(colorId);
        const headerBg = theme.getColor(headerBackground);
        this.style({
          arrowColor: frameColor,
          frameColor,
          headerBackgroundColor: headerBg,
          primaryHeadingColor: theme.getColor(peekViewTitleForeground),
          secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
        });
      }
      _applyStyles() {
        if (this._parentContainer) {
          this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
        }
        super._applyStyles();
      }
      dispose() {
        this._callOnDispose.dispose();
        super.dispose();
      }
      _fillHead(container) {
        super._fillHead(container);
        this._disposables.add(this._actionbarWidget.actionRunner.onBeforeRun((e) => this.editor.focus()));
        const actions = [];
        const menu = this._menuService.createMenu(MarkerNavigationWidget2.TitleMenu, this._contextKeyService);
        createAndFillInActionBarActions(menu, void 0, actions);
        this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });
        menu.dispose();
      }
      _fillTitleIcon(container) {
        this._icon = append(container, $(""));
      }
      _fillBody(container) {
        this._parentContainer = container;
        container.classList.add("marker-widget");
        this._parentContainer.tabIndex = 0;
        this._parentContainer.setAttribute("role", "tooltip");
        this._container = document.createElement("div");
        container.appendChild(this._container);
        this._message = new MessageWidget2(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);
        this._disposables.add(this._message);
      }
      show() {
        throw new Error("call showAtMarker");
      }
      showAtMarker(marker, markerIdx, markerCount) {
        this._container.classList.remove("stale");
        this._message.update(marker);
        this._severity = marker.severity;
        this._applyTheme(this._themeService.getColorTheme());
        let range = Range.lift(marker);
        const editorPosition = this.editor.getPosition();
        let position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();
        super.show(position, this.computeRequiredHeight());
        const model = this.editor.getModel();
        if (model) {
          const detail = markerCount > 1 ? localize("problems", "{0} of {1} problems", markerIdx, markerCount) : localize("change", "{0} of {1} problem", markerIdx, markerCount);
          this.setTitle(basename2(model.uri), detail);
        }
        this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
        this.editor.revealPositionNearTop(
          position,
          0
          /* Smooth */
        );
        this.editor.focus();
      }
      updateMarker(marker) {
        this._container.classList.remove("stale");
        this._message.update(marker);
      }
      showStale() {
        this._container.classList.add("stale");
        this._relayout();
      }
      _doLayoutBody(heightInPixel, widthInPixel) {
        super._doLayoutBody(heightInPixel, widthInPixel);
        this._heightInPixel = heightInPixel;
        this._message.layout(heightInPixel, widthInPixel);
        this._container.style.height = `${heightInPixel}px`;
      }
      _onWidth(widthInPixel) {
        this._message.layout(this._heightInPixel, widthInPixel);
      }
      _relayout() {
        super._relayout(this.computeRequiredHeight());
      }
      computeRequiredHeight() {
        return 3 + this._message.getHeightInLines();
      }
    };
    MarkerNavigationWidget.TitleMenu = new MenuId("gotoErrorTitleMenu");
    MarkerNavigationWidget = __decorate22([
      __param22(1, IThemeService),
      __param22(2, IOpenerService),
      __param22(3, IMenuService),
      __param22(4, IInstantiationService),
      __param22(5, IContextKeyService),
      __param22(6, ILabelService)
    ], MarkerNavigationWidget);
    errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
    warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
    infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
    editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", { dark: errorDefault, light: errorDefault, hc: contrastBorder }, localize("editorMarkerNavigationError", "Editor marker navigation widget error color."));
    editorMarkerNavigationErrorHeader = registerColor("editorMarkerNavigationError.headerBackground", { dark: transparent(editorMarkerNavigationError, 0.1), light: transparent(editorMarkerNavigationError, 0.1), hc: null }, localize("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background."));
    editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", { dark: warningDefault, light: warningDefault, hc: contrastBorder }, localize("editorMarkerNavigationWarning", "Editor marker navigation widget warning color."));
    editorMarkerNavigationWarningHeader = registerColor("editorMarkerNavigationWarning.headerBackground", { dark: transparent(editorMarkerNavigationWarning, 0.1), light: transparent(editorMarkerNavigationWarning, 0.1), hc: "#0C141F" }, localize("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background."));
    editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", { dark: infoDefault, light: infoDefault, hc: contrastBorder }, localize("editorMarkerNavigationInfo", "Editor marker navigation widget info color."));
    editorMarkerNavigationInfoHeader = registerColor("editorMarkerNavigationInfo.headerBackground", { dark: transparent(editorMarkerNavigationInfo, 0.1), light: transparent(editorMarkerNavigationInfo, 0.1), hc: null }, localize("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background."));
    editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", { dark: editorBackground, light: editorBackground, hc: editorBackground }, localize("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
    registerThemingParticipant((theme, collector) => {
      const linkFg = theme.getColor(textLinkForeground);
      if (linkFg) {
        collector.addRule(`.monaco-editor .marker-widget a.code-link span { color: ${linkFg}; }`);
      }
      const activeLinkFg = theme.getColor(textLinkActiveForeground);
      if (activeLinkFg) {
        collector.addRule(`.monaco-editor .marker-widget a.code-link span:hover { color: ${activeLinkFg}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoError.js
var __decorate23, __param23, __awaiter19, MarkerController, MarkerNavigationAction, NextMarkerAction, PrevMarkerAction, NextMarkerInFilesAction, PrevMarkerInFilesAction, CONTEXT_MARKERS_NAVIGATION_VISIBLE, MarkerCommand;
var init_gotoError = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoError.js"() {
    init_codicons();
    init_lifecycle();
    init_editorExtensions();
    init_codeEditorService();
    init_position();
    init_range();
    init_editorContextKeys();
    init_markerNavigationService();
    init_nls();
    init_actions2();
    init_contextkey();
    init_instantiation();
    init_iconRegistry();
    init_gotoErrorWidget();
    __decorate23 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param23 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter19 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MarkerController = class MarkerController2 {
      constructor(editor2, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
        this._markerNavigationService = _markerNavigationService;
        this._contextKeyService = _contextKeyService;
        this._editorService = _editorService;
        this._instantiationService = _instantiationService;
        this._sessionDispoables = new DisposableStore();
        this._editor = editor2;
        this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
      }
      static get(editor2) {
        return editor2.getContribution(MarkerController2.ID);
      }
      dispose() {
        this._cleanUp();
        this._sessionDispoables.dispose();
      }
      _cleanUp() {
        this._widgetVisible.reset();
        this._sessionDispoables.clear();
        this._widget = void 0;
        this._model = void 0;
      }
      _getOrCreateModel(uri) {
        if (this._model && this._model.matches(uri)) {
          return this._model;
        }
        let reusePosition = false;
        if (this._model) {
          reusePosition = true;
          this._cleanUp();
        }
        this._model = this._markerNavigationService.getMarkerList(uri);
        if (reusePosition) {
          this._model.move(true, this._editor.getModel(), this._editor.getPosition());
        }
        this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
        this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
        this._widgetVisible.set(true);
        this._sessionDispoables.add(this._model);
        this._sessionDispoables.add(this._widget);
        this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
          var _a5, _b2, _c2;
          if (!((_a5 = this._model) === null || _a5 === void 0 ? void 0 : _a5.selected) || !Range.containsPosition((_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.selected.marker, e.position)) {
            (_c2 = this._model) === null || _c2 === void 0 ? void 0 : _c2.resetIndex();
          }
        }));
        this._sessionDispoables.add(this._model.onDidChange(() => {
          if (!this._widget || !this._widget.position || !this._model) {
            return;
          }
          const info = this._model.find(this._editor.getModel().uri, this._widget.position);
          if (info) {
            this._widget.updateMarker(info.marker);
          } else {
            this._widget.showStale();
          }
        }));
        this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
          this._editorService.openCodeEditor({
            resource: related.resource,
            options: { pinned: true, revealIfOpened: true, selection: Range.lift(related).collapseToStart() }
          }, this._editor);
          this.close(false);
        }));
        this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
        return this._model;
      }
      close(focusEditor = true) {
        this._cleanUp();
        if (focusEditor) {
          this._editor.focus();
        }
      }
      showAtMarker(marker) {
        if (this._editor.hasModel()) {
          const model = this._getOrCreateModel(this._editor.getModel().uri);
          model.resetIndex();
          model.move(true, this._editor.getModel(), new Position(marker.startLineNumber, marker.startColumn));
          if (model.selected) {
            this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
          }
        }
      }
      nagivate(next, multiFile) {
        return __awaiter19(this, void 0, void 0, function* () {
          if (this._editor.hasModel()) {
            const model = this._getOrCreateModel(multiFile ? void 0 : this._editor.getModel().uri);
            model.move(next, this._editor.getModel(), this._editor.getPosition());
            if (!model.selected) {
              return;
            }
            if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
              this._cleanUp();
              const otherEditor = yield this._editorService.openCodeEditor({
                resource: model.selected.marker.resource,
                options: { pinned: false, revealIfOpened: true, selectionRevealType: 2, selection: model.selected.marker }
              }, this._editor);
              if (otherEditor) {
                MarkerController2.get(otherEditor).close();
                MarkerController2.get(otherEditor).nagivate(next, multiFile);
              }
            } else {
              this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
            }
          }
        });
      }
    };
    MarkerController.ID = "editor.contrib.markerController";
    MarkerController = __decorate23([
      __param23(1, IMarkerNavigationService),
      __param23(2, IContextKeyService),
      __param23(3, ICodeEditorService),
      __param23(4, IInstantiationService)
    ], MarkerController);
    MarkerNavigationAction = class extends EditorAction {
      constructor(_next, _multiFile, opts) {
        super(opts);
        this._next = _next;
        this._multiFile = _multiFile;
      }
      run(_accessor, editor2) {
        return __awaiter19(this, void 0, void 0, function* () {
          if (editor2.hasModel()) {
            MarkerController.get(editor2).nagivate(this._next, this._multiFile);
          }
        });
      }
    };
    NextMarkerAction = class _NextMarkerAction extends MarkerNavigationAction {
      constructor() {
        super(true, false, {
          id: _NextMarkerAction.ID,
          label: _NextMarkerAction.LABEL,
          alias: "Go to Next Problem (Error, Warning, Info)",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 512 | 66,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MarkerNavigationWidget.TitleMenu,
            title: _NextMarkerAction.LABEL,
            icon: registerIcon("marker-navigation-next", Codicon.arrowDown, localize("nextMarkerIcon", "Icon for goto next marker.")),
            group: "navigation",
            order: 1
          }
        });
      }
    };
    NextMarkerAction.ID = "editor.action.marker.next";
    NextMarkerAction.LABEL = localize("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
    PrevMarkerAction = class _PrevMarkerAction extends MarkerNavigationAction {
      constructor() {
        super(false, false, {
          id: _PrevMarkerAction.ID,
          label: _PrevMarkerAction.LABEL,
          alias: "Go to Previous Problem (Error, Warning, Info)",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 1024 | 512 | 66,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MarkerNavigationWidget.TitleMenu,
            title: NextMarkerAction.LABEL,
            icon: registerIcon("marker-navigation-previous", Codicon.arrowUp, localize("previousMarkerIcon", "Icon for goto previous marker.")),
            group: "navigation",
            order: 2
          }
        });
      }
    };
    PrevMarkerAction.ID = "editor.action.marker.prev";
    PrevMarkerAction.LABEL = localize("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
    NextMarkerInFilesAction = class extends MarkerNavigationAction {
      constructor() {
        super(true, true, {
          id: "editor.action.marker.nextInFiles",
          label: localize("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
          alias: "Go to Next Problem in Files (Error, Warning, Info)",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 66,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarGoMenu,
            title: localize({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
            group: "6_problem_nav",
            order: 1
          }
        });
      }
    };
    PrevMarkerInFilesAction = class extends MarkerNavigationAction {
      constructor() {
        super(false, true, {
          id: "editor.action.marker.prevInFiles",
          label: localize("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
          alias: "Go to Previous Problem in Files (Error, Warning, Info)",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 1024 | 66,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarGoMenu,
            title: localize({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
            group: "6_problem_nav",
            order: 2
          }
        });
      }
    };
    registerEditorContribution(MarkerController.ID, MarkerController);
    registerEditorAction(NextMarkerAction);
    registerEditorAction(PrevMarkerAction);
    registerEditorAction(NextMarkerInFilesAction);
    registerEditorAction(PrevMarkerInFilesAction);
    CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
    MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
    registerEditorCommand(new MarkerCommand({
      id: "closeMarkersNavigation",
      precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
      handler: (x) => x.close(),
      kbOpts: {
        weight: 100 + 50,
        kbExpr: EditorContextKeys.focus,
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/markerHoverParticipant.js
var __decorate24, __param24, $5, MarkerHover, markerCodeActionTrigger, MarkerHoverParticipant;
var init_markerHoverParticipant = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/markerHoverParticipant.js"() {
    init_dom();
    init_arrays();
    init_async();
    init_errors();
    init_lifecycle();
    init_resources();
    init_range();
    init_markersDecorationService();
    init_codeAction();
    init_codeActionCommands();
    init_types2();
    init_gotoError();
    init_nls();
    init_markers();
    init_opener();
    init_progress();
    init_colorRegistry();
    init_themeService();
    __decorate24 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param24 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    $5 = $;
    MarkerHover = class {
      constructor(owner, range, marker) {
        this.owner = owner;
        this.range = range;
        this.marker = marker;
      }
      isValidForHoverAnchor(anchor) {
        return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
      }
    };
    markerCodeActionTrigger = {
      type: 1,
      filter: { include: CodeActionKind.QuickFix }
    };
    MarkerHoverParticipant = class MarkerHoverParticipant2 {
      constructor(_editor2, _hover, _markerDecorationsService, _openerService) {
        this._editor = _editor2;
        this._hover = _hover;
        this._markerDecorationsService = _markerDecorationsService;
        this._openerService = _openerService;
        this.recentMarkerCodeActionsInfo = void 0;
      }
      computeSync(anchor, lineDecorations) {
        if (!this._editor.hasModel() || anchor.type !== 1) {
          return [];
        }
        const model = this._editor.getModel();
        const lineNumber = anchor.range.startLineNumber;
        const maxColumn = model.getLineMaxColumn(lineNumber);
        const result = [];
        for (const d of lineDecorations) {
          const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
          const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
          const marker = this._markerDecorationsService.getMarker(model.uri, d);
          if (!marker) {
            continue;
          }
          const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
          result.push(new MarkerHover(this, range, marker));
        }
        return result;
      }
      renderHoverParts(hoverParts, fragment, statusBar) {
        if (!hoverParts.length) {
          return Disposable.None;
        }
        const disposables = new DisposableStore();
        hoverParts.forEach((msg) => fragment.appendChild(this.renderMarkerHover(msg, disposables)));
        const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];
        this.renderMarkerStatusbar(markerHoverForStatusbar, statusBar, disposables);
        return disposables;
      }
      renderMarkerHover(markerHover, disposables) {
        const hoverElement = $5("div.hover-row");
        const markerElement = append(hoverElement, $5("div.marker.hover-contents"));
        const { source, message, code, relatedInformation } = markerHover.marker;
        this._editor.applyFontInfo(markerElement);
        const messageElement = append(markerElement, $5("span"));
        messageElement.style.whiteSpace = "pre-wrap";
        messageElement.innerText = message;
        if (source || code) {
          if (code && typeof code !== "string") {
            const sourceAndCodeElement = $5("span");
            if (source) {
              const sourceElement = append(sourceAndCodeElement, $5("span"));
              sourceElement.innerText = source;
            }
            const codeLink = append(sourceAndCodeElement, $5("a.code-link"));
            codeLink.setAttribute("href", code.target.toString());
            disposables.add(addDisposableListener(codeLink, "click", (e) => {
              this._openerService.open(code.target, { allowCommands: true });
              e.preventDefault();
              e.stopPropagation();
            }));
            const codeElement = append(codeLink, $5("span"));
            codeElement.innerText = code.value;
            const detailsElement = append(markerElement, sourceAndCodeElement);
            detailsElement.style.opacity = "0.6";
            detailsElement.style.paddingLeft = "6px";
          } else {
            const detailsElement = append(markerElement, $5("span"));
            detailsElement.style.opacity = "0.6";
            detailsElement.style.paddingLeft = "6px";
            detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;
          }
        }
        if (isNonEmptyArray(relatedInformation)) {
          for (const { message: message2, resource, startLineNumber, startColumn } of relatedInformation) {
            const relatedInfoContainer = append(markerElement, $5("div"));
            relatedInfoContainer.style.marginTop = "8px";
            const a = append(relatedInfoContainer, $5("a"));
            a.innerText = `${basename2(resource)}(${startLineNumber}, ${startColumn}): `;
            a.style.cursor = "pointer";
            disposables.add(addDisposableListener(a, "click", (e) => {
              e.stopPropagation();
              e.preventDefault();
              if (this._openerService) {
                this._openerService.open(resource, {
                  fromUserGesture: true,
                  editorOptions: { selection: { startLineNumber, startColumn } }
                }).catch(onUnexpectedError);
              }
            }));
            const messageElement2 = append(relatedInfoContainer, $5("span"));
            messageElement2.innerText = message2;
            this._editor.applyFontInfo(messageElement2);
          }
        }
        return hoverElement;
      }
      renderMarkerStatusbar(markerHover, statusBar, disposables) {
        if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
          statusBar.addAction({
            label: localize("view problem", "View Problem"),
            commandId: NextMarkerAction.ID,
            run: () => {
              this._hover.hide();
              MarkerController.get(this._editor).showAtMarker(markerHover.marker);
              this._editor.focus();
            }
          });
        }
        if (!this._editor.getOption(
          80
          /* readOnly */
        )) {
          const quickfixPlaceholderElement = statusBar.append($5("div"));
          if (this.recentMarkerCodeActionsInfo) {
            if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
              if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
                quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
              }
            } else {
              this.recentMarkerCodeActionsInfo = void 0;
            }
          }
          const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = localize("checkingForQuickFixes", "Checking for quick fixes..."), 200));
          if (!quickfixPlaceholderElement.textContent) {
            quickfixPlaceholderElement.textContent = String.fromCharCode(160);
          }
          const codeActionsPromise = this.getCodeActions(markerHover.marker);
          disposables.add(toDisposable(() => codeActionsPromise.cancel()));
          codeActionsPromise.then((actions) => {
            updatePlaceholderDisposable.dispose();
            this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };
            if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
              actions.dispose();
              quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
              return;
            }
            quickfixPlaceholderElement.style.display = "none";
            let showing = false;
            disposables.add(toDisposable(() => {
              if (!showing) {
                actions.dispose();
              }
            }));
            statusBar.addAction({
              label: localize("quick fixes", "Quick Fix..."),
              commandId: QuickFixAction.Id,
              run: (target) => {
                showing = true;
                const controller = QuickFixController.get(this._editor);
                const elementPosition = getDomNodePagePosition(target);
                this._hover.hide();
                controller.showCodeActions(markerCodeActionTrigger, actions, {
                  x: elementPosition.left + 6,
                  y: elementPosition.top + elementPosition.height + 6
                });
              }
            });
          }, onUnexpectedError);
        }
      }
      getCodeActions(marker) {
        return createCancelablePromise((cancellationToken) => {
          return getCodeActions(this._editor.getModel(), new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
        });
      }
    };
    MarkerHoverParticipant = __decorate24([
      __param24(2, IMarkerDecorationsService),
      __param24(3, IOpenerService)
    ], MarkerHoverParticipant);
    registerThemingParticipant((theme, collector) => {
      const linkFg = theme.getColor(textLinkForeground);
      if (linkFg) {
        collector.addRule(`.monaco-hover .hover-contents a.code-link span { color: ${linkFg}; }`);
      }
      const activeLinkFg = theme.getColor(textLinkActiveForeground);
      if (activeLinkFg) {
        collector.addRule(`.monaco-hover .hover-contents a.code-link span:hover { color: ${activeLinkFg}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/consts.js
var inlineSuggestCommitId;
var init_consts = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/consts.js"() {
    inlineSuggestCommitId = "editor.action.inlineSuggest.commit";
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.js
function applyEdits(text2, edits) {
  const transformer = new PositionOffsetTransformer(text2);
  const offsetEdits = edits.map((e) => {
    const range = Range.lift(e.range);
    return {
      startOffset: transformer.getOffset(range.getStartPosition()),
      endOffset: transformer.getOffset(range.getEndPosition()),
      text: e.text
    };
  });
  offsetEdits.sort((a, b) => b.startOffset - a.startOffset);
  for (const edit of offsetEdits) {
    text2 = text2.substring(0, edit.startOffset) + edit.text + text2.substring(edit.endOffset);
  }
  return text2;
}
var GhostText, PositionOffsetTransformer, GhostTextPart, BaseGhostTextWidgetModel;
var init_ghostText = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.js"() {
    init_event();
    init_lifecycle();
    init_range();
    GhostText = class {
      constructor(lineNumber, parts, additionalReservedLineCount = 0) {
        this.lineNumber = lineNumber;
        this.parts = parts;
        this.additionalReservedLineCount = additionalReservedLineCount;
      }
      renderForScreenReader(lineText) {
        if (this.parts.length === 0) {
          return "";
        }
        const lastPart = this.parts[this.parts.length - 1];
        const cappedLineText = lineText.substr(0, lastPart.column - 1);
        const text2 = applyEdits(cappedLineText, this.parts.map((p) => ({
          range: { startLineNumber: 1, endLineNumber: 1, startColumn: p.column, endColumn: p.column },
          text: p.lines.join("\n")
        })));
        return text2.substring(this.parts[0].column - 1);
      }
    };
    PositionOffsetTransformer = class {
      constructor(text2) {
        this.lineStartOffsetByLineIdx = [];
        this.lineStartOffsetByLineIdx.push(0);
        for (let i = 0; i < text2.length; i++) {
          if (text2.charAt(i) === "\n") {
            this.lineStartOffsetByLineIdx.push(i + 1);
          }
        }
      }
      getOffset(position) {
        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
      }
    };
    GhostTextPart = class {
      constructor(column, lines, preview) {
        this.column = column;
        this.lines = lines;
        this.preview = preview;
      }
    };
    BaseGhostTextWidgetModel = class extends Disposable {
      constructor(editor2) {
        super();
        this.editor = editor2;
        this._expanded = void 0;
        this.onDidChangeEmitter = new Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this._register(editor2.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            105
            /* suggest */
          ) && this._expanded === void 0) {
            this.onDidChangeEmitter.fire();
          }
        }));
      }
      setExpanded(expanded) {
        this._expanded = true;
        this.onDidChangeEmitter.fire();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionToGhostText.js
function normalizedInlineCompletionsEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.range.equalsRange(b.range) && a.text === b.text && a.command === b.command;
}
function inlineCompletionToGhostText(inlineCompletion, textModel, mode, cursorPosition, previewSuffixLength = 0) {
  if (inlineCompletion.range.startLineNumber !== inlineCompletion.range.endLineNumber) {
    return void 0;
  }
  const sourceLine = textModel.getLineContent(inlineCompletion.range.startLineNumber);
  const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;
  const suggestionTouchesIndentation = inlineCompletion.range.startColumn - 1 <= sourceIndentationLength;
  if (suggestionTouchesIndentation) {
    const suggestionAddedIndentationLength = getLeadingWhitespace(inlineCompletion.text).length;
    const replacedIndentation = sourceLine.substring(inlineCompletion.range.startColumn - 1, sourceIndentationLength);
    const rangeThatDoesNotReplaceIndentation = Range.fromPositions(inlineCompletion.range.getStartPosition().delta(0, replacedIndentation.length), inlineCompletion.range.getEndPosition());
    const suggestionWithoutIndentationChange = inlineCompletion.text.startsWith(replacedIndentation) ? inlineCompletion.text.substring(replacedIndentation.length) : inlineCompletion.text.substring(suggestionAddedIndentationLength);
    inlineCompletion = {
      range: rangeThatDoesNotReplaceIndentation,
      text: suggestionWithoutIndentationChange,
      command: inlineCompletion.command
    };
  }
  const valueToBeReplaced = textModel.getValueInRange(inlineCompletion.range);
  const changes = cachingDiff(valueToBeReplaced, inlineCompletion.text);
  const lineNumber = inlineCompletion.range.startLineNumber;
  const parts = new Array();
  if (mode === "prefix") {
    const filteredChanges = changes.filter((c) => c.originalLength === 0);
    if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {
      return void 0;
    }
  }
  const previewStartInCompletionText = inlineCompletion.text.length - previewSuffixLength;
  for (const c of changes) {
    const insertColumn = inlineCompletion.range.startColumn + c.originalStart + c.originalLength;
    if (mode === "subwordSmart" && cursorPosition && cursorPosition.lineNumber === inlineCompletion.range.startLineNumber && insertColumn < cursorPosition.column) {
      return void 0;
    }
    if (c.originalLength > 0) {
      return void 0;
    }
    if (c.modifiedLength === 0) {
      continue;
    }
    const modifiedEnd = c.modifiedStart + c.modifiedLength;
    const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));
    const nonPreviewText = inlineCompletion.text.substring(c.modifiedStart, nonPreviewTextEnd);
    const italicText = inlineCompletion.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));
    if (nonPreviewText.length > 0) {
      const lines = splitLines(nonPreviewText);
      parts.push(new GhostTextPart(insertColumn, lines, false));
    }
    if (italicText.length > 0) {
      const lines = splitLines(italicText);
      parts.push(new GhostTextPart(insertColumn, lines, true));
    }
  }
  return new GhostText(lineNumber, parts, 0);
}
function cachingDiff(originalValue, newValue) {
  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {
    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;
  } else {
    const changes = smartDiff(originalValue, newValue);
    lastRequest = {
      originalValue,
      newValue,
      changes
    };
    return changes;
  }
}
function smartDiff(originalValue, newValue) {
  function getMaxCharCode(val) {
    let maxCharCode2 = 0;
    for (let i = 0, len = val.length; i < len; i++) {
      const charCode = val.charCodeAt(i);
      if (charCode > maxCharCode2) {
        maxCharCode2 = charCode;
      }
    }
    return maxCharCode2;
  }
  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));
  function getUniqueCharCode(id) {
    if (id < 0) {
      throw new Error("unexpected");
    }
    return maxCharCode + id + 1;
  }
  function getElements(source) {
    let level = 0;
    let group = 0;
    const characters = new Int32Array(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      const id = group * 100 + level;
      if (source[i] === "(") {
        characters[i] = getUniqueCharCode(2 * id);
        level++;
      } else if (source[i] === ")") {
        characters[i] = getUniqueCharCode(2 * id + 1);
        if (level === 1) {
          group++;
        }
        level = Math.max(level - 1, 0);
      } else {
        characters[i] = source.charCodeAt(i);
      }
    }
    return characters;
  }
  const elements1 = getElements(originalValue);
  const elements2 = getElements(newValue);
  return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;
}
var lastRequest;
var init_inlineCompletionToGhostText = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionToGhostText.js"() {
    init_diff();
    init_strings();
    init_range();
    init_ghostText();
    lastRequest = void 0;
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsModel.js
function getDefaultRange(position, model) {
  const word = model.getWordAtPosition(position);
  const maxColumn = model.getLineMaxColumn(position.lineNumber);
  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(void 0, maxColumn));
}
function provideInlineCompletions(position, model, context, token = CancellationToken.None) {
  return __awaiter20(this, void 0, void 0, function* () {
    const defaultReplaceRange = getDefaultRange(position, model);
    const providers = InlineCompletionsProviderRegistry.all(model);
    const results = yield Promise.all(providers.map((provider) => __awaiter20(this, void 0, void 0, function* () {
      const completions = yield provider.provideInlineCompletions(model, position, context, token);
      return {
        completions,
        provider,
        dispose: () => {
          if (completions) {
            provider.freeInlineCompletions(completions);
          }
        }
      };
    })));
    const itemsByHash = /* @__PURE__ */ new Map();
    for (const result of results) {
      const completions = result.completions;
      if (completions) {
        for (const item of completions.items.map((item2) => ({
          text: item2.text,
          range: item2.range ? Range.lift(item2.range) : defaultReplaceRange,
          command: item2.command,
          sourceProvider: result.provider,
          sourceInlineCompletions: completions,
          sourceInlineCompletion: item2
        }))) {
          if (item.range.startLineNumber !== item.range.endLineNumber) {
            continue;
          }
          itemsByHash.set(JSON.stringify({ text: item.text, range: item.range }), item);
        }
      }
    }
    return {
      items: [...itemsByHash.values()],
      dispose: () => {
        for (const result of results) {
          result.dispose();
        }
      }
    };
  });
}
function minimizeInlineCompletion(model, inlineCompletion) {
  if (!inlineCompletion) {
    return inlineCompletion;
  }
  const valueToReplace = model.getValueInRange(inlineCompletion.range);
  const commonPrefixLen = commonPrefixLength(valueToReplace, inlineCompletion.text);
  const startOffset = model.getOffsetAt(inlineCompletion.range.getStartPosition()) + commonPrefixLen;
  const start = model.getPositionAt(startOffset);
  const remainingValueToReplace = valueToReplace.substr(commonPrefixLen);
  const commonSuffixLen = commonSuffixLength(remainingValueToReplace, inlineCompletion.text);
  const end = model.getPositionAt(Math.max(startOffset, model.getOffsetAt(inlineCompletion.range.getEndPosition()) - commonSuffixLen));
  return {
    range: Range.fromPositions(start, end),
    text: inlineCompletion.text.substr(commonPrefixLen, inlineCompletion.text.length - commonPrefixLen - commonSuffixLen)
  };
}
var __decorate25, __param25, __awaiter20, InlineCompletionsModel, InlineCompletionsSession, UpdateOperation, SynchronizedInlineCompletionsCache, CachedInlineCompletion;
var init_inlineCompletionsModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsModel.js"() {
    init_async();
    init_cancellation();
    init_errors();
    init_event();
    init_lifecycle();
    init_strings();
    init_coreCommands();
    init_editorExtensions();
    init_editOperation();
    init_range();
    init_modes();
    init_ghostText();
    init_commands();
    init_consts();
    init_inlineCompletionToGhostText();
    __decorate25 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param25 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter20 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    InlineCompletionsModel = class InlineCompletionsModel2 extends Disposable {
      constructor(editor2, cache, commandService) {
        super();
        this.editor = editor2;
        this.cache = cache;
        this.commandService = commandService;
        this.onDidChangeEmitter = new Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.completionSession = this._register(new MutableDisposable());
        this.active = false;
        this.disposed = false;
        this._register(commandService.onDidExecuteCommand((e) => {
          const commands = /* @__PURE__ */ new Set([
            UndoCommand.id,
            RedoCommand.id,
            CoreEditingCommands.Tab.id,
            CoreEditingCommands.DeleteLeft.id,
            CoreEditingCommands.DeleteRight.id,
            inlineSuggestCommitId,
            "acceptSelectedSuggestion"
          ]);
          if (commands.has(e.commandId) && editor2.hasTextFocus()) {
            this.handleUserInput();
          }
        }));
        this._register(this.editor.onDidType((e) => {
          this.handleUserInput();
        }));
        this._register(this.editor.onDidChangeCursorPosition((e) => {
          if (this.session && !this.session.isValid) {
            this.hide();
          }
        }));
        this._register(toDisposable(() => {
          this.disposed = true;
        }));
      }
      handleUserInput() {
        if (this.session && !this.session.isValid) {
          this.hide();
        }
        setTimeout(() => {
          if (this.disposed) {
            return;
          }
          this.startSessionIfTriggered();
        }, 0);
      }
      get session() {
        return this.completionSession.value;
      }
      get ghostText() {
        var _a5;
        return (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.ghostText;
      }
      get minReservedLineCount() {
        return this.session ? this.session.minReservedLineCount : 0;
      }
      setExpanded(expanded) {
        var _a5;
        (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.setExpanded(expanded);
      }
      setActive(active) {
        var _a5;
        this.active = active;
        if (active) {
          (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.scheduleAutomaticUpdate();
        }
      }
      startSessionIfTriggered() {
        const suggestOptions = this.editor.getOption(
          54
          /* inlineSuggest */
        );
        if (!suggestOptions.enabled) {
          return;
        }
        if (this.session && this.session.isValid) {
          return;
        }
        this.trigger(InlineCompletionTriggerKind.Automatic);
      }
      trigger(triggerKind) {
        if (this.completionSession.value) {
          if (triggerKind === InlineCompletionTriggerKind.Explicit) {
            void this.completionSession.value.ensureUpdateWithExplicitContext();
          }
          return;
        }
        this.completionSession.value = new InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind);
        this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {
          this.onDidChangeEmitter.fire();
        }));
      }
      hide() {
        this.completionSession.clear();
        this.onDidChangeEmitter.fire();
      }
      commitCurrentSuggestion() {
        var _a5;
        (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.commitCurrentCompletion();
      }
      showNext() {
        var _a5;
        (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.showNextInlineCompletion();
      }
      showPrevious() {
        var _a5;
        (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.showPreviousInlineCompletion();
      }
      hasMultipleInlineCompletions() {
        var _a5;
        return __awaiter20(this, void 0, void 0, function* () {
          const result = yield (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.hasMultipleInlineCompletions();
          return result !== void 0 ? result : false;
        });
      }
    };
    InlineCompletionsModel = __decorate25([
      __param25(2, ICommandService)
    ], InlineCompletionsModel);
    InlineCompletionsSession = class extends BaseGhostTextWidgetModel {
      constructor(editor2, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind) {
        super(editor2);
        this.triggerPosition = triggerPosition;
        this.shouldUpdate = shouldUpdate;
        this.commandService = commandService;
        this.cache = cache;
        this.initialTriggerKind = initialTriggerKind;
        this.minReservedLineCount = 0;
        this.updateOperation = this._register(new MutableDisposable());
        this.updateSoon = this._register(new RunOnceScheduler(() => {
          let triggerKind = this.initialTriggerKind;
          this.initialTriggerKind = InlineCompletionTriggerKind.Automatic;
          return this.update(triggerKind);
        }, 50));
        this.currentlySelectedCompletionId = void 0;
        let lastCompletionItem = void 0;
        this._register(this.onDidChange(() => {
          const currentCompletion = this.currentCompletion;
          if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {
            lastCompletionItem = currentCompletion.sourceInlineCompletion;
            const provider = currentCompletion.sourceProvider;
            if (provider.handleItemDidShow) {
              provider.handleItemDidShow(currentCompletion.sourceInlineCompletions, lastCompletionItem);
            }
          }
        }));
        this._register(toDisposable(() => {
          this.cache.clear();
        }));
        this._register(this.editor.onDidChangeCursorPosition((e) => {
          if (this.cache.value) {
            this.onDidChangeEmitter.fire();
          }
        }));
        this._register(this.editor.onDidChangeModelContent((e) => {
          this.scheduleAutomaticUpdate();
        }));
        this._register(InlineCompletionsProviderRegistry.onDidChange(() => {
          this.updateSoon.schedule();
        }));
        this.scheduleAutomaticUpdate();
      }
      fixAndGetIndexOfCurrentSelection() {
        if (!this.currentlySelectedCompletionId || !this.cache.value) {
          return 0;
        }
        if (this.cache.value.completions.length === 0) {
          return 0;
        }
        const idx = this.cache.value.completions.findIndex((v) => v.semanticId === this.currentlySelectedCompletionId);
        if (idx === -1) {
          this.currentlySelectedCompletionId = void 0;
          return 0;
        }
        return idx;
      }
      get currentCachedCompletion() {
        if (!this.cache.value) {
          return void 0;
        }
        return this.cache.value.completions[this.fixAndGetIndexOfCurrentSelection()];
      }
      showNextInlineCompletion() {
        var _a5;
        return __awaiter20(this, void 0, void 0, function* () {
          yield this.ensureUpdateWithExplicitContext();
          const completions = ((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions) || [];
          if (completions.length > 0) {
            const newIdx = (this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length;
            this.currentlySelectedCompletionId = completions[newIdx].semanticId;
          } else {
            this.currentlySelectedCompletionId = void 0;
          }
          this.onDidChangeEmitter.fire();
        });
      }
      showPreviousInlineCompletion() {
        var _a5;
        return __awaiter20(this, void 0, void 0, function* () {
          yield this.ensureUpdateWithExplicitContext();
          const completions = ((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions) || [];
          if (completions.length > 0) {
            const newIdx = (this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length;
            this.currentlySelectedCompletionId = completions[newIdx].semanticId;
          } else {
            this.currentlySelectedCompletionId = void 0;
          }
          this.onDidChangeEmitter.fire();
        });
      }
      ensureUpdateWithExplicitContext() {
        var _a5;
        return __awaiter20(this, void 0, void 0, function* () {
          if (this.updateOperation.value) {
            if (this.updateOperation.value.triggerKind === InlineCompletionTriggerKind.Explicit) {
              yield this.updateOperation.value.promise;
            } else {
              yield this.update(InlineCompletionTriggerKind.Explicit);
            }
          } else if (((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.triggerKind) !== InlineCompletionTriggerKind.Explicit) {
            yield this.update(InlineCompletionTriggerKind.Explicit);
          }
        });
      }
      hasMultipleInlineCompletions() {
        var _a5;
        return __awaiter20(this, void 0, void 0, function* () {
          yield this.ensureUpdateWithExplicitContext();
          return (((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions.length) || 0) > 1;
        });
      }
      //#endregion
      get ghostText() {
        const currentCompletion = this.currentCompletion;
        const mode = this.editor.getOptions().get(
          54
          /* inlineSuggest */
        ).mode;
        return currentCompletion ? inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, this.editor.getPosition()) : void 0;
      }
      get currentCompletion() {
        const completion = this.currentCachedCompletion;
        if (!completion) {
          return void 0;
        }
        return completion.toLiveInlineCompletion();
      }
      get isValid() {
        return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;
      }
      scheduleAutomaticUpdate() {
        this.updateOperation.clear();
        this.updateSoon.schedule();
      }
      update(triggerKind) {
        return __awaiter20(this, void 0, void 0, function* () {
          if (!this.shouldUpdate()) {
            return;
          }
          const position = this.editor.getPosition();
          const promise = createCancelablePromise((token) => __awaiter20(this, void 0, void 0, function* () {
            let result;
            try {
              result = yield provideInlineCompletions(position, this.editor.getModel(), { triggerKind, selectedSuggestionInfo: void 0 }, token);
            } catch (e) {
              onUnexpectedError(e);
              return;
            }
            if (token.isCancellationRequested) {
              return;
            }
            this.cache.setValue(this.editor, result, triggerKind);
            this.onDidChangeEmitter.fire();
          }));
          const operation = new UpdateOperation(promise, triggerKind);
          this.updateOperation.value = operation;
          yield promise;
          if (this.updateOperation.value === operation) {
            this.updateOperation.clear();
          }
        });
      }
      takeOwnership(disposable) {
        this._register(disposable);
      }
      commitCurrentCompletion() {
        if (!this.ghostText) {
          return;
        }
        const completion = this.currentCompletion;
        if (completion) {
          this.commit(completion);
        }
      }
      commit(completion) {
        const cache = this.cache.clearAndLeak();
        this.editor.executeEdits("inlineSuggestion.accept", [
          EditOperation.replaceMove(completion.range, completion.text)
        ]);
        if (completion.command) {
          this.commandService.executeCommand(completion.command.id, ...completion.command.arguments || []).finally(() => {
            cache === null || cache === void 0 ? void 0 : cache.dispose();
          }).then(void 0, onUnexpectedExternalError);
        } else {
          cache === null || cache === void 0 ? void 0 : cache.dispose();
        }
        this.onDidChangeEmitter.fire();
      }
    };
    UpdateOperation = class {
      constructor(promise, triggerKind) {
        this.promise = promise;
        this.triggerKind = triggerKind;
      }
      dispose() {
        this.promise.cancel();
      }
    };
    SynchronizedInlineCompletionsCache = class extends Disposable {
      constructor(editor2, completionsSource, onChange, triggerKind) {
        super();
        this.triggerKind = triggerKind;
        const decorationIds = editor2.deltaDecorations([], completionsSource.items.map((i) => ({
          range: i.range,
          options: {
            description: "inline-completion-tracking-range"
          }
        })));
        this._register(toDisposable(() => {
          editor2.deltaDecorations(decorationIds, []);
        }));
        this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));
        this._register(editor2.onDidChangeModelContent(() => {
          let hasChanged = false;
          const model = editor2.getModel();
          for (const c of this.completions) {
            const newRange = model.getDecorationRange(c.decorationId);
            if (!newRange) {
              onUnexpectedError(new Error("Decoration has no range"));
              continue;
            }
            if (!c.synchronizedRange.equalsRange(newRange)) {
              hasChanged = true;
              c.synchronizedRange = newRange;
            }
          }
          if (hasChanged) {
            onChange();
          }
        }));
        this._register(completionsSource);
      }
    };
    CachedInlineCompletion = class {
      constructor(inlineCompletion, decorationId) {
        this.inlineCompletion = inlineCompletion;
        this.decorationId = decorationId;
        this.semanticId = JSON.stringify({
          text: this.inlineCompletion.text,
          startLine: this.inlineCompletion.range.startLineNumber,
          startColumn: this.inlineCompletion.range.startColumn,
          command: this.inlineCompletion.command
        });
        this.synchronizedRange = inlineCompletion.range;
      }
      toLiveInlineCompletion() {
        return {
          text: this.inlineCompletion.text,
          range: this.synchronizedRange,
          command: this.inlineCompletion.command,
          sourceProvider: this.inlineCompletion.sourceProvider,
          sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,
          sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion
        };
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetParser.js
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var Scanner, Marker, Text, TransformableMarker, Placeholder, Choice, Transform, FormatString, Variable, TextmateSnippet, SnippetParser;
var init_snippetParser = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetParser.js"() {
    Scanner = class _Scanner {
      constructor() {
        this.value = "";
        this.pos = 0;
      }
      static isDigitCharacter(ch) {
        return ch >= 48 && ch <= 57;
      }
      static isVariableCharacter(ch) {
        return ch === 95 || ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
      }
      text(value) {
        this.value = value;
        this.pos = 0;
      }
      tokenText(token) {
        return this.value.substr(token.pos, token.len);
      }
      next() {
        if (this.pos >= this.value.length) {
          return { type: 14, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        type = _Scanner._table[ch];
        if (typeof type === "number") {
          this.pos += 1;
          return { type, pos, len: 1 };
        }
        if (_Scanner.isDigitCharacter(ch)) {
          type = 8;
          do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
          } while (_Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        if (_Scanner.isVariableCharacter(ch)) {
          type = 9;
          do {
            ch = this.value.charCodeAt(pos + ++len);
          } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        type = 10;
        do {
          len += 1;
          ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
        this.pos += len;
        return { type, pos, len };
      }
    };
    Scanner._table = {
      [
        36
        /* DollarSign */
      ]: 0,
      [
        58
        /* Colon */
      ]: 1,
      [
        44
        /* Comma */
      ]: 2,
      [
        123
        /* OpenCurlyBrace */
      ]: 3,
      [
        125
        /* CloseCurlyBrace */
      ]: 4,
      [
        92
        /* Backslash */
      ]: 5,
      [
        47
        /* Slash */
      ]: 6,
      [
        124
        /* Pipe */
      ]: 7,
      [
        43
        /* Plus */
      ]: 11,
      [
        45
        /* Dash */
      ]: 12,
      [
        63
        /* QuestionMark */
      ]: 13
    };
    Marker = class {
      constructor() {
        this._children = [];
      }
      appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
          this._children[this._children.length - 1].value += child.value;
        } else {
          child.parent = this;
          this._children.push(child);
        }
        return this;
      }
      replace(child, others) {
        const { parent } = child;
        const idx = parent.children.indexOf(child);
        const newChildren = parent.children.slice(0);
        newChildren.splice(idx, 1, ...others);
        parent._children = newChildren;
        (function _fixParent(children, parent2) {
          for (const child2 of children) {
            child2.parent = parent2;
            _fixParent(child2.children, child2);
          }
        })(others, parent);
      }
      get children() {
        return this._children;
      }
      get snippet() {
        let candidate = this;
        while (true) {
          if (!candidate) {
            return void 0;
          }
          if (candidate instanceof TextmateSnippet) {
            return candidate;
          }
          candidate = candidate.parent;
        }
      }
      toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), "");
      }
      len() {
        return 0;
      }
    };
    Text = class _Text extends Marker {
      constructor(value) {
        super();
        this.value = value;
      }
      toString() {
        return this.value;
      }
      len() {
        return this.value.length;
      }
      clone() {
        return new _Text(this.value);
      }
    };
    TransformableMarker = class extends Marker {
    };
    Placeholder = class _Placeholder extends TransformableMarker {
      constructor(index) {
        super();
        this.index = index;
      }
      static compareByIndex(a, b) {
        if (a.index === b.index) {
          return 0;
        } else if (a.isFinalTabstop) {
          return 1;
        } else if (b.isFinalTabstop) {
          return -1;
        } else if (a.index < b.index) {
          return -1;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return 0;
        }
      }
      get isFinalTabstop() {
        return this.index === 0;
      }
      get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
      }
      clone() {
        let ret = new _Placeholder(this.index);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    Choice = class _Choice extends Marker {
      constructor() {
        super(...arguments);
        this.options = [];
      }
      appendChild(marker) {
        if (marker instanceof Text) {
          marker.parent = this;
          this.options.push(marker);
        }
        return this;
      }
      toString() {
        return this.options[0].value;
      }
      len() {
        return this.options[0].len();
      }
      clone() {
        let ret = new _Choice();
        this.options.forEach(ret.appendChild, ret);
        return ret;
      }
    };
    Transform = class _Transform extends Marker {
      constructor() {
        super(...arguments);
        this.regexp = new RegExp("");
      }
      resolve(value) {
        const _this = this;
        let didMatch = false;
        let ret = value.replace(this.regexp, function() {
          didMatch = true;
          return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
        });
        if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
          ret = this._replace([]);
        }
        return ret;
      }
      _replace(groups) {
        let ret = "";
        for (const marker of this._children) {
          if (marker instanceof FormatString) {
            let value = groups[marker.index] || "";
            value = marker.resolve(value);
            ret += value;
          } else {
            ret += marker.toString();
          }
        }
        return ret;
      }
      toString() {
        return "";
      }
      clone() {
        let ret = new _Transform();
        ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    FormatString = class _FormatString extends Marker {
      constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (this.shorthandName === "upcase") {
          return !value ? "" : value.toLocaleUpperCase();
        } else if (this.shorthandName === "downcase") {
          return !value ? "" : value.toLocaleLowerCase();
        } else if (this.shorthandName === "capitalize") {
          return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
        } else if (this.shorthandName === "pascalcase") {
          return !value ? "" : this._toPascalCase(value);
        } else if (this.shorthandName === "camelcase") {
          return !value ? "" : this._toCamelCase(value);
        } else if (Boolean(value) && typeof this.ifValue === "string") {
          return this.ifValue;
        } else if (!Boolean(value) && typeof this.elseValue === "string") {
          return this.elseValue;
        } else {
          return value || "";
        }
      }
      _toPascalCase(value) {
        const match = value.match(/[a-z0-9]+/gi);
        if (!match) {
          return value;
        }
        return match.map((word) => {
          return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
        }).join("");
      }
      _toCamelCase(value) {
        const match = value.match(/[a-z0-9]+/gi);
        if (!match) {
          return value;
        }
        return match.map((word, index) => {
          if (index === 0) {
            return word.toLowerCase();
          } else {
            return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
          }
        }).join("");
      }
      clone() {
        let ret = new _FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
      }
    };
    Variable = class _Variable extends TransformableMarker {
      constructor(name) {
        super();
        this.name = name;
      }
      resolve(resolver) {
        let value = resolver.resolve(this);
        if (this.transform) {
          value = this.transform.resolve(value || "");
        }
        if (value !== void 0) {
          this._children = [new Text(value)];
          return true;
        }
        return false;
      }
      clone() {
        const ret = new _Variable(this.name);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    TextmateSnippet = class _TextmateSnippet extends Marker {
      get placeholderInfo() {
        if (!this._placeholders) {
          let all = [];
          let last;
          this.walk(function(candidate) {
            if (candidate instanceof Placeholder) {
              all.push(candidate);
              last = !last || last.index < candidate.index ? candidate : last;
            }
            return true;
          });
          this._placeholders = { all, last };
        }
        return this._placeholders;
      }
      get placeholders() {
        const { all } = this.placeholderInfo;
        return all;
      }
      offset(marker) {
        let pos = 0;
        let found = false;
        this.walk((candidate) => {
          if (candidate === marker) {
            found = true;
            return false;
          }
          pos += candidate.len();
          return true;
        });
        if (!found) {
          return -1;
        }
        return pos;
      }
      fullLen(marker) {
        let ret = 0;
        walk([marker], (marker2) => {
          ret += marker2.len();
          return true;
        });
        return ret;
      }
      enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
          if (parent instanceof Placeholder) {
            ret.push(parent);
          }
          parent = parent.parent;
        }
        return ret;
      }
      resolveVariables(resolver) {
        this.walk((candidate) => {
          if (candidate instanceof Variable) {
            if (candidate.resolve(resolver)) {
              this._placeholders = void 0;
            }
          }
          return true;
        });
        return this;
      }
      appendChild(child) {
        this._placeholders = void 0;
        return super.appendChild(child);
      }
      replace(child, others) {
        this._placeholders = void 0;
        return super.replace(child, others);
      }
      clone() {
        let ret = new _TextmateSnippet();
        this._children = this.children.map((child) => child.clone());
        return ret;
      }
      walk(visitor) {
        walk(this.children, visitor);
      }
    };
    SnippetParser = class {
      constructor() {
        this._scanner = new Scanner();
        this._token = { type: 14, pos: 0, len: 0 };
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      static guessNeedsClipboard(template) {
        return /\${?CLIPBOARD/.test(template);
      }
      parse(value, insertFinalTabstop, enforceFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet();
        while (this._parse(snippet)) {
        }
        const placeholderDefaultValues = /* @__PURE__ */ new Map();
        const incompletePlaceholders = [];
        let placeholderCount = 0;
        snippet.walk((marker) => {
          if (marker instanceof Placeholder) {
            placeholderCount += 1;
            if (marker.isFinalTabstop) {
              placeholderDefaultValues.set(0, void 0);
            } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
              placeholderDefaultValues.set(marker.index, marker.children);
            } else {
              incompletePlaceholders.push(marker);
            }
          }
          return true;
        });
        for (const placeholder of incompletePlaceholders) {
          const defaultValues = placeholderDefaultValues.get(placeholder.index);
          if (defaultValues) {
            const clone2 = new Placeholder(placeholder.index);
            clone2.transform = placeholder.transform;
            for (const child of defaultValues) {
              clone2.appendChild(child.clone());
            }
            snippet.replace(placeholder, [clone2]);
          }
        }
        if (!enforceFinalTabstop) {
          enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;
        }
        if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {
          snippet.appendChild(new Placeholder(0));
        }
        return snippet;
      }
      _accept(type, value) {
        if (type === void 0 || this._token.type === type) {
          let ret = !value ? true : this._scanner.tokenText(this._token);
          this._token = this._scanner.next();
          return ret;
        }
        return false;
      }
      _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
      }
      _until(type) {
        const start = this._token;
        while (this._token.type !== type) {
          if (this._token.type === 14) {
            return false;
          } else if (this._token.type === 5) {
            const nextToken = this._scanner.next();
            if (nextToken.type !== 0 && nextToken.type !== 4 && nextToken.type !== 5) {
              return false;
            }
          }
          this._token = this._scanner.next();
        }
        const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
        this._token = this._scanner.next();
        return value;
      }
      _parse(marker) {
        return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
      }
      // \$, \\, \} -> just text
      _parseEscaped(marker) {
        let value;
        if (value = this._accept(5, true)) {
          value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
          marker.appendChild(new Text(value));
          return true;
        }
        return false;
      }
      // $foo -> variable, $1 -> tabstop
      _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(
          0
          /* Dollar */
        ) && (value = this._accept(9, true) || this._accept(8, true));
        if (!match) {
          return this._backTo(token);
        }
        parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
        return true;
      }
      // ${1:<children>}, ${1} -> placeholder
      _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(
          0
          /* Dollar */
        ) && this._accept(
          3
          /* CurlyOpen */
        ) && (index = this._accept(8, true));
        if (!match) {
          return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(
          1
          /* Colon */
        )) {
          while (true) {
            if (this._accept(
              4
              /* CurlyClose */
            )) {
              parent.appendChild(placeholder);
              return true;
            }
            if (this._parse(placeholder)) {
              continue;
            }
            parent.appendChild(new Text("${" + index + ":"));
            placeholder.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (placeholder.index > 0 && this._accept(
          7
          /* Pipe */
        )) {
          const choice = new Choice();
          while (true) {
            if (this._parseChoiceElement(choice)) {
              if (this._accept(
                2
                /* Comma */
              )) {
                continue;
              }
              if (this._accept(
                7
                /* Pipe */
              )) {
                placeholder.appendChild(choice);
                if (this._accept(
                  4
                  /* CurlyClose */
                )) {
                  parent.appendChild(placeholder);
                  return true;
                }
              }
            }
            this._backTo(token);
            return false;
          }
        } else if (this._accept(
          6
          /* Forwardslash */
        )) {
          if (this._parseTransform(placeholder)) {
            parent.appendChild(placeholder);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(
          4
          /* CurlyClose */
        )) {
          parent.appendChild(placeholder);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        while (true) {
          if (this._token.type === 2 || this._token.type === 7) {
            break;
          }
          let value;
          if (value = this._accept(5, true)) {
            value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
          } else {
            value = this._accept(void 0, true);
          }
          if (!value) {
            this._backTo(token);
            return false;
          }
          values.push(value);
        }
        if (values.length === 0) {
          this._backTo(token);
          return false;
        }
        parent.appendChild(new Text(values.join("")));
        return true;
      }
      // ${foo:<children>}, ${foo} -> variable
      _parseComplexVariable(parent) {
        let name;
        const token = this._token;
        const match = this._accept(
          0
          /* Dollar */
        ) && this._accept(
          3
          /* CurlyOpen */
        ) && (name = this._accept(9, true));
        if (!match) {
          return this._backTo(token);
        }
        const variable = new Variable(name);
        if (this._accept(
          1
          /* Colon */
        )) {
          while (true) {
            if (this._accept(
              4
              /* CurlyClose */
            )) {
              parent.appendChild(variable);
              return true;
            }
            if (this._parse(variable)) {
              continue;
            }
            parent.appendChild(new Text("${" + name + ":"));
            variable.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (this._accept(
          6
          /* Forwardslash */
        )) {
          if (this._parseTransform(variable)) {
            parent.appendChild(variable);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(
          4
          /* CurlyClose */
        )) {
          parent.appendChild(variable);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseTransform(parent) {
        let transform = new Transform();
        let regexValue = "";
        let regexOptions = "";
        while (true) {
          if (this._accept(
            6
            /* Forwardslash */
          )) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5, true)) {
            escaped = this._accept(6, true) || escaped;
            regexValue += escaped;
            continue;
          }
          if (this._token.type !== 14) {
            regexValue += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(
            6
            /* Forwardslash */
          )) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5, true)) {
            escaped = this._accept(5, true) || this._accept(6, true) || escaped;
            transform.appendChild(new Text(escaped));
            continue;
          }
          if (this._parseFormatString(transform) || this._parseAnything(transform)) {
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(
            4
            /* CurlyClose */
          )) {
            break;
          }
          if (this._token.type !== 14) {
            regexOptions += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        try {
          transform.regexp = new RegExp(regexValue, regexOptions);
        } catch (e) {
          return false;
        }
        parent.transform = transform;
        return true;
      }
      _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(
          0
          /* Dollar */
        )) {
          return false;
        }
        let complex = false;
        if (this._accept(
          3
          /* CurlyOpen */
        )) {
          complex = true;
        }
        let index = this._accept(8, true);
        if (!index) {
          this._backTo(token);
          return false;
        } else if (!complex) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (this._accept(
          4
          /* CurlyClose */
        )) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (!this._accept(
          1
          /* Colon */
        )) {
          this._backTo(token);
          return false;
        }
        if (this._accept(
          6
          /* Forwardslash */
        )) {
          let shorthand = this._accept(9, true);
          if (!shorthand || !this._accept(
            4
            /* CurlyClose */
          )) {
            this._backTo(token);
            return false;
          } else {
            parent.appendChild(new FormatString(Number(index), shorthand));
            return true;
          }
        } else if (this._accept(
          11
          /* Plus */
        )) {
          let ifValue = this._until(
            4
            /* CurlyClose */
          );
          if (ifValue) {
            parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
            return true;
          }
        } else if (this._accept(
          12
          /* Dash */
        )) {
          let elseValue = this._until(
            4
            /* CurlyClose */
          );
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        } else if (this._accept(
          13
          /* QuestionMark */
        )) {
          let ifValue = this._until(
            1
            /* Colon */
          );
          if (ifValue) {
            let elseValue = this._until(
              4
              /* CurlyClose */
            );
            if (elseValue) {
              parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
              return true;
            }
          }
        } else {
          let elseValue = this._until(
            4
            /* CurlyClose */
          );
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseAnything(marker) {
        if (this._token.type !== 14) {
          marker.appendChild(new Text(this._scanner.tokenText(this._token)));
          this._accept(void 0);
          return true;
        }
        return false;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/uuid.js
function generateUuid() {
  _fillRandomValues(_data);
  _data[6] = _data[6] & 15 | 64;
  _data[8] = _data[8] & 63 | 128;
  let i = 0;
  let result = "";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  return result;
}
var _data, _hex, _fillRandomValues;
var init_uuid = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/uuid.js"() {
    _data = new Uint8Array(16);
    _hex = [];
    for (let i = 0; i < 256; i++) {
      _hex.push(i.toString(16).padStart(2, "0"));
    }
    if (typeof crypto === "object" && typeof crypto.getRandomValues === "function") {
      _fillRandomValues = crypto.getRandomValues.bind(crypto);
    } else {
      _fillRandomValues = function(bucket) {
        for (let i = 0; i < bucket.length; i++) {
          bucket[i] = Math.floor(Math.random() * 256);
        }
        return bucket;
      };
    }
  }
});

// node_modules/monaco-editor/esm/vs/platform/workspaces/common/workspaces.js
function isSingleFolderWorkspaceIdentifier(obj) {
  const singleFolderIdentifier = obj;
  return typeof (singleFolderIdentifier === null || singleFolderIdentifier === void 0 ? void 0 : singleFolderIdentifier.id) === "string" && URI.isUri(singleFolderIdentifier.uri);
}
function toWorkspaceIdentifier(workspace) {
  if (workspace.configuration) {
    return {
      id: workspace.id,
      configPath: workspace.configuration
    };
  }
  if (workspace.folders.length === 1) {
    return {
      id: workspace.id,
      uri: workspace.folders[0].uri
    };
  }
  return void 0;
}
var WORKSPACE_EXTENSION;
var init_workspaces = __esm({
  "node_modules/monaco-editor/esm/vs/platform/workspaces/common/workspaces.js"() {
    init_uri();
    WORKSPACE_EXTENSION = "code-workspace";
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetVariables.js
var CompositeSnippetVariableResolver, SelectionBasedVariableResolver, ModelBasedVariableResolver, ClipboardBasedVariableResolver, CommentBasedVariableResolver, TimeBasedVariableResolver, WorkspaceBasedVariableResolver, RandomBasedVariableResolver;
var init_snippetVariables = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetVariables.js"() {
    init_labels();
    init_path();
    init_resources();
    init_strings();
    init_uuid();
    init_languageConfigurationRegistry();
    init_snippetParser();
    init_nls();
    init_workspaces();
    CompositeSnippetVariableResolver = class {
      constructor(_delegates) {
        this._delegates = _delegates;
      }
      resolve(variable) {
        for (const delegate of this._delegates) {
          let value = delegate.resolve(variable);
          if (value !== void 0) {
            return value;
          }
        }
        return void 0;
      }
    };
    SelectionBasedVariableResolver = class {
      constructor(_model, _selection, _selectionIdx, _overtypingCapturer) {
        this._model = _model;
        this._selection = _selection;
        this._selectionIdx = _selectionIdx;
        this._overtypingCapturer = _overtypingCapturer;
      }
      resolve(variable) {
        const { name } = variable;
        if (name === "SELECTION" || name === "TM_SELECTED_TEXT") {
          let value = this._model.getValueInRange(this._selection) || void 0;
          let isMultiline = this._selection.startLineNumber !== this._selection.endLineNumber;
          if (!value && this._overtypingCapturer) {
            const info = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
            if (info) {
              value = info.value;
              isMultiline = info.multiline;
            }
          }
          if (value && isMultiline && variable.snippet) {
            const line = this._model.getLineContent(this._selection.startLineNumber);
            const lineLeadingWhitespace = getLeadingWhitespace(line, 0, this._selection.startColumn - 1);
            let varLeadingWhitespace = lineLeadingWhitespace;
            variable.snippet.walk((marker) => {
              if (marker === variable) {
                return false;
              }
              if (marker instanceof Text) {
                varLeadingWhitespace = getLeadingWhitespace(splitLines(marker.value).pop());
              }
              return true;
            });
            const whitespaceCommonLength = commonPrefixLength(varLeadingWhitespace, lineLeadingWhitespace);
            value = value.replace(/(\r\n|\r|\n)(.*)/g, (m, newline, rest) => `${newline}${varLeadingWhitespace.substr(whitespaceCommonLength)}${rest}`);
          }
          return value;
        } else if (name === "TM_CURRENT_LINE") {
          return this._model.getLineContent(this._selection.positionLineNumber);
        } else if (name === "TM_CURRENT_WORD") {
          const info = this._model.getWordAtPosition({
            lineNumber: this._selection.positionLineNumber,
            column: this._selection.positionColumn
          });
          return info && info.word || void 0;
        } else if (name === "TM_LINE_INDEX") {
          return String(this._selection.positionLineNumber - 1);
        } else if (name === "TM_LINE_NUMBER") {
          return String(this._selection.positionLineNumber);
        }
        return void 0;
      }
    };
    ModelBasedVariableResolver = class {
      constructor(_labelService, _model) {
        this._labelService = _labelService;
        this._model = _model;
      }
      resolve(variable) {
        const { name } = variable;
        if (name === "TM_FILENAME") {
          return basename(this._model.uri.fsPath);
        } else if (name === "TM_FILENAME_BASE") {
          const name2 = basename(this._model.uri.fsPath);
          const idx = name2.lastIndexOf(".");
          if (idx <= 0) {
            return name2;
          } else {
            return name2.slice(0, idx);
          }
        } else if (name === "TM_DIRECTORY") {
          if (dirname(this._model.uri.fsPath) === ".") {
            return "";
          }
          return this._labelService.getUriLabel(dirname2(this._model.uri));
        } else if (name === "TM_FILEPATH") {
          return this._labelService.getUriLabel(this._model.uri);
        } else if (name === "RELATIVE_FILEPATH") {
          return this._labelService.getUriLabel(this._model.uri, { relative: true, noPrefix: true });
        }
        return void 0;
      }
    };
    ClipboardBasedVariableResolver = class {
      constructor(_readClipboardText, _selectionIdx, _selectionCount, _spread) {
        this._readClipboardText = _readClipboardText;
        this._selectionIdx = _selectionIdx;
        this._selectionCount = _selectionCount;
        this._spread = _spread;
      }
      resolve(variable) {
        if (variable.name !== "CLIPBOARD") {
          return void 0;
        }
        const clipboardText = this._readClipboardText();
        if (!clipboardText) {
          return void 0;
        }
        if (this._spread) {
          const lines = clipboardText.split(/\r\n|\n|\r/).filter((s) => !isFalsyOrWhitespace(s));
          if (lines.length === this._selectionCount) {
            return lines[this._selectionIdx];
          }
        }
        return clipboardText;
      }
    };
    CommentBasedVariableResolver = class {
      constructor(_model, _selection) {
        this._model = _model;
        this._selection = _selection;
      }
      resolve(variable) {
        const { name } = variable;
        const langId = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn);
        const config = LanguageConfigurationRegistry.getComments(langId);
        if (!config) {
          return void 0;
        }
        if (name === "LINE_COMMENT") {
          return config.lineCommentToken || void 0;
        } else if (name === "BLOCK_COMMENT_START") {
          return config.blockCommentStartToken || void 0;
        } else if (name === "BLOCK_COMMENT_END") {
          return config.blockCommentEndToken || void 0;
        }
        return void 0;
      }
    };
    TimeBasedVariableResolver = class _TimeBasedVariableResolver {
      constructor() {
        this._date = /* @__PURE__ */ new Date();
      }
      resolve(variable) {
        const { name } = variable;
        if (name === "CURRENT_YEAR") {
          return String(this._date.getFullYear());
        } else if (name === "CURRENT_YEAR_SHORT") {
          return String(this._date.getFullYear()).slice(-2);
        } else if (name === "CURRENT_MONTH") {
          return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
        } else if (name === "CURRENT_DATE") {
          return String(this._date.getDate().valueOf()).padStart(2, "0");
        } else if (name === "CURRENT_HOUR") {
          return String(this._date.getHours().valueOf()).padStart(2, "0");
        } else if (name === "CURRENT_MINUTE") {
          return String(this._date.getMinutes().valueOf()).padStart(2, "0");
        } else if (name === "CURRENT_SECOND") {
          return String(this._date.getSeconds().valueOf()).padStart(2, "0");
        } else if (name === "CURRENT_DAY_NAME") {
          return _TimeBasedVariableResolver.dayNames[this._date.getDay()];
        } else if (name === "CURRENT_DAY_NAME_SHORT") {
          return _TimeBasedVariableResolver.dayNamesShort[this._date.getDay()];
        } else if (name === "CURRENT_MONTH_NAME") {
          return _TimeBasedVariableResolver.monthNames[this._date.getMonth()];
        } else if (name === "CURRENT_MONTH_NAME_SHORT") {
          return _TimeBasedVariableResolver.monthNamesShort[this._date.getMonth()];
        } else if (name === "CURRENT_SECONDS_UNIX") {
          return String(Math.floor(this._date.getTime() / 1e3));
        }
        return void 0;
      }
    };
    TimeBasedVariableResolver.dayNames = [localize("Sunday", "Sunday"), localize("Monday", "Monday"), localize("Tuesday", "Tuesday"), localize("Wednesday", "Wednesday"), localize("Thursday", "Thursday"), localize("Friday", "Friday"), localize("Saturday", "Saturday")];
    TimeBasedVariableResolver.dayNamesShort = [localize("SundayShort", "Sun"), localize("MondayShort", "Mon"), localize("TuesdayShort", "Tue"), localize("WednesdayShort", "Wed"), localize("ThursdayShort", "Thu"), localize("FridayShort", "Fri"), localize("SaturdayShort", "Sat")];
    TimeBasedVariableResolver.monthNames = [localize("January", "January"), localize("February", "February"), localize("March", "March"), localize("April", "April"), localize("May", "May"), localize("June", "June"), localize("July", "July"), localize("August", "August"), localize("September", "September"), localize("October", "October"), localize("November", "November"), localize("December", "December")];
    TimeBasedVariableResolver.monthNamesShort = [localize("JanuaryShort", "Jan"), localize("FebruaryShort", "Feb"), localize("MarchShort", "Mar"), localize("AprilShort", "Apr"), localize("MayShort", "May"), localize("JuneShort", "Jun"), localize("JulyShort", "Jul"), localize("AugustShort", "Aug"), localize("SeptemberShort", "Sep"), localize("OctoberShort", "Oct"), localize("NovemberShort", "Nov"), localize("DecemberShort", "Dec")];
    WorkspaceBasedVariableResolver = class {
      constructor(_workspaceService) {
        this._workspaceService = _workspaceService;
      }
      resolve(variable) {
        if (!this._workspaceService) {
          return void 0;
        }
        const workspaceIdentifier = toWorkspaceIdentifier(this._workspaceService.getWorkspace());
        if (!workspaceIdentifier) {
          return void 0;
        }
        if (variable.name === "WORKSPACE_NAME") {
          return this._resolveWorkspaceName(workspaceIdentifier);
        } else if (variable.name === "WORKSPACE_FOLDER") {
          return this._resoveWorkspacePath(workspaceIdentifier);
        }
        return void 0;
      }
      _resolveWorkspaceName(workspaceIdentifier) {
        if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
          return basename(workspaceIdentifier.uri.path);
        }
        let filename = basename(workspaceIdentifier.configPath.path);
        if (filename.endsWith(WORKSPACE_EXTENSION)) {
          filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
        }
        return filename;
      }
      _resoveWorkspacePath(workspaceIdentifier) {
        if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
          return normalizeDriveLetter(workspaceIdentifier.uri.fsPath);
        }
        let filename = basename(workspaceIdentifier.configPath.path);
        let folderpath = workspaceIdentifier.configPath.fsPath;
        if (folderpath.endsWith(filename)) {
          folderpath = folderpath.substr(0, folderpath.length - filename.length - 1);
        }
        return folderpath ? normalizeDriveLetter(folderpath) : "/";
      }
    };
    RandomBasedVariableResolver = class {
      resolve(variable) {
        const { name } = variable;
        if (name === "RANDOM") {
          return Math.random().toString().slice(-6);
        } else if (name === "RANDOM_HEX") {
          return Math.random().toString(16).slice(-6);
        } else if (name === "UUID") {
          return generateUuid();
        }
        return void 0;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js
var OneSnippet, _defaultOptions, SnippetSession;
var init_snippetSession = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js"() {
    init_arrays();
    init_lifecycle();
    init_strings();
    init_editOperation();
    init_range();
    init_selection();
    init_textModel();
    init_label();
    init_colorRegistry();
    init_themeService();
    init_workspace();
    init_snippetParser();
    init_snippetVariables();
    registerThemingParticipant((theme, collector) => {
      function getColorGraceful(name) {
        const color = theme.getColor(name);
        return color ? color.toString() : "transparent";
      }
      collector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(snippetTabstopHighlightBackground)}; outline-color: ${getColorGraceful(snippetTabstopHighlightBorder)}; }`);
      collector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(snippetFinalTabstopHighlightBackground)}; outline-color: ${getColorGraceful(snippetFinalTabstopHighlightBorder)}; }`);
    });
    OneSnippet = class _OneSnippet {
      constructor(_editor2, _snippet, _offset, _snippetLineLeadingWhitespace) {
        this._editor = _editor2;
        this._snippet = _snippet;
        this._offset = _offset;
        this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;
        this._nestingLevel = 1;
        this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);
        this._placeholderGroupsIdx = -1;
      }
      dispose() {
        if (this._placeholderDecorations) {
          this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);
        }
        this._placeholderGroups.length = 0;
      }
      _initDecorations() {
        if (this._placeholderDecorations) {
          return;
        }
        this._placeholderDecorations = /* @__PURE__ */ new Map();
        const model = this._editor.getModel();
        this._editor.changeDecorations((accessor) => {
          for (const placeholder of this._snippet.placeholders) {
            const placeholderOffset = this._snippet.offset(placeholder);
            const placeholderLen = this._snippet.fullLen(placeholder);
            const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));
            const options = placeholder.isFinalTabstop ? _OneSnippet._decor.inactiveFinal : _OneSnippet._decor.inactive;
            const handle = accessor.addDecoration(range, options);
            this._placeholderDecorations.set(placeholder, handle);
          }
        });
      }
      move(fwd) {
        if (!this._editor.hasModel()) {
          return [];
        }
        this._initDecorations();
        if (this._placeholderGroupsIdx >= 0) {
          let operations = [];
          for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
            if (placeholder.transform) {
              const id = this._placeholderDecorations.get(placeholder);
              const range = this._editor.getModel().getDecorationRange(id);
              const currentValue = this._editor.getModel().getValueInRange(range);
              const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\r\n|\r|\n/);
              for (let i = 1; i < transformedValueLines.length; i++) {
                transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);
              }
              operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));
            }
          }
          if (operations.length > 0) {
            this._editor.executeEdits("snippet.placeholderTransform", operations);
          }
        }
        let couldSkipThisPlaceholder = false;
        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {
          this._placeholderGroupsIdx += 1;
          couldSkipThisPlaceholder = true;
        } else if (fwd === false && this._placeholderGroupsIdx > 0) {
          this._placeholderGroupsIdx -= 1;
          couldSkipThisPlaceholder = true;
        } else {
        }
        const newSelections = this._editor.getModel().changeDecorations((accessor) => {
          const activePlaceholders = /* @__PURE__ */ new Set();
          const selections = [];
          for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
            const id = this._placeholderDecorations.get(placeholder);
            const range = this._editor.getModel().getDecorationRange(id);
            selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));
            couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);
            accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? _OneSnippet._decor.activeFinal : _OneSnippet._decor.active);
            activePlaceholders.add(placeholder);
            for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {
              const id2 = this._placeholderDecorations.get(enclosingPlaceholder);
              accessor.changeDecorationOptions(id2, enclosingPlaceholder.isFinalTabstop ? _OneSnippet._decor.activeFinal : _OneSnippet._decor.active);
              activePlaceholders.add(enclosingPlaceholder);
            }
          }
          for (const [placeholder, id] of this._placeholderDecorations) {
            if (!activePlaceholders.has(placeholder)) {
              accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? _OneSnippet._decor.inactiveFinal : _OneSnippet._decor.inactive);
            }
          }
          return selections;
        });
        return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);
      }
      _hasPlaceholderBeenCollapsed(placeholder) {
        let marker = placeholder;
        while (marker) {
          if (marker instanceof Placeholder) {
            const id = this._placeholderDecorations.get(marker);
            const range = this._editor.getModel().getDecorationRange(id);
            if (range.isEmpty() && marker.toString().length > 0) {
              return true;
            }
          }
          marker = marker.parent;
        }
        return false;
      }
      get isAtFirstPlaceholder() {
        return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
      }
      get isAtLastPlaceholder() {
        return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
      }
      get hasPlaceholder() {
        return this._snippet.placeholders.length > 0;
      }
      computePossibleSelections() {
        const result = /* @__PURE__ */ new Map();
        for (const placeholdersWithEqualIndex of this._placeholderGroups) {
          let ranges;
          for (const placeholder of placeholdersWithEqualIndex) {
            if (placeholder.isFinalTabstop) {
              break;
            }
            if (!ranges) {
              ranges = [];
              result.set(placeholder.index, ranges);
            }
            const id = this._placeholderDecorations.get(placeholder);
            const range = this._editor.getModel().getDecorationRange(id);
            if (!range) {
              result.delete(placeholder.index);
              break;
            }
            ranges.push(range);
          }
        }
        return result;
      }
      get choice() {
        return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;
      }
      merge(others) {
        const model = this._editor.getModel();
        this._nestingLevel *= 10;
        this._editor.changeDecorations((accessor) => {
          for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
            const nested = others.shift();
            console.assert(!nested._placeholderDecorations);
            const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;
            for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {
              if (nestedPlaceholder.isFinalTabstop) {
                nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;
              } else {
                nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;
              }
            }
            this._snippet.replace(placeholder, nested._snippet.children);
            const id = this._placeholderDecorations.get(placeholder);
            accessor.removeDecoration(id);
            this._placeholderDecorations.delete(placeholder);
            for (const placeholder2 of nested._snippet.placeholders) {
              const placeholderOffset = nested._snippet.offset(placeholder2);
              const placeholderLen = nested._snippet.fullLen(placeholder2);
              const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));
              const handle = accessor.addDecoration(range, _OneSnippet._decor.inactive);
              this._placeholderDecorations.set(placeholder2, handle);
            }
          }
          this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
        });
      }
    };
    OneSnippet._decor = {
      active: ModelDecorationOptions.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
      inactive: ModelDecorationOptions.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
      activeFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
      inactiveFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
    };
    _defaultOptions = {
      overwriteBefore: 0,
      overwriteAfter: 0,
      adjustWhitespace: true,
      clipboardText: void 0,
      overtypingCapturer: void 0
    };
    SnippetSession = class _SnippetSession {
      constructor(editor2, template, options = _defaultOptions) {
        this._templateMerges = [];
        this._snippets = [];
        this._editor = editor2;
        this._template = template;
        this._options = options;
      }
      static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {
        const line = model.getLineContent(position.lineNumber);
        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);
        let snippetTextString;
        snippet.walk((marker) => {
          if (!(marker instanceof Text) || marker.parent instanceof Choice) {
            return true;
          }
          const lines = marker.value.split(/\r\n|\r|\n/);
          if (adjustIndentation) {
            const offset = snippet.offset(marker);
            if (offset === 0) {
              lines[0] = model.normalizeIndentation(lines[0]);
            } else {
              snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();
              let prevChar = snippetTextString.charCodeAt(offset - 1);
              if (prevChar === 10 || prevChar === 13) {
                lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);
              }
            }
            for (let i = 1; i < lines.length; i++) {
              lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);
            }
          }
          const newValue = lines.join(model.getEOL());
          if (newValue !== marker.value) {
            marker.parent.replace(marker, [new Text(newValue)]);
            snippetTextString = void 0;
          }
          return true;
        });
        return lineLeadingWhitespace;
      }
      static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {
        if (overwriteBefore !== 0 || overwriteAfter !== 0) {
          const { positionLineNumber, positionColumn } = selection;
          const positionColumnBefore = positionColumn - overwriteBefore;
          const positionColumnAfter = positionColumn + overwriteAfter;
          const range = model.validateRange({
            startLineNumber: positionLineNumber,
            startColumn: positionColumnBefore,
            endLineNumber: positionLineNumber,
            endColumn: positionColumnAfter
          });
          selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());
        }
        return selection;
      }
      static createEditsAndSnippets(editor2, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {
        const edits = [];
        const snippets = [];
        if (!editor2.hasModel()) {
          return { edits, snippets };
        }
        const model = editor2.getModel();
        const workspaceService = editor2.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService));
        const modelBasedVariableResolver = editor2.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model));
        const readClipboardText = () => clipboardText;
        let delta = 0;
        let firstBeforeText = model.getValueInRange(_SnippetSession.adjustSelection(model, editor2.getSelection(), overwriteBefore, 0));
        let firstAfterText = model.getValueInRange(_SnippetSession.adjustSelection(model, editor2.getSelection(), 0, overwriteAfter));
        let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor2.getSelection().positionLineNumber);
        const indexedSelections = editor2.getSelections().map((selection, idx) => ({ selection, idx })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
        for (const { selection, idx } of indexedSelections) {
          let extensionBefore = _SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);
          let extensionAfter = _SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);
          if (firstBeforeText !== model.getValueInRange(extensionBefore)) {
            extensionBefore = selection;
          }
          if (firstAfterText !== model.getValueInRange(extensionAfter)) {
            extensionAfter = selection;
          }
          const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);
          const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);
          const start = snippetSelection.getStartPosition();
          const snippetLineLeadingWhitespace = _SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), true);
          snippet.resolveVariables(new CompositeSnippetVariableResolver([
            modelBasedVariableResolver,
            new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor2.getOption(
              70
              /* multiCursorPaste */
            ) === "spread"),
            new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),
            new CommentBasedVariableResolver(model, selection),
            new TimeBasedVariableResolver(),
            new WorkspaceBasedVariableResolver(workspaceService),
            new RandomBasedVariableResolver()
          ]));
          const offset = model.getOffsetAt(start) + delta;
          delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);
          edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());
          edits[idx].identifier = { major: idx, minor: 0 };
          snippets[idx] = new OneSnippet(editor2, snippet, offset, snippetLineLeadingWhitespace);
        }
        return { edits, snippets };
      }
      dispose() {
        dispose(this._snippets);
      }
      _logInfo() {
        return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
      }
      insert() {
        if (!this._editor.hasModel()) {
          return;
        }
        const { edits, snippets } = _SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);
        this._snippets = snippets;
        this._editor.executeEdits("snippet", edits, (undoEdits) => {
          if (this._snippets[0].hasPlaceholder) {
            return this._move(true);
          } else {
            return undoEdits.filter((edit) => !!edit.identifier).map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
          }
        });
        this._editor.revealRange(this._editor.getSelections()[0]);
      }
      merge(template, options = _defaultOptions) {
        if (!this._editor.hasModel()) {
          return;
        }
        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);
        const { edits, snippets } = _SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);
        this._editor.executeEdits("snippet", edits, (undoEdits) => {
          for (const snippet of this._snippets) {
            snippet.merge(snippets);
          }
          console.assert(snippets.length === 0);
          if (this._snippets[0].hasPlaceholder) {
            return this._move(void 0);
          } else {
            return undoEdits.filter((edit) => !!edit.identifier).map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
          }
        });
      }
      next() {
        const newSelections = this._move(true);
        this._editor.setSelections(newSelections);
        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
      }
      prev() {
        const newSelections = this._move(false);
        this._editor.setSelections(newSelections);
        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
      }
      _move(fwd) {
        const selections = [];
        for (const snippet of this._snippets) {
          const oneSelection = snippet.move(fwd);
          selections.push(...oneSelection);
        }
        return selections;
      }
      get isAtFirstPlaceholder() {
        return this._snippets[0].isAtFirstPlaceholder;
      }
      get isAtLastPlaceholder() {
        return this._snippets[0].isAtLastPlaceholder;
      }
      get hasPlaceholder() {
        return this._snippets[0].hasPlaceholder;
      }
      get choice() {
        return this._snippets[0].choice;
      }
      isSelectionWithinPlaceholders() {
        if (!this.hasPlaceholder) {
          return false;
        }
        const selections = this._editor.getSelections();
        if (selections.length < this._snippets.length) {
          return false;
        }
        let allPossibleSelections = /* @__PURE__ */ new Map();
        for (const snippet of this._snippets) {
          const possibleSelections = snippet.computePossibleSelections();
          if (allPossibleSelections.size === 0) {
            for (const [index, ranges] of possibleSelections) {
              ranges.sort(Range.compareRangesUsingStarts);
              for (const selection of selections) {
                if (ranges[0].containsRange(selection)) {
                  allPossibleSelections.set(index, []);
                  break;
                }
              }
            }
          }
          if (allPossibleSelections.size === 0) {
            return false;
          }
          allPossibleSelections.forEach((array, index) => {
            array.push(...possibleSelections.get(index));
          });
        }
        selections.sort(Range.compareRangesUsingStarts);
        for (let [index, ranges] of allPossibleSelections) {
          if (ranges.length !== selections.length) {
            allPossibleSelections.delete(index);
            continue;
          }
          ranges.sort(Range.compareRangesUsingStarts);
          for (let i = 0; i < ranges.length; i++) {
            if (!ranges[i].containsRange(selections[i])) {
              allPossibleSelections.delete(index);
              continue;
            }
          }
        }
        return allPossibleSelections.size > 0;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggest.js
function getSnippetSuggestSupport() {
  return _snippetSuggestSupport;
}
function provideSuggestionItems(model, position, options = CompletionOptions.default, context = {
  triggerKind: 0
  /* Invoke */
}, token = CancellationToken.None) {
  return __awaiter21(this, void 0, void 0, function* () {
    const sw = new StopWatch(true);
    position = position.clone();
    const word = model.getWordAtPosition(position);
    const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);
    const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };
    const result = [];
    const disposables = new DisposableStore();
    const durations = [];
    let needsClipboard = false;
    const onCompletionList = (provider, container, sw2) => {
      var _a5, _b2, _c2;
      if (!container) {
        return;
      }
      for (let suggestion of container.suggestions) {
        if (!options.kindFilter.has(suggestion.kind)) {
          if (!options.showDeprecated && ((_a5 = suggestion === null || suggestion === void 0 ? void 0 : suggestion.tags) === null || _a5 === void 0 ? void 0 : _a5.includes(
            1
            /* Deprecated */
          ))) {
            continue;
          }
          if (!suggestion.range) {
            suggestion.range = defaultRange;
          }
          if (!suggestion.sortText) {
            suggestion.sortText = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.label;
          }
          if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4) {
            needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
          }
          result.push(new CompletionItem(position, suggestion, container, provider));
        }
      }
      if (isDisposable(container)) {
        disposables.add(container);
      }
      durations.push({
        providerName: (_b2 = provider._debugDisplayName) !== null && _b2 !== void 0 ? _b2 : "unkown_provider",
        elapsedProvider: (_c2 = container.duration) !== null && _c2 !== void 0 ? _c2 : -1,
        elapsedOverall: sw2.elapsed()
      });
    };
    const snippetCompletions = (() => __awaiter21(this, void 0, void 0, function* () {
      if (!_snippetSuggestSupport || options.kindFilter.has(
        27
        /* Snippet */
      )) {
        return;
      }
      if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {
        return;
      }
      const sw2 = new StopWatch(true);
      const list = yield _snippetSuggestSupport.provideCompletionItems(model, position, context, token);
      onCompletionList(_snippetSuggestSupport, list, sw2);
    }))();
    for (let providerGroup of CompletionProviderRegistry.orderedGroups(model)) {
      let lenBefore = result.length;
      yield Promise.all(providerGroup.map((provider) => __awaiter21(this, void 0, void 0, function* () {
        if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {
          return;
        }
        try {
          const sw2 = new StopWatch(true);
          const list = yield provider.provideCompletionItems(model, position, context, token);
          onCompletionList(provider, list, sw2);
        } catch (err) {
          onUnexpectedExternalError(err);
        }
      })));
      if (lenBefore !== result.length || token.isCancellationRequested) {
        break;
      }
    }
    yield snippetCompletions;
    if (token.isCancellationRequested) {
      disposables.dispose();
      return Promise.reject(canceled());
    }
    return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);
  });
}
function defaultComparator(a, b) {
  if (a.sortTextLow && b.sortTextLow) {
    if (a.sortTextLow < b.sortTextLow) {
      return -1;
    } else if (a.sortTextLow > b.sortTextLow) {
      return 1;
    }
  }
  if (a.completion.label < b.completion.label) {
    return -1;
  } else if (a.completion.label > b.completion.label) {
    return 1;
  }
  return a.completion.kind - b.completion.kind;
}
function snippetUpComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return -1;
    } else if (b.completion.kind === 27) {
      return 1;
    }
  }
  return defaultComparator(a, b);
}
function snippetDownComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return 1;
    } else if (b.completion.kind === 27) {
      return -1;
    }
  }
  return defaultComparator(a, b);
}
function getSuggestionComparator(snippetConfig) {
  return _snippetComparators.get(snippetConfig);
}
function showSimpleSuggestions(editor2, suggestions) {
  setTimeout(() => {
    _provider.onlyOnceSuggestions.push(...suggestions);
    editor2.getContribution("editor.contrib.suggestController").triggerSuggest((/* @__PURE__ */ new Set()).add(_provider));
  }, 0);
}
var __awaiter21, Context, suggestWidgetStatusbarMenu, CompletionItem, CompletionOptions, _snippetSuggestSupport, CompletionItemModel, _snippetComparators, _provider;
var init_suggest = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggest.js"() {
    init_cancellation();
    init_errors();
    init_filters();
    init_lifecycle();
    init_stopwatch();
    init_types();
    init_uri();
    init_position();
    init_range();
    init_modes();
    init_resolverService();
    init_snippetParser();
    init_nls();
    init_actions2();
    init_commands();
    init_contextkey();
    __awaiter21 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Context = {
      Visible: new RawContextKey("suggestWidgetVisible", false, localize("suggestWidgetVisible", "Whether suggestion are visible")),
      DetailsVisible: new RawContextKey("suggestWidgetDetailsVisible", false, localize("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
      MultipleSuggestions: new RawContextKey("suggestWidgetMultipleSuggestions", false, localize("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
      MakesTextEdit: new RawContextKey("suggestionMakesTextEdit", true, localize("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
      AcceptSuggestionsOnEnter: new RawContextKey("acceptSuggestionOnEnter", true, localize("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
      HasInsertAndReplaceRange: new RawContextKey("suggestionHasInsertAndReplaceRange", false, localize("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
      InsertMode: new RawContextKey("suggestionInsertMode", void 0, { type: "string", description: localize("suggestionInsertMode", "Whether the default behaviour is to insert or replace") }),
      CanResolve: new RawContextKey("suggestionCanResolve", false, localize("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
    };
    suggestWidgetStatusbarMenu = new MenuId("suggestWidgetStatusBar");
    CompletionItem = class {
      constructor(position, completion, container, provider) {
        this.position = position;
        this.completion = completion;
        this.container = container;
        this.provider = provider;
        this.isInvalid = false;
        this.score = FuzzyScore.Default;
        this.distance = 0;
        this.textLabel = typeof completion.label === "string" ? completion.label : completion.label.label;
        this.labelLow = this.textLabel.toLowerCase();
        this.isInvalid = !this.textLabel;
        this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();
        this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();
        if (Range.isIRange(completion.range)) {
          this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);
          this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
          this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
          this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;
        } else {
          this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);
          this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);
          this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);
          this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;
        }
        if (typeof provider.resolveCompletionItem !== "function") {
          this._resolveCache = Promise.resolve();
          this._isResolved = true;
        }
      }
      // ---- resolving
      get isResolved() {
        return !!this._isResolved;
      }
      resolve(token) {
        return __awaiter21(this, void 0, void 0, function* () {
          if (!this._resolveCache) {
            const sub = token.onCancellationRequested(() => {
              this._resolveCache = void 0;
              this._isResolved = false;
            });
            this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then((value) => {
              Object.assign(this.completion, value);
              this._isResolved = true;
              sub.dispose();
            }, (err) => {
              if (isPromiseCanceledError(err)) {
                this._resolveCache = void 0;
                this._isResolved = false;
              }
            });
          }
          return this._resolveCache;
        });
      }
    };
    CompletionOptions = class {
      constructor(snippetSortOrder = 2, kindFilter = /* @__PURE__ */ new Set(), providerFilter = /* @__PURE__ */ new Set(), showDeprecated = true) {
        this.snippetSortOrder = snippetSortOrder;
        this.kindFilter = kindFilter;
        this.providerFilter = providerFilter;
        this.showDeprecated = showDeprecated;
      }
    };
    CompletionOptions.default = new CompletionOptions();
    CompletionItemModel = class {
      constructor(items, needsClipboard, durations, disposable) {
        this.items = items;
        this.needsClipboard = needsClipboard;
        this.durations = durations;
        this.disposable = disposable;
      }
    };
    _snippetComparators = /* @__PURE__ */ new Map();
    _snippetComparators.set(0, snippetUpComparator);
    _snippetComparators.set(2, snippetDownComparator);
    _snippetComparators.set(1, defaultComparator);
    CommandsRegistry.registerCommand("_executeCompletionItemProvider", (accessor, ...args) => __awaiter21(void 0, void 0, void 0, function* () {
      const [uri, position, triggerCharacter, maxItemsToResolve] = args;
      assertType(URI.isUri(uri));
      assertType(Position.isIPosition(position));
      assertType(typeof triggerCharacter === "string" || !triggerCharacter);
      assertType(typeof maxItemsToResolve === "number" || !maxItemsToResolve);
      const ref = yield accessor.get(ITextModelService).createModelReference(uri);
      try {
        const result = {
          incomplete: false,
          suggestions: []
        };
        const resolving = [];
        const completions = yield provideSuggestionItems(ref.object.textEditorModel, Position.lift(position), void 0, {
          triggerCharacter,
          triggerKind: triggerCharacter ? 1 : 0
          /* Invoke */
        });
        for (const item of completions.items) {
          if (resolving.length < (maxItemsToResolve !== null && maxItemsToResolve !== void 0 ? maxItemsToResolve : 0)) {
            resolving.push(item.resolve(CancellationToken.None));
          }
          result.incomplete = result.incomplete || item.container.incomplete;
          result.suggestions.push(item.completion);
        }
        try {
          yield Promise.all(resolving);
          return result;
        } finally {
          setTimeout(() => completions.disposable.dispose(), 100);
        }
      } finally {
        ref.dispose();
      }
    }));
    _provider = new class {
      constructor() {
        this.onlyOnceSuggestions = [];
      }
      provideCompletionItems() {
        let suggestions = this.onlyOnceSuggestions.slice(0);
        let result = { suggestions };
        this.onlyOnceSuggestions.length = 0;
        return result;
      }
    }();
    CompletionProviderRegistry.register("*", _provider);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetController2.js
var __decorate26, __param26, _defaultOptions2, SnippetController2, CommandCtor;
var init_snippetController2 = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetController2.js"() {
    init_lifecycle();
    init_editorExtensions();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_suggest();
    init_nls();
    init_contextkey();
    init_log();
    init_snippetSession();
    __decorate26 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param26 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    _defaultOptions2 = {
      overwriteBefore: 0,
      overwriteAfter: 0,
      undoStopBefore: true,
      undoStopAfter: true,
      adjustWhitespace: true,
      clipboardText: void 0,
      overtypingCapturer: void 0
    };
    SnippetController2 = class SnippetController22 {
      constructor(_editor2, _logService, contextKeyService) {
        this._editor = _editor2;
        this._logService = _logService;
        this._snippetListener = new DisposableStore();
        this._modelVersionId = -1;
        this._inSnippet = SnippetController22.InSnippetMode.bindTo(contextKeyService);
        this._hasNextTabstop = SnippetController22.HasNextTabstop.bindTo(contextKeyService);
        this._hasPrevTabstop = SnippetController22.HasPrevTabstop.bindTo(contextKeyService);
      }
      static get(editor2) {
        return editor2.getContribution(SnippetController22.ID);
      }
      dispose() {
        var _a5;
        this._inSnippet.reset();
        this._hasPrevTabstop.reset();
        this._hasNextTabstop.reset();
        (_a5 = this._session) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._snippetListener.dispose();
      }
      insert(template, opts) {
        try {
          this._doInsert(template, typeof opts === "undefined" ? _defaultOptions2 : Object.assign(Object.assign({}, _defaultOptions2), opts));
        } catch (e) {
          this.cancel();
          this._logService.error(e);
          this._logService.error("snippet_error");
          this._logService.error("insert_template=", template);
          this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
        }
      }
      _doInsert(template, opts) {
        if (!this._editor.hasModel()) {
          return;
        }
        this._snippetListener.clear();
        if (opts.undoStopBefore) {
          this._editor.getModel().pushStackElement();
        }
        if (!this._session) {
          this._modelVersionId = this._editor.getModel().getAlternativeVersionId();
          this._session = new SnippetSession(this._editor, template, opts);
          this._session.insert();
        } else {
          this._session.merge(template, opts);
        }
        if (opts.undoStopAfter) {
          this._editor.getModel().pushStackElement();
        }
        this._updateState();
        this._snippetListener.add(this._editor.onDidChangeModelContent((e) => e.isFlush && this.cancel()));
        this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel()));
        this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
      }
      _updateState() {
        if (!this._session || !this._editor.hasModel()) {
          return;
        }
        if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) {
          return this.cancel();
        }
        if (!this._session.hasPlaceholder) {
          return this.cancel();
        }
        if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {
          return this.cancel();
        }
        this._inSnippet.set(true);
        this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);
        this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);
        this._handleChoice();
      }
      _handleChoice() {
        if (!this._session || !this._editor.hasModel()) {
          this._currentChoice = void 0;
          return;
        }
        const { choice } = this._session;
        if (!choice) {
          this._currentChoice = void 0;
          return;
        }
        if (this._currentChoice !== choice) {
          this._currentChoice = choice;
          this._editor.setSelections(this._editor.getSelections().map((s) => Selection.fromPositions(s.getStartPosition())));
          const [first2] = choice.options;
          showSimpleSuggestions(this._editor, choice.options.map((option, i) => {
            return {
              kind: 13,
              label: option.value,
              insertText: option.value,
              // insertText: `\${1|${after.concat(before).join(',')}|}$0`,
              // snippetType: 'textmate',
              sortText: "a".repeat(i + 1),
              range: Range.fromPositions(this._editor.getPosition(), this._editor.getPosition().delta(0, first2.value.length))
            };
          }));
        }
      }
      finish() {
        while (this._inSnippet.get()) {
          this.next();
        }
      }
      cancel(resetSelection = false) {
        var _a5;
        this._inSnippet.reset();
        this._hasPrevTabstop.reset();
        this._hasNextTabstop.reset();
        this._snippetListener.clear();
        (_a5 = this._session) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._session = void 0;
        this._modelVersionId = -1;
        if (resetSelection) {
          this._editor.setSelections([this._editor.getSelection()]);
        }
      }
      prev() {
        if (this._session) {
          this._session.prev();
        }
        this._updateState();
      }
      next() {
        if (this._session) {
          this._session.next();
        }
        this._updateState();
      }
      isInSnippet() {
        return Boolean(this._inSnippet.get());
      }
    };
    SnippetController2.ID = "snippetController2";
    SnippetController2.InSnippetMode = new RawContextKey("inSnippetMode", false, localize("inSnippetMode", "Whether the editor in current in snippet mode"));
    SnippetController2.HasNextTabstop = new RawContextKey("hasNextTabstop", false, localize("hasNextTabstop", "Whether there is a next tab stop when in snippet mode"));
    SnippetController2.HasPrevTabstop = new RawContextKey("hasPrevTabstop", false, localize("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode"));
    SnippetController2 = __decorate26([
      __param26(1, ILogService),
      __param26(2, IContextKeyService)
    ], SnippetController2);
    registerEditorContribution(SnippetController2.ID, SnippetController2);
    CommandCtor = EditorCommand.bindToContribution(SnippetController2.get);
    registerEditorCommand(new CommandCtor({
      id: "jumpToNextSnippetPlaceholder",
      precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasNextTabstop),
      handler: (ctrl) => ctrl.next(),
      kbOpts: {
        weight: 100 + 30,
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2
        /* Tab */
      }
    }));
    registerEditorCommand(new CommandCtor({
      id: "jumpToPrevSnippetPlaceholder",
      precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasPrevTabstop),
      handler: (ctrl) => ctrl.prev(),
      kbOpts: {
        weight: 100 + 30,
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 2
        /* Tab */
      }
    }));
    registerEditorCommand(new CommandCtor({
      id: "leaveSnippet",
      precondition: SnippetController2.InSnippetMode,
      handler: (ctrl) => ctrl.cancel(true),
      kbOpts: {
        weight: 100 + 30,
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
    registerEditorCommand(new CommandCtor({
      id: "acceptSnippet",
      precondition: SnippetController2.InSnippetMode,
      handler: (ctrl) => ctrl.finish()
      // kbOpts: {
      // 	weight: KeybindingWeight.EditorContrib + 30,
      // 	kbExpr: EditorContextKeys.textFocus,
      // 	primary: KeyCode.Enter,
      // }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestMemory.js
var __decorate27, __param27, Memory, NoMemory, LRUMemory, PrefixMemory, SuggestMemoryService, ISuggestMemoryService;
var init_suggestMemory = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestMemory.js"() {
    init_async();
    init_lifecycle();
    init_map();
    init_modes();
    init_modeService();
    init_configuration();
    init_extensions();
    init_instantiation();
    init_storage();
    __decorate27 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param27 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Memory = class {
      constructor(name) {
        this.name = name;
      }
      select(model, pos, items) {
        if (items.length === 0) {
          return 0;
        }
        let topScore = items[0].score[0];
        for (let i = 0; i < items.length; i++) {
          const { score, completion: suggestion } = items[i];
          if (score[0] !== topScore) {
            break;
          }
          if (suggestion.preselect) {
            return i;
          }
        }
        return 0;
      }
    };
    NoMemory = class extends Memory {
      constructor() {
        super("first");
      }
      memorize(model, pos, item) {
      }
      toJSON() {
        return void 0;
      }
      fromJSON() {
      }
    };
    LRUMemory = class extends Memory {
      constructor() {
        super("recentlyUsed");
        this._cache = new LRUCache(300, 0.66);
        this._seq = 0;
      }
      memorize(model, pos, item) {
        const key = `${model.getLanguageIdentifier().language}/${item.textLabel}`;
        this._cache.set(key, {
          touch: this._seq++,
          type: item.completion.kind,
          insertText: item.completion.insertText
        });
      }
      select(model, pos, items) {
        if (items.length === 0) {
          return 0;
        }
        const lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);
        if (/\s$/.test(lineSuffix)) {
          return super.select(model, pos, items);
        }
        let topScore = items[0].score[0];
        let indexPreselect = -1;
        let indexRecency = -1;
        let seq = -1;
        for (let i = 0; i < items.length; i++) {
          if (items[i].score[0] !== topScore) {
            break;
          }
          const key = `${model.getLanguageIdentifier().language}/${items[i].textLabel}`;
          const item = this._cache.peek(key);
          if (item && item.touch > seq && item.type === items[i].completion.kind && item.insertText === items[i].completion.insertText) {
            seq = item.touch;
            indexRecency = i;
          }
          if (items[i].completion.preselect && indexPreselect === -1) {
            return indexPreselect = i;
          }
        }
        if (indexRecency !== -1) {
          return indexRecency;
        } else if (indexPreselect !== -1) {
          return indexPreselect;
        } else {
          return 0;
        }
      }
      toJSON() {
        return this._cache.toJSON();
      }
      fromJSON(data) {
        this._cache.clear();
        let seq = 0;
        for (const [key, value] of data) {
          value.touch = seq;
          value.type = typeof value.type === "number" ? value.type : completionKindFromString(value.type);
          this._cache.set(key, value);
        }
        this._seq = this._cache.size;
      }
    };
    PrefixMemory = class extends Memory {
      constructor() {
        super("recentlyUsedByPrefix");
        this._trie = TernarySearchTree.forStrings();
        this._seq = 0;
      }
      memorize(model, pos, item) {
        const { word } = model.getWordUntilPosition(pos);
        const key = `${model.getLanguageIdentifier().language}/${word}`;
        this._trie.set(key, {
          type: item.completion.kind,
          insertText: item.completion.insertText,
          touch: this._seq++
        });
      }
      select(model, pos, items) {
        let { word } = model.getWordUntilPosition(pos);
        if (!word) {
          return super.select(model, pos, items);
        }
        let key = `${model.getLanguageIdentifier().language}/${word}`;
        let item = this._trie.get(key);
        if (!item) {
          item = this._trie.findSubstr(key);
        }
        if (item) {
          for (let i = 0; i < items.length; i++) {
            let { kind, insertText } = items[i].completion;
            if (kind === item.type && insertText === item.insertText) {
              return i;
            }
          }
        }
        return super.select(model, pos, items);
      }
      toJSON() {
        let entries = [];
        this._trie.forEach((value, key) => entries.push([key, value]));
        entries.sort((a, b) => -(a[1].touch - b[1].touch)).forEach((value, i) => value[1].touch = i);
        return entries.slice(0, 200);
      }
      fromJSON(data) {
        this._trie.clear();
        if (data.length > 0) {
          this._seq = data[0][1].touch + 1;
          for (const [key, value] of data) {
            value.type = typeof value.type === "number" ? value.type : completionKindFromString(value.type);
            this._trie.set(key, value);
          }
        }
      }
    };
    SuggestMemoryService = class SuggestMemoryService2 {
      constructor(_storageService, _modeService, _configService) {
        this._storageService = _storageService;
        this._modeService = _modeService;
        this._configService = _configService;
        this._disposables = new DisposableStore();
        this._persistSoon = new RunOnceScheduler(() => this._saveState(), 500);
        this._disposables.add(_storageService.onWillSaveState((e) => {
          if (e.reason === WillSaveStateReason.SHUTDOWN) {
            this._saveState();
          }
        }));
      }
      dispose() {
        this._disposables.dispose();
        this._persistSoon.dispose();
      }
      memorize(model, pos, item) {
        this._withStrategy(model, pos).memorize(model, pos, item);
        this._persistSoon.schedule();
      }
      select(model, pos, items) {
        return this._withStrategy(model, pos).select(model, pos, items);
      }
      _withStrategy(model, pos) {
        var _a5, _b2;
        const mode = this._configService.getValue("editor.suggestSelection", {
          overrideIdentifier: (_a5 = this._modeService.getLanguageIdentifier(model.getLanguageIdAtPosition(pos.lineNumber, pos.column))) === null || _a5 === void 0 ? void 0 : _a5.language,
          resource: model.uri
        });
        if (((_b2 = this._strategy) === null || _b2 === void 0 ? void 0 : _b2.name) !== mode) {
          this._saveState();
          const ctor = SuggestMemoryService2._strategyCtors.get(mode) || NoMemory;
          this._strategy = new ctor();
          try {
            const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
            const scope = share ? 0 : 1;
            const raw = this._storageService.get(`${SuggestMemoryService2._storagePrefix}/${mode}`, scope);
            if (raw) {
              this._strategy.fromJSON(JSON.parse(raw));
            }
          } catch (e) {
          }
        }
        return this._strategy;
      }
      _saveState() {
        if (this._strategy) {
          const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
          const scope = share ? 0 : 1;
          const raw = JSON.stringify(this._strategy);
          this._storageService.store(
            `${SuggestMemoryService2._storagePrefix}/${this._strategy.name}`,
            raw,
            scope,
            1
            /* MACHINE */
          );
        }
      }
    };
    SuggestMemoryService._strategyCtors = /* @__PURE__ */ new Map([
      ["recentlyUsedByPrefix", PrefixMemory],
      ["recentlyUsed", LRUMemory],
      ["first", NoMemory]
    ]);
    SuggestMemoryService._storagePrefix = "suggest/memories";
    SuggestMemoryService = __decorate27([
      __param27(0, IStorageService),
      __param27(1, IModeService),
      __param27(2, IConfigurationService)
    ], SuggestMemoryService);
    ISuggestMemoryService = createDecorator("ISuggestMemories");
    registerSingleton(ISuggestMemoryService, SuggestMemoryService, true);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordContextKey.js
var __decorate28, __param28, WordContextKey;
var init_wordContextKey = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordContextKey.js"() {
    init_contextkey();
    __decorate28 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param28 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    WordContextKey = class WordContextKey2 {
      constructor(_editor2, contextKeyService) {
        this._editor = _editor2;
        this._enabled = false;
        this._ckAtEnd = WordContextKey2.AtEnd.bindTo(contextKeyService);
        this._configListener = this._editor.onDidChangeConfiguration((e) => e.hasChanged(
          110
          /* tabCompletion */
        ) && this._update());
        this._update();
      }
      dispose() {
        var _a5;
        this._configListener.dispose();
        (_a5 = this._selectionListener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._ckAtEnd.reset();
      }
      _update() {
        const enabled = this._editor.getOption(
          110
          /* tabCompletion */
        ) === "on";
        if (this._enabled === enabled) {
          return;
        }
        this._enabled = enabled;
        if (this._enabled) {
          const checkForWordEnd = () => {
            if (!this._editor.hasModel()) {
              this._ckAtEnd.set(false);
              return;
            }
            const model = this._editor.getModel();
            const selection = this._editor.getSelection();
            const word = model.getWordAtPosition(selection.getStartPosition());
            if (!word) {
              this._ckAtEnd.set(false);
              return;
            }
            this._ckAtEnd.set(word.endColumn === selection.getStartPosition().column);
          };
          this._selectionListener = this._editor.onDidChangeCursorSelection(checkForWordEnd);
          checkForWordEnd();
        } else if (this._selectionListener) {
          this._ckAtEnd.reset();
          this._selectionListener.dispose();
          this._selectionListener = void 0;
        }
      }
    };
    WordContextKey.AtEnd = new RawContextKey("atEndOfWord", false);
    WordContextKey = __decorate28([
      __param28(1, IContextKeyService)
    ], WordContextKey);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestAlternatives.js
var __decorate29, __param29, SuggestAlternatives;
var init_suggestAlternatives = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestAlternatives.js"() {
    init_contextkey();
    __decorate29 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param29 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    SuggestAlternatives = class SuggestAlternatives2 {
      constructor(_editor2, contextKeyService) {
        this._editor = _editor2;
        this._index = 0;
        this._ckOtherSuggestions = SuggestAlternatives2.OtherSuggestions.bindTo(contextKeyService);
      }
      dispose() {
        this.reset();
      }
      reset() {
        var _a5;
        this._ckOtherSuggestions.reset();
        (_a5 = this._listener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._model = void 0;
        this._acceptNext = void 0;
        this._ignore = false;
      }
      set({ model, index }, acceptNext) {
        if (model.items.length === 0) {
          this.reset();
          return;
        }
        let nextIndex = SuggestAlternatives2._moveIndex(true, model, index);
        if (nextIndex === index) {
          this.reset();
          return;
        }
        this._acceptNext = acceptNext;
        this._model = model;
        this._index = index;
        this._listener = this._editor.onDidChangeCursorPosition(() => {
          if (!this._ignore) {
            this.reset();
          }
        });
        this._ckOtherSuggestions.set(true);
      }
      static _moveIndex(fwd, model, index) {
        let newIndex = index;
        while (true) {
          newIndex = (newIndex + model.items.length + (fwd ? 1 : -1)) % model.items.length;
          if (newIndex === index) {
            break;
          }
          if (!model.items[newIndex].completion.additionalTextEdits) {
            break;
          }
        }
        return newIndex;
      }
      next() {
        this._move(true);
      }
      prev() {
        this._move(false);
      }
      _move(fwd) {
        if (!this._model) {
          return;
        }
        try {
          this._ignore = true;
          this._index = SuggestAlternatives2._moveIndex(fwd, this._model, this._index);
          this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
        } finally {
          this._ignore = false;
        }
      }
    };
    SuggestAlternatives.OtherSuggestions = new RawContextKey("hasOtherSuggestions", false);
    SuggestAlternatives = __decorate29([
      __param29(1, IContextKeyService)
    ], SuggestAlternatives);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestCommitCharacters.js
var CommitCharacterController;
var init_suggestCommitCharacters = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestCommitCharacters.js"() {
    init_arrays();
    init_lifecycle();
    init_characterClassifier();
    CommitCharacterController = class {
      constructor(editor2, widget, accept) {
        this._disposables = new DisposableStore();
        this._disposables.add(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));
        this._disposables.add(widget.onDidFocus(this._onItem, this));
        this._disposables.add(widget.onDidHide(this.reset, this));
        this._disposables.add(editor2.onWillType((text2) => {
          if (this._active && !widget.isFrozen()) {
            const ch = text2.charCodeAt(text2.length - 1);
            if (this._active.acceptCharacters.has(ch) && editor2.getOption(
              0
              /* acceptSuggestionOnCommitCharacter */
            )) {
              accept(this._active.item);
            }
          }
        }));
      }
      _onItem(selected) {
        if (!selected || !isNonEmptyArray(selected.item.completion.commitCharacters)) {
          this.reset();
          return;
        }
        if (this._active && this._active.item.item === selected.item) {
          return;
        }
        const acceptCharacters = new CharacterSet();
        for (const ch of selected.item.completion.commitCharacters) {
          if (ch.length > 0) {
            acceptCharacters.add(ch.charCodeAt(0));
          }
        }
        this._active = { acceptCharacters, item: selected };
      }
      reset() {
        this._active = void 0;
      }
      dispose() {
        this._disposables.dispose();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/bracketSelections.js
var __awaiter22, BracketSelectionRangeProvider;
var init_bracketSelections = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/bracketSelections.js"() {
    init_linkedList();
    init_position();
    init_range();
    __awaiter22 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    BracketSelectionRangeProvider = class _BracketSelectionRangeProvider {
      provideSelectionRanges(model, positions) {
        return __awaiter22(this, void 0, void 0, function* () {
          const result = [];
          for (const position of positions) {
            const bucket = [];
            result.push(bucket);
            const ranges = /* @__PURE__ */ new Map();
            yield new Promise((resolve) => _BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
            yield new Promise((resolve) => _BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
          }
          return result;
        });
      }
      static _bracketsRightYield(resolve, round, model, pos, ranges) {
        const counts = /* @__PURE__ */ new Map();
        const t1 = Date.now();
        while (true) {
          if (round >= _BracketSelectionRangeProvider._maxRounds) {
            resolve();
            break;
          }
          if (!pos) {
            resolve();
            break;
          }
          let bracket = model.findNextBracket(pos);
          if (!bracket) {
            resolve();
            break;
          }
          let d = Date.now() - t1;
          if (d > _BracketSelectionRangeProvider._maxDuration) {
            setTimeout(() => _BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));
            break;
          }
          const key = bracket.close[0];
          if (bracket.isOpen) {
            let val = counts.has(key) ? counts.get(key) : 0;
            counts.set(key, val + 1);
          } else {
            let val = counts.has(key) ? counts.get(key) : 0;
            val -= 1;
            counts.set(key, Math.max(0, val));
            if (val < 0) {
              let list = ranges.get(key);
              if (!list) {
                list = new LinkedList();
                ranges.set(key, list);
              }
              list.push(bracket.range);
            }
          }
          pos = bracket.range.getEndPosition();
        }
      }
      static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {
        const counts = /* @__PURE__ */ new Map();
        const t1 = Date.now();
        while (true) {
          if (round >= _BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {
            resolve();
            break;
          }
          if (!pos) {
            resolve();
            break;
          }
          let bracket = model.findPrevBracket(pos);
          if (!bracket) {
            resolve();
            break;
          }
          let d = Date.now() - t1;
          if (d > _BracketSelectionRangeProvider._maxDuration) {
            setTimeout(() => _BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));
            break;
          }
          const key = bracket.close[0];
          if (!bracket.isOpen) {
            let val = counts.has(key) ? counts.get(key) : 0;
            counts.set(key, val + 1);
          } else {
            let val = counts.has(key) ? counts.get(key) : 0;
            val -= 1;
            counts.set(key, Math.max(0, val));
            if (val < 0) {
              let list = ranges.get(key);
              if (list) {
                let closing = list.shift();
                if (list.size === 0) {
                  ranges.delete(key);
                }
                const innerBracket = Range.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());
                const outerBracket = Range.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());
                bucket.push({ range: innerBracket });
                bucket.push({ range: outerBracket });
                _BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);
              }
            }
          }
          pos = bracket.range.getStartPosition();
        }
      }
      static _addBracketLeading(model, bracket, bucket) {
        if (bracket.startLineNumber === bracket.endLineNumber) {
          return;
        }
        const startLine = bracket.startLineNumber;
        const column = model.getLineFirstNonWhitespaceColumn(startLine);
        if (column !== 0 && column !== bracket.startColumn) {
          bucket.push({ range: Range.fromPositions(new Position(startLine, column), bracket.getEndPosition()) });
          bucket.push({ range: Range.fromPositions(new Position(startLine, 1), bracket.getEndPosition()) });
        }
        const aboveLine = startLine - 1;
        if (aboveLine > 0) {
          const column2 = model.getLineFirstNonWhitespaceColumn(aboveLine);
          if (column2 === bracket.startColumn && column2 !== model.getLineLastNonWhitespaceColumn(aboveLine)) {
            bucket.push({ range: Range.fromPositions(new Position(aboveLine, column2), bracket.getEndPosition()) });
            bucket.push({ range: Range.fromPositions(new Position(aboveLine, 1), bracket.getEndPosition()) });
          }
        }
      }
    };
    BracketSelectionRangeProvider._maxDuration = 30;
    BracketSelectionRangeProvider._maxRounds = 2;
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordDistance.js
var __awaiter23, WordDistance;
var init_wordDistance = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordDistance.js"() {
    init_arrays();
    init_range();
    init_bracketSelections();
    __awaiter23 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    WordDistance = class _WordDistance {
      static create(service, editor2) {
        return __awaiter23(this, void 0, void 0, function* () {
          if (!editor2.getOption(
            105
            /* suggest */
          ).localityBonus) {
            return _WordDistance.None;
          }
          if (!editor2.hasModel()) {
            return _WordDistance.None;
          }
          const model = editor2.getModel();
          const position = editor2.getPosition();
          if (!service.canComputeWordRanges(model.uri)) {
            return _WordDistance.None;
          }
          const [ranges] = yield new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
          if (ranges.length === 0) {
            return _WordDistance.None;
          }
          const wordRanges = yield service.computeWordRanges(model.uri, ranges[0].range);
          if (!wordRanges) {
            return _WordDistance.None;
          }
          const wordUntilPos = model.getWordUntilPosition(position);
          delete wordRanges[wordUntilPos.word];
          return new class extends _WordDistance {
            distance(anchor, item) {
              if (!position.equals(editor2.getPosition())) {
                return 0;
              }
              if (item.kind === 17) {
                return 2 << 20;
              }
              let word = typeof item.label === "string" ? item.label : item.label.label;
              let wordLines = wordRanges[word];
              if (isFalsyOrEmpty(wordLines)) {
                return 2 << 20;
              }
              let idx = binarySearch(wordLines, Range.fromPositions(anchor), Range.compareRangesUsingStarts);
              let bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
              let blockDistance = ranges.length;
              for (const range of ranges) {
                if (!Range.containsRange(range.range, bestWordRange)) {
                  break;
                }
                blockDistance -= 1;
              }
              return blockDistance;
            }
          }();
        });
      }
    };
    WordDistance.None = new class extends WordDistance {
      distance() {
        return 0;
      }
    }();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/completionModel.js
var CompletionModel;
var init_completionModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/completionModel.js"() {
    init_arrays();
    init_filters();
    init_strings();
    CompletionModel = class _CompletionModel {
      constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {
        this.clipboardText = clipboardText;
        this._snippetCompareFn = _CompletionModel._compareCompletionItems;
        this._items = items;
        this._column = column;
        this._wordDistance = wordDistance;
        this._options = options;
        this._refilterKind = 1;
        this._lineContext = lineContext;
        if (snippetSuggestions === "top") {
          this._snippetCompareFn = _CompletionModel._compareCompletionItemsSnippetsUp;
        } else if (snippetSuggestions === "bottom") {
          this._snippetCompareFn = _CompletionModel._compareCompletionItemsSnippetsDown;
        }
      }
      get lineContext() {
        return this._lineContext;
      }
      set lineContext(value) {
        if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {
          this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 : 1;
          this._lineContext = value;
        }
      }
      get items() {
        this._ensureCachedState();
        return this._filteredItems;
      }
      get allProvider() {
        this._ensureCachedState();
        return this._providerInfo.keys();
      }
      get incomplete() {
        this._ensureCachedState();
        const result = /* @__PURE__ */ new Set();
        for (let [provider, incomplete] of this._providerInfo) {
          if (incomplete) {
            result.add(provider);
          }
        }
        return result;
      }
      adopt(except) {
        let res = [];
        for (let i = 0; i < this._items.length; ) {
          if (!except.has(this._items[i].provider)) {
            res.push(this._items[i]);
            this._items[i] = this._items[this._items.length - 1];
            this._items.pop();
          } else {
            i++;
          }
        }
        this._refilterKind = 1;
        return res;
      }
      get stats() {
        this._ensureCachedState();
        return this._stats;
      }
      _ensureCachedState() {
        if (this._refilterKind !== 0) {
          this._createCachedState();
        }
      }
      _createCachedState() {
        this._providerInfo = /* @__PURE__ */ new Map();
        const labelLengths = [];
        const { leadingLineContent, characterCountDelta } = this._lineContext;
        let word = "";
        let wordLow = "";
        const source = this._refilterKind === 1 ? this._items : this._filteredItems;
        const target = [];
        const scoreFn = !this._options.filterGraceful || source.length > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
        for (let i = 0; i < source.length; i++) {
          const item = source[i];
          if (item.isInvalid) {
            continue;
          }
          this._providerInfo.set(item.provider, Boolean(item.container.incomplete));
          const overwriteBefore = item.position.column - item.editStart.column;
          const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);
          if (word.length !== wordLen) {
            word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
            wordLow = word.toLowerCase();
          }
          item.word = word;
          if (wordLen === 0) {
            item.score = FuzzyScore.Default;
          } else {
            let wordPos = 0;
            while (wordPos < overwriteBefore) {
              const ch = word.charCodeAt(wordPos);
              if (ch === 32 || ch === 9) {
                wordPos += 1;
              } else {
                break;
              }
            }
            if (wordPos >= wordLen) {
              item.score = FuzzyScore.Default;
            } else if (typeof item.completion.filterText === "string") {
              let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);
              if (!match) {
                continue;
              }
              if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {
                item.score = match;
              } else {
                item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);
                item.score[0] = match[0];
              }
            } else {
              let match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, false);
              if (!match) {
                continue;
              }
              item.score = match;
            }
          }
          item.idx = i;
          item.distance = this._wordDistance.distance(item.position, item.completion);
          target.push(item);
          labelLengths.push(item.textLabel.length);
        }
        this._filteredItems = target.sort(this._snippetCompareFn);
        this._refilterKind = 0;
        this._stats = {
          pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - 0.85, labelLengths, (a, b) => a - b) : 0
        };
      }
      static _compareCompletionItems(a, b) {
        if (a.score[0] > b.score[0]) {
          return -1;
        } else if (a.score[0] < b.score[0]) {
          return 1;
        } else if (a.distance < b.distance) {
          return -1;
        } else if (a.distance > b.distance) {
          return 1;
        } else if (a.idx < b.idx) {
          return -1;
        } else if (a.idx > b.idx) {
          return 1;
        } else {
          return 0;
        }
      }
      static _compareCompletionItemsSnippetsDown(a, b) {
        if (a.completion.kind !== b.completion.kind) {
          if (a.completion.kind === 27) {
            return 1;
          } else if (b.completion.kind === 27) {
            return -1;
          }
        }
        return _CompletionModel._compareCompletionItems(a, b);
      }
      static _compareCompletionItemsSnippetsUp(a, b) {
        if (a.completion.kind !== b.completion.kind) {
          if (a.completion.kind === 27) {
            return -1;
          } else if (b.completion.kind === 27) {
            return 1;
          }
        }
        return _CompletionModel._compareCompletionItems(a, b);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestModel.js
function canShowQuickSuggest(editor2, contextKeyService, configurationService) {
  if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) {
    return true;
  }
  const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowQuickSuggestions");
  if (allowQuickSuggestions !== void 0) {
    return Boolean(allowQuickSuggestions);
  }
  return false;
}
function canShowSuggestOnTriggerCharacters(editor2, contextKeyService, configurationService) {
  if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) {
    return true;
  }
  const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowSuggestOnTriggerCharacters");
  if (allowQuickSuggestions !== void 0) {
    return Boolean(allowQuickSuggestions);
  }
  return false;
}
var __decorate30, __param30, __awaiter24, LineContext, SuggestModel;
var init_suggestModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestModel.js"() {
    init_async();
    init_cancellation();
    init_errors();
    init_event();
    init_lifecycle();
    init_strings();
    init_selection();
    init_modes();
    init_editorWorkerService();
    init_snippetController2();
    init_wordDistance();
    init_clipboardService();
    init_configuration();
    init_contextkey();
    init_log();
    init_telemetry();
    init_completionModel();
    init_suggest();
    __decorate30 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param30 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter24 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    LineContext = class {
      constructor(model, position, auto, shy) {
        this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
        this.leadingWord = model.getWordUntilPosition(position);
        this.lineNumber = position.lineNumber;
        this.column = position.column;
        this.auto = auto;
        this.shy = shy;
      }
      static shouldAutoTrigger(editor2) {
        if (!editor2.hasModel()) {
          return false;
        }
        const model = editor2.getModel();
        const pos = editor2.getPosition();
        model.tokenizeIfCheap(pos.lineNumber);
        const word = model.getWordAtPosition(pos);
        if (!word) {
          return false;
        }
        if (word.endColumn !== pos.column) {
          return false;
        }
        if (!isNaN(Number(word.word))) {
          return false;
        }
        return true;
      }
    };
    SuggestModel = class SuggestModel2 {
      constructor(_editor2, _editorWorkerService, _clipboardService, _telemetryService, _logService, _contextKeyService, _configurationService) {
        this._editor = _editor2;
        this._editorWorkerService = _editorWorkerService;
        this._clipboardService = _clipboardService;
        this._telemetryService = _telemetryService;
        this._logService = _logService;
        this._contextKeyService = _contextKeyService;
        this._configurationService = _configurationService;
        this._toDispose = new DisposableStore();
        this._quickSuggestDelay = 10;
        this._triggerCharacterListener = new DisposableStore();
        this._triggerQuickSuggest = new TimeoutTimer();
        this._state = 0;
        this._completionDisposables = new DisposableStore();
        this._onDidCancel = new Emitter();
        this._onDidTrigger = new Emitter();
        this._onDidSuggest = new Emitter();
        this.onDidCancel = this._onDidCancel.event;
        this.onDidTrigger = this._onDidTrigger.event;
        this.onDidSuggest = this._onDidSuggest.event;
        this._telemetryGate = 0;
        this._currentSelection = this._editor.getSelection() || new Selection(1, 1, 1, 1);
        this._toDispose.add(this._editor.onDidChangeModel(() => {
          this._updateTriggerCharacters();
          this.cancel();
        }));
        this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
          this._updateTriggerCharacters();
          this.cancel();
        }));
        this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
          this._updateTriggerCharacters();
          this._updateQuickSuggest();
        }));
        this._toDispose.add(CompletionProviderRegistry.onDidChange(() => {
          this._updateTriggerCharacters();
          this._updateActiveSuggestSession();
        }));
        this._toDispose.add(this._editor.onDidChangeCursorSelection((e) => {
          this._onCursorChange(e);
        }));
        let editorIsComposing = false;
        this._toDispose.add(this._editor.onDidCompositionStart(() => {
          editorIsComposing = true;
        }));
        this._toDispose.add(this._editor.onDidCompositionEnd(() => {
          editorIsComposing = false;
          this._refilterCompletionItems();
        }));
        this._toDispose.add(this._editor.onDidChangeModelContent(() => {
          if (!editorIsComposing) {
            this._refilterCompletionItems();
          }
        }));
        this._updateTriggerCharacters();
        this._updateQuickSuggest();
      }
      dispose() {
        dispose(this._triggerCharacterListener);
        dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]);
        this._toDispose.dispose();
        this._completionDisposables.dispose();
        this.cancel();
      }
      // --- handle configuration & precondition changes
      _updateQuickSuggest() {
        this._quickSuggestDelay = this._editor.getOption(
          79
          /* quickSuggestionsDelay */
        );
        if (isNaN(this._quickSuggestDelay) || !this._quickSuggestDelay && this._quickSuggestDelay !== 0 || this._quickSuggestDelay < 0) {
          this._quickSuggestDelay = 10;
        }
      }
      _updateTriggerCharacters() {
        this._triggerCharacterListener.clear();
        if (this._editor.getOption(
          80
          /* readOnly */
        ) || !this._editor.hasModel() || !this._editor.getOption(
          108
          /* suggestOnTriggerCharacters */
        )) {
          return;
        }
        const supportsByTriggerCharacter = /* @__PURE__ */ new Map();
        for (const support of CompletionProviderRegistry.all(this._editor.getModel())) {
          for (const ch of support.triggerCharacters || []) {
            let set = supportsByTriggerCharacter.get(ch);
            if (!set) {
              set = /* @__PURE__ */ new Set();
              set.add(getSnippetSuggestSupport());
              supportsByTriggerCharacter.set(ch, set);
            }
            set.add(support);
          }
        }
        const checkTriggerCharacter = (text2) => {
          if (!canShowSuggestOnTriggerCharacters(this._editor, this._contextKeyService, this._configurationService)) {
            return;
          }
          if (LineContext.shouldAutoTrigger(this._editor)) {
            return;
          }
          if (!text2) {
            const position = this._editor.getPosition();
            const model = this._editor.getModel();
            text2 = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
          }
          let lastChar = "";
          if (isLowSurrogate(text2.charCodeAt(text2.length - 1))) {
            if (isHighSurrogate(text2.charCodeAt(text2.length - 2))) {
              lastChar = text2.substr(text2.length - 2);
            }
          } else {
            lastChar = text2.charAt(text2.length - 1);
          }
          const supports = supportsByTriggerCharacter.get(lastChar);
          if (supports) {
            const existing = this._completionModel ? { items: this._completionModel.adopt(supports), clipboardText: this._completionModel.clipboardText } : void 0;
            this.trigger({ auto: true, shy: false, triggerCharacter: lastChar }, Boolean(this._completionModel), supports, existing);
          }
        };
        this._triggerCharacterListener.add(this._editor.onDidType(checkTriggerCharacter));
        this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(checkTriggerCharacter));
      }
      // --- trigger/retrigger/cancel suggest
      get state() {
        return this._state;
      }
      cancel(retrigger = false) {
        var _a5;
        if (this._state !== 0) {
          this._triggerQuickSuggest.cancel();
          (_a5 = this._requestToken) === null || _a5 === void 0 ? void 0 : _a5.cancel();
          this._requestToken = void 0;
          this._state = 0;
          this._completionModel = void 0;
          this._context = void 0;
          this._onDidCancel.fire({ retrigger });
        }
      }
      clear() {
        this._completionDisposables.clear();
      }
      _updateActiveSuggestSession() {
        if (this._state !== 0) {
          if (!this._editor.hasModel() || !CompletionProviderRegistry.has(this._editor.getModel())) {
            this.cancel();
          } else {
            this.trigger({ auto: this._state === 2, shy: false }, true);
          }
        }
      }
      _onCursorChange(e) {
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        const prevSelection = this._currentSelection;
        this._currentSelection = this._editor.getSelection();
        if (!e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
          this.cancel();
          return;
        }
        if (!CompletionProviderRegistry.has(model)) {
          return;
        }
        if (this._state === 0 && e.reason === 0) {
          if (this._editor.getOption(
            78
            /* quickSuggestions */
          ) === false) {
            return;
          }
          if (!prevSelection.containsRange(this._currentSelection) && !prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {
            return;
          }
          if (this._editor.getOption(
            105
            /* suggest */
          ).snippetsPreventQuickSuggestions && SnippetController2.get(this._editor).isInSnippet()) {
            return;
          }
          this.cancel();
          this._triggerQuickSuggest.cancelAndSet(() => {
            if (this._state !== 0) {
              return;
            }
            if (!LineContext.shouldAutoTrigger(this._editor)) {
              return;
            }
            if (!this._editor.hasModel()) {
              return;
            }
            const model2 = this._editor.getModel();
            const pos = this._editor.getPosition();
            const quickSuggestions = this._editor.getOption(
              78
              /* quickSuggestions */
            );
            if (quickSuggestions === false) {
              return;
            } else if (quickSuggestions === true) {
            } else {
              model2.tokenizeIfCheap(pos.lineNumber);
              const lineTokens = model2.getLineTokens(pos.lineNumber);
              const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));
              const inValidScope = quickSuggestions.other && tokenType === 0 || quickSuggestions.comments && tokenType === 1 || quickSuggestions.strings && tokenType === 2;
              if (!inValidScope) {
                return;
              }
            }
            if (!canShowQuickSuggest(this._editor, this._contextKeyService, this._configurationService)) {
              return;
            }
            this.trigger({ auto: true, shy: false });
          }, this._quickSuggestDelay);
        } else if (this._state !== 0 && e.reason === 3) {
          this._refilterCompletionItems();
        }
      }
      _refilterCompletionItems() {
        Promise.resolve().then(() => {
          if (this._state === 0) {
            return;
          }
          if (!this._editor.hasModel()) {
            return;
          }
          const model = this._editor.getModel();
          const position = this._editor.getPosition();
          const ctx = new LineContext(model, position, this._state === 2, false);
          this._onNewContext(ctx);
        });
      }
      trigger(context, retrigger = false, onlyFrom, existing) {
        var _a5;
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        const auto = context.auto;
        const ctx = new LineContext(model, this._editor.getPosition(), auto, context.shy);
        this.cancel(retrigger);
        this._state = auto ? 2 : 1;
        this._onDidTrigger.fire({ auto, shy: context.shy, position: this._editor.getPosition() });
        this._context = ctx;
        let suggestCtx = {
          triggerKind: (_a5 = context.triggerKind) !== null && _a5 !== void 0 ? _a5 : 0
          /* Invoke */
        };
        if (context.triggerCharacter) {
          suggestCtx = {
            triggerKind: 1,
            triggerCharacter: context.triggerCharacter
          };
        }
        this._requestToken = new CancellationTokenSource();
        const snippetSuggestions = this._editor.getOption(
          100
          /* snippetSuggestions */
        );
        let snippetSortOrder = 1;
        switch (snippetSuggestions) {
          case "top":
            snippetSortOrder = 0;
            break;
          // 	 that's the default anyways...
          // case 'inline':
          // 	snippetSortOrder = SnippetSortOrder.Inline;
          // 	break;
          case "bottom":
            snippetSortOrder = 2;
            break;
        }
        const { itemKind: itemKindFilter, showDeprecated } = SuggestModel2._createSuggestFilter(this._editor);
        const wordDistance = WordDistance.create(this._editorWorkerService, this._editor);
        const completions = provideSuggestionItems(model, this._editor.getPosition(), new CompletionOptions(snippetSortOrder, itemKindFilter, onlyFrom, showDeprecated), suggestCtx, this._requestToken.token);
        Promise.all([completions, wordDistance]).then(([completions2, wordDistance2]) => __awaiter24(this, void 0, void 0, function* () {
          var _b2;
          (_b2 = this._requestToken) === null || _b2 === void 0 ? void 0 : _b2.dispose();
          if (!this._editor.hasModel()) {
            return;
          }
          let clipboardText = existing === null || existing === void 0 ? void 0 : existing.clipboardText;
          if (!clipboardText && completions2.needsClipboard) {
            clipboardText = yield this._clipboardService.readText();
          }
          if (this._state === 0) {
            return;
          }
          const model2 = this._editor.getModel();
          let items = completions2.items;
          if (existing) {
            const cmpFn = getSuggestionComparator(snippetSortOrder);
            items = items.concat(existing.items).sort(cmpFn);
          }
          const ctx2 = new LineContext(model2, this._editor.getPosition(), auto, context.shy);
          this._completionModel = new CompletionModel(items, this._context.column, {
            leadingLineContent: ctx2.leadingLineContent,
            characterCountDelta: ctx2.column - this._context.column
          }, wordDistance2, this._editor.getOption(
            105
            /* suggest */
          ), this._editor.getOption(
            100
            /* snippetSuggestions */
          ), clipboardText);
          this._completionDisposables.add(completions2.disposable);
          this._onNewContext(ctx2);
          this._reportDurationsTelemetry(completions2.durations);
        })).catch(onUnexpectedError);
      }
      _reportDurationsTelemetry(durations) {
        if (this._telemetryGate++ % 230 !== 0) {
          return;
        }
        setTimeout(() => {
          this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(durations) });
          this._logService.debug("suggest.durations.json", durations);
        });
      }
      static _createSuggestFilter(editor2) {
        const result = /* @__PURE__ */ new Set();
        const snippetSuggestions = editor2.getOption(
          100
          /* snippetSuggestions */
        );
        if (snippetSuggestions === "none") {
          result.add(
            27
            /* Snippet */
          );
        }
        const suggestOptions = editor2.getOption(
          105
          /* suggest */
        );
        if (!suggestOptions.showMethods) {
          result.add(
            0
            /* Method */
          );
        }
        if (!suggestOptions.showFunctions) {
          result.add(
            1
            /* Function */
          );
        }
        if (!suggestOptions.showConstructors) {
          result.add(
            2
            /* Constructor */
          );
        }
        if (!suggestOptions.showFields) {
          result.add(
            3
            /* Field */
          );
        }
        if (!suggestOptions.showVariables) {
          result.add(
            4
            /* Variable */
          );
        }
        if (!suggestOptions.showClasses) {
          result.add(
            5
            /* Class */
          );
        }
        if (!suggestOptions.showStructs) {
          result.add(
            6
            /* Struct */
          );
        }
        if (!suggestOptions.showInterfaces) {
          result.add(
            7
            /* Interface */
          );
        }
        if (!suggestOptions.showModules) {
          result.add(
            8
            /* Module */
          );
        }
        if (!suggestOptions.showProperties) {
          result.add(
            9
            /* Property */
          );
        }
        if (!suggestOptions.showEvents) {
          result.add(
            10
            /* Event */
          );
        }
        if (!suggestOptions.showOperators) {
          result.add(
            11
            /* Operator */
          );
        }
        if (!suggestOptions.showUnits) {
          result.add(
            12
            /* Unit */
          );
        }
        if (!suggestOptions.showValues) {
          result.add(
            13
            /* Value */
          );
        }
        if (!suggestOptions.showConstants) {
          result.add(
            14
            /* Constant */
          );
        }
        if (!suggestOptions.showEnums) {
          result.add(
            15
            /* Enum */
          );
        }
        if (!suggestOptions.showEnumMembers) {
          result.add(
            16
            /* EnumMember */
          );
        }
        if (!suggestOptions.showKeywords) {
          result.add(
            17
            /* Keyword */
          );
        }
        if (!suggestOptions.showWords) {
          result.add(
            18
            /* Text */
          );
        }
        if (!suggestOptions.showColors) {
          result.add(
            19
            /* Color */
          );
        }
        if (!suggestOptions.showFiles) {
          result.add(
            20
            /* File */
          );
        }
        if (!suggestOptions.showReferences) {
          result.add(
            21
            /* Reference */
          );
        }
        if (!suggestOptions.showColors) {
          result.add(
            22
            /* Customcolor */
          );
        }
        if (!suggestOptions.showFolders) {
          result.add(
            23
            /* Folder */
          );
        }
        if (!suggestOptions.showTypeParameters) {
          result.add(
            24
            /* TypeParameter */
          );
        }
        if (!suggestOptions.showSnippets) {
          result.add(
            27
            /* Snippet */
          );
        }
        if (!suggestOptions.showUsers) {
          result.add(
            25
            /* User */
          );
        }
        if (!suggestOptions.showIssues) {
          result.add(
            26
            /* Issue */
          );
        }
        return { itemKind: result, showDeprecated: suggestOptions.showDeprecated };
      }
      _onNewContext(ctx) {
        if (!this._context) {
          return;
        }
        if (ctx.lineNumber !== this._context.lineNumber) {
          this.cancel();
          return;
        }
        if (getLeadingWhitespace(ctx.leadingLineContent) !== getLeadingWhitespace(this._context.leadingLineContent)) {
          this.cancel();
          return;
        }
        if (ctx.column < this._context.column) {
          if (ctx.leadingWord.word) {
            this.trigger({ auto: this._context.auto, shy: false }, true);
          } else {
            this.cancel();
          }
          return;
        }
        if (!this._completionModel) {
          return;
        }
        if (ctx.leadingWord.word.length !== 0 && ctx.leadingWord.startColumn > this._context.leadingWord.startColumn) {
          const inactiveProvider = new Set(CompletionProviderRegistry.all(this._editor.getModel()));
          for (let provider of this._completionModel.allProvider) {
            inactiveProvider.delete(provider);
          }
          const items = this._completionModel.adopt(/* @__PURE__ */ new Set());
          this.trigger({ auto: this._context.auto, shy: false }, true, inactiveProvider, { items, clipboardText: this._completionModel.clipboardText });
          return;
        }
        if (ctx.column > this._context.column && this._completionModel.incomplete.size > 0 && ctx.leadingWord.word.length !== 0) {
          const { incomplete } = this._completionModel;
          const items = this._completionModel.adopt(incomplete);
          this.trigger({
            auto: this._state === 2,
            shy: false,
            triggerKind: 2
            /* TriggerForIncompleteCompletions */
          }, true, incomplete, { items, clipboardText: this._completionModel.clipboardText });
        } else {
          let oldLineContext = this._completionModel.lineContext;
          let isFrozen2 = false;
          this._completionModel.lineContext = {
            leadingLineContent: ctx.leadingLineContent,
            characterCountDelta: ctx.column - this._context.column
          };
          if (this._completionModel.items.length === 0) {
            if (LineContext.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
              this.trigger({ auto: this._context.auto, shy: false }, true);
              return;
            }
            if (!this._context.auto) {
              this._completionModel.lineContext = oldLineContext;
              isFrozen2 = this._completionModel.items.length > 0;
              if (isFrozen2 && ctx.leadingWord.word.length === 0) {
                this.cancel();
                return;
              }
            } else {
              this.cancel();
              return;
            }
          }
          this._onDidSuggest.fire({
            completionModel: this._completionModel,
            auto: this._context.auto,
            shy: this._context.shy,
            isFrozen: isFrozen2
          });
        }
      }
    };
    SuggestModel = __decorate30([
      __param30(1, IEditorWorkerService),
      __param30(2, IClipboardService),
      __param30(3, ITelemetryService),
      __param30(4, ILogService),
      __param30(5, IContextKeyService),
      __param30(6, IConfigurationService)
    ], SuggestModel);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestOvertypingCapturer.js
var OvertypingCapturer;
var init_suggestOvertypingCapturer = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestOvertypingCapturer.js"() {
    init_lifecycle();
    OvertypingCapturer = class _OvertypingCapturer {
      constructor(editor2, suggestModel) {
        this._disposables = new DisposableStore();
        this._lastOvertyped = [];
        this._empty = true;
        this._disposables.add(editor2.onWillType(() => {
          if (!this._empty) {
            return;
          }
          if (!editor2.hasModel()) {
            return;
          }
          const selections = editor2.getSelections();
          const selectionsLength = selections.length;
          let willOvertype = false;
          for (let i = 0; i < selectionsLength; i++) {
            if (!selections[i].isEmpty()) {
              willOvertype = true;
              break;
            }
          }
          if (!willOvertype) {
            return;
          }
          this._lastOvertyped = [];
          const model = editor2.getModel();
          for (let i = 0; i < selectionsLength; i++) {
            const selection = selections[i];
            if (model.getValueLengthInRange(selection) > _OvertypingCapturer._maxSelectionLength) {
              return;
            }
            this._lastOvertyped[i] = { value: model.getValueInRange(selection), multiline: selection.startLineNumber !== selection.endLineNumber };
          }
          this._empty = false;
        }));
        this._disposables.add(suggestModel.onDidCancel((e) => {
          if (!this._empty && !e.retrigger) {
            this._empty = true;
          }
        }));
      }
      getLastOvertypedInfo(idx) {
        if (!this._empty && idx >= 0 && idx < this._lastOvertyped.length) {
          return this._lastOvertyped[idx];
        }
        return void 0;
      }
      dispose() {
        this._disposables.dispose();
      }
    };
    OvertypingCapturer._maxSelectionLength = 51200;
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetStatus.js
var __decorate31, __param31, StatusBarViewItem, SuggestWidgetStatus;
var init_suggestWidgetStatus = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetStatus.js"() {
    init_dom();
    init_actionbar();
    init_lifecycle();
    init_suggest();
    init_nls();
    init_menuEntryActionViewItem();
    init_actions2();
    init_contextkey();
    init_instantiation();
    __decorate31 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param31 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    StatusBarViewItem = class _StatusBarViewItem extends MenuEntryActionViewItem {
      updateLabel() {
        const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
        if (!kb) {
          return super.updateLabel();
        }
        if (this.label) {
          this.label.textContent = localize("ddd", "{0} ({1})", this._action.label, _StatusBarViewItem.symbolPrintEnter(kb));
        }
      }
      static symbolPrintEnter(kb) {
        var _a5;
        return (_a5 = kb.getLabel()) === null || _a5 === void 0 ? void 0 : _a5.replace(/\benter\b/gi, "\u23CE");
      }
    };
    SuggestWidgetStatus = class SuggestWidgetStatus2 {
      constructor(container, instantiationService, _menuService, _contextKeyService) {
        this._menuService = _menuService;
        this._contextKeyService = _contextKeyService;
        this._menuDisposables = new DisposableStore();
        this.element = append(container, $(".suggest-status-bar"));
        const actionViewItemProvider = ((action) => {
          return action instanceof MenuItemAction ? instantiationService.createInstance(StatusBarViewItem, action, void 0) : void 0;
        });
        this._leftActions = new ActionBar(this.element, { actionViewItemProvider });
        this._rightActions = new ActionBar(this.element, { actionViewItemProvider });
        this._leftActions.domNode.classList.add("left");
        this._rightActions.domNode.classList.add("right");
      }
      dispose() {
        this._menuDisposables.dispose();
        this.element.remove();
      }
      show() {
        const menu = this._menuService.createMenu(suggestWidgetStatusbarMenu, this._contextKeyService);
        const renderMenu = () => {
          const left = [];
          const right = [];
          for (let [group, actions] of menu.getActions()) {
            if (group === "left") {
              left.push(...actions);
            } else {
              right.push(...actions);
            }
          }
          this._leftActions.clear();
          this._leftActions.push(left);
          this._rightActions.clear();
          this._rightActions.push(right);
        };
        this._menuDisposables.add(menu.onDidChange(() => renderMenu()));
        this._menuDisposables.add(menu);
      }
      hide() {
        this._menuDisposables.clear();
      }
    };
    SuggestWidgetStatus = __decorate31([
      __param31(1, IInstantiationService),
      __param31(2, IMenuService),
      __param31(3, IContextKeyService)
    ], SuggestWidgetStatus);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/symbolIcons.js
var SYMBOL_ICON_ARRAY_FOREGROUND, SYMBOL_ICON_BOOLEAN_FOREGROUND, SYMBOL_ICON_CLASS_FOREGROUND, SYMBOL_ICON_COLOR_FOREGROUND, SYMBOL_ICON_CONSTANT_FOREGROUND, SYMBOL_ICON_CONSTRUCTOR_FOREGROUND, SYMBOL_ICON_ENUMERATOR_FOREGROUND, SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND, SYMBOL_ICON_EVENT_FOREGROUND, SYMBOL_ICON_FIELD_FOREGROUND, SYMBOL_ICON_FILE_FOREGROUND, SYMBOL_ICON_FOLDER_FOREGROUND, SYMBOL_ICON_FUNCTION_FOREGROUND, SYMBOL_ICON_INTERFACE_FOREGROUND, SYMBOL_ICON_KEY_FOREGROUND, SYMBOL_ICON_KEYWORD_FOREGROUND, SYMBOL_ICON_METHOD_FOREGROUND, SYMBOL_ICON_MODULE_FOREGROUND, SYMBOL_ICON_NAMESPACE_FOREGROUND, SYMBOL_ICON_NULL_FOREGROUND, SYMBOL_ICON_NUMBER_FOREGROUND, SYMBOL_ICON_OBJECT_FOREGROUND, SYMBOL_ICON_OPERATOR_FOREGROUND, SYMBOL_ICON_PACKAGE_FOREGROUND, SYMBOL_ICON_PROPERTY_FOREGROUND, SYMBOL_ICON_REFERENCE_FOREGROUND, SYMBOL_ICON_SNIPPET_FOREGROUND, SYMBOL_ICON_STRING_FOREGROUND, SYMBOL_ICON_STRUCT_FOREGROUND, SYMBOL_ICON_TEXT_FOREGROUND, SYMBOL_ICON_TYPEPARAMETER_FOREGROUND, SYMBOL_ICON_UNIT_FOREGROUND, SYMBOL_ICON_VARIABLE_FOREGROUND;
var init_symbolIcons = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/symbolIcons.js"() {
    init_codicons();
    init_nls();
    init_colorRegistry();
    init_themeService();
    SYMBOL_ICON_ARRAY_FOREGROUND = registerColor("symbolIcon.arrayForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor("symbolIcon.booleanForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_CLASS_FOREGROUND = registerColor("symbolIcon.classForeground", {
      dark: "#EE9D28",
      light: "#D67E00",
      hc: "#EE9D28"
    }, localize("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_COLOR_FOREGROUND = registerColor("symbolIcon.colorForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor("symbolIcon.constantForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor("symbolIcon.constructorForeground", {
      dark: "#B180D7",
      light: "#652D90",
      hc: "#B180D7"
    }, localize("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor("symbolIcon.enumeratorForeground", {
      dark: "#EE9D28",
      light: "#D67E00",
      hc: "#EE9D28"
    }, localize("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor("symbolIcon.enumeratorMemberForeground", {
      dark: "#75BEFF",
      light: "#007ACC",
      hc: "#75BEFF"
    }, localize("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_EVENT_FOREGROUND = registerColor("symbolIcon.eventForeground", {
      dark: "#EE9D28",
      light: "#D67E00",
      hc: "#EE9D28"
    }, localize("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_FIELD_FOREGROUND = registerColor("symbolIcon.fieldForeground", {
      dark: "#75BEFF",
      light: "#007ACC",
      hc: "#75BEFF"
    }, localize("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_FILE_FOREGROUND = registerColor("symbolIcon.fileForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_FOLDER_FOREGROUND = registerColor("symbolIcon.folderForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor("symbolIcon.functionForeground", {
      dark: "#B180D7",
      light: "#652D90",
      hc: "#B180D7"
    }, localize("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor("symbolIcon.interfaceForeground", {
      dark: "#75BEFF",
      light: "#007ACC",
      hc: "#75BEFF"
    }, localize("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_KEY_FOREGROUND = registerColor("symbolIcon.keyForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor("symbolIcon.keywordForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_METHOD_FOREGROUND = registerColor("symbolIcon.methodForeground", {
      dark: "#B180D7",
      light: "#652D90",
      hc: "#B180D7"
    }, localize("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_MODULE_FOREGROUND = registerColor("symbolIcon.moduleForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor("symbolIcon.namespaceForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_NULL_FOREGROUND = registerColor("symbolIcon.nullForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_NUMBER_FOREGROUND = registerColor("symbolIcon.numberForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_OBJECT_FOREGROUND = registerColor("symbolIcon.objectForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor("symbolIcon.operatorForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor("symbolIcon.packageForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor("symbolIcon.propertyForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor("symbolIcon.referenceForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor("symbolIcon.snippetForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_STRING_FOREGROUND = registerColor("symbolIcon.stringForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_STRUCT_FOREGROUND = registerColor("symbolIcon.structForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_TEXT_FOREGROUND = registerColor("symbolIcon.textForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor("symbolIcon.typeParameterForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_UNIT_FOREGROUND = registerColor("symbolIcon.unitForeground", {
      dark: foreground,
      light: foreground,
      hc: foreground
    }, localize("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor("symbolIcon.variableForeground", {
      dark: "#75BEFF",
      light: "#007ACC",
      hc: "#75BEFF"
    }, localize("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
    registerThemingParticipant((theme, collector) => {
      const symbolIconArrayColor = theme.getColor(SYMBOL_ICON_ARRAY_FOREGROUND);
      if (symbolIconArrayColor) {
        collector.addRule(`${Codicon.symbolArray.cssSelector} { color: ${symbolIconArrayColor}; }`);
      }
      const symbolIconBooleanColor = theme.getColor(SYMBOL_ICON_BOOLEAN_FOREGROUND);
      if (symbolIconBooleanColor) {
        collector.addRule(`${Codicon.symbolBoolean.cssSelector} { color: ${symbolIconBooleanColor}; }`);
      }
      const symbolIconClassColor = theme.getColor(SYMBOL_ICON_CLASS_FOREGROUND);
      if (symbolIconClassColor) {
        collector.addRule(`${Codicon.symbolClass.cssSelector} { color: ${symbolIconClassColor}; }`);
      }
      const symbolIconMethodColor = theme.getColor(SYMBOL_ICON_METHOD_FOREGROUND);
      if (symbolIconMethodColor) {
        collector.addRule(`${Codicon.symbolMethod.cssSelector} { color: ${symbolIconMethodColor}; }`);
      }
      const symbolIconColorColor = theme.getColor(SYMBOL_ICON_COLOR_FOREGROUND);
      if (symbolIconColorColor) {
        collector.addRule(`${Codicon.symbolColor.cssSelector} { color: ${symbolIconColorColor}; }`);
      }
      const symbolIconConstantColor = theme.getColor(SYMBOL_ICON_CONSTANT_FOREGROUND);
      if (symbolIconConstantColor) {
        collector.addRule(`${Codicon.symbolConstant.cssSelector} { color: ${symbolIconConstantColor}; }`);
      }
      const symbolIconConstructorColor = theme.getColor(SYMBOL_ICON_CONSTRUCTOR_FOREGROUND);
      if (symbolIconConstructorColor) {
        collector.addRule(`${Codicon.symbolConstructor.cssSelector} { color: ${symbolIconConstructorColor}; }`);
      }
      const symbolIconEnumeratorColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_FOREGROUND);
      if (symbolIconEnumeratorColor) {
        collector.addRule(`
			${Codicon.symbolValue.cssSelector},${Codicon.symbolEnum.cssSelector} { color: ${symbolIconEnumeratorColor}; }`);
      }
      const symbolIconEnumeratorMemberColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND);
      if (symbolIconEnumeratorMemberColor) {
        collector.addRule(`${Codicon.symbolEnumMember.cssSelector} { color: ${symbolIconEnumeratorMemberColor}; }`);
      }
      const symbolIconEventColor = theme.getColor(SYMBOL_ICON_EVENT_FOREGROUND);
      if (symbolIconEventColor) {
        collector.addRule(`${Codicon.symbolEvent.cssSelector} { color: ${symbolIconEventColor}; }`);
      }
      const symbolIconFieldColor = theme.getColor(SYMBOL_ICON_FIELD_FOREGROUND);
      if (symbolIconFieldColor) {
        collector.addRule(`${Codicon.symbolField.cssSelector} { color: ${symbolIconFieldColor}; }`);
      }
      const symbolIconFileColor = theme.getColor(SYMBOL_ICON_FILE_FOREGROUND);
      if (symbolIconFileColor) {
        collector.addRule(`${Codicon.symbolFile.cssSelector} { color: ${symbolIconFileColor}; }`);
      }
      const symbolIconFolderColor = theme.getColor(SYMBOL_ICON_FOLDER_FOREGROUND);
      if (symbolIconFolderColor) {
        collector.addRule(`${Codicon.symbolFolder.cssSelector} { color: ${symbolIconFolderColor}; }`);
      }
      const symbolIconFunctionColor = theme.getColor(SYMBOL_ICON_FUNCTION_FOREGROUND);
      if (symbolIconFunctionColor) {
        collector.addRule(`${Codicon.symbolFunction.cssSelector} { color: ${symbolIconFunctionColor}; }`);
      }
      const symbolIconInterfaceColor = theme.getColor(SYMBOL_ICON_INTERFACE_FOREGROUND);
      if (symbolIconInterfaceColor) {
        collector.addRule(`${Codicon.symbolInterface.cssSelector} { color: ${symbolIconInterfaceColor}; }`);
      }
      const symbolIconKeyColor = theme.getColor(SYMBOL_ICON_KEY_FOREGROUND);
      if (symbolIconKeyColor) {
        collector.addRule(`${Codicon.symbolKey.cssSelector} { color: ${symbolIconKeyColor}; }`);
      }
      const symbolIconKeywordColor = theme.getColor(SYMBOL_ICON_KEYWORD_FOREGROUND);
      if (symbolIconKeywordColor) {
        collector.addRule(`${Codicon.symbolKeyword.cssSelector} { color: ${symbolIconKeywordColor}; }`);
      }
      const symbolIconModuleColor = theme.getColor(SYMBOL_ICON_MODULE_FOREGROUND);
      if (symbolIconModuleColor) {
        collector.addRule(`${Codicon.symbolModule.cssSelector} { color: ${symbolIconModuleColor}; }`);
      }
      const outlineNamespaceColor = theme.getColor(SYMBOL_ICON_NAMESPACE_FOREGROUND);
      if (outlineNamespaceColor) {
        collector.addRule(`${Codicon.symbolNamespace.cssSelector} { color: ${outlineNamespaceColor}; }`);
      }
      const symbolIconNullColor = theme.getColor(SYMBOL_ICON_NULL_FOREGROUND);
      if (symbolIconNullColor) {
        collector.addRule(`${Codicon.symbolNull.cssSelector} { color: ${symbolIconNullColor}; }`);
      }
      const symbolIconNumberColor = theme.getColor(SYMBOL_ICON_NUMBER_FOREGROUND);
      if (symbolIconNumberColor) {
        collector.addRule(`${Codicon.symbolNumber.cssSelector} { color: ${symbolIconNumberColor}; }`);
      }
      const symbolIconObjectColor = theme.getColor(SYMBOL_ICON_OBJECT_FOREGROUND);
      if (symbolIconObjectColor) {
        collector.addRule(`${Codicon.symbolObject.cssSelector} { color: ${symbolIconObjectColor}; }`);
      }
      const symbolIconOperatorColor = theme.getColor(SYMBOL_ICON_OPERATOR_FOREGROUND);
      if (symbolIconOperatorColor) {
        collector.addRule(`${Codicon.symbolOperator.cssSelector} { color: ${symbolIconOperatorColor}; }`);
      }
      const symbolIconPackageColor = theme.getColor(SYMBOL_ICON_PACKAGE_FOREGROUND);
      if (symbolIconPackageColor) {
        collector.addRule(`${Codicon.symbolPackage.cssSelector} { color: ${symbolIconPackageColor}; }`);
      }
      const symbolIconPropertyColor = theme.getColor(SYMBOL_ICON_PROPERTY_FOREGROUND);
      if (symbolIconPropertyColor) {
        collector.addRule(`${Codicon.symbolProperty.cssSelector} { color: ${symbolIconPropertyColor}; }`);
      }
      const symbolIconReferenceColor = theme.getColor(SYMBOL_ICON_REFERENCE_FOREGROUND);
      if (symbolIconReferenceColor) {
        collector.addRule(`${Codicon.symbolReference.cssSelector} { color: ${symbolIconReferenceColor}; }`);
      }
      const symbolIconSnippetColor = theme.getColor(SYMBOL_ICON_SNIPPET_FOREGROUND);
      if (symbolIconSnippetColor) {
        collector.addRule(`${Codicon.symbolSnippet.cssSelector} { color: ${symbolIconSnippetColor}; }`);
      }
      const symbolIconStringColor = theme.getColor(SYMBOL_ICON_STRING_FOREGROUND);
      if (symbolIconStringColor) {
        collector.addRule(`${Codicon.symbolString.cssSelector} { color: ${symbolIconStringColor}; }`);
      }
      const symbolIconStructColor = theme.getColor(SYMBOL_ICON_STRUCT_FOREGROUND);
      if (symbolIconStructColor) {
        collector.addRule(`${Codicon.symbolStruct.cssSelector} { color: ${symbolIconStructColor}; }`);
      }
      const symbolIconTextColor = theme.getColor(SYMBOL_ICON_TEXT_FOREGROUND);
      if (symbolIconTextColor) {
        collector.addRule(`${Codicon.symbolText.cssSelector} { color: ${symbolIconTextColor}; }`);
      }
      const symbolIconTypeParameterColor = theme.getColor(SYMBOL_ICON_TYPEPARAMETER_FOREGROUND);
      if (symbolIconTypeParameterColor) {
        collector.addRule(`${Codicon.symbolTypeParameter.cssSelector} { color: ${symbolIconTypeParameterColor}; }`);
      }
      const symbolIconUnitColor = theme.getColor(SYMBOL_ICON_UNIT_FOREGROUND);
      if (symbolIconUnitColor) {
        collector.addRule(`${Codicon.symbolUnit.cssSelector} { color: ${symbolIconUnitColor}; }`);
      }
      const symbolIconVariableColor = theme.getColor(SYMBOL_ICON_VARIABLE_FOREGROUND);
      if (symbolIconVariableColor) {
        collector.addRule(`${Codicon.symbolVariable.cssSelector} { color: ${symbolIconVariableColor}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/resizable.js
var ResizableHTMLElement;
var init_resizable = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/resizable.js"() {
    init_dom();
    init_sash();
    init_event();
    init_lifecycle();
    ResizableHTMLElement = class {
      constructor() {
        this._onDidWillResize = new Emitter();
        this.onDidWillResize = this._onDidWillResize.event;
        this._onDidResize = new Emitter();
        this.onDidResize = this._onDidResize.event;
        this._sashListener = new DisposableStore();
        this._size = new Dimension(0, 0);
        this._minSize = new Dimension(0, 0);
        this._maxSize = new Dimension(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
        this.domNode = document.createElement("div");
        this._eastSash = new Sash(this.domNode, { getVerticalSashLeft: () => this._size.width }, {
          orientation: 0
          /* VERTICAL */
        });
        this._westSash = new Sash(this.domNode, { getVerticalSashLeft: () => 0 }, {
          orientation: 0
          /* VERTICAL */
        });
        this._northSash = new Sash(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: OrthogonalEdge.North });
        this._southSash = new Sash(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: OrthogonalEdge.South });
        this._northSash.orthogonalStartSash = this._westSash;
        this._northSash.orthogonalEndSash = this._eastSash;
        this._southSash.orthogonalStartSash = this._westSash;
        this._southSash.orthogonalEndSash = this._eastSash;
        let currentSize;
        let deltaY = 0;
        let deltaX = 0;
        this._sashListener.add(Event.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
          if (currentSize === void 0) {
            this._onDidWillResize.fire();
            currentSize = this._size;
            deltaY = 0;
            deltaX = 0;
          }
        }));
        this._sashListener.add(Event.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
          if (currentSize !== void 0) {
            currentSize = void 0;
            deltaY = 0;
            deltaX = 0;
            this._onDidResize.fire({ dimension: this._size, done: true });
          }
        }));
        this._sashListener.add(this._eastSash.onDidChange((e) => {
          if (currentSize) {
            deltaX = e.currentX - e.startX;
            this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
            this._onDidResize.fire({ dimension: this._size, done: false, east: true });
          }
        }));
        this._sashListener.add(this._westSash.onDidChange((e) => {
          if (currentSize) {
            deltaX = -(e.currentX - e.startX);
            this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
            this._onDidResize.fire({ dimension: this._size, done: false, west: true });
          }
        }));
        this._sashListener.add(this._northSash.onDidChange((e) => {
          if (currentSize) {
            deltaY = -(e.currentY - e.startY);
            this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
            this._onDidResize.fire({ dimension: this._size, done: false, north: true });
          }
        }));
        this._sashListener.add(this._southSash.onDidChange((e) => {
          if (currentSize) {
            deltaY = e.currentY - e.startY;
            this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
            this._onDidResize.fire({ dimension: this._size, done: false, south: true });
          }
        }));
        this._sashListener.add(Event.any(this._eastSash.onDidReset, this._westSash.onDidReset)((e) => {
          if (this._preferredSize) {
            this.layout(this._size.height, this._preferredSize.width);
            this._onDidResize.fire({ dimension: this._size, done: true });
          }
        }));
        this._sashListener.add(Event.any(this._northSash.onDidReset, this._southSash.onDidReset)((e) => {
          if (this._preferredSize) {
            this.layout(this._preferredSize.height, this._size.width);
            this._onDidResize.fire({ dimension: this._size, done: true });
          }
        }));
      }
      dispose() {
        this._northSash.dispose();
        this._southSash.dispose();
        this._eastSash.dispose();
        this._westSash.dispose();
        this._sashListener.dispose();
        this._onDidResize.dispose();
        this._onDidWillResize.dispose();
        this.domNode.remove();
      }
      enableSashes(north, east, south, west) {
        this._northSash.state = north ? 3 : 0;
        this._eastSash.state = east ? 3 : 0;
        this._southSash.state = south ? 3 : 0;
        this._westSash.state = west ? 3 : 0;
      }
      layout(height = this.size.height, width = this.size.width) {
        const { height: minHeight, width: minWidth } = this._minSize;
        const { height: maxHeight, width: maxWidth } = this._maxSize;
        height = Math.max(minHeight, Math.min(maxHeight, height));
        width = Math.max(minWidth, Math.min(maxWidth, width));
        const newSize = new Dimension(width, height);
        if (!Dimension.equals(newSize, this._size)) {
          this.domNode.style.height = height + "px";
          this.domNode.style.width = width + "px";
          this._size = newSize;
          this._northSash.layout();
          this._eastSash.layout();
          this._southSash.layout();
          this._westSash.layout();
        }
      }
      clearSashHoverState() {
        this._eastSash.clearSashHoverState();
        this._westSash.clearSashHoverState();
        this._northSash.clearSashHoverState();
        this._southSash.clearSashHoverState();
      }
      get size() {
        return this._size;
      }
      set maxSize(value) {
        this._maxSize = value;
      }
      get maxSize() {
        return this._maxSize;
      }
      set minSize(value) {
        this._minSize = value;
      }
      get minSize() {
        return this._minSize;
      }
      set preferredSize(value) {
        this._preferredSize = value;
      }
      get preferredSize() {
        return this._preferredSize;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetDetails.js
function canExpandCompletionItem(item) {
  return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);
}
var __decorate32, __param32, SuggestDetailsWidget, SuggestDetailsOverlay;
var init_suggestWidgetDetails = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetDetails.js"() {
    init_dom();
    init_scrollableElement();
    init_codicons();
    init_event();
    init_htmlContent();
    init_lifecycle();
    init_markdownRenderer2();
    init_resizable();
    init_nls();
    init_instantiation();
    __decorate32 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param32 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    SuggestDetailsWidget = class SuggestDetailsWidget2 {
      constructor(_editor2, instaService) {
        this._editor = _editor2;
        this._onDidClose = new Emitter();
        this.onDidClose = this._onDidClose.event;
        this._onDidChangeContents = new Emitter();
        this.onDidChangeContents = this._onDidChangeContents.event;
        this._disposables = new DisposableStore();
        this._renderDisposeable = new DisposableStore();
        this._borderWidth = 1;
        this._size = new Dimension(330, 0);
        this.domNode = $(".suggest-details");
        this.domNode.classList.add("no-docs");
        this._markdownRenderer = instaService.createInstance(MarkdownRenderer, { editor: _editor2 });
        this._body = $(".body");
        this._scrollbar = new DomScrollableElement(this._body, {});
        append(this.domNode, this._scrollbar.getDomNode());
        this._disposables.add(this._scrollbar);
        this._header = append(this._body, $(".header"));
        this._close = append(this._header, $("span" + Codicon.close.cssSelector));
        this._close.title = localize("details.close", "Close");
        this._type = append(this._header, $("p.type"));
        this._docs = append(this._body, $("p.docs"));
        this._configureFont();
        this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            43
            /* fontInfo */
          )) {
            this._configureFont();
          }
        }));
      }
      dispose() {
        this._disposables.dispose();
        this._renderDisposeable.dispose();
      }
      _configureFont() {
        const options = this._editor.getOptions();
        const fontInfo = options.get(
          43
          /* fontInfo */
        );
        const fontFamily = fontInfo.fontFamily;
        const fontSize = options.get(
          106
          /* suggestFontSize */
        ) || fontInfo.fontSize;
        const lineHeight = options.get(
          107
          /* suggestLineHeight */
        ) || fontInfo.lineHeight;
        const fontWeight = fontInfo.fontWeight;
        const fontSizePx = `${fontSize}px`;
        const lineHeightPx = `${lineHeight}px`;
        this.domNode.style.fontSize = fontSizePx;
        this.domNode.style.lineHeight = lineHeightPx;
        this.domNode.style.fontWeight = fontWeight;
        this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
        this._type.style.fontFamily = fontFamily;
        this._close.style.height = lineHeightPx;
        this._close.style.width = lineHeightPx;
      }
      getLayoutInfo() {
        const lineHeight = this._editor.getOption(
          107
          /* suggestLineHeight */
        ) || this._editor.getOption(
          43
          /* fontInfo */
        ).lineHeight;
        const borderWidth = this._borderWidth;
        const borderHeight = borderWidth * 2;
        return {
          lineHeight,
          borderWidth,
          borderHeight,
          verticalPadding: 22,
          horizontalPadding: 14
        };
      }
      renderLoading() {
        this._type.textContent = localize("loading", "Loading...");
        this._docs.textContent = "";
        this.domNode.classList.remove("no-docs", "no-type");
        this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);
        this._onDidChangeContents.fire(this);
      }
      renderItem(item, explainMode) {
        var _a5, _b2;
        this._renderDisposeable.clear();
        let { detail, documentation } = item.completion;
        if (explainMode) {
          let md = "";
          md += `score: ${item.score[0]}
`;
          md += `prefix: ${(_a5 = item.word) !== null && _a5 !== void 0 ? _a5 : "(no prefix)"}
`;
          md += `word: ${item.completion.filterText ? item.completion.filterText + " (filterText)" : item.textLabel}
`;
          md += `distance: ${item.distance} (localityBonus-setting)
`;
          md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || "label"}
`;
          md += `commit_chars: ${(_b2 = item.completion.commitCharacters) === null || _b2 === void 0 ? void 0 : _b2.join("")}
`;
          documentation = new MarkdownString().appendCodeblock("empty", md);
          detail = `Provider: ${item.provider._debugDisplayName}`;
        }
        if (!explainMode && !canExpandCompletionItem(item)) {
          this.clearContents();
          return;
        }
        this.domNode.classList.remove("no-docs", "no-type");
        if (detail) {
          const cappedDetail = detail.length > 1e5 ? `${detail.substr(0, 1e5)}\u2026` : detail;
          this._type.textContent = cappedDetail;
          this._type.title = cappedDetail;
          show(this._type);
          this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(cappedDetail));
        } else {
          clearNode(this._type);
          this._type.title = "";
          hide(this._type);
          this.domNode.classList.add("no-type");
        }
        clearNode(this._docs);
        if (typeof documentation === "string") {
          this._docs.classList.remove("markdown-docs");
          this._docs.textContent = documentation;
        } else if (documentation) {
          this._docs.classList.add("markdown-docs");
          clearNode(this._docs);
          const renderedContents = this._markdownRenderer.render(documentation);
          this._docs.appendChild(renderedContents.element);
          this._renderDisposeable.add(renderedContents);
          this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
            this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
            this._onDidChangeContents.fire(this);
          }));
        }
        this.domNode.style.userSelect = "text";
        this.domNode.tabIndex = -1;
        this._close.onmousedown = (e) => {
          e.preventDefault();
          e.stopPropagation();
        };
        this._close.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          this._onDidClose.fire();
        };
        this._body.scrollTop = 0;
        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
        this._onDidChangeContents.fire(this);
      }
      clearContents() {
        this.domNode.classList.add("no-docs");
        this._type.textContent = "";
        this._docs.textContent = "";
      }
      get size() {
        return this._size;
      }
      layout(width, height) {
        const newSize = new Dimension(width, height);
        if (!Dimension.equals(newSize, this._size)) {
          this._size = newSize;
          size(this.domNode, width, height);
        }
        this._scrollbar.scanDomNode();
      }
      scrollDown(much = 8) {
        this._body.scrollTop += much;
      }
      scrollUp(much = 8) {
        this._body.scrollTop -= much;
      }
      scrollTop() {
        this._body.scrollTop = 0;
      }
      scrollBottom() {
        this._body.scrollTop = this._body.scrollHeight;
      }
      pageDown() {
        this.scrollDown(80);
      }
      pageUp() {
        this.scrollUp(80);
      }
      set borderWidth(width) {
        this._borderWidth = width;
      }
      get borderWidth() {
        return this._borderWidth;
      }
    };
    SuggestDetailsWidget = __decorate32([
      __param32(1, IInstantiationService)
    ], SuggestDetailsWidget);
    SuggestDetailsOverlay = class {
      constructor(widget, _editor2) {
        this.widget = widget;
        this._editor = _editor2;
        this._disposables = new DisposableStore();
        this._added = false;
        this._resizable = new ResizableHTMLElement();
        this._resizable.domNode.classList.add("suggest-details-container");
        this._resizable.domNode.appendChild(widget.domNode);
        this._resizable.enableSashes(false, true, true, false);
        let topLeftNow;
        let sizeNow;
        let deltaTop = 0;
        let deltaLeft = 0;
        this._disposables.add(this._resizable.onDidWillResize(() => {
          topLeftNow = this._topLeft;
          sizeNow = this._resizable.size;
        }));
        this._disposables.add(this._resizable.onDidResize((e) => {
          if (topLeftNow && sizeNow) {
            this.widget.layout(e.dimension.width, e.dimension.height);
            let updateTopLeft = false;
            if (e.west) {
              deltaLeft = sizeNow.width - e.dimension.width;
              updateTopLeft = true;
            }
            if (e.north) {
              deltaTop = sizeNow.height - e.dimension.height;
              updateTopLeft = true;
            }
            if (updateTopLeft) {
              this._applyTopLeft({
                top: topLeftNow.top + deltaTop,
                left: topLeftNow.left + deltaLeft
              });
            }
          }
          if (e.done) {
            topLeftNow = void 0;
            sizeNow = void 0;
            deltaTop = 0;
            deltaLeft = 0;
            this._userSize = e.dimension;
          }
        }));
        this._disposables.add(this.widget.onDidChangeContents(() => {
          var _a5;
          if (this._anchorBox) {
            this._placeAtAnchor(this._anchorBox, (_a5 = this._userSize) !== null && _a5 !== void 0 ? _a5 : this.widget.size);
          }
        }));
      }
      dispose() {
        this._resizable.dispose();
        this._disposables.dispose();
        this.hide();
      }
      getId() {
        return "suggest.details";
      }
      getDomNode() {
        return this._resizable.domNode;
      }
      getPosition() {
        return null;
      }
      show() {
        if (!this._added) {
          this._editor.addOverlayWidget(this);
          this.getDomNode().style.position = "fixed";
          this._added = true;
        }
      }
      hide(sessionEnded = false) {
        this._resizable.clearSashHoverState();
        if (this._added) {
          this._editor.removeOverlayWidget(this);
          this._added = false;
          this._anchorBox = void 0;
          this._topLeft = void 0;
        }
        if (sessionEnded) {
          this._userSize = void 0;
          this.widget.clearContents();
        }
      }
      placeAtAnchor(anchor) {
        var _a5;
        const anchorBox = getDomNodePagePosition(anchor);
        this._anchorBox = anchorBox;
        this._placeAtAnchor(this._anchorBox, (_a5 = this._userSize) !== null && _a5 !== void 0 ? _a5 : this.widget.size);
      }
      _placeAtAnchor(anchorBox, size2) {
        const bodyBox = getClientArea(document.body);
        const info = this.widget.getLayoutInfo();
        let maxSizeTop;
        let maxSizeBottom;
        let minSize = new Dimension(220, 2 * info.lineHeight);
        let left = 0;
        let top = anchorBox.top;
        let bottom = anchorBox.top + anchorBox.height - info.borderHeight;
        let alignAtTop;
        let alignEast;
        let width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);
        left = -info.borderWidth + anchorBox.left + anchorBox.width;
        alignEast = true;
        maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
        maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
        if (size2.width > width) {
          if (anchorBox.left > width) {
            width = anchorBox.left - info.borderWidth - info.horizontalPadding;
            alignEast = false;
            left = Math.max(info.horizontalPadding, anchorBox.left - size2.width - info.borderWidth);
            maxSizeTop = maxSizeTop.with(width);
            maxSizeBottom = maxSizeTop.with(void 0, maxSizeBottom.height);
          }
          if (anchorBox.width > width * 1.3 && bodyBox.height - (anchorBox.top + anchorBox.height) > anchorBox.height) {
            width = anchorBox.width;
            left = anchorBox.left;
            top = -info.borderWidth + anchorBox.top + anchorBox.height;
            maxSizeTop = new Dimension(anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);
            maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top - info.verticalPadding);
            minSize = minSize.with(maxSizeTop.width);
          }
        }
        let height = size2.height;
        let maxHeight = Math.max(maxSizeTop.height, maxSizeBottom.height);
        if (height > maxHeight) {
          height = maxHeight;
        }
        let maxSize;
        if (height <= maxSizeTop.height) {
          alignAtTop = true;
          maxSize = maxSizeTop;
        } else {
          alignAtTop = false;
          maxSize = maxSizeBottom;
        }
        this._applyTopLeft({ left, top: alignAtTop ? top : bottom - height });
        this.getDomNode().style.position = "fixed";
        this._resizable.enableSashes(!alignAtTop, alignEast, alignAtTop, !alignEast);
        this._resizable.minSize = minSize;
        this._resizable.maxSize = maxSize;
        this._resizable.layout(height, Math.min(maxSize.width, size2.width));
        this.widget.layout(this._resizable.size.width, this._resizable.size.height);
      }
      _applyTopLeft(topLeft) {
        this._topLeft = topLeft;
        this.getDomNode().style.left = `${this._topLeft.left}px`;
        this.getDomNode().style.top = `${this._topLeft.top}px`;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/files/common/files.js
var FileKind;
var init_files = __esm({
  "node_modules/monaco-editor/esm/vs/platform/files/common/files.js"() {
    (function(FileKind2) {
      FileKind2[FileKind2["FILE"] = 0] = "FILE";
      FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
      FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
    })(FileKind || (FileKind = {}));
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
function getIconClasses(modelService, modeService, resource, fileKind) {
  const classes = fileKind === FileKind.ROOT_FOLDER ? ["rootfolder-icon"] : fileKind === FileKind.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (resource) {
    let name;
    if (resource.scheme === Schemas.data) {
      const metadata = DataUri.parseMetaData(resource);
      name = metadata.get(DataUri.META_DATA_LABEL);
    } else {
      name = cssEscape(basenameOrAuthority(resource).toLowerCase());
    }
    if (fileKind === FileKind.FOLDER) {
      classes.push(`${name}-name-folder-icon`);
    } else {
      if (name) {
        classes.push(`${name}-name-file-icon`);
        if (name.length <= 255) {
          const dotSegments = name.split(".");
          for (let i = 1; i < dotSegments.length; i++) {
            classes.push(`${dotSegments.slice(i).join(".")}-ext-file-icon`);
          }
        }
        classes.push(`ext-file-icon`);
      }
      const detectedModeId = detectModeId(modelService, modeService, resource);
      if (detectedModeId) {
        classes.push(`${cssEscape(detectedModeId)}-lang-file-icon`);
      }
    }
  }
  return classes;
}
function detectModeId(modelService, modeService, resource) {
  if (!resource) {
    return null;
  }
  let modeId = null;
  if (resource.scheme === Schemas.data) {
    const metadata = DataUri.parseMetaData(resource);
    const mime = metadata.get(DataUri.META_DATA_MIME);
    if (mime) {
      modeId = modeService.getModeId(mime);
    }
  } else {
    const model = modelService.getModel(resource);
    if (model) {
      modeId = model.getModeId();
    }
  }
  if (modeId && modeId !== PLAINTEXT_MODE_ID) {
    return modeId;
  }
  return modeService.getModeIdByFilepathOrFirstLine(resource);
}
function cssEscape(str) {
  return str.replace(/[\11\12\14\15\40]/g, "/");
}
var init_getIconClasses = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js"() {
    init_network();
    init_resources();
    init_modesRegistry();
    init_files();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetRenderer.js
function getAriaId(index) {
  return `suggest-aria-id:${index}`;
}
function stripNewLines(str) {
  return str.replace(/\r\n|\r|\n/g, "");
}
var __decorate33, __param33, _a3, suggestMoreInfoIcon, _completionItemColor, ItemRenderer;
var init_suggestWidgetRenderer = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetRenderer.js"() {
    init_dom();
    init_iconLabel();
    init_arrays();
    init_codicons();
    init_event();
    init_filters();
    init_lifecycle();
    init_uri();
    init_modes();
    init_getIconClasses();
    init_modelService();
    init_modeService();
    init_nls();
    init_files();
    init_iconRegistry();
    init_themeService();
    init_suggestWidgetDetails();
    __decorate33 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param33 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    suggestMoreInfoIcon = registerIcon("suggest-more-info", Codicon.chevronRight, localize("suggestMoreInfoIcon", "Icon for more information in the suggest widget."));
    _completionItemColor = new (_a3 = class ColorExtractor {
      extract(item, out) {
        if (item.textLabel.match(ColorExtractor._regexStrict)) {
          out[0] = item.textLabel;
          return true;
        }
        if (item.completion.detail && item.completion.detail.match(ColorExtractor._regexStrict)) {
          out[0] = item.completion.detail;
          return true;
        }
        if (typeof item.completion.documentation === "string") {
          const match = ColorExtractor._regexRelaxed.exec(item.completion.documentation);
          if (match && (match.index === 0 || match.index + match[0].length === item.completion.documentation.length)) {
            out[0] = match[0];
            return true;
          }
        }
        return false;
      }
    }, _a3._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, _a3._regexStrict = new RegExp(`^${_a3._regexRelaxed.source}$`, "i"), _a3)();
    ItemRenderer = class ItemRenderer2 {
      constructor(_editor2, _modelService, _modeService, _themeService) {
        this._editor = _editor2;
        this._modelService = _modelService;
        this._modeService = _modeService;
        this._themeService = _themeService;
        this._onDidToggleDetails = new Emitter();
        this.onDidToggleDetails = this._onDidToggleDetails.event;
        this.templateId = "suggestion";
      }
      dispose() {
        this._onDidToggleDetails.dispose();
      }
      renderTemplate(container) {
        const data = /* @__PURE__ */ Object.create(null);
        data.disposables = new DisposableStore();
        data.root = container;
        data.root.classList.add("show-file-icons");
        data.icon = append(container, $(".icon"));
        data.colorspan = append(data.icon, $("span.colorspan"));
        const text2 = append(container, $(".contents"));
        const main = append(text2, $(".main"));
        data.iconContainer = append(main, $(".icon-label.codicon"));
        data.left = append(main, $("span.left"));
        data.right = append(main, $("span.right"));
        data.iconLabel = new IconLabel(data.left, { supportHighlights: true, supportIcons: true });
        data.disposables.add(data.iconLabel);
        data.parametersLabel = append(data.left, $("span.signature-label"));
        data.qualifierLabel = append(data.left, $("span.qualifier-label"));
        data.detailsLabel = append(data.right, $("span.details-label"));
        data.readMore = append(data.right, $("span.readMore" + ThemeIcon.asCSSSelector(suggestMoreInfoIcon)));
        data.readMore.title = localize("readMore", "Read More");
        const configureFont = () => {
          const options = this._editor.getOptions();
          const fontInfo = options.get(
            43
            /* fontInfo */
          );
          const fontFamily = fontInfo.fontFamily;
          const fontFeatureSettings = fontInfo.fontFeatureSettings;
          const fontSize = options.get(
            106
            /* suggestFontSize */
          ) || fontInfo.fontSize;
          const lineHeight = options.get(
            107
            /* suggestLineHeight */
          ) || fontInfo.lineHeight;
          const fontWeight = fontInfo.fontWeight;
          const fontSizePx = `${fontSize}px`;
          const lineHeightPx = `${lineHeight}px`;
          data.root.style.fontSize = fontSizePx;
          data.root.style.fontWeight = fontWeight;
          main.style.fontFamily = fontFamily;
          main.style.fontFeatureSettings = fontFeatureSettings;
          main.style.lineHeight = lineHeightPx;
          data.icon.style.height = lineHeightPx;
          data.icon.style.width = lineHeightPx;
          data.readMore.style.height = lineHeightPx;
          data.readMore.style.width = lineHeightPx;
        };
        configureFont();
        data.disposables.add(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            43
            /* fontInfo */
          ) || e.hasChanged(
            106
            /* suggestFontSize */
          ) || e.hasChanged(
            107
            /* suggestLineHeight */
          )) {
            configureFont();
          }
        }));
        return data;
      }
      renderElement(element, index, data) {
        const { completion } = element;
        data.root.id = getAriaId(index);
        data.colorspan.style.backgroundColor = "";
        const labelOptions = {
          labelEscapeNewLines: true,
          matches: createMatches(element.score)
        };
        let color = [];
        if (completion.kind === 19 && _completionItemColor.extract(element, color)) {
          data.icon.className = "icon customcolor";
          data.iconContainer.className = "icon hide";
          data.colorspan.style.backgroundColor = color[0];
        } else if (completion.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
          data.icon.className = "icon hide";
          data.iconContainer.className = "icon hide";
          const labelClasses = getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FILE);
          const detailClasses = getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FILE);
          labelOptions.extraClasses = labelClasses.length > detailClasses.length ? labelClasses : detailClasses;
        } else if (completion.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons) {
          data.icon.className = "icon hide";
          data.iconContainer.className = "icon hide";
          labelOptions.extraClasses = flatten([
            getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FOLDER),
            getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FOLDER)
          ]);
        } else {
          data.icon.className = "icon hide";
          data.iconContainer.className = "";
          data.iconContainer.classList.add("suggest-icon", ...completionKindToCssClass(completion.kind).split(" "));
        }
        if (completion.tags && completion.tags.indexOf(
          1
          /* Deprecated */
        ) >= 0) {
          labelOptions.extraClasses = (labelOptions.extraClasses || []).concat(["deprecated"]);
          labelOptions.matches = [];
        }
        data.iconLabel.setLabel(element.textLabel, void 0, labelOptions);
        if (typeof completion.label === "string") {
          data.parametersLabel.textContent = "";
          data.detailsLabel.textContent = stripNewLines(completion.detail || "");
          data.root.classList.add("string-label");
        } else {
          data.parametersLabel.textContent = stripNewLines(completion.label.detail || "");
          data.detailsLabel.textContent = stripNewLines(completion.label.description || "");
          data.root.classList.remove("string-label");
        }
        if (this._editor.getOption(
          105
          /* suggest */
        ).showInlineDetails) {
          show(data.detailsLabel);
        } else {
          hide(data.detailsLabel);
        }
        if (canExpandCompletionItem(element)) {
          data.right.classList.add("can-expand-details");
          show(data.readMore);
          data.readMore.onmousedown = (e) => {
            e.stopPropagation();
            e.preventDefault();
          };
          data.readMore.onclick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            this._onDidToggleDetails.fire();
          };
        } else {
          data.right.classList.remove("can-expand-details");
          hide(data.readMore);
          data.readMore.onmousedown = null;
          data.readMore.onclick = null;
        }
      }
      disposeTemplate(templateData) {
        templateData.disposables.dispose();
      }
    };
    ItemRenderer = __decorate33([
      __param33(1, IModelService),
      __param33(2, IModeService),
      __param33(3, IThemeService)
    ], ItemRenderer);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidget.js
var __decorate34, __param34, __awaiter25, editorSuggestWidgetBackground, editorSuggestWidgetBorder, editorSuggestWidgetForeground, editorSuggestWidgetSelectedForeground, editorSuggestWidgetSelectedIconForeground, editorSuggestWidgetSelectedBackground, editorSuggestWidgetHighlightForeground, editorSuggestWidgetHighlightFocusForeground, PersistedWidgetSize, SuggestWidget, SuggestContentWidget;
var init_suggestWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidget.js"() {
    init_dom();
    init_codiconStyles();
    init_listWidget();
    init_async();
    init_errors();
    init_event();
    init_lifecycle();
    init_numbers();
    init_strings();
    init_embeddedCodeEditorWidget();
    init_suggestWidgetStatus();
    init_symbolIcons();
    init_nls();
    init_contextkey();
    init_instantiation();
    init_storage();
    init_colorRegistry();
    init_styler();
    init_themeService();
    init_resizable();
    init_suggest();
    init_suggestWidgetDetails();
    init_suggestWidgetRenderer();
    __decorate34 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param34 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter25 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    editorSuggestWidgetBackground = registerColor("editorSuggestWidget.background", { dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground }, localize("editorSuggestWidgetBackground", "Background color of the suggest widget."));
    editorSuggestWidgetBorder = registerColor("editorSuggestWidget.border", { dark: editorWidgetBorder, light: editorWidgetBorder, hc: editorWidgetBorder }, localize("editorSuggestWidgetBorder", "Border color of the suggest widget."));
    editorSuggestWidgetForeground = registerColor("editorSuggestWidget.foreground", { dark: editorForeground, light: editorForeground, hc: editorForeground }, localize("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
    editorSuggestWidgetSelectedForeground = registerColor("editorSuggestWidget.selectedForeground", { dark: quickInputListFocusForeground, light: quickInputListFocusForeground, hc: quickInputListFocusForeground }, localize("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
    editorSuggestWidgetSelectedIconForeground = registerColor("editorSuggestWidget.selectedIconForeground", { dark: quickInputListFocusIconForeground, light: quickInputListFocusIconForeground, hc: quickInputListFocusIconForeground }, localize("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
    editorSuggestWidgetSelectedBackground = registerColor("editorSuggestWidget.selectedBackground", { dark: quickInputListFocusBackground, light: quickInputListFocusBackground, hc: quickInputListFocusBackground }, localize("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
    editorSuggestWidgetHighlightForeground = registerColor("editorSuggestWidget.highlightForeground", { dark: listHighlightForeground, light: listHighlightForeground, hc: listHighlightForeground }, localize("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
    editorSuggestWidgetHighlightFocusForeground = registerColor("editorSuggestWidget.focusHighlightForeground", { dark: listFocusHighlightForeground, light: listFocusHighlightForeground, hc: listFocusHighlightForeground }, localize("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
    PersistedWidgetSize = class {
      constructor(_service, editor2) {
        this._service = _service;
        this._key = `suggestWidget.size/${editor2.getEditorType()}/${editor2 instanceof EmbeddedCodeEditorWidget}`;
      }
      restore() {
        var _a5;
        const raw = (_a5 = this._service.get(
          this._key,
          0
          /* GLOBAL */
        )) !== null && _a5 !== void 0 ? _a5 : "";
        try {
          const obj = JSON.parse(raw);
          if (Dimension.is(obj)) {
            return Dimension.lift(obj);
          }
        } catch (_b2) {
        }
        return void 0;
      }
      store(size2) {
        this._service.store(
          this._key,
          JSON.stringify(size2),
          0,
          1
          /* MACHINE */
        );
      }
      reset() {
        this._service.remove(
          this._key,
          0
          /* GLOBAL */
        );
      }
    };
    SuggestWidget = class SuggestWidget2 {
      constructor(editor2, _storageService, _contextKeyService, _themeService, instantiationService) {
        this.editor = editor2;
        this._storageService = _storageService;
        this._state = 0;
        this._isAuto = false;
        this._ignoreFocusEvents = false;
        this._forceRenderingAbove = false;
        this._explainMode = false;
        this._showTimeout = new TimeoutTimer();
        this._disposables = new DisposableStore();
        this._onDidSelect = new Emitter();
        this._onDidFocus = new Emitter();
        this._onDidHide = new Emitter();
        this._onDidShow = new Emitter();
        this.onDidSelect = this._onDidSelect.event;
        this.onDidFocus = this._onDidFocus.event;
        this.onDidHide = this._onDidHide.event;
        this.onDidShow = this._onDidShow.event;
        this._onDetailsKeydown = new Emitter();
        this.onDetailsKeyDown = this._onDetailsKeydown.event;
        this.element = new ResizableHTMLElement();
        this.element.domNode.classList.add("editor-widget", "suggest-widget");
        this._contentWidget = new SuggestContentWidget(this, editor2);
        this._persistedSize = new PersistedWidgetSize(_storageService, editor2);
        class ResizeState {
          constructor(persistedSize, currentSize, persistHeight = false, persistWidth = false) {
            this.persistedSize = persistedSize;
            this.currentSize = currentSize;
            this.persistHeight = persistHeight;
            this.persistWidth = persistWidth;
          }
        }
        let state;
        this._disposables.add(this.element.onDidWillResize(() => {
          this._contentWidget.lockPreference();
          state = new ResizeState(this._persistedSize.restore(), this.element.size);
        }));
        this._disposables.add(this.element.onDidResize((e) => {
          var _a5, _b2, _c2, _d2;
          this._resize(e.dimension.width, e.dimension.height);
          if (state) {
            state.persistHeight = state.persistHeight || !!e.north || !!e.south;
            state.persistWidth = state.persistWidth || !!e.east || !!e.west;
          }
          if (!e.done) {
            return;
          }
          if (state) {
            const { itemHeight, defaultSize } = this.getLayoutInfo();
            const threshold = Math.round(itemHeight / 2);
            let { width, height } = this.element.size;
            if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) {
              height = (_b2 = (_a5 = state.persistedSize) === null || _a5 === void 0 ? void 0 : _a5.height) !== null && _b2 !== void 0 ? _b2 : defaultSize.height;
            }
            if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) {
              width = (_d2 = (_c2 = state.persistedSize) === null || _c2 === void 0 ? void 0 : _c2.width) !== null && _d2 !== void 0 ? _d2 : defaultSize.width;
            }
            this._persistedSize.store(new Dimension(width, height));
          }
          this._contentWidget.unlockPreference();
          state = void 0;
        }));
        this._messageElement = append(this.element.domNode, $(".message"));
        this._listElement = append(this.element.domNode, $(".tree"));
        const details = instantiationService.createInstance(SuggestDetailsWidget, this.editor);
        details.onDidClose(this.toggleDetails, this, this._disposables);
        this._details = new SuggestDetailsOverlay(details, this.editor);
        const applyIconStyle = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(
          105
          /* suggest */
        ).showIcons);
        applyIconStyle();
        const renderer = instantiationService.createInstance(ItemRenderer, this.editor);
        this._disposables.add(renderer);
        this._disposables.add(renderer.onDidToggleDetails(() => this.toggleDetails()));
        this._list = new List("SuggestWidget", this._listElement, {
          getHeight: (_element) => this.getLayoutInfo().itemHeight,
          getTemplateId: (_element) => "suggestion"
        }, [renderer], {
          alwaysConsumeMouseWheel: true,
          useShadows: false,
          mouseSupport: false,
          accessibilityProvider: {
            getRole: () => "option",
            getAriaLabel: (item) => {
              if (item.isResolved && this._isDetailsVisible()) {
                const { documentation, detail } = item.completion;
                const docs = format("{0}{1}", detail || "", documentation ? typeof documentation === "string" ? documentation : documentation.value : "");
                return localize("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", item.textLabel, docs);
              } else {
                return item.textLabel;
              }
            },
            getWidgetAriaLabel: () => localize("suggest", "Suggest"),
            getWidgetRole: () => "listbox"
          }
        });
        this._status = instantiationService.createInstance(SuggestWidgetStatus, this.element.domNode);
        const applyStatusBarStyle = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(
          105
          /* suggest */
        ).showStatusBar);
        applyStatusBarStyle();
        this._disposables.add(attachListStyler(this._list, _themeService, {
          listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
          listInactiveFocusOutline: activeContrastBorder
        }));
        this._disposables.add(_themeService.onDidColorThemeChange((t) => this._onThemeChange(t)));
        this._onThemeChange(_themeService.getColorTheme());
        this._disposables.add(this._list.onMouseDown((e) => this._onListMouseDownOrTap(e)));
        this._disposables.add(this._list.onTap((e) => this._onListMouseDownOrTap(e)));
        this._disposables.add(this._list.onDidChangeSelection((e) => this._onListSelection(e)));
        this._disposables.add(this._list.onDidChangeFocus((e) => this._onListFocus(e)));
        this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged()));
        this._disposables.add(this.editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            105
            /* suggest */
          )) {
            applyStatusBarStyle();
            applyIconStyle();
          }
        }));
        this._ctxSuggestWidgetVisible = Context.Visible.bindTo(_contextKeyService);
        this._ctxSuggestWidgetDetailsVisible = Context.DetailsVisible.bindTo(_contextKeyService);
        this._ctxSuggestWidgetMultipleSuggestions = Context.MultipleSuggestions.bindTo(_contextKeyService);
        this._disposables.add(addStandardDisposableListener(this._details.widget.domNode, "keydown", (e) => {
          this._onDetailsKeydown.fire(e);
        }));
        this._disposables.add(this.editor.onMouseDown((e) => this._onEditorMouseDown(e)));
      }
      dispose() {
        var _a5;
        this._details.widget.dispose();
        this._details.dispose();
        this._list.dispose();
        this._status.dispose();
        this._disposables.dispose();
        (_a5 = this._loadingTimeout) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._showTimeout.dispose();
        this._contentWidget.dispose();
        this.element.dispose();
      }
      _onEditorMouseDown(mouseEvent) {
        if (this._details.widget.domNode.contains(mouseEvent.target.element)) {
          this._details.widget.domNode.focus();
        } else {
          if (this.element.domNode.contains(mouseEvent.target.element)) {
            this.editor.focus();
          }
        }
      }
      _onCursorSelectionChanged() {
        if (this._state !== 0) {
          this._contentWidget.layout();
        }
      }
      _onListMouseDownOrTap(e) {
        if (typeof e.element === "undefined" || typeof e.index === "undefined") {
          return;
        }
        e.browserEvent.preventDefault();
        e.browserEvent.stopPropagation();
        this._select(e.element, e.index);
      }
      _onListSelection(e) {
        if (e.elements.length) {
          this._select(e.elements[0], e.indexes[0]);
        }
      }
      _select(item, index) {
        const completionModel = this._completionModel;
        if (completionModel) {
          this._onDidSelect.fire({ item, index, model: completionModel });
          this.editor.focus();
        }
      }
      _onThemeChange(theme) {
        const backgroundColor = theme.getColor(editorSuggestWidgetBackground);
        if (backgroundColor) {
          this.element.domNode.style.backgroundColor = backgroundColor.toString();
          this._messageElement.style.backgroundColor = backgroundColor.toString();
          this._details.widget.domNode.style.backgroundColor = backgroundColor.toString();
        }
        const borderColor = theme.getColor(editorSuggestWidgetBorder);
        if (borderColor) {
          this.element.domNode.style.borderColor = borderColor.toString();
          this._messageElement.style.borderColor = borderColor.toString();
          this._status.element.style.borderTopColor = borderColor.toString();
          this._details.widget.domNode.style.borderColor = borderColor.toString();
          this._detailsBorderColor = borderColor.toString();
        }
        const focusBorderColor = theme.getColor(focusBorder);
        if (focusBorderColor) {
          this._detailsFocusBorderColor = focusBorderColor.toString();
        }
        this._details.widget.borderWidth = theme.type === "hc" ? 2 : 1;
      }
      _onListFocus(e) {
        var _a5;
        if (this._ignoreFocusEvents) {
          return;
        }
        if (!e.elements.length) {
          if (this._currentSuggestionDetails) {
            this._currentSuggestionDetails.cancel();
            this._currentSuggestionDetails = void 0;
            this._focusedItem = void 0;
          }
          this.editor.setAriaOptions({ activeDescendant: void 0 });
          return;
        }
        if (!this._completionModel) {
          return;
        }
        const item = e.elements[0];
        const index = e.indexes[0];
        if (item !== this._focusedItem) {
          (_a5 = this._currentSuggestionDetails) === null || _a5 === void 0 ? void 0 : _a5.cancel();
          this._currentSuggestionDetails = void 0;
          this._focusedItem = item;
          this._list.reveal(index);
          this._currentSuggestionDetails = createCancelablePromise((token) => __awaiter25(this, void 0, void 0, function* () {
            const loading = disposableTimeout(() => {
              if (this._isDetailsVisible()) {
                this.showDetails(true);
              }
            }, 250);
            token.onCancellationRequested(() => loading.dispose());
            const result = yield item.resolve(token);
            loading.dispose();
            return result;
          }));
          this._currentSuggestionDetails.then(() => {
            if (index >= this._list.length || item !== this._list.element(index)) {
              return;
            }
            this._ignoreFocusEvents = true;
            this._list.splice(index, 1, [item]);
            this._list.setFocus([index]);
            this._ignoreFocusEvents = false;
            if (this._isDetailsVisible()) {
              this.showDetails(false);
            } else {
              this.element.domNode.classList.remove("docs-side");
            }
            this.editor.setAriaOptions({ activeDescendant: getAriaId(index) });
          }).catch(onUnexpectedError);
        }
        this._onDidFocus.fire({ item, index, model: this._completionModel });
      }
      _setState(state) {
        if (this._state === state) {
          return;
        }
        this._state = state;
        this.element.domNode.classList.toggle(
          "frozen",
          state === 4
          /* Frozen */
        );
        this.element.domNode.classList.remove("message");
        switch (state) {
          case 0:
            hide(this._messageElement, this._listElement, this._status.element);
            this._details.hide(true);
            this._status.hide();
            this._contentWidget.hide();
            this._ctxSuggestWidgetVisible.reset();
            this._ctxSuggestWidgetMultipleSuggestions.reset();
            this._showTimeout.cancel();
            this.element.domNode.classList.remove("visible");
            this._list.splice(0, this._list.length);
            this._focusedItem = void 0;
            this._cappedHeight = void 0;
            this._explainMode = false;
            break;
          case 1:
            this.element.domNode.classList.add("message");
            this._messageElement.textContent = SuggestWidget2.LOADING_MESSAGE;
            hide(this._listElement, this._status.element);
            show(this._messageElement);
            this._details.hide();
            this._show();
            this._focusedItem = void 0;
            break;
          case 2:
            this.element.domNode.classList.add("message");
            this._messageElement.textContent = SuggestWidget2.NO_SUGGESTIONS_MESSAGE;
            hide(this._listElement, this._status.element);
            show(this._messageElement);
            this._details.hide();
            this._show();
            this._focusedItem = void 0;
            break;
          case 3:
            hide(this._messageElement);
            show(this._listElement, this._status.element);
            this._show();
            break;
          case 4:
            hide(this._messageElement);
            show(this._listElement, this._status.element);
            this._show();
            break;
          case 5:
            hide(this._messageElement);
            show(this._listElement, this._status.element);
            this._details.show();
            this._show();
            break;
        }
      }
      _show() {
        this._status.show();
        this._contentWidget.show();
        this._layout(this._persistedSize.restore());
        this._ctxSuggestWidgetVisible.set(true);
        this._showTimeout.cancelAndSet(() => {
          this.element.domNode.classList.add("visible");
          this._onDidShow.fire(this);
        }, 100);
      }
      showTriggered(auto, delay) {
        if (this._state !== 0) {
          return;
        }
        this._contentWidget.setPosition(this.editor.getPosition());
        this._isAuto = !!auto;
        if (!this._isAuto) {
          this._loadingTimeout = disposableTimeout(() => this._setState(
            1
            /* Loading */
          ), delay);
        }
      }
      showSuggestions(completionModel, selectionIndex, isFrozen2, isAuto) {
        var _a5, _b2;
        this._contentWidget.setPosition(this.editor.getPosition());
        (_a5 = this._loadingTimeout) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        (_b2 = this._currentSuggestionDetails) === null || _b2 === void 0 ? void 0 : _b2.cancel();
        this._currentSuggestionDetails = void 0;
        if (this._completionModel !== completionModel) {
          this._completionModel = completionModel;
        }
        if (isFrozen2 && this._state !== 2 && this._state !== 0) {
          this._setState(
            4
            /* Frozen */
          );
          return;
        }
        const visibleCount = this._completionModel.items.length;
        const isEmpty = visibleCount === 0;
        this._ctxSuggestWidgetMultipleSuggestions.set(visibleCount > 1);
        if (isEmpty) {
          this._setState(
            isAuto ? 0 : 2
            /* Empty */
          );
          this._completionModel = void 0;
          return;
        }
        this._focusedItem = void 0;
        this._list.splice(0, this._list.length, this._completionModel.items);
        this._setState(
          isFrozen2 ? 4 : 3
          /* Open */
        );
        this._list.reveal(selectionIndex, 0);
        this._list.setFocus([selectionIndex]);
        this._layout(this.element.size);
        if (this._detailsBorderColor) {
          this._details.widget.domNode.style.borderColor = this._detailsBorderColor;
        }
      }
      selectNextPage() {
        switch (this._state) {
          case 0:
            return false;
          case 5:
            this._details.widget.pageDown();
            return true;
          case 1:
            return !this._isAuto;
          default:
            this._list.focusNextPage();
            return true;
        }
      }
      selectNext() {
        switch (this._state) {
          case 0:
            return false;
          case 1:
            return !this._isAuto;
          default:
            this._list.focusNext(1, true);
            return true;
        }
      }
      selectLast() {
        switch (this._state) {
          case 0:
            return false;
          case 5:
            this._details.widget.scrollBottom();
            return true;
          case 1:
            return !this._isAuto;
          default:
            this._list.focusLast();
            return true;
        }
      }
      selectPreviousPage() {
        switch (this._state) {
          case 0:
            return false;
          case 5:
            this._details.widget.pageUp();
            return true;
          case 1:
            return !this._isAuto;
          default:
            this._list.focusPreviousPage();
            return true;
        }
      }
      selectPrevious() {
        switch (this._state) {
          case 0:
            return false;
          case 1:
            return !this._isAuto;
          default:
            this._list.focusPrevious(1, true);
            return false;
        }
      }
      selectFirst() {
        switch (this._state) {
          case 0:
            return false;
          case 5:
            this._details.widget.scrollTop();
            return true;
          case 1:
            return !this._isAuto;
          default:
            this._list.focusFirst();
            return true;
        }
      }
      getFocusedItem() {
        if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel) {
          return {
            item: this._list.getFocusedElements()[0],
            index: this._list.getFocus()[0],
            model: this._completionModel
          };
        }
        return void 0;
      }
      toggleDetailsFocus() {
        if (this._state === 5) {
          this._setState(
            3
            /* Open */
          );
          if (this._detailsBorderColor) {
            this._details.widget.domNode.style.borderColor = this._detailsBorderColor;
          }
        } else if (this._state === 3 && this._isDetailsVisible()) {
          this._setState(
            5
            /* Details */
          );
          if (this._detailsFocusBorderColor) {
            this._details.widget.domNode.style.borderColor = this._detailsFocusBorderColor;
          }
        }
      }
      toggleDetails() {
        if (this._isDetailsVisible()) {
          this._ctxSuggestWidgetDetailsVisible.set(false);
          this._setDetailsVisible(false);
          this._details.hide();
          this.element.domNode.classList.remove("shows-details");
        } else if ((canExpandCompletionItem(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4)) {
          this._ctxSuggestWidgetDetailsVisible.set(true);
          this._setDetailsVisible(true);
          this.showDetails(false);
        }
      }
      showDetails(loading) {
        this._details.show();
        if (loading) {
          this._details.widget.renderLoading();
        } else {
          this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode);
        }
        this._positionDetails();
        this.editor.focus();
        this.element.domNode.classList.add("shows-details");
      }
      toggleExplainMode() {
        if (this._list.getFocusedElements()[0]) {
          this._explainMode = !this._explainMode;
          if (!this._isDetailsVisible()) {
            this.toggleDetails();
          } else {
            this.showDetails(false);
          }
        }
      }
      resetPersistedSize() {
        this._persistedSize.reset();
      }
      hideWidget() {
        var _a5;
        (_a5 = this._loadingTimeout) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        this._setState(
          0
          /* Hidden */
        );
        this._onDidHide.fire(this);
        this.element.clearSashHoverState();
        const dim = this._persistedSize.restore();
        const minPersistedHeight = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
        if (dim && dim.height < minPersistedHeight) {
          this._persistedSize.store(dim.with(void 0, minPersistedHeight));
        }
      }
      isFrozen() {
        return this._state === 4;
      }
      _afterRender(position) {
        if (position === null) {
          if (this._isDetailsVisible()) {
            this._details.hide();
          }
          return;
        }
        if (this._state === 2 || this._state === 1) {
          return;
        }
        if (this._isDetailsVisible()) {
          this._details.show();
        }
        this._positionDetails();
      }
      _layout(size2) {
        var _a5, _b2, _c2;
        if (!this.editor.hasModel()) {
          return;
        }
        if (!this.editor.getDomNode()) {
          return;
        }
        const bodyBox = getClientArea(document.body);
        const info = this.getLayoutInfo();
        if (!size2) {
          size2 = info.defaultSize;
        }
        let height = size2.height;
        let width = size2.width;
        this._status.element.style.lineHeight = `${info.itemHeight}px`;
        if (this._state === 2 || this._state === 1) {
          height = info.itemHeight + info.borderHeight;
          width = info.defaultSize.width / 2;
          this.element.enableSashes(false, false, false, false);
          this.element.minSize = this.element.maxSize = new Dimension(width, height);
          this._contentWidget.setPreference(
            2
            /* BELOW */
          );
        } else {
          const maxWidth = bodyBox.width - info.borderHeight - 2 * info.horizontalPadding;
          if (width > maxWidth) {
            width = maxWidth;
          }
          const preferredWidth = this._completionModel ? this._completionModel.stats.pLabelLen * info.typicalHalfwidthCharacterWidth : width;
          const fullHeight = info.statusBarHeight + this._list.contentHeight + info.borderHeight;
          const minHeight = info.itemHeight + info.statusBarHeight;
          const editorBox = getDomNodePagePosition(this.editor.getDomNode());
          const cursorBox = this.editor.getScrolledVisiblePosition(this.editor.getPosition());
          const cursorBottom = editorBox.top + cursorBox.top + cursorBox.height;
          const maxHeightBelow = Math.min(bodyBox.height - cursorBottom - info.verticalPadding, fullHeight);
          const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;
          const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);
          let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);
          if (height === ((_a5 = this._cappedHeight) === null || _a5 === void 0 ? void 0 : _a5.capped)) {
            height = this._cappedHeight.wanted;
          }
          if (height < minHeight) {
            height = minHeight;
          }
          if (height > maxHeight) {
            height = maxHeight;
          }
          const forceRenderingAboveRequiredSpace = 150;
          if (height > maxHeightBelow || this._forceRenderingAbove && availableSpaceAbove > forceRenderingAboveRequiredSpace) {
            this._contentWidget.setPreference(
              1
              /* ABOVE */
            );
            this.element.enableSashes(true, true, false, false);
            maxHeight = maxHeightAbove;
          } else {
            this._contentWidget.setPreference(
              2
              /* BELOW */
            );
            this.element.enableSashes(false, true, true, false);
            maxHeight = maxHeightBelow;
          }
          this.element.preferredSize = new Dimension(preferredWidth, info.defaultSize.height);
          this.element.maxSize = new Dimension(maxWidth, maxHeight);
          this.element.minSize = new Dimension(220, minHeight);
          this._cappedHeight = height === fullHeight ? { wanted: (_c2 = (_b2 = this._cappedHeight) === null || _b2 === void 0 ? void 0 : _b2.wanted) !== null && _c2 !== void 0 ? _c2 : size2.height, capped: height } : void 0;
        }
        this._resize(width, height);
      }
      _resize(width, height) {
        const { width: maxWidth, height: maxHeight } = this.element.maxSize;
        width = Math.min(maxWidth, width);
        height = Math.min(maxHeight, height);
        const { statusBarHeight } = this.getLayoutInfo();
        this._list.layout(height - statusBarHeight, width);
        this._listElement.style.height = `${height - statusBarHeight}px`;
        this.element.layout(height, width);
        this._contentWidget.layout();
        this._positionDetails();
      }
      _positionDetails() {
        if (this._isDetailsVisible()) {
          this._details.placeAtAnchor(this.element.domNode);
        }
      }
      getLayoutInfo() {
        const fontInfo = this.editor.getOption(
          43
          /* fontInfo */
        );
        const itemHeight = clamp(this.editor.getOption(
          107
          /* suggestLineHeight */
        ) || fontInfo.lineHeight, 8, 1e3);
        const statusBarHeight = !this.editor.getOption(
          105
          /* suggest */
        ).showStatusBar || this._state === 2 || this._state === 1 ? 0 : itemHeight;
        const borderWidth = this._details.widget.borderWidth;
        const borderHeight = 2 * borderWidth;
        return {
          itemHeight,
          statusBarHeight,
          borderWidth,
          borderHeight,
          typicalHalfwidthCharacterWidth: fontInfo.typicalHalfwidthCharacterWidth,
          verticalPadding: 22,
          horizontalPadding: 14,
          defaultSize: new Dimension(430, statusBarHeight + 12 * itemHeight + borderHeight)
        };
      }
      _isDetailsVisible() {
        return this._storageService.getBoolean("expandSuggestionDocs", 0, false);
      }
      _setDetailsVisible(value) {
        this._storageService.store(
          "expandSuggestionDocs",
          value,
          0,
          0
          /* USER */
        );
      }
      forceRenderingAbove() {
        if (!this._forceRenderingAbove) {
          this._forceRenderingAbove = true;
          this._layout(this._persistedSize.restore());
        }
      }
      stopForceRenderingAbove() {
        this._forceRenderingAbove = false;
      }
    };
    SuggestWidget.LOADING_MESSAGE = localize("suggestWidget.loading", "Loading...");
    SuggestWidget.NO_SUGGESTIONS_MESSAGE = localize("suggestWidget.noSuggestions", "No suggestions.");
    SuggestWidget = __decorate34([
      __param34(1, IStorageService),
      __param34(2, IContextKeyService),
      __param34(3, IThemeService),
      __param34(4, IInstantiationService)
    ], SuggestWidget);
    SuggestContentWidget = class {
      constructor(_widget, _editor2) {
        this._widget = _widget;
        this._editor = _editor2;
        this.allowEditorOverflow = true;
        this.suppressMouseDown = false;
        this._preferenceLocked = false;
        this._added = false;
        this._hidden = false;
      }
      dispose() {
        if (this._added) {
          this._added = false;
          this._editor.removeContentWidget(this);
        }
      }
      getId() {
        return "editor.widget.suggestWidget";
      }
      getDomNode() {
        return this._widget.element.domNode;
      }
      show() {
        this._hidden = false;
        if (!this._added) {
          this._added = true;
          this._editor.addContentWidget(this);
        }
      }
      hide() {
        if (!this._hidden) {
          this._hidden = true;
          this.layout();
        }
      }
      layout() {
        this._editor.layoutContentWidget(this);
      }
      getPosition() {
        if (this._hidden || !this._position || !this._preference) {
          return null;
        }
        return {
          position: this._position,
          preference: [this._preference]
        };
      }
      beforeRender() {
        const { height, width } = this._widget.element.size;
        const { borderWidth, horizontalPadding } = this._widget.getLayoutInfo();
        return new Dimension(width + 2 * borderWidth + horizontalPadding, height + 2 * borderWidth);
      }
      afterRender(position) {
        this._widget._afterRender(position);
      }
      setPreference(preference) {
        if (!this._preferenceLocked) {
          this._preference = preference;
        }
      }
      lockPreference() {
        this._preferenceLocked = true;
      }
      unlockPreference() {
        this._preferenceLocked = false;
      }
      setPosition(position) {
        this._position = position;
      }
    };
    registerThemingParticipant((theme, collector) => {
      const matchHighlight = theme.getColor(editorSuggestWidgetHighlightForeground);
      if (matchHighlight) {
        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-highlighted-label .highlight { color: ${matchHighlight}; }`);
      }
      const matchHighlightFocus = theme.getColor(editorSuggestWidgetHighlightFocusForeground);
      if (matchHighlight) {
        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused .monaco-highlighted-label .highlight { color: ${matchHighlightFocus}; }`);
      }
      const foreground2 = theme.getColor(editorSuggestWidgetForeground);
      if (foreground2) {
        collector.addRule(`.monaco-editor .suggest-widget, .monaco-editor .suggest-details { color: ${foreground2}; }`);
      }
      const selectedForeground = theme.getColor(editorSuggestWidgetSelectedForeground);
      if (selectedForeground) {
        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused { color: ${selectedForeground}; }`);
      }
      const selectedIconForeground = theme.getColor(editorSuggestWidgetSelectedIconForeground);
      if (selectedIconForeground) {
        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused .codicon { color: ${selectedIconForeground}; }`);
      }
      const link = theme.getColor(textLinkForeground);
      if (link) {
        collector.addRule(`.monaco-editor .suggest-details a { color: ${link}; }`);
      }
      const linkHover = theme.getColor(textLinkActiveForeground);
      if (linkHover) {
        collector.addRule(`.monaco-editor .suggest-details a:hover { color: ${linkHover}; }`);
      }
      const codeBackground = theme.getColor(textCodeBlockBackground);
      if (codeBackground) {
        collector.addRule(`.monaco-editor .suggest-details code { background-color: ${codeBackground}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestController.js
var __decorate35, __param35, _sticky, LineSuffix, SuggestController, PriorityRegistry, TriggerSuggestAction, weight, SuggestCommand;
var init_suggestController = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestController.js"() {
    init_aria();
    init_arrays();
    init_async();
    init_cancellation();
    init_errors();
    init_event();
    init_keyCodes();
    init_lifecycle();
    init_platform();
    init_stopwatch();
    init_types();
    init_editorState();
    init_editorExtensions();
    init_editOperation();
    init_position();
    init_range();
    init_editorContextKeys();
    init_snippetController2();
    init_snippetParser();
    init_suggestMemory();
    init_wordContextKey();
    init_nls();
    init_actions2();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_keybindingsRegistry();
    init_log();
    init_suggest();
    init_suggestAlternatives();
    init_suggestCommitCharacters();
    init_suggestModel();
    init_suggestOvertypingCapturer();
    init_suggestWidget();
    __decorate35 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param35 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    _sticky = false;
    LineSuffix = class {
      constructor(_model, _position) {
        this._model = _model;
        this._position = _position;
        const maxColumn = _model.getLineMaxColumn(_position.lineNumber);
        if (maxColumn !== _position.column) {
          const offset = _model.getOffsetAt(_position);
          const end = _model.getPositionAt(offset + 1);
          this._marker = _model.deltaDecorations([], [{
            range: Range.fromPositions(_position, end),
            options: {
              description: "suggest-line-suffix",
              stickiness: 1
              /* NeverGrowsWhenTypingAtEdges */
            }
          }]);
        }
      }
      dispose() {
        if (this._marker && !this._model.isDisposed()) {
          this._model.deltaDecorations(this._marker, []);
        }
      }
      delta(position) {
        if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) {
          return 0;
        }
        if (this._marker) {
          const range = this._model.getDecorationRange(this._marker[0]);
          const end = this._model.getOffsetAt(range.getStartPosition());
          return end - this._model.getOffsetAt(position);
        } else {
          return this._model.getLineMaxColumn(position.lineNumber) - position.column;
        }
      }
    };
    SuggestController = class SuggestController2 {
      constructor(editor2, _memoryService, _commandService, _contextKeyService, _instantiationService, _logService) {
        this._memoryService = _memoryService;
        this._commandService = _commandService;
        this._contextKeyService = _contextKeyService;
        this._instantiationService = _instantiationService;
        this._logService = _logService;
        this._lineSuffix = new MutableDisposable();
        this._toDispose = new DisposableStore();
        this._selectors = new PriorityRegistry((s) => s.priority);
        this.editor = editor2;
        this.model = _instantiationService.createInstance(SuggestModel, this.editor);
        const ctxInsertMode = Context.InsertMode.bindTo(_contextKeyService);
        ctxInsertMode.set(editor2.getOption(
          105
          /* suggest */
        ).insertMode);
        this.model.onDidTrigger(() => ctxInsertMode.set(editor2.getOption(
          105
          /* suggest */
        ).insertMode));
        this.widget = this._toDispose.add(new IdleValue(() => {
          const widget = this._instantiationService.createInstance(SuggestWidget, this.editor);
          this._toDispose.add(widget);
          this._toDispose.add(widget.onDidSelect((item) => this._insertSuggestion(item, 0), this));
          const commitCharacterController = new CommitCharacterController(this.editor, widget, (item) => this._insertSuggestion(
            item,
            2
            /* NoAfterUndoStop */
          ));
          this._toDispose.add(commitCharacterController);
          this._toDispose.add(this.model.onDidSuggest((e) => {
            if (e.completionModel.items.length === 0) {
              commitCharacterController.reset();
            }
          }));
          const ctxMakesTextEdit = Context.MakesTextEdit.bindTo(this._contextKeyService);
          const ctxHasInsertAndReplace = Context.HasInsertAndReplaceRange.bindTo(this._contextKeyService);
          const ctxCanResolve = Context.CanResolve.bindTo(this._contextKeyService);
          this._toDispose.add(toDisposable(() => {
            ctxMakesTextEdit.reset();
            ctxHasInsertAndReplace.reset();
            ctxCanResolve.reset();
          }));
          this._toDispose.add(widget.onDidFocus(({ item }) => {
            const position = this.editor.getPosition();
            const startColumn = item.editStart.column;
            const endColumn = position.column;
            let value = true;
            if (this.editor.getOption(
              1
              /* acceptSuggestionOnEnter */
            ) === "smart" && this.model.state === 2 && !item.completion.command && !item.completion.additionalTextEdits && !(item.completion.insertTextRules & 4) && endColumn - startColumn === item.completion.insertText.length) {
              const oldText = this.editor.getModel().getValueInRange({
                startLineNumber: position.lineNumber,
                startColumn,
                endLineNumber: position.lineNumber,
                endColumn
              });
              value = oldText !== item.completion.insertText;
            }
            ctxMakesTextEdit.set(value);
            ctxHasInsertAndReplace.set(!Position.equals(item.editInsertEnd, item.editReplaceEnd));
            ctxCanResolve.set(Boolean(item.provider.resolveCompletionItem) || Boolean(item.completion.documentation) || item.completion.detail !== item.completion.label);
          }));
          this._toDispose.add(widget.onDetailsKeyDown((e) => {
            if (e.toKeybinding().equals(new SimpleKeybinding(
              true,
              false,
              false,
              false,
              33
              /* KEY_C */
            )) || isMacintosh && e.toKeybinding().equals(new SimpleKeybinding(
              false,
              false,
              false,
              true,
              33
              /* KEY_C */
            ))) {
              e.stopPropagation();
              return;
            }
            if (!e.toKeybinding().isModifierKey()) {
              this.editor.focus();
            }
          }));
          return widget;
        }));
        this._overtypingCapturer = this._toDispose.add(new IdleValue(() => {
          return this._toDispose.add(new OvertypingCapturer(this.editor, this.model));
        }));
        this._alternatives = this._toDispose.add(new IdleValue(() => {
          return this._toDispose.add(new SuggestAlternatives(this.editor, this._contextKeyService));
        }));
        this._toDispose.add(_instantiationService.createInstance(WordContextKey, editor2));
        this._toDispose.add(this.model.onDidTrigger((e) => {
          this.widget.value.showTriggered(e.auto, e.shy ? 250 : 50);
          this._lineSuffix.value = new LineSuffix(this.editor.getModel(), e.position);
        }));
        this._toDispose.add(this.model.onDidSuggest((e) => {
          if (!e.shy) {
            let index = -1;
            for (const selector of this._selectors.itemsOrderedByPriorityDesc) {
              index = selector.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
              if (index !== -1) {
                break;
              }
            }
            if (index === -1) {
              index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
            }
            this.widget.value.showSuggestions(e.completionModel, index, e.isFrozen, e.auto);
          }
        }));
        this._toDispose.add(this.model.onDidCancel((e) => {
          if (!e.retrigger) {
            this.widget.value.hideWidget();
          }
        }));
        this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
          if (!_sticky) {
            this.model.cancel();
            this.model.clear();
          }
        }));
        let acceptSuggestionsOnEnter = Context.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);
        let updateFromConfig = () => {
          const acceptSuggestionOnEnter = this.editor.getOption(
            1
            /* acceptSuggestionOnEnter */
          );
          acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === "on" || acceptSuggestionOnEnter === "smart");
        };
        this._toDispose.add(this.editor.onDidChangeConfiguration(() => updateFromConfig()));
        updateFromConfig();
      }
      static get(editor2) {
        return editor2.getContribution(SuggestController2.ID);
      }
      dispose() {
        this._alternatives.dispose();
        this._toDispose.dispose();
        this.widget.dispose();
        this.model.dispose();
        this._lineSuffix.dispose();
      }
      _insertSuggestion(event, flags) {
        if (!event || !event.item) {
          this._alternatives.value.reset();
          this.model.cancel();
          this.model.clear();
          return;
        }
        if (!this.editor.hasModel()) {
          return;
        }
        const model = this.editor.getModel();
        const modelVersionNow = model.getAlternativeVersionId();
        const { item } = event;
        const tasks = [];
        const cts = new CancellationTokenSource();
        if (!(flags & 1)) {
          this.editor.pushUndoStop();
        }
        const info = this.getOverwriteInfo(item, Boolean(
          flags & 8
          /* AlternativeOverwriteConfig */
        ));
        this._memoryService.memorize(model, this.editor.getPosition(), item);
        if (Array.isArray(item.completion.additionalTextEdits)) {
          const scrollState = StableEditorScrollState.capture(this.editor);
          this.editor.executeEdits("suggestController.additionalTextEdits.sync", item.completion.additionalTextEdits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text)));
          scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
        } else if (!item.isResolved) {
          const sw = new StopWatch(true);
          let position;
          const docListener = model.onDidChangeContent((e) => {
            if (e.isFlush) {
              cts.cancel();
              docListener.dispose();
              return;
            }
            for (let change of e.changes) {
              const thisPosition = Range.getEndPosition(change.range);
              if (!position || Position.isBefore(thisPosition, position)) {
                position = thisPosition;
              }
            }
          });
          let oldFlags = flags;
          flags |= 2;
          let didType = false;
          let typeListener = this.editor.onWillType(() => {
            typeListener.dispose();
            didType = true;
            if (!(oldFlags & 2)) {
              this.editor.pushUndoStop();
            }
          });
          tasks.push(item.resolve(cts.token).then(() => {
            if (!item.completion.additionalTextEdits || cts.token.isCancellationRequested) {
              return false;
            }
            if (position && item.completion.additionalTextEdits.some((edit) => Position.isBefore(position, Range.getStartPosition(edit.range)))) {
              return false;
            }
            if (didType) {
              this.editor.pushUndoStop();
            }
            const scrollState = StableEditorScrollState.capture(this.editor);
            this.editor.executeEdits("suggestController.additionalTextEdits.async", item.completion.additionalTextEdits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text)));
            scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
            if (didType || !(oldFlags & 2)) {
              this.editor.pushUndoStop();
            }
            return true;
          }).then((applied) => {
            this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", sw.elapsed(), applied);
            docListener.dispose();
            typeListener.dispose();
          }));
        }
        let { insertText } = item.completion;
        if (!(item.completion.insertTextRules & 4)) {
          insertText = SnippetParser.escape(insertText);
        }
        SnippetController2.get(this.editor).insert(insertText, {
          overwriteBefore: info.overwriteBefore,
          overwriteAfter: info.overwriteAfter,
          undoStopBefore: false,
          undoStopAfter: false,
          adjustWhitespace: !(item.completion.insertTextRules & 1),
          clipboardText: event.model.clipboardText,
          overtypingCapturer: this._overtypingCapturer.value
        });
        if (!(flags & 2)) {
          this.editor.pushUndoStop();
        }
        if (!item.completion.command) {
          this.model.cancel();
        } else if (item.completion.command.id === TriggerSuggestAction.id) {
          this.model.trigger({ auto: true, shy: false }, true);
        } else {
          tasks.push(this._commandService.executeCommand(item.completion.command.id, ...item.completion.command.arguments ? [...item.completion.command.arguments] : []).catch(onUnexpectedError));
          this.model.cancel();
        }
        if (flags & 4) {
          this._alternatives.value.set(event, (next) => {
            cts.cancel();
            while (model.canUndo()) {
              if (modelVersionNow !== model.getAlternativeVersionId()) {
                model.undo();
              }
              this._insertSuggestion(next, 1 | 2 | (flags & 8 ? 8 : 0));
              break;
            }
          });
        }
        this._alertCompletionItem(item);
        Promise.all(tasks).finally(() => {
          this.model.clear();
          cts.dispose();
        });
      }
      getOverwriteInfo(item, toggleMode) {
        assertType(this.editor.hasModel());
        let replace = this.editor.getOption(
          105
          /* suggest */
        ).insertMode === "replace";
        if (toggleMode) {
          replace = !replace;
        }
        const overwriteBefore = item.position.column - item.editStart.column;
        const overwriteAfter = (replace ? item.editReplaceEnd.column : item.editInsertEnd.column) - item.position.column;
        const columnDelta = this.editor.getPosition().column - item.position.column;
        const suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
        return {
          overwriteBefore: overwriteBefore + columnDelta,
          overwriteAfter: overwriteAfter + suffixDelta
        };
      }
      _alertCompletionItem(item) {
        if (isNonEmptyArray(item.completion.additionalTextEdits)) {
          let msg = localize("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length);
          alert(msg);
        }
      }
      triggerSuggest(onlyFrom) {
        if (this.editor.hasModel()) {
          this.model.trigger({ auto: false, shy: false }, false, onlyFrom);
          this.editor.revealLine(
            this.editor.getPosition().lineNumber,
            0
            /* Smooth */
          );
          this.editor.focus();
        }
      }
      triggerSuggestAndAcceptBest(arg) {
        if (!this.editor.hasModel()) {
          return;
        }
        const positionNow = this.editor.getPosition();
        const fallback = () => {
          if (positionNow.equals(this.editor.getPosition())) {
            this._commandService.executeCommand(arg.fallback);
          }
        };
        const makesTextEdit = (item) => {
          if (item.completion.insertTextRules & 4 || item.completion.additionalTextEdits) {
            return true;
          }
          const position = this.editor.getPosition();
          const startColumn = item.editStart.column;
          const endColumn = position.column;
          if (endColumn - startColumn !== item.completion.insertText.length) {
            return true;
          }
          const textNow = this.editor.getModel().getValueInRange({
            startLineNumber: position.lineNumber,
            startColumn,
            endLineNumber: position.lineNumber,
            endColumn
          });
          return textNow !== item.completion.insertText;
        };
        Event.once(this.model.onDidTrigger)((_) => {
          let listener = [];
          Event.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
            dispose(listener);
            fallback();
          }, void 0, listener);
          this.model.onDidSuggest(({ completionModel }) => {
            dispose(listener);
            if (completionModel.items.length === 0) {
              fallback();
              return;
            }
            const index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), completionModel.items);
            const item = completionModel.items[index];
            if (!makesTextEdit(item)) {
              fallback();
              return;
            }
            this.editor.pushUndoStop();
            this._insertSuggestion(
              { index, item, model: completionModel },
              4 | 1 | 2
              /* NoAfterUndoStop */
            );
          }, void 0, listener);
        });
        this.model.trigger({ auto: false, shy: true });
        this.editor.revealLine(
          positionNow.lineNumber,
          0
          /* Smooth */
        );
        this.editor.focus();
      }
      acceptSelectedSuggestion(keepAlternativeSuggestions, alternativeOverwriteConfig) {
        const item = this.widget.value.getFocusedItem();
        let flags = 0;
        if (keepAlternativeSuggestions) {
          flags |= 4;
        }
        if (alternativeOverwriteConfig) {
          flags |= 8;
        }
        this._insertSuggestion(item, flags);
      }
      acceptNextSuggestion() {
        this._alternatives.value.next();
      }
      acceptPrevSuggestion() {
        this._alternatives.value.prev();
      }
      cancelSuggestWidget() {
        this.model.cancel();
        this.model.clear();
        this.widget.value.hideWidget();
      }
      selectNextSuggestion() {
        this.widget.value.selectNext();
      }
      selectNextPageSuggestion() {
        this.widget.value.selectNextPage();
      }
      selectLastSuggestion() {
        this.widget.value.selectLast();
      }
      selectPrevSuggestion() {
        this.widget.value.selectPrevious();
      }
      selectPrevPageSuggestion() {
        this.widget.value.selectPreviousPage();
      }
      selectFirstSuggestion() {
        this.widget.value.selectFirst();
      }
      toggleSuggestionDetails() {
        this.widget.value.toggleDetails();
      }
      toggleExplainMode() {
        this.widget.value.toggleExplainMode();
      }
      toggleSuggestionFocus() {
        this.widget.value.toggleDetailsFocus();
      }
      resetWidgetSize() {
        this.widget.value.resetPersistedSize();
      }
      forceRenderingAbove() {
        this.widget.value.forceRenderingAbove();
      }
      stopForceRenderingAbove() {
        if (!this.widget.isInitialized) {
          return;
        }
        this.widget.value.stopForceRenderingAbove();
      }
      registerSelector(selector) {
        return this._selectors.register(selector);
      }
    };
    SuggestController.ID = "editor.contrib.suggestController";
    SuggestController = __decorate35([
      __param35(1, ISuggestMemoryService),
      __param35(2, ICommandService),
      __param35(3, IContextKeyService),
      __param35(4, IInstantiationService),
      __param35(5, ILogService)
    ], SuggestController);
    PriorityRegistry = class {
      constructor(prioritySelector) {
        this.prioritySelector = prioritySelector;
        this._items = new Array();
      }
      register(value) {
        if (this._items.indexOf(value) !== -1) {
          throw new Error("Value is already registered");
        }
        this._items.push(value);
        this._items.sort((s1, s2) => this.prioritySelector(s2) - this.prioritySelector(s1));
        return {
          dispose: () => {
            const idx = this._items.indexOf(value);
            if (idx >= 0) {
              this._items.splice(idx, 1);
            }
          }
        };
      }
      get itemsOrderedByPriorityDesc() {
        return this._items;
      }
    };
    TriggerSuggestAction = class _TriggerSuggestAction extends EditorAction {
      constructor() {
        super({
          id: _TriggerSuggestAction.id,
          label: localize("suggest.trigger.label", "Trigger Suggest"),
          alias: "Trigger Suggest",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 | 10,
            secondary: [
              2048 | 39
              /* KEY_I */
            ],
            mac: { primary: 256 | 10, secondary: [
              512 | 9,
              2048 | 39
              /* KEY_I */
            ] },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = SuggestController.get(editor2);
        if (!controller) {
          return;
        }
        controller.triggerSuggest();
      }
    };
    TriggerSuggestAction.id = "editor.action.triggerSuggest";
    registerEditorContribution(SuggestController.ID, SuggestController);
    registerEditorAction(TriggerSuggestAction);
    weight = 100 + 90;
    SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);
    registerEditorCommand(new SuggestCommand({
      id: "acceptSelectedSuggestion",
      precondition: Context.Visible,
      handler(x) {
        x.acceptSelectedSuggestion(true, false);
      }
    }));
    KeybindingsRegistry.registerKeybindingRule({
      id: "acceptSelectedSuggestion",
      when: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus),
      primary: 2,
      weight
    });
    KeybindingsRegistry.registerKeybindingRule({
      id: "acceptSelectedSuggestion",
      when: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus, Context.AcceptSuggestionsOnEnter, Context.MakesTextEdit),
      primary: 3,
      weight
    });
    MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
      command: { id: "acceptSelectedSuggestion", title: localize("accept.insert", "Insert") },
      group: "left",
      order: 1,
      when: Context.HasInsertAndReplaceRange.toNegated()
    });
    MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
      command: { id: "acceptSelectedSuggestion", title: localize("accept.insert", "Insert") },
      group: "left",
      order: 1,
      when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert"))
    });
    MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
      command: { id: "acceptSelectedSuggestion", title: localize("accept.replace", "Replace") },
      group: "left",
      order: 1,
      when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace"))
    });
    registerEditorCommand(new SuggestCommand({
      id: "acceptAlternativeSelectedSuggestion",
      precondition: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 3,
        secondary: [
          1024 | 2
          /* Tab */
        ]
      },
      handler(x) {
        x.acceptSelectedSuggestion(false, true);
      },
      menuOpts: [{
        menuId: suggestWidgetStatusbarMenu,
        group: "left",
        order: 2,
        when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert")),
        title: localize("accept.replace", "Replace")
      }, {
        menuId: suggestWidgetStatusbarMenu,
        group: "left",
        order: 2,
        when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace")),
        title: localize("accept.insert", "Insert")
      }]
    }));
    CommandsRegistry.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
    registerEditorCommand(new SuggestCommand({
      id: "hideSuggestWidget",
      precondition: Context.Visible,
      handler: (x) => x.cancelSuggestWidget(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "selectNextSuggestion",
      precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
      handler: (c) => c.selectNextSuggestion(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 18,
        secondary: [
          2048 | 18
          /* DownArrow */
        ],
        mac: { primary: 18, secondary: [
          2048 | 18,
          256 | 44
          /* KEY_N */
        ] }
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "selectNextPageSuggestion",
      precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
      handler: (c) => c.selectNextPageSuggestion(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 12,
        secondary: [
          2048 | 12
          /* PageDown */
        ]
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "selectLastSuggestion",
      precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
      handler: (c) => c.selectLastSuggestion()
    }));
    registerEditorCommand(new SuggestCommand({
      id: "selectPrevSuggestion",
      precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
      handler: (c) => c.selectPrevSuggestion(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 16,
        secondary: [
          2048 | 16
          /* UpArrow */
        ],
        mac: { primary: 16, secondary: [
          2048 | 16,
          256 | 46
          /* KEY_P */
        ] }
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "selectPrevPageSuggestion",
      precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
      handler: (c) => c.selectPrevPageSuggestion(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 11,
        secondary: [
          2048 | 11
          /* PageUp */
        ]
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "selectFirstSuggestion",
      precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
      handler: (c) => c.selectFirstSuggestion()
    }));
    registerEditorCommand(new SuggestCommand({
      id: "toggleSuggestionDetails",
      precondition: Context.Visible,
      handler: (x) => x.toggleSuggestionDetails(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 10,
        secondary: [
          2048 | 39
          /* KEY_I */
        ],
        mac: { primary: 256 | 10, secondary: [
          2048 | 39
          /* KEY_I */
        ] }
      },
      menuOpts: [{
        menuId: suggestWidgetStatusbarMenu,
        group: "right",
        order: 1,
        when: ContextKeyExpr.and(Context.DetailsVisible, Context.CanResolve),
        title: localize("detail.more", "show less")
      }, {
        menuId: suggestWidgetStatusbarMenu,
        group: "right",
        order: 1,
        when: ContextKeyExpr.and(Context.DetailsVisible.toNegated(), Context.CanResolve),
        title: localize("detail.less", "show more")
      }]
    }));
    registerEditorCommand(new SuggestCommand({
      id: "toggleExplainMode",
      precondition: Context.Visible,
      handler: (x) => x.toggleExplainMode(),
      kbOpts: {
        weight: 100,
        primary: 2048 | 85
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "toggleSuggestionFocus",
      precondition: Context.Visible,
      handler: (x) => x.toggleSuggestionFocus(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 512 | 10,
        mac: {
          primary: 256 | 512 | 10
          /* Space */
        }
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "insertBestCompletion",
      precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), WordContextKey.AtEnd, Context.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),
      handler: (x, arg) => {
        x.triggerSuggestAndAcceptBest(isObject(arg) ? Object.assign({ fallback: "tab" }, arg) : { fallback: "tab" });
      },
      kbOpts: {
        weight,
        primary: 2
        /* Tab */
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "insertNextSuggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
      handler: (x) => x.acceptNextSuggestion(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2
        /* Tab */
      }
    }));
    registerEditorCommand(new SuggestCommand({
      id: "insertPrevSuggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
      handler: (x) => x.acceptPrevSuggestion(),
      kbOpts: {
        weight,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 2
        /* Tab */
      }
    }));
    registerEditorAction(class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.resetSuggestSize",
          label: localize("suggest.reset.label", "Reset Suggest Widget Size"),
          alias: "Reset Suggest Widget Size",
          precondition: void 0
        });
      }
      run(_accessor, editor2) {
        SuggestController.get(editor2).resetWidgetSize();
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/utils.js
function createDisposableRef(object, disposable) {
  return {
    object,
    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()
  };
}
function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
function compareByNumber() {
  return (a, b) => a - b;
}
function findMaxBy(items, comparator) {
  let min = void 0;
  for (const item of items) {
    if (min === void 0 || comparator(item, min) > 0) {
      min = item;
    }
  }
  return min;
}
var init_utils = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/utils.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetInlineCompletionProvider.js
function suggestionToInlineCompletion(suggestController, position, item, toggleMode) {
  if (Array.isArray(item.completion.additionalTextEdits) && item.completion.additionalTextEdits.length > 0) {
    return {
      text: "",
      range: Range.fromPositions(position, position)
    };
  }
  let { insertText } = item.completion;
  if (item.completion.insertTextRules & 4) {
    const snippet = new SnippetParser().parse(insertText);
    const model = suggestController.editor.getModel();
    SnippetSession.adjustWhitespace(model, position, snippet, true, true);
    insertText = snippet.toString();
  }
  const info = suggestController.getOverwriteInfo(item, toggleMode);
  return {
    text: insertText,
    range: Range.fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0)))
  };
}
var SuggestWidgetInlineCompletionProvider;
var init_suggestWidgetInlineCompletionProvider = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetInlineCompletionProvider.js"() {
    init_async();
    init_event();
    init_lifecycle();
    init_position();
    init_range();
    init_snippetParser();
    init_snippetSession();
    init_suggestController();
    init_inlineCompletionsModel();
    init_inlineCompletionToGhostText();
    init_utils();
    SuggestWidgetInlineCompletionProvider = class extends Disposable {
      constructor(editor2, suggestControllerPreselector) {
        super();
        this.editor = editor2;
        this.suggestControllerPreselector = suggestControllerPreselector;
        this.isSuggestWidgetVisible = false;
        this.isShiftKeyPressed = false;
        this._isActive = false;
        this._currentInlineCompletion = void 0;
        this.onDidChangeEmitter = new Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.setInactiveDelayed = this._register(new RunOnceScheduler(() => {
          if (!this.isSuggestWidgetVisible) {
            if (this._isActive) {
              this._isActive = false;
              this.onDidChangeEmitter.fire();
            }
          }
        }, 100));
        this._register(editor2.onKeyDown((e) => {
          if (e.shiftKey && !this.isShiftKeyPressed) {
            this.isShiftKeyPressed = true;
            this.update(this._isActive);
          }
        }));
        this._register(editor2.onKeyUp((e) => {
          if (e.shiftKey && this.isShiftKeyPressed) {
            this.isShiftKeyPressed = false;
            this.update(this._isActive);
          }
        }));
        const suggestController = SuggestController.get(this.editor);
        if (suggestController) {
          this._register(suggestController.registerSelector({
            priority: 100,
            select: (model, pos, suggestItems) => {
              const textModel = this.editor.getModel();
              const normalizedItemToPreselect = minimizeInlineCompletion(textModel, this.suggestControllerPreselector());
              if (!normalizedItemToPreselect) {
                return -1;
              }
              const position = Position.lift(pos);
              const candidates = suggestItems.map((suggestItem, index) => {
                const inlineSuggestItem = suggestionToInlineCompletion(suggestController, position, suggestItem, this.isShiftKeyPressed);
                const normalizedSuggestItem = minimizeInlineCompletion(textModel, inlineSuggestItem);
                const valid = normalizedSuggestItem.range.equalsRange(normalizedItemToPreselect.range) && normalizedItemToPreselect.text.startsWith(normalizedSuggestItem.text);
                return { index, valid, prefixLength: normalizedSuggestItem.text.length, suggestItem };
              }).filter((item) => item.valid);
              const result = findMaxBy(candidates, compareBy((s) => s.prefixLength, compareByNumber()));
              return result ? result.index : -1;
            }
          }));
          let isBoundToSuggestWidget = false;
          const bindToSuggestWidget = () => {
            if (isBoundToSuggestWidget) {
              return;
            }
            isBoundToSuggestWidget = true;
            this._register(suggestController.widget.value.onDidShow(() => {
              this.isSuggestWidgetVisible = true;
              this.update(true);
            }));
            this._register(suggestController.widget.value.onDidHide(() => {
              this.isSuggestWidgetVisible = false;
              this.setInactiveDelayed.schedule();
              this.update(this._isActive);
            }));
            this._register(suggestController.widget.value.onDidFocus(() => {
              this.isSuggestWidgetVisible = true;
              this.update(true);
            }));
          };
          this._register(Event.once(suggestController.model.onDidTrigger)((e) => {
            bindToSuggestWidget();
          }));
        }
        this.update(this._isActive);
      }
      /**
       * Returns undefined if the suggest widget is not active.
      */
      get state() {
        if (!this._isActive) {
          return void 0;
        }
        return { selectedItemAsInlineCompletion: this._currentInlineCompletion };
      }
      update(newActive) {
        const newInlineCompletion = this.getInlineCompletion();
        let shouldFire = false;
        if (!normalizedInlineCompletionsEquals(this._currentInlineCompletion, newInlineCompletion)) {
          this._currentInlineCompletion = newInlineCompletion;
          shouldFire = true;
        }
        if (this._isActive !== newActive) {
          this._isActive = newActive;
          shouldFire = true;
        }
        if (shouldFire) {
          this.onDidChangeEmitter.fire();
        }
      }
      getInlineCompletion() {
        const suggestController = SuggestController.get(this.editor);
        if (!suggestController) {
          return void 0;
        }
        if (!this.isSuggestWidgetVisible) {
          return void 0;
        }
        const focusedItem = suggestController.widget.value.getFocusedItem();
        if (!focusedItem) {
          return void 0;
        }
        return suggestionToInlineCompletion(suggestController, this.editor.getPosition(), focusedItem.item, this.isShiftKeyPressed);
      }
      stopForceRenderingAbove() {
        const suggestController = SuggestController.get(this.editor);
        if (suggestController) {
          suggestController.stopForceRenderingAbove();
        }
      }
      forceRenderingAbove() {
        const suggestController = SuggestController.get(this.editor);
        if (suggestController) {
          suggestController.forceRenderingAbove();
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetPreviewModel.js
function sum(arr) {
  return arr.reduce((a, b) => a + b, 0);
}
var __awaiter26, SuggestWidgetPreviewModel;
var init_suggestWidgetPreviewModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetPreviewModel.js"() {
    init_async();
    init_errors();
    init_lifecycle();
    init_modes();
    init_ghostText();
    init_inlineCompletionsModel();
    init_inlineCompletionToGhostText();
    init_suggestWidgetInlineCompletionProvider();
    __awaiter26 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    SuggestWidgetPreviewModel = class extends BaseGhostTextWidgetModel {
      constructor(editor2, cache) {
        super(editor2);
        this.cache = cache;
        this.suggestionInlineCompletionSource = this._register(new SuggestWidgetInlineCompletionProvider(
          this.editor,
          // Use the first cache item (if any) as preselection.
          () => {
            var _a5, _b2;
            return (_b2 = (_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions[0]) === null || _b2 === void 0 ? void 0 : _b2.toLiveInlineCompletion();
          }
        ));
        this.updateOperation = this._register(new MutableDisposable());
        this.updateCacheSoon = this._register(new RunOnceScheduler(() => this.updateCache(), 50));
        this.minReservedLineCount = 0;
        this._register(this.suggestionInlineCompletionSource.onDidChange(() => {
          this.updateCacheSoon.schedule();
          const suggestWidgetState = this.suggestionInlineCompletionSource.state;
          if (!suggestWidgetState) {
            this.minReservedLineCount = 0;
          }
          const newGhostText = this.ghostText;
          if (newGhostText) {
            this.minReservedLineCount = Math.max(this.minReservedLineCount, sum(newGhostText.parts.map((p) => p.lines.length - 1)));
          }
          if (this.minReservedLineCount >= 1 && this.isSuggestionPreviewEnabled()) {
            this.suggestionInlineCompletionSource.forceRenderingAbove();
          } else {
            this.suggestionInlineCompletionSource.stopForceRenderingAbove();
          }
          this.onDidChangeEmitter.fire();
        }));
        this._register(this.cache.onDidChange(() => {
          this.onDidChangeEmitter.fire();
        }));
        this._register(this.editor.onDidChangeCursorPosition((e) => {
          if (this.isSuggestionPreviewEnabled()) {
            this.minReservedLineCount = 0;
            this.updateCacheSoon.schedule();
            this.onDidChangeEmitter.fire();
          }
        }));
        this._register(toDisposable(() => this.suggestionInlineCompletionSource.stopForceRenderingAbove()));
      }
      get isActive() {
        return this.suggestionInlineCompletionSource.state !== void 0;
      }
      isSuggestionPreviewEnabled() {
        const suggestOptions = this.editor.getOption(
          105
          /* suggest */
        );
        return suggestOptions.preview;
      }
      updateCache() {
        return __awaiter26(this, void 0, void 0, function* () {
          const state = this.suggestionInlineCompletionSource.state;
          if (!state || !state.selectedItemAsInlineCompletion) {
            return;
          }
          const info = {
            text: state.selectedItemAsInlineCompletion.text,
            range: state.selectedItemAsInlineCompletion.range
          };
          const position = this.editor.getPosition();
          const promise = createCancelablePromise((token) => __awaiter26(this, void 0, void 0, function* () {
            let result;
            try {
              result = yield provideInlineCompletions(position, this.editor.getModel(), { triggerKind: InlineCompletionTriggerKind.Automatic, selectedSuggestionInfo: info }, token);
            } catch (e) {
              onUnexpectedError(e);
              return;
            }
            if (token.isCancellationRequested) {
              return;
            }
            this.cache.setValue(this.editor, result, InlineCompletionTriggerKind.Automatic);
            this.onDidChangeEmitter.fire();
          }));
          const operation = new UpdateOperation(promise, InlineCompletionTriggerKind.Automatic);
          this.updateOperation.value = operation;
          yield promise;
          if (this.updateOperation.value === operation) {
            this.updateOperation.clear();
          }
        });
      }
      get ghostText() {
        var _a5, _b2;
        const suggestWidgetState = this.suggestionInlineCompletionSource.state;
        const originalInlineCompletion = minimizeInlineCompletion(this.editor.getModel(), suggestWidgetState === null || suggestWidgetState === void 0 ? void 0 : suggestWidgetState.selectedItemAsInlineCompletion);
        const augmentedCompletion = minimizeInlineCompletion(this.editor.getModel(), (_b2 = (_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions[0]) === null || _b2 === void 0 ? void 0 : _b2.toLiveInlineCompletion());
        const finalCompletion = augmentedCompletion && originalInlineCompletion && augmentedCompletion.text.startsWith(originalInlineCompletion.text) && augmentedCompletion.range.equalsRange(originalInlineCompletion.range) ? augmentedCompletion : originalInlineCompletion || augmentedCompletion;
        const inlineCompletionPreviewLength = originalInlineCompletion ? ((finalCompletion === null || finalCompletion === void 0 ? void 0 : finalCompletion.text.length) || 0) - originalInlineCompletion.text.length : 0;
        const toGhostText = (completion) => {
          const mode = this.editor.getOptions().get(
            105
            /* suggest */
          ).previewMode;
          return completion ? inlineCompletionToGhostText(completion, this.editor.getModel(), mode, this.editor.getPosition(), inlineCompletionPreviewLength) || // Show an invisible ghost text to reserve space
          new GhostText(completion.range.endLineNumber, [], this.minReservedLineCount) : void 0;
        };
        const newGhostText = toGhostText(finalCompletion);
        return this.isSuggestionPreviewEnabled() ? newGhostText : void 0;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextModel.js
var __decorate36, __param36, __awaiter27, DelegatingModel, GhostTextModel, SharedInlineCompletionCache;
var init_ghostTextModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextModel.js"() {
    init_event();
    init_lifecycle();
    init_position();
    init_modes();
    init_inlineCompletionsModel();
    init_suggestWidgetPreviewModel();
    init_utils();
    init_commands();
    __decorate36 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param36 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter27 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    DelegatingModel = class extends Disposable {
      constructor() {
        super(...arguments);
        this.onDidChangeEmitter = new Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.hasCachedGhostText = false;
        this.currentModelRef = this._register(new MutableDisposable());
      }
      get targetModel() {
        var _a5;
        return (_a5 = this.currentModelRef.value) === null || _a5 === void 0 ? void 0 : _a5.object;
      }
      setTargetModel(model) {
        var _a5;
        if (((_a5 = this.currentModelRef.value) === null || _a5 === void 0 ? void 0 : _a5.object) === model) {
          return;
        }
        this.currentModelRef.clear();
        this.currentModelRef.value = model ? createDisposableRef(model, model.onDidChange(() => {
          this.hasCachedGhostText = false;
          this.onDidChangeEmitter.fire();
        })) : void 0;
        this.hasCachedGhostText = false;
        this.onDidChangeEmitter.fire();
      }
      get ghostText() {
        var _a5, _b2;
        if (!this.hasCachedGhostText) {
          this.cachedGhostText = (_b2 = (_a5 = this.currentModelRef.value) === null || _a5 === void 0 ? void 0 : _a5.object) === null || _b2 === void 0 ? void 0 : _b2.ghostText;
          this.hasCachedGhostText = true;
        }
        return this.cachedGhostText;
      }
      setExpanded(expanded) {
        var _a5;
        (_a5 = this.targetModel) === null || _a5 === void 0 ? void 0 : _a5.setExpanded(expanded);
      }
      get minReservedLineCount() {
        return this.targetModel ? this.targetModel.minReservedLineCount : 0;
      }
    };
    GhostTextModel = class GhostTextModel2 extends DelegatingModel {
      constructor(editor2, commandService) {
        super();
        this.editor = editor2;
        this.commandService = commandService;
        this.sharedCache = this._register(new SharedInlineCompletionCache());
        this.suggestWidgetAdapterModel = this._register(new SuggestWidgetPreviewModel(this.editor, this.sharedCache));
        this.inlineCompletionsModel = this._register(new InlineCompletionsModel(this.editor, this.sharedCache, this.commandService));
        this._register(this.suggestWidgetAdapterModel.onDidChange(() => {
          this.updateModel();
        }));
        this.updateModel();
      }
      get activeInlineCompletionsModel() {
        if (this.targetModel === this.inlineCompletionsModel) {
          return this.inlineCompletionsModel;
        }
        return void 0;
      }
      updateModel() {
        this.setTargetModel(this.suggestWidgetAdapterModel.isActive ? this.suggestWidgetAdapterModel : this.inlineCompletionsModel);
        this.inlineCompletionsModel.setActive(this.targetModel === this.inlineCompletionsModel);
      }
      shouldShowHoverAt(hoverRange) {
        var _a5;
        const ghostText = (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.ghostText;
        if (ghostText) {
          return ghostText.parts.some((p) => hoverRange.containsPosition(new Position(ghostText.lineNumber, p.column)));
        }
        return false;
      }
      triggerInlineCompletion() {
        var _a5;
        (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.trigger(InlineCompletionTriggerKind.Explicit);
      }
      commitInlineCompletion() {
        var _a5;
        (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.commitCurrentSuggestion();
      }
      hideInlineCompletion() {
        var _a5;
        (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.hide();
      }
      showNextInlineCompletion() {
        var _a5;
        (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.showNext();
      }
      showPreviousInlineCompletion() {
        var _a5;
        (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.showPrevious();
      }
      hasMultipleInlineCompletions() {
        var _a5;
        return __awaiter27(this, void 0, void 0, function* () {
          const result = yield (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.hasMultipleInlineCompletions();
          return result !== void 0 ? result : false;
        });
      }
    };
    GhostTextModel = __decorate36([
      __param36(1, ICommandService)
    ], GhostTextModel);
    SharedInlineCompletionCache = class extends Disposable {
      constructor() {
        super(...arguments);
        this.onDidChangeEmitter = new Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.cache = this._register(new MutableDisposable());
      }
      get value() {
        return this.cache.value;
      }
      setValue(editor2, completionsSource, triggerKind) {
        this.cache.value = new SynchronizedInlineCompletionsCache(editor2, completionsSource, () => this.onDidChangeEmitter.fire(), triggerKind);
      }
      clearAndLeak() {
        return this.cache.clearAndLeak();
      }
      clear() {
        this.cache.clear();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextWidget.js
function opaque(color) {
  const { r, b, g } = color.rgba;
  return new Color(new RGBA(r, g, b, 255));
}
function renderLines(domNode, tabSize, lines, opts) {
  const disableMonospaceOptimizations = opts.get(
    29
    /* disableMonospaceOptimizations */
  );
  const stopRenderingLineAfter = opts.get(
    104
    /* stopRenderingLineAfter */
  );
  const renderWhitespace = "none";
  const renderControlCharacters = opts.get(
    82
    /* renderControlCharacters */
  );
  const fontLigatures = opts.get(
    44
    /* fontLigatures */
  );
  const fontInfo = opts.get(
    43
    /* fontInfo */
  );
  const lineHeight = opts.get(
    58
    /* lineHeight */
  );
  const sb = createStringBuilder(1e4);
  sb.appendASCIIString('<div class="suggest-preview-text">');
  for (let i = 0, len = lines.length; i < len; i++) {
    const lineData = lines[i];
    const line = lineData.content;
    sb.appendASCIIString('<div class="view-line');
    sb.appendASCIIString('" style="top:');
    sb.appendASCIIString(String(i * lineHeight));
    sb.appendASCIIString('px;width:1000000px;">');
    const isBasicASCII2 = isBasicASCII(line);
    const containsRTL2 = containsRTL(line);
    const lineTokens = LineTokens.createEmpty(line);
    renderViewLine(new RenderLineInput(fontInfo.isMonospace && !disableMonospaceOptimizations, fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII2, containsRTL2, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null), sb);
    sb.appendASCIIString("</div>");
  }
  sb.appendASCIIString("</div>");
  Configuration.applyFontInfoSlow(domNode, fontInfo);
  const html2 = sb.build();
  const trustedhtml = ttPolicy ? ttPolicy.createHTML(html2) : html2;
  domNode.innerHTML = trustedhtml;
}
function registerDecorationType(service, description, keyPrefix, options) {
  const key = keyPrefix + keyCounter++;
  service.registerDecorationType(description, key, options);
  return {
    dispose() {
      service.removeDecorationType(key);
    },
    resolve() {
      return service.resolveDecorationOptions(key, true);
    }
  };
}
var __decorate37, __param37, _a4, ttPolicy, GhostTextWidget, DecorationsWidget, AdditionalLinesWidget, keyCounter, ViewMoreLinesContentWidget;
var init_ghostTextWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextWidget.js"() {
    init_dom();
    init_color();
    init_lifecycle();
    init_strings();
    init_configuration2();
    init_codeEditorService();
    init_editorOptions();
    init_cursorCommon();
    init_lineTokens();
    init_position();
    init_range();
    init_stringBuilder();
    init_editorColorRegistry();
    init_lineDecorations();
    init_viewLineRenderer();
    init_contextkey();
    init_instantiation();
    init_themeService();
    __decorate37 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param37 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    ttPolicy = (_a4 = window.trustedTypes) === null || _a4 === void 0 ? void 0 : _a4.createPolicy("editorGhostText", { createHTML: (value) => value });
    GhostTextWidget = class GhostTextWidget2 extends Disposable {
      constructor(editor2, model, instantiationService) {
        super();
        this.editor = editor2;
        this.model = model;
        this.instantiationService = instantiationService;
        this.disposed = false;
        this.partsWidget = this._register(this.instantiationService.createInstance(DecorationsWidget, this.editor));
        this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this.editor));
        this.viewMoreContentWidget = void 0;
        this._register(this.editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            29
            /* disableMonospaceOptimizations */
          ) || e.hasChanged(
            104
            /* stopRenderingLineAfter */
          ) || e.hasChanged(
            87
            /* renderWhitespace */
          ) || e.hasChanged(
            82
            /* renderControlCharacters */
          ) || e.hasChanged(
            44
            /* fontLigatures */
          ) || e.hasChanged(
            43
            /* fontInfo */
          ) || e.hasChanged(
            58
            /* lineHeight */
          )) {
            this.update();
          }
        }));
        this._register(toDisposable(() => {
          var _a5;
          this.disposed = true;
          this.update();
          (_a5 = this.viewMoreContentWidget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
          this.viewMoreContentWidget = void 0;
        }));
        this._register(model.onDidChange(() => {
          this.update();
        }));
        this.update();
      }
      shouldShowHoverAtViewZone(viewZoneId) {
        return this.additionalLinesWidget.viewZoneId === viewZoneId;
      }
      update() {
        var _a5;
        const ghostText = this.model.ghostText;
        if (!this.editor.hasModel() || !ghostText || this.disposed) {
          this.partsWidget.clear();
          this.additionalLinesWidget.clear();
          return;
        }
        const inlineTexts = new Array();
        const additionalLines = new Array();
        function addToAdditionalLines(lines, className) {
          if (additionalLines.length > 0) {
            const lastLine = additionalLines[additionalLines.length - 1];
            if (className) {
              lastLine.decorations.push(new LineDecoration(
                lastLine.content.length + 1,
                lastLine.content.length + 1 + lines[0].length,
                className,
                0
                /* Regular */
              ));
            }
            lastLine.content += lines[0];
            lines = lines.slice(1);
          }
          for (const line of lines) {
            additionalLines.push({
              content: line,
              decorations: className ? [new LineDecoration(
                1,
                line.length + 1,
                className,
                0
                /* Regular */
              )] : []
            });
          }
        }
        const textBufferLine = this.editor.getModel().getLineContent(ghostText.lineNumber);
        this.editor.getModel().getLineTokens(ghostText.lineNumber);
        let hiddenTextStartColumn = void 0;
        let lastIdx = 0;
        for (const part of ghostText.parts) {
          let lines = part.lines;
          if (hiddenTextStartColumn === void 0) {
            inlineTexts.push({
              column: part.column,
              text: lines[0],
              preview: part.preview
            });
            lines = lines.slice(1);
          } else {
            addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], void 0);
          }
          if (lines.length > 0) {
            addToAdditionalLines(lines, "ghost-text");
            if (hiddenTextStartColumn === void 0 && part.column <= textBufferLine.length) {
              hiddenTextStartColumn = part.column;
            }
          }
          lastIdx = part.column - 1;
        }
        if (hiddenTextStartColumn !== void 0) {
          addToAdditionalLines([textBufferLine.substring(lastIdx)], void 0);
        }
        this.partsWidget.setParts(ghostText.lineNumber, inlineTexts, hiddenTextStartColumn !== void 0 ? { column: hiddenTextStartColumn, length: textBufferLine.length + 1 - hiddenTextStartColumn } : void 0);
        this.additionalLinesWidget.updateLines(ghostText.lineNumber, additionalLines, ghostText.additionalReservedLineCount);
        if (ghostText.parts.some((p) => p.lines.length < 0)) {
          this.viewMoreContentWidget = this.renderViewMoreLines(new Position(ghostText.lineNumber, this.editor.getModel().getLineMaxColumn(ghostText.lineNumber)), "", 0);
        } else {
          (_a5 = this.viewMoreContentWidget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
          this.viewMoreContentWidget = void 0;
        }
      }
      renderViewMoreLines(position, firstLineText, remainingLinesLength) {
        const fontInfo = this.editor.getOption(
          43
          /* fontInfo */
        );
        const domNode = document.createElement("div");
        domNode.className = "suggest-preview-additional-widget";
        Configuration.applyFontInfoSlow(domNode, fontInfo);
        const spacer = document.createElement("span");
        spacer.className = "content-spacer";
        spacer.append(firstLineText);
        domNode.append(spacer);
        const newline = document.createElement("span");
        newline.className = "content-newline suggest-preview-text";
        newline.append("\u23CE  ");
        domNode.append(newline);
        const disposableStore = new DisposableStore();
        const button = document.createElement("div");
        button.className = "button suggest-preview-text";
        button.append(`+${remainingLinesLength} lines\u2026`);
        disposableStore.add(addStandardDisposableListener(button, "mousedown", (e) => {
          var _a5;
          (_a5 = this.model) === null || _a5 === void 0 ? void 0 : _a5.setExpanded(true);
          e.preventDefault();
          this.editor.focus();
        }));
        domNode.append(button);
        return new ViewMoreLinesContentWidget(this.editor, position, domNode, disposableStore);
      }
    };
    GhostTextWidget = __decorate37([
      __param37(2, IInstantiationService)
    ], GhostTextWidget);
    DecorationsWidget = class DecorationsWidget2 {
      constructor(editor2, codeEditorService, themeService, contextKeyService) {
        this.editor = editor2;
        this.codeEditorService = codeEditorService;
        this.themeService = themeService;
        this.contextKeyService = contextKeyService;
        this.decorationIds = [];
        this.disposableStore = new DisposableStore();
      }
      dispose() {
        this.clear();
        this.disposableStore.dispose();
      }
      clear() {
        this.editor.deltaDecorations(this.decorationIds, []);
        this.disposableStore.clear();
      }
      setParts(lineNumber, parts, hiddenText) {
        this.disposableStore.clear();
        const colorTheme = this.themeService.getColorTheme();
        const foreground2 = colorTheme.getColor(ghostTextForeground);
        let opacity = void 0;
        let color = void 0;
        if (foreground2) {
          opacity = String(foreground2.rgba.a);
          color = Color.Format.CSS.format(opaque(foreground2));
        }
        const borderColor = colorTheme.getColor(ghostTextBorder);
        let border = void 0;
        if (borderColor) {
          border = `2px dashed ${borderColor}`;
        }
        const textModel = this.editor.getModel();
        if (!textModel) {
          return;
        }
        const { tabSize } = textModel.getOptions();
        const line = textModel.getLineContent(lineNumber) || "";
        let lastIndex = 0;
        let currentLinePrefix = "";
        const hiddenTextDecorations = new Array();
        if (hiddenText) {
          hiddenTextDecorations.push({
            range: Range.fromPositions(new Position(lineNumber, hiddenText.column), new Position(lineNumber, hiddenText.column + hiddenText.length)),
            options: {
              inlineClassName: "ghost-text-hidden",
              description: "ghost-text-hidden"
            }
          });
        }
        const key = this.contextKeyService.getContextKeyValue("config.editor.useInjectedText");
        const shouldUseInjectedText = key === void 0 ? true : !!key;
        this.decorationIds = this.editor.deltaDecorations(this.decorationIds, parts.map((p) => {
          currentLinePrefix += line.substring(lastIndex, p.column - 1);
          lastIndex = p.column - 1;
          const contentText = shouldUseInjectedText ? p.text : this.renderSingleLineText(p.text, currentLinePrefix, tabSize, false);
          const decorationType = this.disposableStore.add(registerDecorationType(this.codeEditorService, "ghost-text", "0-ghost-text-", {
            after: {
              // TODO: escape?
              contentText,
              opacity,
              color,
              border,
              fontWeight: p.preview ? "bold" : "normal"
            }
          }));
          return {
            range: Range.fromPositions(new Position(lineNumber, p.column)),
            options: shouldUseInjectedText ? {
              description: "ghost-text",
              after: { content: contentText, inlineClassName: p.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration" },
              showIfCollapsed: true
            } : Object.assign({}, decorationType.resolve())
          };
        }).concat(hiddenTextDecorations));
      }
      renderSingleLineText(text2, lineStart, tabSize, renderWhitespace) {
        const newLine = lineStart + text2;
        const visibleColumnsByColumns = CursorColumns.visibleColumnsByColumns(newLine, tabSize);
        let contentText = "";
        let curCol = lineStart.length + 1;
        for (const c of text2) {
          if (c === "	") {
            const width = visibleColumnsByColumns[curCol + 1] - visibleColumnsByColumns[curCol];
            if (renderWhitespace) {
              contentText += "\u2192";
              for (let i = 1; i < width; i++) {
                contentText += "\xA0";
              }
            } else {
              for (let i = 0; i < width; i++) {
                contentText += "\xA0";
              }
            }
          } else if (c === " ") {
            if (renderWhitespace) {
              contentText += "\xB7";
            } else {
              contentText += "\xA0";
            }
          } else {
            contentText += c;
          }
          curCol += 1;
        }
        return contentText;
      }
    };
    DecorationsWidget = __decorate37([
      __param37(1, ICodeEditorService),
      __param37(2, IThemeService),
      __param37(3, IContextKeyService)
    ], DecorationsWidget);
    AdditionalLinesWidget = class {
      constructor(editor2) {
        this.editor = editor2;
        this._viewZoneId = void 0;
      }
      get viewZoneId() {
        return this._viewZoneId;
      }
      dispose() {
        this.clear();
      }
      clear() {
        this.editor.changeViewZones((changeAccessor) => {
          if (this._viewZoneId) {
            changeAccessor.removeZone(this._viewZoneId);
            this._viewZoneId = void 0;
          }
        });
      }
      updateLines(lineNumber, additionalLines, minReservedLineCount) {
        const textModel = this.editor.getModel();
        if (!textModel) {
          return;
        }
        const { tabSize } = textModel.getOptions();
        this.editor.changeViewZones((changeAccessor) => {
          if (this._viewZoneId) {
            changeAccessor.removeZone(this._viewZoneId);
            this._viewZoneId = void 0;
          }
          const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
          if (heightInLines > 0) {
            const domNode = document.createElement("div");
            renderLines(domNode, tabSize, additionalLines, this.editor.getOptions());
            this._viewZoneId = changeAccessor.addZone({
              afterLineNumber: lineNumber,
              heightInLines,
              domNode
            });
          }
        });
      }
    };
    keyCounter = 0;
    ViewMoreLinesContentWidget = class extends Disposable {
      constructor(editor2, position, domNode, disposableStore) {
        super();
        this.editor = editor2;
        this.position = position;
        this.domNode = domNode;
        this.allowEditorOverflow = false;
        this.suppressMouseDown = false;
        this._register(disposableStore);
        this._register(toDisposable(() => {
          this.editor.removeContentWidget(this);
        }));
        this.editor.addContentWidget(this);
      }
      getId() {
        return "editor.widget.viewMoreLinesWidget";
      }
      getDomNode() {
        return this.domNode;
      }
      getPosition() {
        return {
          position: this.position,
          preference: [
            0
            /* EXACT */
          ]
        };
      }
    };
    registerThemingParticipant((theme, collector) => {
      const foreground2 = theme.getColor(ghostTextForeground);
      if (foreground2) {
        const opacity = String(foreground2.rgba.a);
        const color = Color.Format.CSS.format(opaque(foreground2));
        collector.addRule(`.monaco-editor .ghost-text-decoration { opacity: ${opacity} !important; color: ${color} !important; }`);
        collector.addRule(`.monaco-editor .ghost-text-decoration-preview { color: ${foreground2.toString()} !important; }`);
        collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { opacity: ${opacity} !important; color: ${color} !important; }`);
      }
      const border = theme.getColor(ghostTextBorder);
      if (border) {
        collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { border: 2px dashed ${border}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextController.js
var __decorate38, __param38, __awaiter28, GhostTextController, GhostTextContextKeys, ActiveGhostTextController, GhostTextCommand, commitInlineSuggestionAction, ShowNextInlineSuggestionAction, ShowPreviousInlineSuggestionAction, TriggerInlineSuggestionAction;
var init_ghostTextController = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextController.js"() {
    init_lifecycle();
    init_editorExtensions();
    init_editorContextKeys();
    init_consts();
    init_ghostTextModel();
    init_ghostTextWidget();
    init_nls();
    init_contextkey();
    init_instantiation();
    init_keybindingsRegistry();
    __decorate38 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param38 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter28 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    GhostTextController = class GhostTextController2 extends Disposable {
      constructor(editor2, instantiationService) {
        super();
        this.editor = editor2;
        this.instantiationService = instantiationService;
        this.triggeredExplicitly = false;
        this.activeController = this._register(new MutableDisposable());
        this._register(this.editor.onDidChangeModel(() => {
          this.updateModelController();
        }));
        this._register(this.editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            105
            /* suggest */
          )) {
            this.updateModelController();
          }
          if (e.hasChanged(
            54
            /* inlineSuggest */
          )) {
            this.updateModelController();
          }
        }));
        this.updateModelController();
      }
      static get(editor2) {
        return editor2.getContribution(GhostTextController2.ID);
      }
      get activeModel() {
        var _a5;
        return (_a5 = this.activeController.value) === null || _a5 === void 0 ? void 0 : _a5.model;
      }
      // Don't call this method when not neccessary. It will recreate the activeController.
      updateModelController() {
        const suggestOptions = this.editor.getOption(
          105
          /* suggest */
        );
        const inlineSuggestOptions = this.editor.getOption(
          54
          /* inlineSuggest */
        );
        this.activeController.value = void 0;
        this.activeController.value = this.editor.hasModel() && (suggestOptions.preview || inlineSuggestOptions.enabled || this.triggeredExplicitly) ? this.instantiationService.createInstance(ActiveGhostTextController, this.editor) : void 0;
      }
      shouldShowHoverAt(hoverRange) {
        var _a5;
        return ((_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.shouldShowHoverAt(hoverRange)) || false;
      }
      shouldShowHoverAtViewZone(viewZoneId) {
        var _a5, _b2;
        return ((_b2 = (_a5 = this.activeController.value) === null || _a5 === void 0 ? void 0 : _a5.widget) === null || _b2 === void 0 ? void 0 : _b2.shouldShowHoverAtViewZone(viewZoneId)) || false;
      }
      trigger() {
        var _a5;
        this.triggeredExplicitly = true;
        if (!this.activeController.value) {
          this.updateModelController();
        }
        (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.triggerInlineCompletion();
      }
      commit() {
        var _a5;
        (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.commitInlineCompletion();
      }
      hide() {
        var _a5;
        (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.hideInlineCompletion();
      }
      showNextInlineCompletion() {
        var _a5;
        (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.showNextInlineCompletion();
      }
      showPreviousInlineCompletion() {
        var _a5;
        (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.showPreviousInlineCompletion();
      }
      hasMultipleInlineCompletions() {
        var _a5;
        return __awaiter28(this, void 0, void 0, function* () {
          const result = yield (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.hasMultipleInlineCompletions();
          return result !== void 0 ? result : false;
        });
      }
    };
    GhostTextController.inlineSuggestionVisible = new RawContextKey("inlineSuggestionVisible", false, localize("inlineSuggestionVisible", "Whether an inline suggestion is visible"));
    GhostTextController.inlineSuggestionHasIndentation = new RawContextKey("inlineSuggestionHasIndentation", false, localize("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace"));
    GhostTextController.ID = "editor.contrib.ghostTextController";
    GhostTextController = __decorate38([
      __param38(1, IInstantiationService)
    ], GhostTextController);
    GhostTextContextKeys = class {
      constructor(contextKeyService) {
        this.contextKeyService = contextKeyService;
        this.inlineCompletionVisible = GhostTextController.inlineSuggestionVisible.bindTo(this.contextKeyService);
        this.inlineCompletionSuggestsIndentation = GhostTextController.inlineSuggestionHasIndentation.bindTo(this.contextKeyService);
      }
    };
    ActiveGhostTextController = class ActiveGhostTextController2 extends Disposable {
      constructor(editor2, instantiationService, contextKeyService) {
        super();
        this.editor = editor2;
        this.instantiationService = instantiationService;
        this.contextKeyService = contextKeyService;
        this.contextKeys = new GhostTextContextKeys(this.contextKeyService);
        this.model = this._register(this.instantiationService.createInstance(GhostTextModel, this.editor));
        this.widget = this._register(this.instantiationService.createInstance(GhostTextWidget, this.editor, this.model));
        this._register(toDisposable(() => {
          this.contextKeys.inlineCompletionVisible.set(false);
          this.contextKeys.inlineCompletionSuggestsIndentation.set(false);
        }));
        this._register(this.model.onDidChange(() => {
          this.updateContextKeys();
        }));
        this.updateContextKeys();
      }
      updateContextKeys() {
        var _a5;
        this.contextKeys.inlineCompletionVisible.set(((_a5 = this.model.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.ghostText) !== void 0);
        const ghostText = this.model.inlineCompletionsModel.ghostText;
        if (ghostText && ghostText.parts.length > 0) {
          const { column, lines } = ghostText.parts[0];
          const suggestionStartsWithWs = lines[0].startsWith(" ") || lines[0].startsWith("	");
          const indentationEndColumn = this.editor.getModel().getLineIndentColumn(ghostText.lineNumber);
          const inIndentation = column <= indentationEndColumn;
          this.contextKeys.inlineCompletionSuggestsIndentation.set(!!this.model.activeInlineCompletionsModel && suggestionStartsWithWs && inIndentation);
        } else {
          this.contextKeys.inlineCompletionSuggestsIndentation.set(false);
        }
      }
    };
    ActiveGhostTextController = __decorate38([
      __param38(1, IInstantiationService),
      __param38(2, IContextKeyService)
    ], ActiveGhostTextController);
    GhostTextCommand = EditorCommand.bindToContribution(GhostTextController.get);
    commitInlineSuggestionAction = new GhostTextCommand({
      id: inlineSuggestCommitId,
      precondition: GhostTextController.inlineSuggestionVisible,
      handler(x) {
        x.commit();
        x.editor.focus();
      }
    });
    registerEditorCommand(commitInlineSuggestionAction);
    KeybindingsRegistry.registerKeybindingRule({
      primary: 2,
      weight: 200,
      id: commitInlineSuggestionAction.id,
      when: ContextKeyExpr.and(commitInlineSuggestionAction.precondition, EditorContextKeys.tabMovesFocus.toNegated(), GhostTextController.inlineSuggestionHasIndentation.toNegated())
    });
    registerEditorCommand(new GhostTextCommand({
      id: "editor.action.inlineSuggest.hide",
      precondition: GhostTextController.inlineSuggestionVisible,
      kbOpts: {
        weight: 100,
        primary: 9
      },
      handler(x) {
        x.hide();
      }
    }));
    ShowNextInlineSuggestionAction = class _ShowNextInlineSuggestionAction extends EditorAction {
      constructor() {
        super({
          id: _ShowNextInlineSuggestionAction.ID,
          label: localize("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
          alias: "Show Next Inline Suggestion",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
          kbOpts: {
            weight: 100,
            primary: 512 | 89
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter28(this, void 0, void 0, function* () {
          const controller = GhostTextController.get(editor2);
          if (controller) {
            controller.showNextInlineCompletion();
            editor2.focus();
          }
        });
      }
    };
    ShowNextInlineSuggestionAction.ID = "editor.action.inlineSuggest.showNext";
    ShowPreviousInlineSuggestionAction = class _ShowPreviousInlineSuggestionAction extends EditorAction {
      constructor() {
        super({
          id: _ShowPreviousInlineSuggestionAction.ID,
          label: localize("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
          alias: "Show Previous Inline Suggestion",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
          kbOpts: {
            weight: 100,
            primary: 512 | 87
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter28(this, void 0, void 0, function* () {
          const controller = GhostTextController.get(editor2);
          if (controller) {
            controller.showPreviousInlineCompletion();
            editor2.focus();
          }
        });
      }
    };
    ShowPreviousInlineSuggestionAction.ID = "editor.action.inlineSuggest.showPrevious";
    TriggerInlineSuggestionAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inlineSuggest.trigger",
          label: localize("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
          alias: "Trigger Inline Suggestion",
          precondition: EditorContextKeys.writable
        });
      }
      run(accessor, editor2) {
        return __awaiter28(this, void 0, void 0, function* () {
          const controller = GhostTextController.get(editor2);
          if (controller) {
            controller.trigger();
          }
        });
      }
    };
    registerEditorContribution(GhostTextController.ID, GhostTextController);
    registerEditorAction(TriggerInlineSuggestionAction);
    registerEditorAction(ShowNextInlineSuggestionAction);
    registerEditorAction(ShowPreviousInlineSuggestionAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsHoverParticipant.js
var __decorate39, __param39, InlineCompletionsHover, InlineCompletionsHoverParticipant;
var init_inlineCompletionsHoverParticipant = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsHoverParticipant.js"() {
    init_dom();
    init_htmlContent();
    init_lifecycle();
    init_markdownRenderer2();
    init_range();
    init_modeService();
    init_hoverTypes();
    init_ghostTextController();
    init_nls();
    init_accessibility();
    init_actions2();
    init_commands();
    init_contextkey();
    init_opener();
    __decorate39 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param39 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    InlineCompletionsHover = class {
      constructor(owner, range, controller) {
        this.owner = owner;
        this.range = range;
        this.controller = controller;
      }
      isValidForHoverAnchor(anchor) {
        return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
      }
      hasMultipleSuggestions() {
        return this.controller.hasMultipleInlineCompletions();
      }
    };
    InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant2 {
      constructor(_editor2, _hover, _commandService, _menuService, _contextKeyService, _modeService, _openerService, accessibilityService) {
        this._editor = _editor2;
        this._hover = _hover;
        this._commandService = _commandService;
        this._menuService = _menuService;
        this._contextKeyService = _contextKeyService;
        this._modeService = _modeService;
        this._openerService = _openerService;
        this.accessibilityService = accessibilityService;
      }
      suggestHoverAnchor(mouseEvent) {
        const controller = GhostTextController.get(this._editor);
        if (!controller) {
          return null;
        }
        if (mouseEvent.target.type === 8) {
          const viewZoneData = mouseEvent.target.detail;
          if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
            return new HoverForeignElementAnchor(1e3, this, Range.fromPositions(viewZoneData.positionBefore || viewZoneData.position, viewZoneData.positionBefore || viewZoneData.position));
          }
        }
        if (mouseEvent.target.type === 7 && mouseEvent.target.range) {
          if (controller.shouldShowHoverAt(mouseEvent.target.range)) {
            return new HoverForeignElementAnchor(1e3, this, mouseEvent.target.range);
          }
        }
        if (mouseEvent.target.type === 6 && mouseEvent.target.range && mouseEvent.target.detail) {
          const mightBeForeignElement = mouseEvent.target.detail.mightBeForeignElement;
          if (mightBeForeignElement && controller.shouldShowHoverAt(mouseEvent.target.range)) {
            return new HoverForeignElementAnchor(1e3, this, mouseEvent.target.range);
          }
        }
        return null;
      }
      computeSync(anchor, lineDecorations) {
        const controller = GhostTextController.get(this._editor);
        if (controller && controller.shouldShowHoverAt(anchor.range)) {
          return [new InlineCompletionsHover(this, anchor.range, controller)];
        }
        return [];
      }
      renderHoverParts(hoverParts, fragment, statusBar) {
        const disposableStore = new DisposableStore();
        const part = hoverParts[0];
        if (this.accessibilityService.isScreenReaderOptimized()) {
          this.renderScreenReaderText(part, fragment, disposableStore);
        }
        const menu = disposableStore.add(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
        const previousAction = statusBar.addAction({
          label: localize("showNextInlineSuggestion", "Next"),
          commandId: ShowNextInlineSuggestionAction.ID,
          run: () => this._commandService.executeCommand(ShowNextInlineSuggestionAction.ID)
        });
        const nextAction = statusBar.addAction({
          label: localize("showPreviousInlineSuggestion", "Previous"),
          commandId: ShowPreviousInlineSuggestionAction.ID,
          run: () => this._commandService.executeCommand(ShowPreviousInlineSuggestionAction.ID)
        });
        statusBar.addAction({
          label: localize("acceptInlineSuggestion", "Accept"),
          commandId: commitInlineSuggestionAction.id,
          run: () => this._commandService.executeCommand(commitInlineSuggestionAction.id)
        });
        const actions = [previousAction, nextAction];
        for (const action of actions) {
          action.setEnabled(false);
        }
        part.hasMultipleSuggestions().then((hasMore) => {
          for (const action of actions) {
            action.setEnabled(hasMore);
          }
        });
        for (const [_, group] of menu.getActions()) {
          for (const action of group) {
            if (action instanceof MenuItemAction) {
              statusBar.addAction({
                label: action.label,
                commandId: action.item.id,
                run: () => this._commandService.executeCommand(action.item.id)
              });
            }
          }
        }
        return disposableStore;
      }
      renderScreenReaderText(part, fragment, disposableStore) {
        var _a5, _b2;
        const $9 = $;
        const markdownHoverElement = $9("div.hover-row.markdown-hover");
        const hoverContentsElement = append(markdownHoverElement, $9("div.hover-contents"));
        const renderer = disposableStore.add(new MarkdownRenderer({ editor: this._editor }, this._modeService, this._openerService));
        const render = (code) => {
          disposableStore.add(renderer.onDidRenderAsync(() => {
            hoverContentsElement.className = "hover-contents code-hover-contents";
            this._hover.onContentsChanged();
          }));
          const inlineSuggestionAvailable = localize("inlineSuggestionFollows", "Suggestion:");
          const renderedContents = disposableStore.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock("text", code)));
          hoverContentsElement.replaceChildren(renderedContents.element);
        };
        const ghostText = (_b2 = (_a5 = part.controller.activeModel) === null || _a5 === void 0 ? void 0 : _a5.inlineCompletionsModel) === null || _b2 === void 0 ? void 0 : _b2.ghostText;
        if (ghostText) {
          const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
          render(ghostText.renderForScreenReader(lineText));
        }
        fragment.appendChild(markdownHoverElement);
      }
    };
    InlineCompletionsHoverParticipant = __decorate39([
      __param39(2, ICommandService),
      __param39(3, IMenuService),
      __param39(4, IContextKeyService),
      __param39(5, IModeService),
      __param39(6, IOpenerService),
      __param39(7, IAccessibilityService)
    ], InlineCompletionsHoverParticipant);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesContentHover.js
var __decorate40, __param40, __awaiter29, $6, EditorHoverStatusBar, ModesContentComputer, ModesContentHoverWidget;
var init_modesContentHover = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesContentHover.js"() {
    init_dom();
    init_hoverWidget();
    init_widget();
    init_arrays();
    init_lifecycle();
    init_position();
    init_range();
    init_textModel();
    init_modes();
    init_colorHoverParticipant();
    init_hoverOperation();
    init_hoverTypes();
    init_markdownHoverParticipant();
    init_markerHoverParticipant();
    init_inlineCompletionsHoverParticipant();
    init_instantiation();
    init_keybinding();
    __decorate40 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param40 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter29 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    $6 = $;
    EditorHoverStatusBar = class EditorHoverStatusBar2 extends Disposable {
      constructor(_keybindingService) {
        super();
        this._keybindingService = _keybindingService;
        this._hasContent = false;
        this.hoverElement = $6("div.hover-row.status-bar");
        this.actionsElement = append(this.hoverElement, $6("div.actions"));
      }
      get hasContent() {
        return this._hasContent;
      }
      addAction(actionOptions) {
        const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
        const keybindingLabel = keybinding ? keybinding.getLabel() : null;
        this._hasContent = true;
        return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));
      }
      append(element) {
        const result = append(this.actionsElement, element);
        this._hasContent = true;
        return result;
      }
    };
    EditorHoverStatusBar = __decorate40([
      __param40(0, IKeybindingService)
    ], EditorHoverStatusBar);
    ModesContentComputer = class _ModesContentComputer {
      constructor(editor2, _participants) {
        this._participants = _participants;
        this._editor = editor2;
        this._result = [];
        this._anchor = null;
      }
      setAnchor(anchor) {
        this._anchor = anchor;
        this._result = [];
      }
      clearResult() {
        this._result = [];
      }
      static _getLineDecorations(editor2, anchor) {
        if (anchor.type !== 1) {
          return [];
        }
        const model = editor2.getModel();
        const lineNumber = anchor.range.startLineNumber;
        const maxColumn = model.getLineMaxColumn(lineNumber);
        return editor2.getLineDecorations(lineNumber).filter((d) => {
          if (d.options.isWholeLine) {
            return true;
          }
          const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
          const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
          if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {
            return false;
          }
          return true;
        });
      }
      computeAsync(token) {
        return __awaiter29(this, void 0, void 0, function* () {
          const anchor = this._anchor;
          if (!this._editor.hasModel() || !anchor) {
            return Promise.resolve([]);
          }
          const lineDecorations = _ModesContentComputer._getLineDecorations(this._editor, anchor);
          const allResults = yield Promise.all(this._participants.map((p) => this._computeAsync(p, lineDecorations, anchor, token)));
          return flatten(allResults);
        });
      }
      _computeAsync(participant, lineDecorations, anchor, token) {
        return __awaiter29(this, void 0, void 0, function* () {
          if (!participant.computeAsync) {
            return [];
          }
          return participant.computeAsync(anchor, lineDecorations, token);
        });
      }
      computeSync() {
        if (!this._editor.hasModel() || !this._anchor) {
          return [];
        }
        const lineDecorations = _ModesContentComputer._getLineDecorations(this._editor, this._anchor);
        let result = [];
        for (const participant of this._participants) {
          result = result.concat(participant.computeSync(this._anchor, lineDecorations));
        }
        return coalesce(result);
      }
      onResult(result, isFromSynchronousComputation) {
        if (isFromSynchronousComputation) {
          this._result = result.concat(this._result);
        } else {
          this._result = this._result.concat(result);
        }
      }
      getResult() {
        return this._result.slice(0);
      }
      getResultWithLoadingMessage() {
        if (this._anchor) {
          for (const participant of this._participants) {
            if (participant.createLoadingMessage) {
              const loadingMessage = participant.createLoadingMessage(this._anchor);
              if (loadingMessage) {
                return this._result.slice(0).concat([loadingMessage]);
              }
            }
          }
        }
        return this._result.slice(0);
      }
    };
    ModesContentHoverWidget = class ModesContentHoverWidget2 extends Widget {
      constructor(editor2, _hoverVisibleKey, instantiationService, _keybindingService) {
        super();
        this._hoverVisibleKey = _hoverVisibleKey;
        this._keybindingService = _keybindingService;
        this.allowEditorOverflow = true;
        this._participants = [
          instantiationService.createInstance(ColorHoverParticipant, editor2, this),
          instantiationService.createInstance(MarkdownHoverParticipant, editor2, this),
          instantiationService.createInstance(InlineCompletionsHoverParticipant, editor2, this),
          instantiationService.createInstance(MarkerHoverParticipant, editor2, this)
        ];
        this._hover = this._register(new HoverWidget());
        this._editor = editor2;
        this._isVisible = false;
        this._stoleFocus = false;
        this._renderDisposable = null;
        this.onkeydown(this._hover.containerDomNode, (e) => {
          if (e.equals(
            9
            /* Escape */
          )) {
            this.hide();
          }
        });
        this._register(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            43
            /* fontInfo */
          )) {
            this._updateFont();
          }
        }));
        this._editor.onDidLayoutChange(() => this.layout());
        this.layout();
        this._editor.addContentWidget(this);
        this._showAtPosition = null;
        this._showAtRange = null;
        this._stoleFocus = false;
        this._messages = [];
        this._lastAnchor = null;
        this._computer = new ModesContentComputer(this._editor, this._participants);
        this._highlightDecorations = [];
        this._isChangingDecorations = false;
        this._shouldFocus = false;
        this._colorPicker = null;
        this._hoverOperation = new HoverOperation(this._computer, (result) => this._withResult(result, true), null, (result) => this._withResult(result, false), this._editor.getOption(
          52
          /* hover */
        ).delay);
        this._register(addStandardDisposableListener(this.getDomNode(), EventType.FOCUS, () => {
          if (this._colorPicker) {
            this.getDomNode().classList.add("colorpicker-hover");
          }
        }));
        this._register(addStandardDisposableListener(this.getDomNode(), EventType.BLUR, () => {
          this.getDomNode().classList.remove("colorpicker-hover");
        }));
        this._register(editor2.onDidChangeConfiguration(() => {
          this._hoverOperation.setHoverTime(this._editor.getOption(
            52
            /* hover */
          ).delay);
        }));
        this._register(TokenizationRegistry.onDidChange(() => {
          if (this._isVisible && this._lastAnchor && this._messages.length > 0) {
            this._hover.contentsDomNode.textContent = "";
            this._renderMessages(this._lastAnchor, this._messages);
          }
        }));
      }
      dispose() {
        this._hoverOperation.cancel();
        this._editor.removeContentWidget(this);
        super.dispose();
      }
      getId() {
        return ModesContentHoverWidget2.ID;
      }
      getDomNode() {
        return this._hover.containerDomNode;
      }
      _shouldShowAt(mouseEvent) {
        const targetType = mouseEvent.target.type;
        if (targetType === 6) {
          return true;
        }
        if (targetType === 7) {
          const epsilon = this._editor.getOption(
            43
            /* fontInfo */
          ).typicalHalfwidthCharacterWidth / 2;
          const data = mouseEvent.target.detail;
          if (data && !data.isAfterLines && typeof data.horizontalDistanceToText === "number" && data.horizontalDistanceToText < epsilon) {
            return true;
          }
        }
        return false;
      }
      maybeShowAt(mouseEvent) {
        var _a5;
        const anchorCandidates = [];
        for (const participant of this._participants) {
          if (typeof participant.suggestHoverAnchor === "function") {
            const anchor = participant.suggestHoverAnchor(mouseEvent);
            if (anchor) {
              anchorCandidates.push(anchor);
            }
          }
        }
        if (this._shouldShowAt(mouseEvent) && mouseEvent.target.range) {
          const hoverOnColorDecorator = [...((_a5 = mouseEvent.target.element) === null || _a5 === void 0 ? void 0 : _a5.classList.values()) || []].find((className) => className.startsWith("ced-colorBox")) && mouseEvent.target.range.endColumn - mouseEvent.target.range.startColumn === 1;
          const showAtRange = hoverOnColorDecorator ? new Range(mouseEvent.target.range.startLineNumber, mouseEvent.target.range.startColumn + 1, mouseEvent.target.range.endLineNumber, mouseEvent.target.range.endColumn + 1) : mouseEvent.target.range;
          anchorCandidates.push(new HoverRangeAnchor(0, showAtRange));
        }
        if (anchorCandidates.length === 0) {
          return false;
        }
        anchorCandidates.sort((a, b) => b.priority - a.priority);
        this._startShowingAt(anchorCandidates[0], 0, false);
        return true;
      }
      _showAt(position, range, focus) {
        this._showAtPosition = position;
        this._showAtRange = range;
        this._hoverVisibleKey.set(true);
        this._isVisible = true;
        this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
        this._editor.layoutContentWidget(this);
        this._editor.render();
        this._stoleFocus = focus;
        if (focus) {
          this._hover.containerDomNode.focus();
        }
      }
      getPosition() {
        if (this._isVisible) {
          return {
            position: this._showAtPosition,
            range: this._showAtRange,
            preference: [
              1,
              2
              /* BELOW */
            ]
          };
        }
        return null;
      }
      _updateFont() {
        const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
        codeClasses.forEach((node) => this._editor.applyFontInfo(node));
      }
      _updateContents(node) {
        this._hover.contentsDomNode.textContent = "";
        this._hover.contentsDomNode.appendChild(node);
        this._updateFont();
        this._editor.layoutContentWidget(this);
        this._hover.onContentsChanged();
      }
      layout() {
        const height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
        const { fontSize, lineHeight } = this._editor.getOption(
          43
          /* fontInfo */
        );
        this._hover.contentsDomNode.style.fontSize = `${fontSize}px`;
        this._hover.contentsDomNode.style.lineHeight = `${lineHeight}px`;
        this._hover.contentsDomNode.style.maxHeight = `${height}px`;
        this._hover.contentsDomNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;
      }
      onModelDecorationsChanged() {
        if (this._isChangingDecorations) {
          return;
        }
        if (this._isVisible) {
          this._hoverOperation.cancel();
          this._computer.clearResult();
          if (!this._colorPicker) {
            this._hoverOperation.start(
              0
              /* Delayed */
            );
          }
        }
      }
      startShowingAtRange(range, mode, focus) {
        this._startShowingAt(new HoverRangeAnchor(0, range), mode, focus);
      }
      _startShowingAt(anchor, mode, focus) {
        if (this._lastAnchor && this._lastAnchor.equals(anchor)) {
          return;
        }
        this._hoverOperation.cancel();
        if (this._isVisible) {
          if (!this._showAtPosition || !this._lastAnchor || !anchor.canAdoptVisibleHover(this._lastAnchor, this._showAtPosition)) {
            this.hide();
          } else {
            const filteredMessages = this._messages.filter((m) => m.isValidForHoverAnchor(anchor));
            if (filteredMessages.length === 0) {
              this.hide();
            } else if (filteredMessages.length === this._messages.length) {
              return;
            } else {
              this._renderMessages(anchor, filteredMessages);
            }
          }
        }
        this._lastAnchor = anchor;
        this._computer.setAnchor(anchor);
        this._shouldFocus = focus;
        this._hoverOperation.start(mode);
      }
      hide() {
        this._lastAnchor = null;
        this._hoverOperation.cancel();
        if (this._isVisible) {
          setTimeout(() => {
            if (!this._isVisible) {
              this._hoverVisibleKey.set(false);
            }
          }, 0);
          this._isVisible = false;
          this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
          this._editor.layoutContentWidget(this);
          if (this._stoleFocus) {
            this._editor.focus();
          }
        }
        this._isChangingDecorations = true;
        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);
        this._isChangingDecorations = false;
        if (this._renderDisposable) {
          this._renderDisposable.dispose();
          this._renderDisposable = null;
        }
        this._colorPicker = null;
      }
      isColorPickerVisible() {
        return !!this._colorPicker;
      }
      setColorPicker(widget) {
        this._colorPicker = widget;
      }
      onContentsChanged() {
        this._hover.onContentsChanged();
      }
      _withResult(result, complete) {
        this._messages = result;
        if (this._lastAnchor && this._messages.length > 0) {
          this._renderMessages(this._lastAnchor, this._messages);
        } else if (complete) {
          this.hide();
        }
      }
      _renderMessages(anchor, messages) {
        if (this._renderDisposable) {
          this._renderDisposable.dispose();
          this._renderDisposable = null;
        }
        this._colorPicker = null;
        let renderColumn = 1073741824;
        let highlightRange = messages[0].range;
        let forceShowAtRange = null;
        let fragment = document.createDocumentFragment();
        const disposables = new DisposableStore();
        const hoverParts = /* @__PURE__ */ new Map();
        for (const msg of messages) {
          renderColumn = Math.min(renderColumn, msg.range.startColumn);
          highlightRange = Range.plusRange(highlightRange, msg.range);
          if (msg.forceShowAtRange) {
            forceShowAtRange = msg.range;
          }
          if (!hoverParts.has(msg.owner)) {
            hoverParts.set(msg.owner, []);
          }
          const dest = hoverParts.get(msg.owner);
          dest.push(msg);
        }
        const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));
        for (const [participant, participantHoverParts] of hoverParts) {
          disposables.add(participant.renderHoverParts(participantHoverParts, fragment, statusBar));
        }
        if (statusBar.hasContent) {
          fragment.appendChild(statusBar.hoverElement);
        }
        this._renderDisposable = disposables;
        if (fragment.hasChildNodes()) {
          if (forceShowAtRange) {
            this._showAt(forceShowAtRange.getStartPosition(), forceShowAtRange, this._shouldFocus);
          } else {
            this._showAt(new Position(anchor.range.startLineNumber, renderColumn), highlightRange, this._shouldFocus);
          }
          this._updateContents(fragment);
        }
        if (this._colorPicker) {
          this._colorPicker.layout();
        }
        this._isChangingDecorations = true;
        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, highlightRange ? [{
          range: highlightRange,
          options: ModesContentHoverWidget2._DECORATION_OPTIONS
        }] : []);
        this._isChangingDecorations = false;
      }
    };
    ModesContentHoverWidget.ID = "editor.contrib.modesContentHoverWidget";
    ModesContentHoverWidget._DECORATION_OPTIONS = ModelDecorationOptions.register({
      description: "content-hover-highlight",
      className: "hoverHighlight"
    });
    ModesContentHoverWidget = __decorate40([
      __param40(2, IInstantiationService),
      __param40(3, IKeybindingService)
    ], ModesContentHoverWidget);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesGlyphHover.js
var $7, MarginComputer, ModesGlyphHoverWidget;
var init_modesGlyphHover = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesGlyphHover.js"() {
    init_dom();
    init_arrays();
    init_htmlContent();
    init_lifecycle();
    init_markdownRenderer2();
    init_hoverOperation();
    init_widget();
    init_opener();
    init_hoverWidget();
    $7 = $;
    MarginComputer = class {
      constructor(editor2) {
        this._editor = editor2;
        this._lineNumber = -1;
        this._result = [];
      }
      setLineNumber(lineNumber) {
        this._lineNumber = lineNumber;
        this._result = [];
      }
      clearResult() {
        this._result = [];
      }
      computeSync() {
        const toHoverMessage = (contents) => {
          return {
            value: contents
          };
        };
        const lineDecorations = this._editor.getLineDecorations(this._lineNumber);
        const result = [];
        if (!lineDecorations) {
          return result;
        }
        for (const d of lineDecorations) {
          if (!d.options.glyphMarginClassName) {
            continue;
          }
          const hoverMessage = d.options.glyphMarginHoverMessage;
          if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
            continue;
          }
          result.push(...asArray(hoverMessage).map(toHoverMessage));
        }
        return result;
      }
      onResult(result, isFromSynchronousComputation) {
        this._result = this._result.concat(result);
      }
      getResult() {
        return this._result;
      }
      getResultWithLoadingMessage() {
        return this.getResult();
      }
    };
    ModesGlyphHoverWidget = class _ModesGlyphHoverWidget extends Widget {
      constructor(editor2, modeService, openerService = NullOpenerService) {
        super();
        this._renderDisposeables = this._register(new DisposableStore());
        this._editor = editor2;
        this._hover = this._register(new HoverWidget());
        this._isVisible = false;
        this._messages = [];
        this._lastLineNumber = -1;
        this._markdownRenderer = this._register(new MarkdownRenderer({ editor: this._editor }, modeService, openerService));
        this._computer = new MarginComputer(this._editor);
        this._hoverOperation = new HoverOperation(this._computer, (result) => this._withResult(result), void 0, (result) => this._withResult(result), 300);
        this._register(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            43
            /* fontInfo */
          )) {
            this._updateFont();
          }
        }));
        this._editor.addOverlayWidget(this);
      }
      dispose() {
        this._hoverOperation.cancel();
        this._editor.removeOverlayWidget(this);
        super.dispose();
      }
      getId() {
        return _ModesGlyphHoverWidget.ID;
      }
      getDomNode() {
        return this._hover.containerDomNode;
      }
      getPosition() {
        return null;
      }
      _showAt(lineNumber) {
        if (!this._isVisible) {
          this._isVisible = true;
          this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
        }
        const editorLayout = this._editor.getLayoutInfo();
        const topForLineNumber = this._editor.getTopForLineNumber(lineNumber);
        const editorScrollTop = this._editor.getScrollTop();
        const lineHeight = this._editor.getOption(
          58
          /* lineHeight */
        );
        const nodeHeight = this._hover.containerDomNode.clientHeight;
        const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
        this._hover.containerDomNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;
        this._hover.containerDomNode.style.top = `${Math.max(Math.round(top), 0)}px`;
      }
      _updateFont() {
        const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
        codeClasses.forEach((node) => this._editor.applyFontInfo(node));
      }
      _updateContents(node) {
        this._hover.contentsDomNode.textContent = "";
        this._hover.contentsDomNode.appendChild(node);
        this._updateFont();
      }
      onModelDecorationsChanged() {
        if (this._isVisible) {
          this._hoverOperation.cancel();
          this._computer.clearResult();
          this._hoverOperation.start(
            0
            /* Delayed */
          );
        }
      }
      startShowingAt(lineNumber) {
        if (this._lastLineNumber === lineNumber) {
          return;
        }
        this._hoverOperation.cancel();
        this.hide();
        this._lastLineNumber = lineNumber;
        this._computer.setLineNumber(lineNumber);
        this._hoverOperation.start(
          0
          /* Delayed */
        );
      }
      hide() {
        this._lastLineNumber = -1;
        this._hoverOperation.cancel();
        if (!this._isVisible) {
          return;
        }
        this._isVisible = false;
        this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
      }
      _withResult(result) {
        this._messages = result;
        if (this._messages.length > 0) {
          this._renderMessages(this._lastLineNumber, this._messages);
        } else {
          this.hide();
        }
      }
      _renderMessages(lineNumber, messages) {
        this._renderDisposeables.clear();
        const fragment = document.createDocumentFragment();
        for (const msg of messages) {
          const markdownHoverElement = $7("div.hover-row.markdown-hover");
          const hoverContentsElement = append(markdownHoverElement, $7("div.hover-contents"));
          const renderedContents = this._renderDisposeables.add(this._markdownRenderer.render(msg.value));
          hoverContentsElement.appendChild(renderedContents.element);
          fragment.appendChild(markdownHoverElement);
        }
        this._updateContents(fragment);
        this._showAt(lineNumber);
      }
    };
    ModesGlyphHoverWidget.ID = "editor.contrib.modesGlyphHoverWidget";
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js
var __decorate41, __param41, ModesHoverController, ShowHoverAction, ShowDefinitionPreviewHoverAction;
var init_hover = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js"() {
    init_keyCodes();
    init_lifecycle();
    init_editorExtensions();
    init_range();
    init_editorContextKeys();
    init_modeService();
    init_goToDefinitionAtPosition();
    init_modesContentHover();
    init_modesGlyphHover();
    init_nls();
    init_contextkey();
    init_instantiation();
    init_opener();
    init_colorRegistry();
    init_themeService();
    __decorate41 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param41 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    ModesHoverController = class ModesHoverController2 {
      constructor(_editor2, _instantiationService, _openerService, _modeService, _contextKeyService) {
        this._editor = _editor2;
        this._instantiationService = _instantiationService;
        this._openerService = _openerService;
        this._modeService = _modeService;
        this._toUnhook = new DisposableStore();
        this._isMouseDown = false;
        this._hoverClicked = false;
        this._contentWidget = null;
        this._glyphWidget = null;
        this._hookEvents();
        this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            52
            /* hover */
          )) {
            this._unhookEvents();
            this._hookEvents();
          }
        });
        this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(_contextKeyService);
      }
      static get(editor2) {
        return editor2.getContribution(ModesHoverController2.ID);
      }
      _hookEvents() {
        const hideWidgetsEventHandler = () => this._hideWidgets();
        const hoverOpts = this._editor.getOption(
          52
          /* hover */
        );
        this._isHoverEnabled = hoverOpts.enabled;
        this._isHoverSticky = hoverOpts.sticky;
        if (this._isHoverEnabled) {
          this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
          this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
          this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
          this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
          this._toUnhook.add(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
        } else {
          this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
          this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
        }
        this._toUnhook.add(this._editor.onMouseLeave(hideWidgetsEventHandler));
        this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));
        this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
      }
      _unhookEvents() {
        this._toUnhook.clear();
      }
      _onModelDecorationsChanged() {
        var _a5, _b2;
        (_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.onModelDecorationsChanged();
        (_b2 = this._glyphWidget) === null || _b2 === void 0 ? void 0 : _b2.onModelDecorationsChanged();
      }
      _onEditorScrollChanged(e) {
        if (e.scrollTopChanged || e.scrollLeftChanged) {
          this._hideWidgets();
        }
      }
      _onEditorMouseDown(mouseEvent) {
        this._isMouseDown = true;
        const targetType = mouseEvent.target.type;
        if (targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID) {
          this._hoverClicked = true;
          return;
        }
        if (targetType === 12 && mouseEvent.target.detail === ModesGlyphHoverWidget.ID) {
          return;
        }
        if (targetType !== 12 && mouseEvent.target.detail !== ModesGlyphHoverWidget.ID) {
          this._hoverClicked = false;
        }
        this._hideWidgets();
      }
      _onEditorMouseUp(mouseEvent) {
        this._isMouseDown = false;
      }
      _onEditorMouseMove(mouseEvent) {
        var _a5, _b2, _c2, _d2, _e2;
        let targetType = mouseEvent.target.type;
        if (this._isMouseDown && this._hoverClicked) {
          return;
        }
        if (this._isHoverSticky && targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID) {
          return;
        }
        if (this._isHoverSticky && !((_b2 = (_a5 = mouseEvent.event.browserEvent.view) === null || _a5 === void 0 ? void 0 : _a5.getSelection()) === null || _b2 === void 0 ? void 0 : _b2.isCollapsed)) {
          return;
        }
        if (!this._isHoverSticky && targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID && ((_c2 = this._contentWidget) === null || _c2 === void 0 ? void 0 : _c2.isColorPickerVisible())) {
          return;
        }
        if (this._isHoverSticky && targetType === 12 && mouseEvent.target.detail === ModesGlyphHoverWidget.ID) {
          return;
        }
        if (!this._isHoverEnabled) {
          this._hideWidgets();
          return;
        }
        const contentWidget = this._getOrCreateContentWidget();
        if (contentWidget.maybeShowAt(mouseEvent)) {
          (_d2 = this._glyphWidget) === null || _d2 === void 0 ? void 0 : _d2.hide();
          return;
        }
        if (targetType === 2 && mouseEvent.target.position) {
          (_e2 = this._contentWidget) === null || _e2 === void 0 ? void 0 : _e2.hide();
          if (!this._glyphWidget) {
            this._glyphWidget = new ModesGlyphHoverWidget(this._editor, this._modeService, this._openerService);
          }
          this._glyphWidget.startShowingAt(mouseEvent.target.position.lineNumber);
          return;
        }
        this._hideWidgets();
      }
      _onKeyDown(e) {
        if (e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4) {
          this._hideWidgets();
        }
      }
      _hideWidgets() {
        var _a5, _b2, _c2;
        if (this._isMouseDown && this._hoverClicked && ((_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.isColorPickerVisible())) {
          return;
        }
        this._hoverClicked = false;
        (_b2 = this._glyphWidget) === null || _b2 === void 0 ? void 0 : _b2.hide();
        (_c2 = this._contentWidget) === null || _c2 === void 0 ? void 0 : _c2.hide();
      }
      _getOrCreateContentWidget() {
        if (!this._contentWidget) {
          this._contentWidget = this._instantiationService.createInstance(ModesContentHoverWidget, this._editor, this._hoverVisibleKey);
        }
        return this._contentWidget;
      }
      isColorPickerVisible() {
        var _a5;
        return ((_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.isColorPickerVisible()) || false;
      }
      showContentHover(range, mode, focus) {
        this._getOrCreateContentWidget().startShowingAtRange(range, mode, focus);
      }
      dispose() {
        var _a5, _b2;
        this._unhookEvents();
        this._toUnhook.dispose();
        this._didChangeConfigurationHandler.dispose();
        (_a5 = this._glyphWidget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
        (_b2 = this._contentWidget) === null || _b2 === void 0 ? void 0 : _b2.dispose();
      }
    };
    ModesHoverController.ID = "editor.contrib.hover";
    ModesHoverController = __decorate41([
      __param41(1, IInstantiationService),
      __param41(2, IOpenerService),
      __param41(3, IModeService),
      __param41(4, IContextKeyService)
    ], ModesHoverController);
    ShowHoverAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.showHover",
          label: localize({
            key: "showHover",
            comment: [
              "Label for action that will trigger the showing of a hover in the editor.",
              "This allows for users to show the hover without using the mouse."
            ]
          }, "Show Hover"),
          alias: "Show Hover",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 39
              /* KEY_I */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        let controller = ModesHoverController.get(editor2);
        if (!controller) {
          return;
        }
        const position = editor2.getPosition();
        const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        const focus = editor2.getOption(
          2
          /* accessibilitySupport */
        ) === 2;
        controller.showContentHover(range, 1, focus);
      }
    };
    ShowDefinitionPreviewHoverAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.showDefinitionPreviewHover",
          label: localize({
            key: "showDefinitionPreviewHover",
            comment: [
              "Label for action that will trigger the showing of definition preview hover in the editor.",
              "This allows for users to show the definition preview hover without using the mouse."
            ]
          }, "Show Definition Preview Hover"),
          alias: "Show Definition Preview Hover",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        let controller = ModesHoverController.get(editor2);
        if (!controller) {
          return;
        }
        const position = editor2.getPosition();
        if (!position) {
          return;
        }
        const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
        const goto = GotoDefinitionAtPositionEditorContribution.get(editor2);
        const promise = goto.startFindDefinitionFromCursor(position);
        promise.then(() => {
          controller.showContentHover(range, 1, true);
        });
      }
    };
    registerEditorContribution(ModesHoverController.ID, ModesHoverController);
    registerEditorAction(ShowHoverAction);
    registerEditorAction(ShowDefinitionPreviewHoverAction);
    registerThemingParticipant((theme, collector) => {
      const editorHoverHighlightColor = theme.getColor(editorHoverHighlight);
      if (editorHoverHighlightColor) {
        collector.addRule(`.monaco-editor .hoverHighlight { background-color: ${editorHoverHighlightColor}; }`);
      }
      const hoverBackground = theme.getColor(editorHoverBackground);
      if (hoverBackground) {
        collector.addRule(`.monaco-editor .monaco-hover { background-color: ${hoverBackground}; }`);
      }
      const hoverBorder = theme.getColor(editorHoverBorder);
      if (hoverBorder) {
        collector.addRule(`.monaco-editor .monaco-hover { border: 1px solid ${hoverBorder}; }`);
        collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
        collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
        collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);
      }
      const link = theme.getColor(textLinkForeground);
      if (link) {
        collector.addRule(`.monaco-editor .monaco-hover a { color: ${link}; }`);
      }
      const linkHover = theme.getColor(textLinkActiveForeground);
      if (linkHover) {
        collector.addRule(`.monaco-editor .monaco-hover a:hover { color: ${linkHover}; }`);
      }
      const hoverForeground = theme.getColor(editorHoverForeground);
      if (hoverForeground) {
        collector.addRule(`.monaco-editor .monaco-hover { color: ${hoverForeground}; }`);
      }
      const actionsBackground = theme.getColor(editorHoverStatusBarBackground);
      if (actionsBackground) {
        collector.addRule(`.monaco-editor .monaco-hover .hover-row .actions { background-color: ${actionsBackground}; }`);
      }
      const codeBackground = theme.getColor(textCodeBlockBackground);
      if (codeBackground) {
        collector.addRule(`.monaco-editor .monaco-hover code { background-color: ${codeBackground}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorContributions.js
var ColorContribution;
var init_colorContributions = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorContributions.js"() {
    init_lifecycle();
    init_editorExtensions();
    init_range();
    init_colorDetector();
    init_hover();
    ColorContribution = class extends Disposable {
      constructor(_editor2) {
        super();
        this._editor = _editor2;
        this._register(_editor2.onMouseDown((e) => this.onMouseDown(e)));
      }
      dispose() {
        super.dispose();
      }
      onMouseDown(mouseEvent) {
        var _a5;
        const targetType = mouseEvent.target.type;
        if (targetType !== 6) {
          return;
        }
        const hoverOnColorDecorator = [...((_a5 = mouseEvent.target.element) === null || _a5 === void 0 ? void 0 : _a5.classList.values()) || []].find((className) => className.startsWith("ced-colorBox"));
        if (!hoverOnColorDecorator) {
          return;
        }
        if (!mouseEvent.target.range) {
          return;
        }
        const hoverController = this._editor.getContribution(ModesHoverController.ID);
        if (!hoverController.isColorPickerVisible()) {
          const range = new Range(mouseEvent.target.range.startLineNumber, mouseEvent.target.range.startColumn + 1, mouseEvent.target.range.endLineNumber, mouseEvent.target.range.endColumn + 1);
          hoverController.showContentHover(range, 0, false);
        }
      }
    };
    ColorContribution.ID = "editor.contrib.colorContribution";
    registerEditorContribution(ColorContribution.ID, ColorContribution);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/blockCommentCommand.js
var BlockCommentCommand;
var init_blockCommentCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/comment/blockCommentCommand.js"() {
    init_editOperation();
    init_position();
    init_range();
    init_selection();
    init_languageConfigurationRegistry();
    BlockCommentCommand = class _BlockCommentCommand {
      constructor(selection, insertSpace) {
        this._selection = selection;
        this._insertSpace = insertSpace;
        this._usedEndToken = null;
      }
      static _haystackHasNeedleAtOffset(haystack, needle, offset) {
        if (offset < 0) {
          return false;
        }
        const needleLength = needle.length;
        const haystackLength = haystack.length;
        if (offset + needleLength > haystackLength) {
          return false;
        }
        for (let i = 0; i < needleLength; i++) {
          const codeA = haystack.charCodeAt(offset + i);
          const codeB = needle.charCodeAt(i);
          if (codeA === codeB) {
            continue;
          }
          if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) {
            continue;
          }
          if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) {
            continue;
          }
          return false;
        }
        return true;
      }
      _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
        const startLineNumber = selection.startLineNumber;
        const startColumn = selection.startColumn;
        const endLineNumber = selection.endLineNumber;
        const endColumn = selection.endColumn;
        const startLineText = model.getLineContent(startLineNumber);
        const endLineText = model.getLineContent(endLineNumber);
        let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
        let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
        if (startTokenIndex !== -1 && endTokenIndex !== -1) {
          if (startLineNumber === endLineNumber) {
            const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
            if (lineBetweenTokens.indexOf(endToken) >= 0) {
              startTokenIndex = -1;
              endTokenIndex = -1;
            }
          } else {
            const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
            const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
            if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
              startTokenIndex = -1;
              endTokenIndex = -1;
            }
          }
        }
        let ops;
        if (startTokenIndex !== -1 && endTokenIndex !== -1) {
          if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) {
            startToken = startToken + " ";
          }
          if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
            endToken = " " + endToken;
            endTokenIndex -= 1;
          }
          ops = _BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
        } else {
          ops = _BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
          this._usedEndToken = ops.length === 1 ? endToken : null;
        }
        for (const op of ops) {
          builder.addTrackedEditOperation(op.range, op.text);
        }
      }
      static _createRemoveBlockCommentOperations(r, startToken, endToken) {
        let res = [];
        if (!Range.isEmpty(r)) {
          res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
          res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
        } else {
          res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
        }
        return res;
      }
      static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
        let res = [];
        if (!Range.isEmpty(r)) {
          res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
          res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
        } else {
          res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
        }
        return res;
      }
      getEditOperations(model, builder) {
        const startLineNumber = this._selection.startLineNumber;
        const startColumn = this._selection.startColumn;
        model.tokenizeIfCheap(startLineNumber);
        const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
        const config = LanguageConfigurationRegistry.getComments(languageId);
        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
          return;
        }
        this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
      }
      computeCursorState(model, helper) {
        const inverseEditOperations = helper.getInverseEditOperations();
        if (inverseEditOperations.length === 2) {
          const startTokenEditOperation = inverseEditOperations[0];
          const endTokenEditOperation = inverseEditOperations[1];
          return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
        } else {
          const srcRange = inverseEditOperations[0].range;
          const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
          return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js
var LineCommentCommand;
var init_lineCommentCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js"() {
    init_strings();
    init_editOperation();
    init_position();
    init_range();
    init_selection();
    init_languageConfigurationRegistry();
    init_blockCommentCommand();
    LineCommentCommand = class _LineCommentCommand {
      constructor(selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {
        this._selection = selection;
        this._tabSize = tabSize;
        this._type = type;
        this._insertSpace = insertSpace;
        this._selectionId = null;
        this._deltaColumn = 0;
        this._moveEndPositionDown = false;
        this._ignoreEmptyLines = ignoreEmptyLines;
        this._ignoreFirstLine = ignoreFirstLine || false;
      }
      /**
       * Do an initial pass over the lines and gather info about the line comment string.
       * Returns null if any of the lines doesn't support a line comment string.
       */
      static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {
        model.tokenizeIfCheap(startLineNumber);
        const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
        const config = LanguageConfigurationRegistry.getComments(languageId);
        const commentStr = config ? config.lineCommentToken : null;
        if (!commentStr) {
          return null;
        }
        let lines = [];
        for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
          lines[i] = {
            ignore: false,
            commentStr,
            commentStrOffset: 0,
            commentStrLength: commentStr.length
          };
        }
        return lines;
      }
      /**
       * Analyze lines and decide which lines are relevant and what the toggle should do.
       * Also, build up several offsets and lengths useful in the generation of editor operations.
       */
      static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine) {
        let onlyWhitespaceLines = true;
        let shouldRemoveComments;
        if (type === 0) {
          shouldRemoveComments = true;
        } else if (type === 1) {
          shouldRemoveComments = false;
        } else {
          shouldRemoveComments = true;
        }
        for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
          const lineData = lines[i];
          const lineNumber = startLineNumber + i;
          if (lineNumber === startLineNumber && ignoreFirstLine) {
            lineData.ignore = true;
            continue;
          }
          const lineContent = model.getLineContent(lineNumber);
          const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
          if (lineContentStartOffset === -1) {
            lineData.ignore = ignoreEmptyLines;
            lineData.commentStrOffset = lineContent.length;
            continue;
          }
          onlyWhitespaceLines = false;
          lineData.ignore = false;
          lineData.commentStrOffset = lineContentStartOffset;
          if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
            if (type === 0) {
              shouldRemoveComments = false;
            } else if (type === 1) {
            } else {
              lineData.ignore = true;
            }
          }
          if (shouldRemoveComments && insertSpace) {
            const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
            if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) {
              lineData.commentStrLength += 1;
            }
          }
        }
        if (type === 0 && onlyWhitespaceLines) {
          shouldRemoveComments = false;
          for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
            lines[i].ignore = false;
          }
        }
        return {
          supported: true,
          shouldRemoveComments,
          lines
        };
      }
      /**
       * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
       */
      static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine) {
        const lines = _LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);
        if (lines === null) {
          return {
            supported: false
          };
        }
        return _LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine);
      }
      /**
       * Given a successful analysis, execute either insert line comments, either remove line comments
       */
      _executeLineComments(model, builder, data, s) {
        let ops;
        if (data.shouldRemoveComments) {
          ops = _LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
        } else {
          _LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
          ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
        }
        const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);
        for (let i = 0, len = ops.length; i < len; i++) {
          builder.addEditOperation(ops[i].range, ops[i].text);
          if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {
            const lineContent = model.getLineContent(cursorPosition.lineNumber);
            if (lineContent.length + 1 === cursorPosition.column) {
              this._deltaColumn = (ops[i].text || "").length;
            }
          }
        }
        this._selectionId = builder.trackSelection(s);
      }
      _attemptRemoveBlockComment(model, s, startToken, endToken) {
        let startLineNumber = s.startLineNumber;
        let endLineNumber = s.endLineNumber;
        let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
        let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
        let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
        if (startTokenIndex !== -1 && endTokenIndex === -1) {
          endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
          endLineNumber = startLineNumber;
        }
        if (startTokenIndex === -1 && endTokenIndex !== -1) {
          startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
          startLineNumber = endLineNumber;
        }
        if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
          startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
          if (startTokenIndex !== -1) {
            endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
          }
        }
        if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) {
          startToken += " ";
        }
        if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
          endToken = " " + endToken;
          endTokenIndex -= 1;
        }
        if (startTokenIndex !== -1 && endTokenIndex !== -1) {
          return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
        }
        return null;
      }
      /**
       * Given an unsuccessful analysis, delegate to the block comment command
       */
      _executeBlockComment(model, builder, s) {
        model.tokenizeIfCheap(s.startLineNumber);
        let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
        let config = LanguageConfigurationRegistry.getComments(languageId);
        if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
          return;
        }
        const startToken = config.blockCommentStartToken;
        const endToken = config.blockCommentEndToken;
        let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
        if (!ops) {
          if (s.isEmpty()) {
            const lineContent = model.getLineContent(s.startLineNumber);
            let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
            if (firstNonWhitespaceIndex2 === -1) {
              firstNonWhitespaceIndex2 = lineContent.length;
            }
            ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex2 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
          } else {
            ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
          }
          if (ops.length === 1) {
            this._deltaColumn = startToken.length + 1;
          }
        }
        this._selectionId = builder.trackSelection(s);
        for (const op of ops) {
          builder.addEditOperation(op.range, op.text);
        }
      }
      getEditOperations(model, builder) {
        let s = this._selection;
        this._moveEndPositionDown = false;
        if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {
          builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? "" : "\n");
          this._selectionId = builder.trackSelection(s);
          return;
        }
        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
          this._moveEndPositionDown = true;
          s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
        }
        const data = _LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine);
        if (data.supported) {
          return this._executeLineComments(model, builder, data, s);
        }
        return this._executeBlockComment(model, builder, s);
      }
      computeCursorState(model, helper) {
        let result = helper.getTrackedSelection(this._selectionId);
        if (this._moveEndPositionDown) {
          result = result.setEndPosition(result.endLineNumber + 1, 1);
        }
        return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
      }
      /**
       * Generate edit operations in the remove line comment case
       */
      static _createRemoveLineCommentsOperations(lines, startLineNumber) {
        let res = [];
        for (let i = 0, len = lines.length; i < len; i++) {
          const lineData = lines[i];
          if (lineData.ignore) {
            continue;
          }
          res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
        }
        return res;
      }
      /**
       * Generate edit operations in the add line comment case
       */
      _createAddLineCommentsOperations(lines, startLineNumber) {
        let res = [];
        const afterCommentStr = this._insertSpace ? " " : "";
        for (let i = 0, len = lines.length; i < len; i++) {
          const lineData = lines[i];
          if (lineData.ignore) {
            continue;
          }
          res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
        }
        return res;
      }
      static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {
        if (isTab) {
          return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);
        }
        return currentVisibleColumn + columnSize;
      }
      /**
       * Adjust insertion points to have them vertically aligned in the add line comment case
       */
      static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {
        let minVisibleColumn = 1073741824;
        let j;
        let lenJ;
        for (let i = 0, len = lines.length; i < len; i++) {
          if (lines[i].ignore) {
            continue;
          }
          const lineContent = model.getLineContent(startLineNumber + i);
          let currentVisibleColumn = 0;
          for (let j2 = 0, lenJ2 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j2 < lenJ2; j2++) {
            currentVisibleColumn = _LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j2) === 9, 1);
          }
          if (currentVisibleColumn < minVisibleColumn) {
            minVisibleColumn = currentVisibleColumn;
          }
        }
        minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
        for (let i = 0, len = lines.length; i < len; i++) {
          if (lines[i].ignore) {
            continue;
          }
          const lineContent = model.getLineContent(startLineNumber + i);
          let currentVisibleColumn = 0;
          for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
            currentVisibleColumn = _LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9, 1);
          }
          if (currentVisibleColumn > minVisibleColumn) {
            lines[i].commentStrOffset = j - 1;
          } else {
            lines[i].commentStrOffset = j;
          }
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/comment.js
var CommentLineAction, ToggleCommentLineAction, AddLineCommentAction, RemoveLineCommentAction, BlockCommentAction;
var init_comment = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/comment/comment.js"() {
    init_keyCodes();
    init_editorExtensions();
    init_range();
    init_editorContextKeys();
    init_blockCommentCommand();
    init_lineCommentCommand();
    init_nls();
    init_actions2();
    CommentLineAction = class extends EditorAction {
      constructor(type, opts) {
        super(opts);
        this._type = type;
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const model = editor2.getModel();
        const commands = [];
        const modelOptions = model.getOptions();
        const commentsOptions = editor2.getOption(
          19
          /* comments */
        );
        const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignoreFirstLine: false }));
        selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
        let prev = selections[0];
        for (let i = 1; i < selections.length; i++) {
          const curr = selections[i];
          if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
            if (prev.index < curr.index) {
              curr.ignoreFirstLine = true;
            } else {
              prev.ignoreFirstLine = true;
              prev = curr;
            }
          }
        }
        for (const selection of selections) {
          commands.push(new LineCommentCommand(selection.selection, modelOptions.tabSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines, selection.ignoreFirstLine));
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    ToggleCommentLineAction = class extends CommentLineAction {
      constructor() {
        super(0, {
          id: "editor.action.commentLine",
          label: localize("comment.line", "Toggle Line Comment"),
          alias: "Toggle Line Comment",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 85,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarEditMenu,
            group: "5_insert",
            title: localize({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
            order: 1
          }
        });
      }
    };
    AddLineCommentAction = class extends CommentLineAction {
      constructor() {
        super(1, {
          id: "editor.action.addCommentLine",
          label: localize("comment.line.add", "Add Line Comment"),
          alias: "Add Line Comment",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 33
              /* KEY_C */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    RemoveLineCommentAction = class extends CommentLineAction {
      constructor() {
        super(2, {
          id: "editor.action.removeCommentLine",
          label: localize("comment.line.remove", "Remove Line Comment"),
          alias: "Remove Line Comment",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 51
              /* KEY_U */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    BlockCommentAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.blockComment",
          label: localize("comment.block", "Toggle Block Comment"),
          alias: "Toggle Block Comment",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 31,
            linux: {
              primary: 2048 | 1024 | 31
              /* KEY_A */
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarEditMenu,
            group: "5_insert",
            title: localize({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
            order: 2
          }
        });
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const commentsOptions = editor2.getOption(
          19
          /* comments */
        );
        const commands = [];
        const selections = editor2.getSelections();
        for (const selection of selections) {
          commands.push(new BlockCommentCommand(selection, commentsOptions.insertSpace));
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    registerEditorAction(ToggleCommentLineAction);
    registerEditorAction(AddLineCommentAction);
    registerEditorAction(RemoveLineCommentAction);
    registerEditorAction(BlockCommentAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/contextmenu/contextmenu.js
var __decorate42, __param42, ContextMenuController, ShowContextMenu;
var init_contextmenu = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/contextmenu/contextmenu.js"() {
    init_dom();
    init_actionViewItems();
    init_actions();
    init_lifecycle();
    init_platform();
    init_editorExtensions();
    init_editorContextKeys();
    init_nls();
    init_actions2();
    init_contextkey();
    init_contextView();
    init_keybinding();
    __decorate42 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param42 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    ContextMenuController = class ContextMenuController2 {
      constructor(editor2, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService) {
        this._contextMenuService = _contextMenuService;
        this._contextViewService = _contextViewService;
        this._contextKeyService = _contextKeyService;
        this._keybindingService = _keybindingService;
        this._menuService = _menuService;
        this._toDispose = new DisposableStore();
        this._contextMenuIsBeingShownCount = 0;
        this._editor = editor2;
        this._toDispose.add(this._editor.onContextMenu((e) => this._onContextMenu(e)));
        this._toDispose.add(this._editor.onMouseWheel((e) => {
          if (this._contextMenuIsBeingShownCount > 0) {
            const view = this._contextViewService.getContextViewElement();
            const target = e.srcElement;
            if (!(target.shadowRoot && getShadowRoot(view) === target.shadowRoot)) {
              this._contextViewService.hideContextView();
            }
          }
        }));
        this._toDispose.add(this._editor.onKeyDown((e) => {
          if (e.keyCode === 58) {
            e.preventDefault();
            e.stopPropagation();
            this.showContextMenu();
          }
        }));
      }
      static get(editor2) {
        return editor2.getContribution(ContextMenuController2.ID);
      }
      _onContextMenu(e) {
        if (!this._editor.hasModel()) {
          return;
        }
        if (!this._editor.getOption(
          20
          /* contextmenu */
        )) {
          this._editor.focus();
          if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
            this._editor.setPosition(e.target.position);
          }
          return;
        }
        if (e.target.type === 12) {
          return;
        }
        e.event.preventDefault();
        e.event.stopPropagation();
        if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1) {
          return;
        }
        this._editor.focus();
        if (e.target.position) {
          let hasSelectionAtPosition = false;
          for (const selection of this._editor.getSelections()) {
            if (selection.containsPosition(e.target.position)) {
              hasSelectionAtPosition = true;
              break;
            }
          }
          if (!hasSelectionAtPosition) {
            this._editor.setPosition(e.target.position);
          }
        }
        let anchor = null;
        if (e.target.type !== 1) {
          anchor = { x: e.event.posx - 1, width: 2, y: e.event.posy - 1, height: 2 };
        }
        this.showContextMenu(anchor);
      }
      showContextMenu(anchor) {
        if (!this._editor.getOption(
          20
          /* contextmenu */
        )) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        if (!this._contextMenuService) {
          this._editor.focus();
          return;
        }
        const menuActions = this._getMenuActions(this._editor.getModel(), this._editor.isSimpleWidget ? MenuId.SimpleEditorContext : MenuId.EditorContext);
        if (menuActions.length > 0) {
          this._doShowContextMenu(menuActions, anchor);
        }
      }
      _getMenuActions(model, menuId) {
        const result = [];
        const menu = this._menuService.createMenu(menuId, this._contextKeyService);
        const groups = menu.getActions({ arg: model.uri });
        menu.dispose();
        for (let group of groups) {
          const [, actions] = group;
          let addedItems = 0;
          for (const action of actions) {
            if (action instanceof SubmenuItemAction) {
              const subActions = this._getMenuActions(model, action.item.submenu);
              if (subActions.length > 0) {
                result.push(new SubmenuAction(action.id, action.label, subActions));
                addedItems++;
              }
            } else {
              result.push(action);
              addedItems++;
            }
          }
          if (addedItems) {
            result.push(new Separator());
          }
        }
        if (result.length) {
          result.pop();
        }
        return result;
      }
      _doShowContextMenu(actions, anchor = null) {
        if (!this._editor.hasModel()) {
          return;
        }
        const oldHoverSetting = this._editor.getOption(
          52
          /* hover */
        );
        this._editor.updateOptions({
          hover: {
            enabled: false
          }
        });
        if (!anchor) {
          this._editor.revealPosition(
            this._editor.getPosition(),
            1
            /* Immediate */
          );
          this._editor.render();
          const cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
          const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
          const posx = editorCoords.left + cursorCoords.left;
          const posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
          anchor = { x: posx, y: posy };
        }
        const useShadowDOM = this._editor.getOption(
          113
          /* useShadowDOM */
        ) && !isIOS;
        this._contextMenuIsBeingShownCount++;
        this._contextMenuService.showContextMenu({
          domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
          getAnchor: () => anchor,
          getActions: () => actions,
          getActionViewItem: (action) => {
            const keybinding = this._keybindingFor(action);
            if (keybinding) {
              return new ActionViewItem(action, action, { label: true, keybinding: keybinding.getLabel(), isMenu: true });
            }
            const customActionViewItem = action;
            if (typeof customActionViewItem.getActionViewItem === "function") {
              return customActionViewItem.getActionViewItem();
            }
            return new ActionViewItem(action, action, { icon: true, label: true, isMenu: true });
          },
          getKeyBinding: (action) => {
            return this._keybindingFor(action);
          },
          onHide: (wasCancelled) => {
            this._contextMenuIsBeingShownCount--;
            this._editor.focus();
            this._editor.updateOptions({
              hover: oldHoverSetting
            });
          }
        });
      }
      _keybindingFor(action) {
        return this._keybindingService.lookupKeybinding(action.id);
      }
      dispose() {
        if (this._contextMenuIsBeingShownCount > 0) {
          this._contextViewService.hideContextView();
        }
        this._toDispose.dispose();
      }
    };
    ContextMenuController.ID = "editor.contrib.contextmenu";
    ContextMenuController = __decorate42([
      __param42(1, IContextMenuService),
      __param42(2, IContextViewService),
      __param42(3, IContextKeyService),
      __param42(4, IKeybindingService),
      __param42(5, IMenuService)
    ], ContextMenuController);
    ShowContextMenu = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.showContextMenu",
          label: localize("action.showContextMenu.label", "Show Editor Context Menu"),
          alias: "Show Editor Context Menu",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 1024 | 68,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        let contribution = ContextMenuController.get(editor2);
        contribution.showContextMenu();
      }
    };
    registerEditorContribution(ContextMenuController.ID, ContextMenuController);
    registerEditorAction(ShowContextMenu);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/cursorUndo.js
var CursorState2, StackElement, CursorUndoRedoController, CursorUndo, CursorRedo;
var init_cursorUndo = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/cursorUndo.js"() {
    init_lifecycle();
    init_editorExtensions();
    init_editorContextKeys();
    init_nls();
    CursorState2 = class {
      constructor(selections) {
        this.selections = selections;
      }
      equals(other) {
        const thisLen = this.selections.length;
        const otherLen = other.selections.length;
        if (thisLen !== otherLen) {
          return false;
        }
        for (let i = 0; i < thisLen; i++) {
          if (!this.selections[i].equalsSelection(other.selections[i])) {
            return false;
          }
        }
        return true;
      }
    };
    StackElement = class {
      constructor(cursorState, scrollTop, scrollLeft) {
        this.cursorState = cursorState;
        this.scrollTop = scrollTop;
        this.scrollLeft = scrollLeft;
      }
    };
    CursorUndoRedoController = class _CursorUndoRedoController extends Disposable {
      constructor(editor2) {
        super();
        this._editor = editor2;
        this._isCursorUndoRedo = false;
        this._undoStack = [];
        this._redoStack = [];
        this._register(editor2.onDidChangeModel((e) => {
          this._undoStack = [];
          this._redoStack = [];
        }));
        this._register(editor2.onDidChangeModelContent((e) => {
          this._undoStack = [];
          this._redoStack = [];
        }));
        this._register(editor2.onDidChangeCursorSelection((e) => {
          if (this._isCursorUndoRedo) {
            return;
          }
          if (!e.oldSelections) {
            return;
          }
          if (e.oldModelVersionId !== e.modelVersionId) {
            return;
          }
          const prevState = new CursorState2(e.oldSelections);
          const isEqualToLastUndoStack = this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState);
          if (!isEqualToLastUndoStack) {
            this._undoStack.push(new StackElement(prevState, editor2.getScrollTop(), editor2.getScrollLeft()));
            this._redoStack = [];
            if (this._undoStack.length > 50) {
              this._undoStack.shift();
            }
          }
        }));
      }
      static get(editor2) {
        return editor2.getContribution(_CursorUndoRedoController.ID);
      }
      cursorUndo() {
        if (!this._editor.hasModel() || this._undoStack.length === 0) {
          return;
        }
        this._redoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
        this._applyState(this._undoStack.pop());
      }
      cursorRedo() {
        if (!this._editor.hasModel() || this._redoStack.length === 0) {
          return;
        }
        this._undoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
        this._applyState(this._redoStack.pop());
      }
      _applyState(stackElement) {
        this._isCursorUndoRedo = true;
        this._editor.setSelections(stackElement.cursorState.selections);
        this._editor.setScrollPosition({
          scrollTop: stackElement.scrollTop,
          scrollLeft: stackElement.scrollLeft
        });
        this._isCursorUndoRedo = false;
      }
    };
    CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
    CursorUndo = class extends EditorAction {
      constructor() {
        super({
          id: "cursorUndo",
          label: localize("cursor.undo", "Cursor Undo"),
          alias: "Cursor Undo",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 | 51,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2, args) {
        CursorUndoRedoController.get(editor2).cursorUndo();
      }
    };
    CursorRedo = class extends EditorAction {
      constructor() {
        super({
          id: "cursorRedo",
          label: localize("cursor.redo", "Cursor Redo"),
          alias: "Cursor Redo",
          precondition: void 0
        });
      }
      run(accessor, editor2, args) {
        CursorUndoRedoController.get(editor2).cursorRedo();
      }
    };
    registerEditorContribution(CursorUndoRedoController.ID, CursorUndoRedoController);
    registerEditorAction(CursorUndo);
    registerEditorAction(CursorRedo);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dragAndDropCommand.js
var DragAndDropCommand;
var init_dragAndDropCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dragAndDropCommand.js"() {
    init_range();
    init_selection();
    DragAndDropCommand = class {
      constructor(selection, targetPosition, copy) {
        this.selection = selection;
        this.targetPosition = targetPosition;
        this.copy = copy;
        this.targetSelection = null;
      }
      getEditOperations(model, builder) {
        let text2 = model.getValueInRange(this.selection);
        if (!this.copy) {
          builder.addEditOperation(this.selection, null);
        }
        builder.addEditOperation(new Range(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text2);
        if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
          this.targetSelection = this.selection;
          return;
        }
        if (this.copy) {
          this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
          return;
        }
        if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
          this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
          return;
        }
        if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
          this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
          return;
        }
        if (this.selection.endColumn <= this.targetPosition.column) {
          this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
        } else {
          this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
        }
      }
      computeCursorState(model, helper) {
        return this.targetSelection;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dnd.js
function hasTriggerModifier(e) {
  if (isMacintosh) {
    return e.altKey;
  } else {
    return e.ctrlKey;
  }
}
var DragAndDropController;
var init_dnd = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dnd.js"() {
    init_lifecycle();
    init_platform();
    init_editorExtensions();
    init_position();
    init_range();
    init_selection();
    init_textModel();
    init_dragAndDropCommand();
    DragAndDropController = class _DragAndDropController extends Disposable {
      constructor(editor2) {
        super();
        this._editor = editor2;
        this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
        this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
        this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
        this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
        this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled()));
        this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
        this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
        this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
        this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
        this._dndDecorationIds = [];
        this._mouseDown = false;
        this._modifierPressed = false;
        this._dragSelection = null;
      }
      onEditorBlur() {
        this._removeDecoration();
        this._dragSelection = null;
        this._mouseDown = false;
        this._modifierPressed = false;
      }
      onEditorKeyDown(e) {
        if (!this._editor.getOption(
          31
          /* dragAndDrop */
        ) || this._editor.getOption(
          18
          /* columnSelection */
        )) {
          return;
        }
        if (hasTriggerModifier(e)) {
          this._modifierPressed = true;
        }
        if (this._mouseDown && hasTriggerModifier(e)) {
          this._editor.updateOptions({
            mouseStyle: "copy"
          });
        }
      }
      onEditorKeyUp(e) {
        if (!this._editor.getOption(
          31
          /* dragAndDrop */
        ) || this._editor.getOption(
          18
          /* columnSelection */
        )) {
          return;
        }
        if (hasTriggerModifier(e)) {
          this._modifierPressed = false;
        }
        if (this._mouseDown && e.keyCode === _DragAndDropController.TRIGGER_KEY_VALUE) {
          this._editor.updateOptions({
            mouseStyle: "default"
          });
        }
      }
      _onEditorMouseDown(mouseEvent) {
        this._mouseDown = true;
      }
      _onEditorMouseUp(mouseEvent) {
        this._mouseDown = false;
        this._editor.updateOptions({
          mouseStyle: "text"
        });
      }
      _onEditorMouseDrag(mouseEvent) {
        let target = mouseEvent.target;
        if (this._dragSelection === null) {
          const selections = this._editor.getSelections() || [];
          let possibleSelections = selections.filter((selection) => target.position && selection.containsPosition(target.position));
          if (possibleSelections.length === 1) {
            this._dragSelection = possibleSelections[0];
          } else {
            return;
          }
        }
        if (hasTriggerModifier(mouseEvent.event)) {
          this._editor.updateOptions({
            mouseStyle: "copy"
          });
        } else {
          this._editor.updateOptions({
            mouseStyle: "default"
          });
        }
        if (target.position) {
          if (this._dragSelection.containsPosition(target.position)) {
            this._removeDecoration();
          } else {
            this.showAt(target.position);
          }
        }
      }
      _onEditorMouseDropCanceled() {
        this._editor.updateOptions({
          mouseStyle: "text"
        });
        this._removeDecoration();
        this._dragSelection = null;
        this._mouseDown = false;
      }
      _onEditorMouseDrop(mouseEvent) {
        if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
          let newCursorPosition = new Position(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
          if (this._dragSelection === null) {
            let newSelections = null;
            if (mouseEvent.event.shiftKey) {
              let primarySelection = this._editor.getSelection();
              if (primarySelection) {
                const { selectionStartLineNumber, selectionStartColumn } = primarySelection;
                newSelections = [new Selection(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
              }
            } else {
              newSelections = (this._editor.getSelections() || []).map((selection) => {
                if (selection.containsPosition(newCursorPosition)) {
                  return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
                } else {
                  return selection;
                }
              });
            }
            this._editor.setSelections(
              newSelections || [],
              "mouse",
              3
              /* Explicit */
            );
          } else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
            this._editor.pushUndoStop();
            this._editor.executeCommand(_DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
            this._editor.pushUndoStop();
          }
        }
        this._editor.updateOptions({
          mouseStyle: "text"
        });
        this._removeDecoration();
        this._dragSelection = null;
        this._mouseDown = false;
      }
      showAt(position) {
        let newDecorations = [{
          range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
          options: _DragAndDropController._DECORATION_OPTIONS
        }];
        this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, newDecorations);
        this._editor.revealPosition(
          position,
          1
          /* Immediate */
        );
      }
      _removeDecoration() {
        this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, []);
      }
      _hitContent(target) {
        return target.type === 6 || target.type === 7;
      }
      _hitMargin(target) {
        return target.type === 2 || target.type === 3 || target.type === 4;
      }
      dispose() {
        this._removeDecoration();
        this._dragSelection = null;
        this._mouseDown = false;
        this._modifierPressed = false;
        super.dispose();
      }
    };
    DragAndDropController.ID = "editor.contrib.dragAndDrop";
    DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
    DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
      description: "dnd-target",
      className: "dnd-target"
    });
    registerEditorContribution(DragAndDropController.ID, DragAndDropController);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findDecorations.js
var FindDecorations;
var init_findDecorations = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/findDecorations.js"() {
    init_range();
    init_model();
    init_textModel();
    init_colorRegistry();
    init_themeService();
    FindDecorations = class _FindDecorations {
      constructor(editor2) {
        this._editor = editor2;
        this._decorations = [];
        this._overviewRulerApproximateDecorations = [];
        this._findScopeDecorationIds = [];
        this._rangeHighlightDecorationId = null;
        this._highlightedDecorationId = null;
        this._startPosition = this._editor.getPosition();
      }
      dispose() {
        this._editor.deltaDecorations(this._allDecorations(), []);
        this._decorations = [];
        this._overviewRulerApproximateDecorations = [];
        this._findScopeDecorationIds = [];
        this._rangeHighlightDecorationId = null;
        this._highlightedDecorationId = null;
      }
      reset() {
        this._decorations = [];
        this._overviewRulerApproximateDecorations = [];
        this._findScopeDecorationIds = [];
        this._rangeHighlightDecorationId = null;
        this._highlightedDecorationId = null;
      }
      getCount() {
        return this._decorations.length;
      }
      /** @deprecated use getFindScopes to support multiple selections */
      getFindScope() {
        if (this._findScopeDecorationIds[0]) {
          return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
        }
        return null;
      }
      getFindScopes() {
        if (this._findScopeDecorationIds.length) {
          const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
          if (scopes.length) {
            return scopes;
          }
        }
        return null;
      }
      getStartPosition() {
        return this._startPosition;
      }
      setStartPosition(newStartPosition) {
        this._startPosition = newStartPosition;
        this.setCurrentFindMatch(null);
      }
      _getDecorationIndex(decorationId) {
        const index = this._decorations.indexOf(decorationId);
        if (index >= 0) {
          return index + 1;
        }
        return 1;
      }
      getCurrentMatchesPosition(desiredRange) {
        let candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
        for (const candidate of candidates) {
          const candidateOpts = candidate.options;
          if (candidateOpts === _FindDecorations._FIND_MATCH_DECORATION || candidateOpts === _FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
            return this._getDecorationIndex(candidate.id);
          }
        }
        return 0;
      }
      setCurrentFindMatch(nextMatch) {
        let newCurrentDecorationId = null;
        let matchPosition = 0;
        if (nextMatch) {
          for (let i = 0, len = this._decorations.length; i < len; i++) {
            let range = this._editor.getModel().getDecorationRange(this._decorations[i]);
            if (nextMatch.equalsRange(range)) {
              newCurrentDecorationId = this._decorations[i];
              matchPosition = i + 1;
              break;
            }
          }
        }
        if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
          this._editor.changeDecorations((changeAccessor) => {
            if (this._highlightedDecorationId !== null) {
              changeAccessor.changeDecorationOptions(this._highlightedDecorationId, _FindDecorations._FIND_MATCH_DECORATION);
              this._highlightedDecorationId = null;
            }
            if (newCurrentDecorationId !== null) {
              this._highlightedDecorationId = newCurrentDecorationId;
              changeAccessor.changeDecorationOptions(this._highlightedDecorationId, _FindDecorations._CURRENT_FIND_MATCH_DECORATION);
            }
            if (this._rangeHighlightDecorationId !== null) {
              changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
              this._rangeHighlightDecorationId = null;
            }
            if (newCurrentDecorationId !== null) {
              let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
              if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
                let lineBeforeEnd = rng.endLineNumber - 1;
                let lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
                rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
              }
              this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, _FindDecorations._RANGE_HIGHLIGHT_DECORATION);
            }
          });
        }
        return matchPosition;
      }
      set(findMatches, findScopes) {
        this._editor.changeDecorations((accessor) => {
          let findMatchesOptions = _FindDecorations._FIND_MATCH_DECORATION;
          let newOverviewRulerApproximateDecorations = [];
          if (findMatches.length > 1e3) {
            findMatchesOptions = _FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
            const lineCount = this._editor.getModel().getLineCount();
            const height = this._editor.getLayoutInfo().height;
            const approxPixelsPerLine = height / lineCount;
            const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
            let prevStartLineNumber = findMatches[0].range.startLineNumber;
            let prevEndLineNumber = findMatches[0].range.endLineNumber;
            for (let i = 1, len = findMatches.length; i < len; i++) {
              const range = findMatches[i].range;
              if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {
                if (range.endLineNumber > prevEndLineNumber) {
                  prevEndLineNumber = range.endLineNumber;
                }
              } else {
                newOverviewRulerApproximateDecorations.push({
                  range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
                  options: _FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
                });
                prevStartLineNumber = range.startLineNumber;
                prevEndLineNumber = range.endLineNumber;
              }
            }
            newOverviewRulerApproximateDecorations.push({
              range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
              options: _FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            });
          }
          let newFindMatchesDecorations = new Array(findMatches.length);
          for (let i = 0, len = findMatches.length; i < len; i++) {
            newFindMatchesDecorations[i] = {
              range: findMatches[i].range,
              options: findMatchesOptions
            };
          }
          this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
          this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
          if (this._rangeHighlightDecorationId) {
            accessor.removeDecoration(this._rangeHighlightDecorationId);
            this._rangeHighlightDecorationId = null;
          }
          if (this._findScopeDecorationIds.length) {
            this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
            this._findScopeDecorationIds = [];
          }
          if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {
            this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, _FindDecorations._FIND_SCOPE_DECORATION));
          }
        });
      }
      matchBeforePosition(position) {
        if (this._decorations.length === 0) {
          return null;
        }
        for (let i = this._decorations.length - 1; i >= 0; i--) {
          let decorationId = this._decorations[i];
          let r = this._editor.getModel().getDecorationRange(decorationId);
          if (!r || r.endLineNumber > position.lineNumber) {
            continue;
          }
          if (r.endLineNumber < position.lineNumber) {
            return r;
          }
          if (r.endColumn > position.column) {
            continue;
          }
          return r;
        }
        return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
      }
      matchAfterPosition(position) {
        if (this._decorations.length === 0) {
          return null;
        }
        for (let i = 0, len = this._decorations.length; i < len; i++) {
          let decorationId = this._decorations[i];
          let r = this._editor.getModel().getDecorationRange(decorationId);
          if (!r || r.startLineNumber < position.lineNumber) {
            continue;
          }
          if (r.startLineNumber > position.lineNumber) {
            return r;
          }
          if (r.startColumn < position.column) {
            continue;
          }
          return r;
        }
        return this._editor.getModel().getDecorationRange(this._decorations[0]);
      }
      _allDecorations() {
        let result = [];
        result = result.concat(this._decorations);
        result = result.concat(this._overviewRulerApproximateDecorations);
        if (this._findScopeDecorationIds.length) {
          result.push(...this._findScopeDecorationIds);
        }
        if (this._rangeHighlightDecorationId) {
          result.push(this._rangeHighlightDecorationId);
        }
        return result;
      }
    };
    FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
      description: "current-find-match",
      stickiness: 1,
      zIndex: 13,
      className: "currentFindMatch",
      showIfCollapsed: true,
      overviewRuler: {
        color: themeColorFromId(overviewRulerFindMatchForeground),
        position: OverviewRulerLane.Center
      },
      minimap: {
        color: themeColorFromId(minimapFindMatch),
        position: MinimapPosition.Inline
      }
    });
    FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
      description: "find-match",
      stickiness: 1,
      zIndex: 10,
      className: "findMatch",
      showIfCollapsed: true,
      overviewRuler: {
        color: themeColorFromId(overviewRulerFindMatchForeground),
        position: OverviewRulerLane.Center
      },
      minimap: {
        color: themeColorFromId(minimapFindMatch),
        position: MinimapPosition.Inline
      }
    });
    FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
      description: "find-match-no-overview",
      stickiness: 1,
      className: "findMatch",
      showIfCollapsed: true
    });
    FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
      description: "find-match-only-overview",
      stickiness: 1,
      overviewRuler: {
        color: themeColorFromId(overviewRulerFindMatchForeground),
        position: OverviewRulerLane.Center
      }
    });
    FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
      description: "find-range-highlight",
      stickiness: 1,
      className: "rangeHighlight",
      isWholeLine: true
    });
    FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
      description: "find-scope",
      className: "findScope",
      isWholeLine: true
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/replaceAllCommand.js
var ReplaceAllCommand;
var init_replaceAllCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/replaceAllCommand.js"() {
    init_range();
    ReplaceAllCommand = class {
      constructor(editorSelection, ranges, replaceStrings) {
        this._editorSelection = editorSelection;
        this._ranges = ranges;
        this._replaceStrings = replaceStrings;
        this._trackedEditorSelectionId = null;
      }
      getEditOperations(model, builder) {
        if (this._ranges.length > 0) {
          let ops = [];
          for (let i = 0; i < this._ranges.length; i++) {
            ops.push({
              range: this._ranges[i],
              text: this._replaceStrings[i]
            });
          }
          ops.sort((o1, o2) => {
            return Range.compareRangesUsingStarts(o1.range, o2.range);
          });
          let resultOps = [];
          let previousOp = ops[0];
          for (let i = 1; i < ops.length; i++) {
            if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
              previousOp.range = previousOp.range.plusRange(ops[i].range);
              previousOp.text = previousOp.text + ops[i].text;
            } else {
              resultOps.push(previousOp);
              previousOp = ops[i];
            }
          }
          resultOps.push(previousOp);
          for (const op of resultOps) {
            builder.addEditOperation(op.range, op.text);
          }
        }
        this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
      }
      computeCursorState(model, helper) {
        return helper.getTrackedSelection(this._trackedEditorSelectionId);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/common/search.js
function buildReplaceStringWithCasePreserved(matches, pattern) {
  if (matches && matches[0] !== "") {
    const containsHyphens = validateSpecificSpecialCharacter(matches, pattern, "-");
    const containsUnderscores = validateSpecificSpecialCharacter(matches, pattern, "_");
    if (containsHyphens && !containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "-");
    } else if (!containsHyphens && containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "_");
    }
    if (matches[0].toUpperCase() === matches[0]) {
      return pattern.toUpperCase();
    } else if (matches[0].toLowerCase() === matches[0]) {
      return pattern.toLowerCase();
    } else if (containsUppercaseCharacter(matches[0][0]) && pattern.length > 0) {
      return pattern[0].toUpperCase() + pattern.substr(1);
    } else if (matches[0][0].toUpperCase() !== matches[0][0] && pattern.length > 0) {
      return pattern[0].toLowerCase() + pattern.substr(1);
    } else {
      return pattern;
    }
  } else {
    return pattern;
  }
}
function validateSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const doesContainSpecialCharacter = matches[0].indexOf(specialCharacter) !== -1 && pattern.indexOf(specialCharacter) !== -1;
  return doesContainSpecialCharacter && matches[0].split(specialCharacter).length === pattern.split(specialCharacter).length;
}
function buildReplaceStringForSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const splitPatternAtSpecialCharacter = pattern.split(specialCharacter);
  const splitMatchAtSpecialCharacter = matches[0].split(specialCharacter);
  let replaceString = "";
  splitPatternAtSpecialCharacter.forEach((splitValue, index) => {
    replaceString += buildReplaceStringWithCasePreserved([splitMatchAtSpecialCharacter[index]], splitValue) + specialCharacter;
  });
  return replaceString.slice(0, -1);
}
var init_search = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/search.js"() {
    init_strings();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/replacePattern.js
function parseReplaceString(replaceString) {
  if (!replaceString || replaceString.length === 0) {
    return new ReplacePattern(null);
  }
  let caseOps = [];
  let result = new ReplacePieceBuilder(replaceString);
  for (let i = 0, len = replaceString.length; i < len; i++) {
    let chCode = replaceString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      let nextChCode = replaceString.charCodeAt(i);
      switch (nextChCode) {
        case 92:
          result.emitUnchanged(i - 1);
          result.emitStatic("\\", i + 1);
          break;
        case 110:
          result.emitUnchanged(i - 1);
          result.emitStatic("\n", i + 1);
          break;
        case 116:
          result.emitUnchanged(i - 1);
          result.emitStatic("	", i + 1);
          break;
        // Case modification of string replacements, patterned after Boost, but only applied
        // to the replacement text, not subsequent content.
        case 117:
        // \u => upper-cases one character.
        case 85:
        // \U => upper-cases ALL following characters.
        case 108:
        // \l => lower-cases one character.
        case 76:
          result.emitUnchanged(i - 1);
          result.emitStatic("", i + 1);
          caseOps.push(String.fromCharCode(nextChCode));
          break;
      }
      continue;
    }
    if (chCode === 36) {
      i++;
      if (i >= len) {
        break;
      }
      let nextChCode = replaceString.charCodeAt(i);
      if (nextChCode === 36) {
        result.emitUnchanged(i - 1);
        result.emitStatic("$", i + 1);
        continue;
      }
      if (nextChCode === 48 || nextChCode === 38) {
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(0, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
      if (49 <= nextChCode && nextChCode <= 57) {
        let matchIndex = nextChCode - 48;
        if (i + 1 < len) {
          let nextNextChCode = replaceString.charCodeAt(i + 1);
          if (48 <= nextNextChCode && nextNextChCode <= 57) {
            i++;
            matchIndex = matchIndex * 10 + (nextNextChCode - 48);
            result.emitUnchanged(i - 2);
            result.emitMatchIndex(matchIndex, i + 1, caseOps);
            caseOps.length = 0;
            continue;
          }
        }
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(matchIndex, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
    }
  }
  return result.finalize();
}
var StaticValueReplacePattern, DynamicPiecesReplacePattern, ReplacePattern, ReplacePiece, ReplacePieceBuilder;
var init_replacePattern = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/replacePattern.js"() {
    init_search();
    StaticValueReplacePattern = class {
      constructor(staticValue) {
        this.staticValue = staticValue;
        this.kind = 0;
      }
    };
    DynamicPiecesReplacePattern = class {
      constructor(pieces) {
        this.pieces = pieces;
        this.kind = 1;
      }
    };
    ReplacePattern = class _ReplacePattern {
      constructor(pieces) {
        if (!pieces || pieces.length === 0) {
          this._state = new StaticValueReplacePattern("");
        } else if (pieces.length === 1 && pieces[0].staticValue !== null) {
          this._state = new StaticValueReplacePattern(pieces[0].staticValue);
        } else {
          this._state = new DynamicPiecesReplacePattern(pieces);
        }
      }
      static fromStaticValue(value) {
        return new _ReplacePattern([ReplacePiece.staticValue(value)]);
      }
      get hasReplacementPatterns() {
        return this._state.kind === 1;
      }
      buildReplaceString(matches, preserveCase) {
        if (this._state.kind === 0) {
          if (preserveCase) {
            return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
          } else {
            return this._state.staticValue;
          }
        }
        let result = "";
        for (let i = 0, len = this._state.pieces.length; i < len; i++) {
          let piece = this._state.pieces[i];
          if (piece.staticValue !== null) {
            result += piece.staticValue;
            continue;
          }
          let match = _ReplacePattern._substitute(piece.matchIndex, matches);
          if (piece.caseOps !== null && piece.caseOps.length > 0) {
            let repl = [];
            let lenOps = piece.caseOps.length;
            let opIdx = 0;
            for (let idx = 0, len2 = match.length; idx < len2; idx++) {
              if (opIdx >= lenOps) {
                repl.push(match.slice(idx));
                break;
              }
              switch (piece.caseOps[opIdx]) {
                case "U":
                  repl.push(match[idx].toUpperCase());
                  break;
                case "u":
                  repl.push(match[idx].toUpperCase());
                  opIdx++;
                  break;
                case "L":
                  repl.push(match[idx].toLowerCase());
                  break;
                case "l":
                  repl.push(match[idx].toLowerCase());
                  opIdx++;
                  break;
                default:
                  repl.push(match[idx]);
              }
            }
            match = repl.join("");
          }
          result += match;
        }
        return result;
      }
      static _substitute(matchIndex, matches) {
        if (matches === null) {
          return "";
        }
        if (matchIndex === 0) {
          return matches[0];
        }
        let remainder = "";
        while (matchIndex > 0) {
          if (matchIndex < matches.length) {
            let match = matches[matchIndex] || "";
            return match + remainder;
          }
          remainder = String(matchIndex % 10) + remainder;
          matchIndex = Math.floor(matchIndex / 10);
        }
        return "$" + remainder;
      }
    };
    ReplacePiece = class _ReplacePiece {
      constructor(staticValue, matchIndex, caseOps) {
        this.staticValue = staticValue;
        this.matchIndex = matchIndex;
        if (!caseOps || caseOps.length === 0) {
          this.caseOps = null;
        } else {
          this.caseOps = caseOps.slice(0);
        }
      }
      static staticValue(value) {
        return new _ReplacePiece(value, -1, null);
      }
      static caseOps(index, caseOps) {
        return new _ReplacePiece(null, index, caseOps);
      }
    };
    ReplacePieceBuilder = class {
      constructor(source) {
        this._source = source;
        this._lastCharIndex = 0;
        this._result = [];
        this._resultLen = 0;
        this._currentStaticPiece = "";
      }
      emitUnchanged(toCharIndex) {
        this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
        this._lastCharIndex = toCharIndex;
      }
      emitStatic(value, toCharIndex) {
        this._emitStatic(value);
        this._lastCharIndex = toCharIndex;
      }
      _emitStatic(value) {
        if (value.length === 0) {
          return;
        }
        this._currentStaticPiece += value;
      }
      emitMatchIndex(index, toCharIndex, caseOps) {
        if (this._currentStaticPiece.length !== 0) {
          this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
          this._currentStaticPiece = "";
        }
        this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);
        this._lastCharIndex = toCharIndex;
      }
      finalize() {
        this.emitUnchanged(this._source.length);
        if (this._currentStaticPiece.length !== 0) {
          this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
          this._currentStaticPiece = "";
        }
        return new ReplacePattern(this._result);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findModel.js
var CONTEXT_FIND_WIDGET_VISIBLE, CONTEXT_FIND_INPUT_FOCUSED, CONTEXT_REPLACE_INPUT_FOCUSED, ToggleCaseSensitiveKeybinding, ToggleWholeWordKeybinding, ToggleRegexKeybinding, ToggleSearchScopeKeybinding, TogglePreserveCaseKeybinding, FIND_IDS, MATCHES_LIMIT, RESEARCH_DELAY, FindModelBoundToEditorModel;
var init_findModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/findModel.js"() {
    init_arrays();
    init_async();
    init_lifecycle();
    init_replaceCommand();
    init_position();
    init_range();
    init_selection();
    init_textModelSearch();
    init_findDecorations();
    init_replaceAllCommand();
    init_replacePattern();
    init_contextkey();
    CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
    CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
    CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
    ToggleCaseSensitiveKeybinding = {
      primary: 512 | 33,
      mac: {
        primary: 2048 | 512 | 33
        /* KEY_C */
      }
    };
    ToggleWholeWordKeybinding = {
      primary: 512 | 53,
      mac: {
        primary: 2048 | 512 | 53
        /* KEY_W */
      }
    };
    ToggleRegexKeybinding = {
      primary: 512 | 48,
      mac: {
        primary: 2048 | 512 | 48
        /* KEY_R */
      }
    };
    ToggleSearchScopeKeybinding = {
      primary: 512 | 42,
      mac: {
        primary: 2048 | 512 | 42
        /* KEY_L */
      }
    };
    TogglePreserveCaseKeybinding = {
      primary: 512 | 46,
      mac: {
        primary: 2048 | 512 | 46
        /* KEY_P */
      }
    };
    FIND_IDS = {
      StartFindAction: "actions.find",
      StartFindWithSelection: "actions.findWithSelection",
      NextMatchFindAction: "editor.action.nextMatchFindAction",
      PreviousMatchFindAction: "editor.action.previousMatchFindAction",
      NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
      PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
      StartFindReplaceAction: "editor.action.startFindReplaceAction",
      CloseFindWidgetCommand: "closeFindWidget",
      ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
      ToggleWholeWordCommand: "toggleFindWholeWord",
      ToggleRegexCommand: "toggleFindRegex",
      ToggleSearchScopeCommand: "toggleFindInSelection",
      TogglePreserveCaseCommand: "togglePreserveCase",
      ReplaceOneAction: "editor.action.replaceOne",
      ReplaceAllAction: "editor.action.replaceAll",
      SelectAllMatchesAction: "editor.action.selectAllMatches"
    };
    MATCHES_LIMIT = 19999;
    RESEARCH_DELAY = 240;
    FindModelBoundToEditorModel = class _FindModelBoundToEditorModel {
      constructor(editor2, state) {
        this._toDispose = new DisposableStore();
        this._editor = editor2;
        this._state = state;
        this._isDisposed = false;
        this._startSearchingTimer = new TimeoutTimer();
        this._decorations = new FindDecorations(editor2);
        this._toDispose.add(this._decorations);
        this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);
        this._toDispose.add(this._updateDecorationsScheduler);
        this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
          if (e.reason === 3 || e.reason === 5 || e.reason === 6) {
            this._decorations.setStartPosition(this._editor.getPosition());
          }
        }));
        this._ignoreModelContentChanged = false;
        this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
          if (this._ignoreModelContentChanged) {
            return;
          }
          if (e.isFlush) {
            this._decorations.reset();
          }
          this._decorations.setStartPosition(this._editor.getPosition());
          this._updateDecorationsScheduler.schedule();
        }));
        this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
        this.research(false, this._state.searchScope);
      }
      dispose() {
        this._isDisposed = true;
        dispose(this._startSearchingTimer);
        this._toDispose.dispose();
      }
      _onStateChanged(e) {
        if (this._isDisposed) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
          let model = this._editor.getModel();
          if (model.isTooLargeForSyncing()) {
            this._startSearchingTimer.cancel();
            this._startSearchingTimer.setIfNotSet(() => {
              if (e.searchScope) {
                this.research(e.moveCursor, this._state.searchScope);
              } else {
                this.research(e.moveCursor);
              }
            }, RESEARCH_DELAY);
          } else {
            if (e.searchScope) {
              this.research(e.moveCursor, this._state.searchScope);
            } else {
              this.research(e.moveCursor);
            }
          }
        }
      }
      static _getSearchRange(model, findScope) {
        if (findScope) {
          return findScope;
        }
        return model.getFullModelRange();
      }
      research(moveCursor, newFindScope) {
        let findScopes = null;
        if (typeof newFindScope !== "undefined") {
          if (newFindScope !== null) {
            if (!Array.isArray(newFindScope)) {
              findScopes = [newFindScope];
            } else {
              findScopes = newFindScope;
            }
          }
        } else {
          findScopes = this._decorations.getFindScopes();
        }
        if (findScopes !== null) {
          findScopes = findScopes.map((findScope) => {
            if (findScope.startLineNumber !== findScope.endLineNumber) {
              let endLineNumber = findScope.endLineNumber;
              if (findScope.endColumn === 1) {
                endLineNumber = endLineNumber - 1;
              }
              return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
            }
            return findScope;
          });
        }
        let findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
        this._decorations.set(findMatches, findScopes);
        const editorSelection = this._editor.getSelection();
        let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
        if (currentMatchesPosition === 0 && findMatches.length > 0) {
          const matchAfterSelection = findFirstInSorted(findMatches.map((match) => match.range), (range) => Range.compareRangesUsingStarts(range, editorSelection) >= 0);
          currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
        }
        this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
        if (moveCursor && this._editor.getOption(
          35
          /* find */
        ).cursorMoveOnType) {
          this._moveToNextMatch(this._decorations.getStartPosition());
        }
      }
      _hasMatches() {
        return this._state.matchesCount > 0;
      }
      _cannotFind() {
        if (!this._hasMatches()) {
          let findScope = this._decorations.getFindScope();
          if (findScope) {
            this._editor.revealRangeInCenterIfOutsideViewport(
              findScope,
              0
              /* Smooth */
            );
          }
          return true;
        }
        return false;
      }
      _setCurrentFindMatch(match) {
        let matchesPosition = this._decorations.setCurrentFindMatch(match);
        this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
        this._editor.setSelection(match);
        this._editor.revealRangeInCenterIfOutsideViewport(
          match,
          0
          /* Smooth */
        );
      }
      _prevSearchPosition(before) {
        let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
        let { lineNumber, column } = before;
        let model = this._editor.getModel();
        if (isUsingLineStops || column === 1) {
          if (lineNumber === 1) {
            lineNumber = model.getLineCount();
          } else {
            lineNumber--;
          }
          column = model.getLineMaxColumn(lineNumber);
        } else {
          column--;
        }
        return new Position(lineNumber, column);
      }
      _moveToPrevMatch(before, isRecursed = false) {
        if (!this._state.canNavigateBack()) {
          const nextMatchRange = this._decorations.matchAfterPosition(before);
          if (nextMatchRange) {
            this._setCurrentFindMatch(nextMatchRange);
          }
          return;
        }
        if (this._decorations.getCount() < MATCHES_LIMIT) {
          let prevMatchRange = this._decorations.matchBeforePosition(before);
          if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
            before = this._prevSearchPosition(before);
            prevMatchRange = this._decorations.matchBeforePosition(before);
          }
          if (prevMatchRange) {
            this._setCurrentFindMatch(prevMatchRange);
          }
          return;
        }
        if (this._cannotFind()) {
          return;
        }
        let findScope = this._decorations.getFindScope();
        let searchRange = _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
        if (searchRange.getEndPosition().isBefore(before)) {
          before = searchRange.getEndPosition();
        }
        if (before.isBefore(searchRange.getStartPosition())) {
          before = searchRange.getEndPosition();
        }
        let { lineNumber, column } = before;
        let model = this._editor.getModel();
        let position = new Position(lineNumber, column);
        let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
          115
          /* wordSeparators */
        ) : null, false);
        if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
          position = this._prevSearchPosition(position);
          prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
            115
            /* wordSeparators */
          ) : null, false);
        }
        if (!prevMatch) {
          return;
        }
        if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
          return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
        }
        this._setCurrentFindMatch(prevMatch.range);
      }
      moveToPrevMatch() {
        this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
      }
      _nextSearchPosition(after) {
        let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
        let { lineNumber, column } = after;
        let model = this._editor.getModel();
        if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
          if (lineNumber === model.getLineCount()) {
            lineNumber = 1;
          } else {
            lineNumber++;
          }
          column = 1;
        } else {
          column++;
        }
        return new Position(lineNumber, column);
      }
      _moveToNextMatch(after) {
        if (!this._state.canNavigateForward()) {
          const prevMatchRange = this._decorations.matchBeforePosition(after);
          if (prevMatchRange) {
            this._setCurrentFindMatch(prevMatchRange);
          }
          return;
        }
        if (this._decorations.getCount() < MATCHES_LIMIT) {
          let nextMatchRange = this._decorations.matchAfterPosition(after);
          if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
            after = this._nextSearchPosition(after);
            nextMatchRange = this._decorations.matchAfterPosition(after);
          }
          if (nextMatchRange) {
            this._setCurrentFindMatch(nextMatchRange);
          }
          return;
        }
        let nextMatch = this._getNextMatch(after, false, true);
        if (nextMatch) {
          this._setCurrentFindMatch(nextMatch.range);
        }
      }
      _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
        if (this._cannotFind()) {
          return null;
        }
        let findScope = this._decorations.getFindScope();
        let searchRange = _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
        if (searchRange.getEndPosition().isBefore(after)) {
          after = searchRange.getStartPosition();
        }
        if (after.isBefore(searchRange.getStartPosition())) {
          after = searchRange.getStartPosition();
        }
        let { lineNumber, column } = after;
        let model = this._editor.getModel();
        let position = new Position(lineNumber, column);
        let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
          115
          /* wordSeparators */
        ) : null, captureMatches);
        if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
          position = this._nextSearchPosition(position);
          nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
            115
            /* wordSeparators */
          ) : null, captureMatches);
        }
        if (!nextMatch) {
          return null;
        }
        if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
          return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
        }
        return nextMatch;
      }
      moveToNextMatch() {
        this._moveToNextMatch(this._editor.getSelection().getEndPosition());
      }
      _getReplacePattern() {
        if (this._state.isRegex) {
          return parseReplaceString(this._state.replaceString);
        }
        return ReplacePattern.fromStaticValue(this._state.replaceString);
      }
      replace() {
        if (!this._hasMatches()) {
          return;
        }
        let replacePattern = this._getReplacePattern();
        let selection = this._editor.getSelection();
        let nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
        if (nextMatch) {
          if (selection.equalsRange(nextMatch.range)) {
            let replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
            let command = new ReplaceCommand(selection, replaceString);
            this._executeEditorCommand("replace", command);
            this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));
            this.research(true);
          } else {
            this._decorations.setStartPosition(this._editor.getPosition());
            this._setCurrentFindMatch(nextMatch.range);
          }
        }
      }
      _findMatches(findScopes, captureMatches, limitResultCount) {
        const searchRanges = (findScopes || [null]).map((scope) => _FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
        return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
          115
          /* wordSeparators */
        ) : null, captureMatches, limitResultCount);
      }
      replaceAll() {
        if (!this._hasMatches()) {
          return;
        }
        const findScopes = this._decorations.getFindScopes();
        if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {
          this._largeReplaceAll();
        } else {
          this._regularReplaceAll(findScopes);
        }
        this.research(false);
      }
      _largeReplaceAll() {
        const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
          115
          /* wordSeparators */
        ) : null);
        const searchData = searchParams.parseSearchRequest();
        if (!searchData) {
          return;
        }
        let searchRegex = searchData.regex;
        if (!searchRegex.multiline) {
          let mod = "mu";
          if (searchRegex.ignoreCase) {
            mod += "i";
          }
          if (searchRegex.global) {
            mod += "g";
          }
          searchRegex = new RegExp(searchRegex.source, mod);
        }
        const model = this._editor.getModel();
        const modelText = model.getValue(
          1
          /* LF */
        );
        const fullModelRange = model.getFullModelRange();
        const replacePattern = this._getReplacePattern();
        let resultText;
        const preserveCase = this._state.preserveCase;
        if (replacePattern.hasReplacementPatterns || preserveCase) {
          resultText = modelText.replace(searchRegex, function() {
            return replacePattern.buildReplaceString(arguments, preserveCase);
          });
        } else {
          resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
        }
        let command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
        this._executeEditorCommand("replaceAll", command);
      }
      _regularReplaceAll(findScopes) {
        const replacePattern = this._getReplacePattern();
        let matches = this._findMatches(
          findScopes,
          replacePattern.hasReplacementPatterns || this._state.preserveCase,
          1073741824
          /* MAX_SAFE_SMALL_INTEGER */
        );
        let replaceStrings = [];
        for (let i = 0, len = matches.length; i < len; i++) {
          replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);
        }
        let command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
        this._executeEditorCommand("replaceAll", command);
      }
      selectAllMatches() {
        if (!this._hasMatches()) {
          return;
        }
        let findScopes = this._decorations.getFindScopes();
        let matches = this._findMatches(
          findScopes,
          false,
          1073741824
          /* MAX_SAFE_SMALL_INTEGER */
        );
        let selections = matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
        let editorSelection = this._editor.getSelection();
        for (let i = 0, len = selections.length; i < len; i++) {
          let sel = selections[i];
          if (sel.equalsRange(editorSelection)) {
            selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
            break;
          }
        }
        this._editor.setSelections(selections);
      }
      _executeEditorCommand(source, command) {
        try {
          this._ignoreModelContentChanged = true;
          this._editor.pushUndoStop();
          this._editor.executeCommand(source, command);
          this._editor.pushUndoStop();
        } finally {
          this._ignoreModelContentChanged = false;
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/checkbox/checkbox.js
var defaultOpts, Checkbox;
var init_checkbox = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/checkbox/checkbox.js"() {
    init_widget();
    init_codicons();
    init_color();
    init_event();
    defaultOpts = {
      inputActiveOptionBorder: Color.fromHex("#007ACC00"),
      inputActiveOptionForeground: Color.fromHex("#FFFFFF"),
      inputActiveOptionBackground: Color.fromHex("#0E639C50")
    };
    Checkbox = class extends Widget {
      constructor(opts) {
        super();
        this._onChange = this._register(new Emitter());
        this.onChange = this._onChange.event;
        this._onKeyDown = this._register(new Emitter());
        this.onKeyDown = this._onKeyDown.event;
        this._opts = Object.assign(Object.assign({}, defaultOpts), opts);
        this._checked = this._opts.isChecked;
        const classes = ["monaco-custom-checkbox"];
        if (this._opts.icon) {
          classes.push(...CSSIcon.asClassNameArray(this._opts.icon));
        }
        if (this._opts.actionClassName) {
          classes.push(...this._opts.actionClassName.split(" "));
        }
        if (this._checked) {
          classes.push("checked");
        }
        this.domNode = document.createElement("div");
        this.domNode.title = this._opts.title;
        this.domNode.classList.add(...classes);
        if (!this._opts.notFocusable) {
          this.domNode.tabIndex = 0;
        }
        this.domNode.setAttribute("role", "checkbox");
        this.domNode.setAttribute("aria-checked", String(this._checked));
        this.domNode.setAttribute("aria-label", this._opts.title);
        this.applyStyles();
        this.onclick(this.domNode, (ev) => {
          this.checked = !this._checked;
          this._onChange.fire(false);
          ev.preventDefault();
        });
        this.ignoreGesture(this.domNode);
        this.onkeydown(this.domNode, (keyboardEvent) => {
          if (keyboardEvent.keyCode === 10 || keyboardEvent.keyCode === 3) {
            this.checked = !this._checked;
            this._onChange.fire(true);
            keyboardEvent.preventDefault();
            return;
          }
          this._onKeyDown.fire(keyboardEvent);
        });
      }
      get enabled() {
        return this.domNode.getAttribute("aria-disabled") !== "true";
      }
      focus() {
        this.domNode.focus();
      }
      get checked() {
        return this._checked;
      }
      set checked(newIsChecked) {
        this._checked = newIsChecked;
        this.domNode.setAttribute("aria-checked", String(this._checked));
        this.domNode.classList.toggle("checked", this._checked);
        this.applyStyles();
      }
      width() {
        return 2 + 2 + 2 + 16;
      }
      style(styles) {
        if (styles.inputActiveOptionBorder) {
          this._opts.inputActiveOptionBorder = styles.inputActiveOptionBorder;
        }
        if (styles.inputActiveOptionForeground) {
          this._opts.inputActiveOptionForeground = styles.inputActiveOptionForeground;
        }
        if (styles.inputActiveOptionBackground) {
          this._opts.inputActiveOptionBackground = styles.inputActiveOptionBackground;
        }
        this.applyStyles();
      }
      applyStyles() {
        if (this.domNode) {
          this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : "transparent";
          this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground ? this._opts.inputActiveOptionForeground.toString() : "inherit";
          this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground ? this._opts.inputActiveOptionBackground.toString() : "transparent";
        }
      }
      enable() {
        this.domNode.setAttribute("aria-disabled", String(false));
      }
      disable() {
        this.domNode.setAttribute("aria-disabled", String(true));
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInputCheckboxes.js
var NLS_CASE_SENSITIVE_CHECKBOX_LABEL, NLS_WHOLE_WORD_CHECKBOX_LABEL, NLS_REGEX_CHECKBOX_LABEL, CaseSensitiveCheckbox, WholeWordsCheckbox, RegexCheckbox;
var init_findInputCheckboxes = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInputCheckboxes.js"() {
    init_checkbox();
    init_codicons();
    init_nls();
    NLS_CASE_SENSITIVE_CHECKBOX_LABEL = localize("caseDescription", "Match Case");
    NLS_WHOLE_WORD_CHECKBOX_LABEL = localize("wordsDescription", "Match Whole Word");
    NLS_REGEX_CHECKBOX_LABEL = localize("regexDescription", "Use Regular Expression");
    CaseSensitiveCheckbox = class extends Checkbox {
      constructor(opts) {
        super({
          icon: Codicon.caseSensitive,
          title: NLS_CASE_SENSITIVE_CHECKBOX_LABEL + opts.appendTitle,
          isChecked: opts.isChecked,
          inputActiveOptionBorder: opts.inputActiveOptionBorder,
          inputActiveOptionForeground: opts.inputActiveOptionForeground,
          inputActiveOptionBackground: opts.inputActiveOptionBackground
        });
      }
    };
    WholeWordsCheckbox = class extends Checkbox {
      constructor(opts) {
        super({
          icon: Codicon.wholeWord,
          title: NLS_WHOLE_WORD_CHECKBOX_LABEL + opts.appendTitle,
          isChecked: opts.isChecked,
          inputActiveOptionBorder: opts.inputActiveOptionBorder,
          inputActiveOptionForeground: opts.inputActiveOptionForeground,
          inputActiveOptionBackground: opts.inputActiveOptionBackground
        });
      }
    };
    RegexCheckbox = class extends Checkbox {
      constructor(opts) {
        super({
          icon: Codicon.regex,
          title: NLS_REGEX_CHECKBOX_LABEL + opts.appendTitle,
          isChecked: opts.isChecked,
          inputActiveOptionBorder: opts.inputActiveOptionBorder,
          inputActiveOptionForeground: opts.inputActiveOptionForeground,
          inputActiveOptionBackground: opts.inputActiveOptionBackground
        });
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findOptionsWidget.js
var FindOptionsWidget;
var init_findOptionsWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/findOptionsWidget.js"() {
    init_dom();
    init_findInputCheckboxes();
    init_widget();
    init_async();
    init_findModel();
    init_colorRegistry();
    init_themeService();
    FindOptionsWidget = class _FindOptionsWidget extends Widget {
      constructor(editor2, state, keybindingService, themeService) {
        super();
        this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
        this._isVisible = false;
        this._editor = editor2;
        this._state = state;
        this._keybindingService = keybindingService;
        this._domNode = document.createElement("div");
        this._domNode.className = "findOptionsWidget";
        this._domNode.style.display = "none";
        this._domNode.style.top = "10px";
        this._domNode.setAttribute("role", "presentation");
        this._domNode.setAttribute("aria-hidden", "true");
        const inputActiveOptionBorderColor = themeService.getColorTheme().getColor(inputActiveOptionBorder);
        const inputActiveOptionForegroundColor = themeService.getColorTheme().getColor(inputActiveOptionForeground);
        const inputActiveOptionBackgroundColor = themeService.getColorTheme().getColor(inputActiveOptionBackground);
        this.caseSensitive = this._register(new CaseSensitiveCheckbox({
          appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
          isChecked: this._state.matchCase,
          inputActiveOptionBorder: inputActiveOptionBorderColor,
          inputActiveOptionForeground: inputActiveOptionForegroundColor,
          inputActiveOptionBackground: inputActiveOptionBackgroundColor
        }));
        this._domNode.appendChild(this.caseSensitive.domNode);
        this._register(this.caseSensitive.onChange(() => {
          this._state.change({
            matchCase: this.caseSensitive.checked
          }, false);
        }));
        this.wholeWords = this._register(new WholeWordsCheckbox({
          appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
          isChecked: this._state.wholeWord,
          inputActiveOptionBorder: inputActiveOptionBorderColor,
          inputActiveOptionForeground: inputActiveOptionForegroundColor,
          inputActiveOptionBackground: inputActiveOptionBackgroundColor
        }));
        this._domNode.appendChild(this.wholeWords.domNode);
        this._register(this.wholeWords.onChange(() => {
          this._state.change({
            wholeWord: this.wholeWords.checked
          }, false);
        }));
        this.regex = this._register(new RegexCheckbox({
          appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
          isChecked: this._state.isRegex,
          inputActiveOptionBorder: inputActiveOptionBorderColor,
          inputActiveOptionForeground: inputActiveOptionForegroundColor,
          inputActiveOptionBackground: inputActiveOptionBackgroundColor
        }));
        this._domNode.appendChild(this.regex.domNode);
        this._register(this.regex.onChange(() => {
          this._state.change({
            isRegex: this.regex.checked
          }, false);
        }));
        this._editor.addOverlayWidget(this);
        this._register(this._state.onFindReplaceStateChange((e) => {
          let somethingChanged = false;
          if (e.isRegex) {
            this.regex.checked = this._state.isRegex;
            somethingChanged = true;
          }
          if (e.wholeWord) {
            this.wholeWords.checked = this._state.wholeWord;
            somethingChanged = true;
          }
          if (e.matchCase) {
            this.caseSensitive.checked = this._state.matchCase;
            somethingChanged = true;
          }
          if (!this._state.isRevealed && somethingChanged) {
            this._revealTemporarily();
          }
        }));
        this._register(addDisposableNonBubblingMouseOutListener(this._domNode, (e) => this._onMouseOut()));
        this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
        this._applyTheme(themeService.getColorTheme());
        this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
      }
      _keybindingLabelFor(actionId) {
        let kb = this._keybindingService.lookupKeybinding(actionId);
        if (!kb) {
          return "";
        }
        return ` (${kb.getLabel()})`;
      }
      dispose() {
        this._editor.removeOverlayWidget(this);
        super.dispose();
      }
      // ----- IOverlayWidget API
      getId() {
        return _FindOptionsWidget.ID;
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        return {
          preference: 0
          /* TOP_RIGHT_CORNER */
        };
      }
      highlightFindOptions() {
        this._revealTemporarily();
      }
      _revealTemporarily() {
        this._show();
        this._hideSoon.schedule();
      }
      _onMouseOut() {
        this._hideSoon.schedule();
      }
      _onMouseOver() {
        this._hideSoon.cancel();
      }
      _show() {
        if (this._isVisible) {
          return;
        }
        this._isVisible = true;
        this._domNode.style.display = "block";
      }
      _hide() {
        if (!this._isVisible) {
          return;
        }
        this._isVisible = false;
        this._domNode.style.display = "none";
      }
      _applyTheme(theme) {
        let inputStyles = {
          inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),
          inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),
          inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground)
        };
        this.caseSensitive.style(inputStyles);
        this.wholeWords.style(inputStyles);
        this.regex.style(inputStyles);
      }
    };
    FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";
    registerThemingParticipant((theme, collector) => {
      const widgetBackground = theme.getColor(editorWidgetBackground);
      if (widgetBackground) {
        collector.addRule(`.monaco-editor .findOptionsWidget { background-color: ${widgetBackground}; }`);
      }
      const widgetForeground = theme.getColor(editorWidgetForeground);
      if (widgetForeground) {
        collector.addRule(`.monaco-editor .findOptionsWidget { color: ${widgetForeground}; }`);
      }
      const widgetShadowColor = theme.getColor(widgetShadow);
      if (widgetShadowColor) {
        collector.addRule(`.monaco-editor .findOptionsWidget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
      }
      const hcBorder = theme.getColor(contrastBorder);
      if (hcBorder) {
        collector.addRule(`.monaco-editor .findOptionsWidget { border: 2px solid ${hcBorder}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findState.js
function effectiveOptionValue(override, value) {
  if (override === 1) {
    return true;
  }
  if (override === 2) {
    return false;
  }
  return value;
}
var FindReplaceState;
var init_findState = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/findState.js"() {
    init_event();
    init_lifecycle();
    init_range();
    init_findModel();
    FindReplaceState = class extends Disposable {
      constructor() {
        super();
        this._onFindReplaceStateChange = this._register(new Emitter());
        this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
        this._searchString = "";
        this._replaceString = "";
        this._isRevealed = false;
        this._isReplaceRevealed = false;
        this._isRegex = false;
        this._isRegexOverride = 0;
        this._wholeWord = false;
        this._wholeWordOverride = 0;
        this._matchCase = false;
        this._matchCaseOverride = 0;
        this._preserveCase = false;
        this._preserveCaseOverride = 0;
        this._searchScope = null;
        this._matchesPosition = 0;
        this._matchesCount = 0;
        this._currentMatch = null;
        this._loop = true;
      }
      get searchString() {
        return this._searchString;
      }
      get replaceString() {
        return this._replaceString;
      }
      get isRevealed() {
        return this._isRevealed;
      }
      get isReplaceRevealed() {
        return this._isReplaceRevealed;
      }
      get isRegex() {
        return effectiveOptionValue(this._isRegexOverride, this._isRegex);
      }
      get wholeWord() {
        return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
      }
      get matchCase() {
        return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
      }
      get preserveCase() {
        return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
      }
      get actualIsRegex() {
        return this._isRegex;
      }
      get actualWholeWord() {
        return this._wholeWord;
      }
      get actualMatchCase() {
        return this._matchCase;
      }
      get actualPreserveCase() {
        return this._preserveCase;
      }
      get searchScope() {
        return this._searchScope;
      }
      get matchesPosition() {
        return this._matchesPosition;
      }
      get matchesCount() {
        return this._matchesCount;
      }
      get currentMatch() {
        return this._currentMatch;
      }
      changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
        let changeEvent = {
          moveCursor: false,
          updateHistory: false,
          searchString: false,
          replaceString: false,
          isRevealed: false,
          isReplaceRevealed: false,
          isRegex: false,
          wholeWord: false,
          matchCase: false,
          preserveCase: false,
          searchScope: false,
          matchesPosition: false,
          matchesCount: false,
          currentMatch: false,
          loop: false
        };
        let somethingChanged = false;
        if (matchesCount === 0) {
          matchesPosition = 0;
        }
        if (matchesPosition > matchesCount) {
          matchesPosition = matchesCount;
        }
        if (this._matchesPosition !== matchesPosition) {
          this._matchesPosition = matchesPosition;
          changeEvent.matchesPosition = true;
          somethingChanged = true;
        }
        if (this._matchesCount !== matchesCount) {
          this._matchesCount = matchesCount;
          changeEvent.matchesCount = true;
          somethingChanged = true;
        }
        if (typeof currentMatch !== "undefined") {
          if (!Range.equalsRange(this._currentMatch, currentMatch)) {
            this._currentMatch = currentMatch;
            changeEvent.currentMatch = true;
            somethingChanged = true;
          }
        }
        if (somethingChanged) {
          this._onFindReplaceStateChange.fire(changeEvent);
        }
      }
      change(newState, moveCursor, updateHistory = true) {
        var _a5;
        let changeEvent = {
          moveCursor,
          updateHistory,
          searchString: false,
          replaceString: false,
          isRevealed: false,
          isReplaceRevealed: false,
          isRegex: false,
          wholeWord: false,
          matchCase: false,
          preserveCase: false,
          searchScope: false,
          matchesPosition: false,
          matchesCount: false,
          currentMatch: false,
          loop: false
        };
        let somethingChanged = false;
        const oldEffectiveIsRegex = this.isRegex;
        const oldEffectiveWholeWords = this.wholeWord;
        const oldEffectiveMatchCase = this.matchCase;
        const oldEffectivePreserveCase = this.preserveCase;
        if (typeof newState.searchString !== "undefined") {
          if (this._searchString !== newState.searchString) {
            this._searchString = newState.searchString;
            changeEvent.searchString = true;
            somethingChanged = true;
          }
        }
        if (typeof newState.replaceString !== "undefined") {
          if (this._replaceString !== newState.replaceString) {
            this._replaceString = newState.replaceString;
            changeEvent.replaceString = true;
            somethingChanged = true;
          }
        }
        if (typeof newState.isRevealed !== "undefined") {
          if (this._isRevealed !== newState.isRevealed) {
            this._isRevealed = newState.isRevealed;
            changeEvent.isRevealed = true;
            somethingChanged = true;
          }
        }
        if (typeof newState.isReplaceRevealed !== "undefined") {
          if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
            this._isReplaceRevealed = newState.isReplaceRevealed;
            changeEvent.isReplaceRevealed = true;
            somethingChanged = true;
          }
        }
        if (typeof newState.isRegex !== "undefined") {
          this._isRegex = newState.isRegex;
        }
        if (typeof newState.wholeWord !== "undefined") {
          this._wholeWord = newState.wholeWord;
        }
        if (typeof newState.matchCase !== "undefined") {
          this._matchCase = newState.matchCase;
        }
        if (typeof newState.preserveCase !== "undefined") {
          this._preserveCase = newState.preserveCase;
        }
        if (typeof newState.searchScope !== "undefined") {
          if (!((_a5 = newState.searchScope) === null || _a5 === void 0 ? void 0 : _a5.every((newSearchScope) => {
            var _a6;
            return (_a6 = this._searchScope) === null || _a6 === void 0 ? void 0 : _a6.some((existingSearchScope) => {
              return !Range.equalsRange(existingSearchScope, newSearchScope);
            });
          }))) {
            this._searchScope = newState.searchScope;
            changeEvent.searchScope = true;
            somethingChanged = true;
          }
        }
        if (typeof newState.loop !== "undefined") {
          if (this._loop !== newState.loop) {
            this._loop = newState.loop;
            changeEvent.loop = true;
            somethingChanged = true;
          }
        }
        this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
        this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
        this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
        this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
        if (oldEffectiveIsRegex !== this.isRegex) {
          somethingChanged = true;
          changeEvent.isRegex = true;
        }
        if (oldEffectiveWholeWords !== this.wholeWord) {
          somethingChanged = true;
          changeEvent.wholeWord = true;
        }
        if (oldEffectiveMatchCase !== this.matchCase) {
          somethingChanged = true;
          changeEvent.matchCase = true;
        }
        if (oldEffectivePreserveCase !== this.preserveCase) {
          somethingChanged = true;
          changeEvent.preserveCase = true;
        }
        if (somethingChanged) {
          this._onFindReplaceStateChange.fire(changeEvent);
        }
      }
      canNavigateBack() {
        return this.canNavigateInLoop() || this.matchesPosition !== 1;
      }
      canNavigateForward() {
        return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
      }
      canNavigateInLoop() {
        return this._loop || this.matchesCount >= MATCHES_LIMIT;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.js
var NLS_DEFAULT_LABEL, FindInput;
var init_findInput = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.js"() {
    init_dom();
    init_findInputCheckboxes();
    init_inputBox();
    init_widget();
    init_event();
    init_nls();
    NLS_DEFAULT_LABEL = localize("defaultLabel", "input");
    FindInput = class extends Widget {
      constructor(parent, contextViewProvider, _showOptionButtons, options) {
        super();
        this._showOptionButtons = _showOptionButtons;
        this.fixFocusOnOptionClickEnabled = true;
        this.imeSessionInProgress = false;
        this._onDidOptionChange = this._register(new Emitter());
        this.onDidOptionChange = this._onDidOptionChange.event;
        this._onKeyDown = this._register(new Emitter());
        this.onKeyDown = this._onKeyDown.event;
        this._onMouseDown = this._register(new Emitter());
        this.onMouseDown = this._onMouseDown.event;
        this._onInput = this._register(new Emitter());
        this._onKeyUp = this._register(new Emitter());
        this._onCaseSensitiveKeyDown = this._register(new Emitter());
        this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
        this._onRegexKeyDown = this._register(new Emitter());
        this.onRegexKeyDown = this._onRegexKeyDown.event;
        this._lastHighlightFindOptions = 0;
        this.contextViewProvider = contextViewProvider;
        this.placeholder = options.placeholder || "";
        this.validation = options.validation;
        this.label = options.label || NLS_DEFAULT_LABEL;
        this.inputActiveOptionBorder = options.inputActiveOptionBorder;
        this.inputActiveOptionForeground = options.inputActiveOptionForeground;
        this.inputActiveOptionBackground = options.inputActiveOptionBackground;
        this.inputBackground = options.inputBackground;
        this.inputForeground = options.inputForeground;
        this.inputBorder = options.inputBorder;
        this.inputValidationInfoBorder = options.inputValidationInfoBorder;
        this.inputValidationInfoBackground = options.inputValidationInfoBackground;
        this.inputValidationInfoForeground = options.inputValidationInfoForeground;
        this.inputValidationWarningBorder = options.inputValidationWarningBorder;
        this.inputValidationWarningBackground = options.inputValidationWarningBackground;
        this.inputValidationWarningForeground = options.inputValidationWarningForeground;
        this.inputValidationErrorBorder = options.inputValidationErrorBorder;
        this.inputValidationErrorBackground = options.inputValidationErrorBackground;
        this.inputValidationErrorForeground = options.inputValidationErrorForeground;
        const appendCaseSensitiveLabel = options.appendCaseSensitiveLabel || "";
        const appendWholeWordsLabel = options.appendWholeWordsLabel || "";
        const appendRegexLabel = options.appendRegexLabel || "";
        const history = options.history || [];
        const flexibleHeight = !!options.flexibleHeight;
        const flexibleWidth = !!options.flexibleWidth;
        const flexibleMaxHeight = options.flexibleMaxHeight;
        this.domNode = document.createElement("div");
        this.domNode.classList.add("monaco-findInput");
        this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
          placeholder: this.placeholder || "",
          ariaLabel: this.label || "",
          validationOptions: {
            validation: this.validation
          },
          inputBackground: this.inputBackground,
          inputForeground: this.inputForeground,
          inputBorder: this.inputBorder,
          inputValidationInfoBackground: this.inputValidationInfoBackground,
          inputValidationInfoForeground: this.inputValidationInfoForeground,
          inputValidationInfoBorder: this.inputValidationInfoBorder,
          inputValidationWarningBackground: this.inputValidationWarningBackground,
          inputValidationWarningForeground: this.inputValidationWarningForeground,
          inputValidationWarningBorder: this.inputValidationWarningBorder,
          inputValidationErrorBackground: this.inputValidationErrorBackground,
          inputValidationErrorForeground: this.inputValidationErrorForeground,
          inputValidationErrorBorder: this.inputValidationErrorBorder,
          history,
          showHistoryHint: options.showHistoryHint,
          flexibleHeight,
          flexibleWidth,
          flexibleMaxHeight
        }));
        this.regex = this._register(new RegexCheckbox({
          appendTitle: appendRegexLabel,
          isChecked: false,
          inputActiveOptionBorder: this.inputActiveOptionBorder,
          inputActiveOptionForeground: this.inputActiveOptionForeground,
          inputActiveOptionBackground: this.inputActiveOptionBackground
        }));
        this._register(this.regex.onChange((viaKeyboard) => {
          this._onDidOptionChange.fire(viaKeyboard);
          if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
            this.inputBox.focus();
          }
          this.validate();
        }));
        this._register(this.regex.onKeyDown((e) => {
          this._onRegexKeyDown.fire(e);
        }));
        this.wholeWords = this._register(new WholeWordsCheckbox({
          appendTitle: appendWholeWordsLabel,
          isChecked: false,
          inputActiveOptionBorder: this.inputActiveOptionBorder,
          inputActiveOptionForeground: this.inputActiveOptionForeground,
          inputActiveOptionBackground: this.inputActiveOptionBackground
        }));
        this._register(this.wholeWords.onChange((viaKeyboard) => {
          this._onDidOptionChange.fire(viaKeyboard);
          if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
            this.inputBox.focus();
          }
          this.validate();
        }));
        this.caseSensitive = this._register(new CaseSensitiveCheckbox({
          appendTitle: appendCaseSensitiveLabel,
          isChecked: false,
          inputActiveOptionBorder: this.inputActiveOptionBorder,
          inputActiveOptionForeground: this.inputActiveOptionForeground,
          inputActiveOptionBackground: this.inputActiveOptionBackground
        }));
        this._register(this.caseSensitive.onChange((viaKeyboard) => {
          this._onDidOptionChange.fire(viaKeyboard);
          if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
            this.inputBox.focus();
          }
          this.validate();
        }));
        this._register(this.caseSensitive.onKeyDown((e) => {
          this._onCaseSensitiveKeyDown.fire(e);
        }));
        if (this._showOptionButtons) {
          this.inputBox.paddingRight = this.caseSensitive.width() + this.wholeWords.width() + this.regex.width();
        }
        let indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
        this.onkeydown(this.domNode, (event) => {
          if (event.equals(
            15
            /* LeftArrow */
          ) || event.equals(
            17
            /* RightArrow */
          ) || event.equals(
            9
            /* Escape */
          )) {
            let index = indexes.indexOf(document.activeElement);
            if (index >= 0) {
              let newIndex = -1;
              if (event.equals(
                17
                /* RightArrow */
              )) {
                newIndex = (index + 1) % indexes.length;
              } else if (event.equals(
                15
                /* LeftArrow */
              )) {
                if (index === 0) {
                  newIndex = indexes.length - 1;
                } else {
                  newIndex = index - 1;
                }
              }
              if (event.equals(
                9
                /* Escape */
              )) {
                indexes[index].blur();
                this.inputBox.focus();
              } else if (newIndex >= 0) {
                indexes[newIndex].focus();
              }
              EventHelper.stop(event, true);
            }
          }
        });
        let controls = document.createElement("div");
        controls.className = "controls";
        controls.style.display = this._showOptionButtons ? "block" : "none";
        controls.appendChild(this.caseSensitive.domNode);
        controls.appendChild(this.wholeWords.domNode);
        controls.appendChild(this.regex.domNode);
        this.domNode.appendChild(controls);
        if (parent) {
          parent.appendChild(this.domNode);
        }
        this._register(addDisposableListener(this.inputBox.inputElement, "compositionstart", (e) => {
          this.imeSessionInProgress = true;
        }));
        this._register(addDisposableListener(this.inputBox.inputElement, "compositionend", (e) => {
          this.imeSessionInProgress = false;
          this._onInput.fire();
        }));
        this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
        this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
        this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
        this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
      }
      enable() {
        this.domNode.classList.remove("disabled");
        this.inputBox.enable();
        this.regex.enable();
        this.wholeWords.enable();
        this.caseSensitive.enable();
      }
      disable() {
        this.domNode.classList.add("disabled");
        this.inputBox.disable();
        this.regex.disable();
        this.wholeWords.disable();
        this.caseSensitive.disable();
      }
      setFocusInputOnOptionClick(value) {
        this.fixFocusOnOptionClickEnabled = value;
      }
      setEnabled(enabled) {
        if (enabled) {
          this.enable();
        } else {
          this.disable();
        }
      }
      getValue() {
        return this.inputBox.value;
      }
      setValue(value) {
        if (this.inputBox.value !== value) {
          this.inputBox.value = value;
        }
      }
      style(styles) {
        this.inputActiveOptionBorder = styles.inputActiveOptionBorder;
        this.inputActiveOptionForeground = styles.inputActiveOptionForeground;
        this.inputActiveOptionBackground = styles.inputActiveOptionBackground;
        this.inputBackground = styles.inputBackground;
        this.inputForeground = styles.inputForeground;
        this.inputBorder = styles.inputBorder;
        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
        this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
        this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
        this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
        this.applyStyles();
      }
      applyStyles() {
        if (this.domNode) {
          const checkBoxStyles = {
            inputActiveOptionBorder: this.inputActiveOptionBorder,
            inputActiveOptionForeground: this.inputActiveOptionForeground,
            inputActiveOptionBackground: this.inputActiveOptionBackground
          };
          this.regex.style(checkBoxStyles);
          this.wholeWords.style(checkBoxStyles);
          this.caseSensitive.style(checkBoxStyles);
          const inputBoxStyles = {
            inputBackground: this.inputBackground,
            inputForeground: this.inputForeground,
            inputBorder: this.inputBorder,
            inputValidationInfoBackground: this.inputValidationInfoBackground,
            inputValidationInfoForeground: this.inputValidationInfoForeground,
            inputValidationInfoBorder: this.inputValidationInfoBorder,
            inputValidationWarningBackground: this.inputValidationWarningBackground,
            inputValidationWarningForeground: this.inputValidationWarningForeground,
            inputValidationWarningBorder: this.inputValidationWarningBorder,
            inputValidationErrorBackground: this.inputValidationErrorBackground,
            inputValidationErrorForeground: this.inputValidationErrorForeground,
            inputValidationErrorBorder: this.inputValidationErrorBorder
          };
          this.inputBox.style(inputBoxStyles);
        }
      }
      select() {
        this.inputBox.select();
      }
      focus() {
        this.inputBox.focus();
      }
      getCaseSensitive() {
        return this.caseSensitive.checked;
      }
      setCaseSensitive(value) {
        this.caseSensitive.checked = value;
      }
      getWholeWords() {
        return this.wholeWords.checked;
      }
      setWholeWords(value) {
        this.wholeWords.checked = value;
      }
      getRegex() {
        return this.regex.checked;
      }
      setRegex(value) {
        this.regex.checked = value;
        this.validate();
      }
      focusOnCaseSensitive() {
        this.caseSensitive.focus();
      }
      highlightFindOptions() {
        this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions);
        this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
        this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
      }
      validate() {
        this.inputBox.validate();
      }
      clearMessage() {
        this.inputBox.hideMessage();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/replaceInput.js
var NLS_DEFAULT_LABEL2, NLS_PRESERVE_CASE_LABEL, PreserveCaseCheckbox, ReplaceInput;
var init_replaceInput = __esm({
  "node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/replaceInput.js"() {
    init_dom();
    init_checkbox();
    init_inputBox();
    init_widget();
    init_codicons();
    init_event();
    init_nls();
    NLS_DEFAULT_LABEL2 = localize("defaultLabel", "input");
    NLS_PRESERVE_CASE_LABEL = localize("label.preserveCaseCheckbox", "Preserve Case");
    PreserveCaseCheckbox = class extends Checkbox {
      constructor(opts) {
        super({
          // TODO: does this need its own icon?
          icon: Codicon.preserveCase,
          title: NLS_PRESERVE_CASE_LABEL + opts.appendTitle,
          isChecked: opts.isChecked,
          inputActiveOptionBorder: opts.inputActiveOptionBorder,
          inputActiveOptionForeground: opts.inputActiveOptionForeground,
          inputActiveOptionBackground: opts.inputActiveOptionBackground
        });
      }
    };
    ReplaceInput = class extends Widget {
      constructor(parent, contextViewProvider, _showOptionButtons, options) {
        super();
        this._showOptionButtons = _showOptionButtons;
        this.fixFocusOnOptionClickEnabled = true;
        this.cachedOptionsWidth = 0;
        this._onDidOptionChange = this._register(new Emitter());
        this.onDidOptionChange = this._onDidOptionChange.event;
        this._onKeyDown = this._register(new Emitter());
        this.onKeyDown = this._onKeyDown.event;
        this._onMouseDown = this._register(new Emitter());
        this._onInput = this._register(new Emitter());
        this._onKeyUp = this._register(new Emitter());
        this._onPreserveCaseKeyDown = this._register(new Emitter());
        this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;
        this.contextViewProvider = contextViewProvider;
        this.placeholder = options.placeholder || "";
        this.validation = options.validation;
        this.label = options.label || NLS_DEFAULT_LABEL2;
        this.inputActiveOptionBorder = options.inputActiveOptionBorder;
        this.inputActiveOptionForeground = options.inputActiveOptionForeground;
        this.inputActiveOptionBackground = options.inputActiveOptionBackground;
        this.inputBackground = options.inputBackground;
        this.inputForeground = options.inputForeground;
        this.inputBorder = options.inputBorder;
        this.inputValidationInfoBorder = options.inputValidationInfoBorder;
        this.inputValidationInfoBackground = options.inputValidationInfoBackground;
        this.inputValidationInfoForeground = options.inputValidationInfoForeground;
        this.inputValidationWarningBorder = options.inputValidationWarningBorder;
        this.inputValidationWarningBackground = options.inputValidationWarningBackground;
        this.inputValidationWarningForeground = options.inputValidationWarningForeground;
        this.inputValidationErrorBorder = options.inputValidationErrorBorder;
        this.inputValidationErrorBackground = options.inputValidationErrorBackground;
        this.inputValidationErrorForeground = options.inputValidationErrorForeground;
        const appendPreserveCaseLabel = options.appendPreserveCaseLabel || "";
        const history = options.history || [];
        const flexibleHeight = !!options.flexibleHeight;
        const flexibleWidth = !!options.flexibleWidth;
        const flexibleMaxHeight = options.flexibleMaxHeight;
        this.domNode = document.createElement("div");
        this.domNode.classList.add("monaco-findInput");
        this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
          ariaLabel: this.label || "",
          placeholder: this.placeholder || "",
          validationOptions: {
            validation: this.validation
          },
          inputBackground: this.inputBackground,
          inputForeground: this.inputForeground,
          inputBorder: this.inputBorder,
          inputValidationInfoBackground: this.inputValidationInfoBackground,
          inputValidationInfoForeground: this.inputValidationInfoForeground,
          inputValidationInfoBorder: this.inputValidationInfoBorder,
          inputValidationWarningBackground: this.inputValidationWarningBackground,
          inputValidationWarningForeground: this.inputValidationWarningForeground,
          inputValidationWarningBorder: this.inputValidationWarningBorder,
          inputValidationErrorBackground: this.inputValidationErrorBackground,
          inputValidationErrorForeground: this.inputValidationErrorForeground,
          inputValidationErrorBorder: this.inputValidationErrorBorder,
          history,
          showHistoryHint: options.showHistoryHint,
          flexibleHeight,
          flexibleWidth,
          flexibleMaxHeight
        }));
        this.preserveCase = this._register(new PreserveCaseCheckbox({
          appendTitle: appendPreserveCaseLabel,
          isChecked: false,
          inputActiveOptionBorder: this.inputActiveOptionBorder,
          inputActiveOptionForeground: this.inputActiveOptionForeground,
          inputActiveOptionBackground: this.inputActiveOptionBackground
        }));
        this._register(this.preserveCase.onChange((viaKeyboard) => {
          this._onDidOptionChange.fire(viaKeyboard);
          if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
            this.inputBox.focus();
          }
          this.validate();
        }));
        this._register(this.preserveCase.onKeyDown((e) => {
          this._onPreserveCaseKeyDown.fire(e);
        }));
        if (this._showOptionButtons) {
          this.cachedOptionsWidth = this.preserveCase.width();
        } else {
          this.cachedOptionsWidth = 0;
        }
        let indexes = [this.preserveCase.domNode];
        this.onkeydown(this.domNode, (event) => {
          if (event.equals(
            15
            /* LeftArrow */
          ) || event.equals(
            17
            /* RightArrow */
          ) || event.equals(
            9
            /* Escape */
          )) {
            let index = indexes.indexOf(document.activeElement);
            if (index >= 0) {
              let newIndex = -1;
              if (event.equals(
                17
                /* RightArrow */
              )) {
                newIndex = (index + 1) % indexes.length;
              } else if (event.equals(
                15
                /* LeftArrow */
              )) {
                if (index === 0) {
                  newIndex = indexes.length - 1;
                } else {
                  newIndex = index - 1;
                }
              }
              if (event.equals(
                9
                /* Escape */
              )) {
                indexes[index].blur();
                this.inputBox.focus();
              } else if (newIndex >= 0) {
                indexes[newIndex].focus();
              }
              EventHelper.stop(event, true);
            }
          }
        });
        let controls = document.createElement("div");
        controls.className = "controls";
        controls.style.display = this._showOptionButtons ? "block" : "none";
        controls.appendChild(this.preserveCase.domNode);
        this.domNode.appendChild(controls);
        if (parent) {
          parent.appendChild(this.domNode);
        }
        this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
        this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
        this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
        this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
      }
      enable() {
        this.domNode.classList.remove("disabled");
        this.inputBox.enable();
        this.preserveCase.enable();
      }
      disable() {
        this.domNode.classList.add("disabled");
        this.inputBox.disable();
        this.preserveCase.disable();
      }
      setEnabled(enabled) {
        if (enabled) {
          this.enable();
        } else {
          this.disable();
        }
      }
      style(styles) {
        this.inputActiveOptionBorder = styles.inputActiveOptionBorder;
        this.inputActiveOptionForeground = styles.inputActiveOptionForeground;
        this.inputActiveOptionBackground = styles.inputActiveOptionBackground;
        this.inputBackground = styles.inputBackground;
        this.inputForeground = styles.inputForeground;
        this.inputBorder = styles.inputBorder;
        this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
        this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
        this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
        this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
        this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
        this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
        this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
        this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
        this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
        this.applyStyles();
      }
      applyStyles() {
        if (this.domNode) {
          const checkBoxStyles = {
            inputActiveOptionBorder: this.inputActiveOptionBorder,
            inputActiveOptionForeground: this.inputActiveOptionForeground,
            inputActiveOptionBackground: this.inputActiveOptionBackground
          };
          this.preserveCase.style(checkBoxStyles);
          const inputBoxStyles = {
            inputBackground: this.inputBackground,
            inputForeground: this.inputForeground,
            inputBorder: this.inputBorder,
            inputValidationInfoBackground: this.inputValidationInfoBackground,
            inputValidationInfoForeground: this.inputValidationInfoForeground,
            inputValidationInfoBorder: this.inputValidationInfoBorder,
            inputValidationWarningBackground: this.inputValidationWarningBackground,
            inputValidationWarningForeground: this.inputValidationWarningForeground,
            inputValidationWarningBorder: this.inputValidationWarningBorder,
            inputValidationErrorBackground: this.inputValidationErrorBackground,
            inputValidationErrorForeground: this.inputValidationErrorForeground,
            inputValidationErrorBorder: this.inputValidationErrorBorder
          };
          this.inputBox.style(inputBoxStyles);
        }
      }
      select() {
        this.inputBox.select();
      }
      focus() {
        this.inputBox.focus();
      }
      getPreserveCase() {
        return this.preserveCase.checked;
      }
      setPreserveCase(value) {
        this.preserveCase.checked = value;
      }
      focusOnPreserve() {
        this.preserveCase.focus();
      }
      validate() {
        if (this.inputBox) {
          this.inputBox.validate();
        }
      }
      set width(newWidth) {
        this.inputBox.paddingRight = this.cachedOptionsWidth;
        this.inputBox.width = newWidth;
        this.domNode.style.width = newWidth + "px";
      }
      dispose() {
        super.dispose();
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/platform/browser/contextScopedHistoryWidget.js
function bindContextScopedWidget(contextKeyService, widget, contextKey) {
  new RawContextKey(contextKey, widget).bindTo(contextKeyService);
}
function createWidgetScopedContextKeyService(contextKeyService, widget) {
  return contextKeyService.createScoped(widget.target);
}
function getContextScopedWidget(contextKeyService, contextKey) {
  return contextKeyService.getContext(document.activeElement).getValue(contextKey);
}
function createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, widget) {
  const scopedContextKeyService = createWidgetScopedContextKeyService(contextKeyService, widget);
  bindContextScopedWidget(scopedContextKeyService, widget, HistoryNavigationWidgetContext);
  const historyNavigationForwardsEnablement = new RawContextKey(HistoryNavigationForwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const historyNavigationBackwardsEnablement = new RawContextKey(HistoryNavigationBackwardsEnablementContext, true).bindTo(scopedContextKeyService);
  return {
    scopedContextKeyService,
    historyNavigationForwardsEnablement,
    historyNavigationBackwardsEnablement
  };
}
var __decorate43, __param43, HistoryNavigationWidgetContext, HistoryNavigationForwardsEnablementContext, HistoryNavigationBackwardsEnablementContext, ContextScopedFindInput, ContextScopedReplaceInput;
var init_contextScopedHistoryWidget = __esm({
  "node_modules/monaco-editor/esm/vs/platform/browser/contextScopedHistoryWidget.js"() {
    init_findInput();
    init_replaceInput();
    init_contextkey();
    init_keybindingsRegistry();
    init_suggest();
    __decorate43 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param43 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    HistoryNavigationWidgetContext = "historyNavigationWidget";
    HistoryNavigationForwardsEnablementContext = "historyNavigationForwardsEnabled";
    HistoryNavigationBackwardsEnablementContext = "historyNavigationBackwardsEnabled";
    ContextScopedFindInput = class ContextScopedFindInput2 extends FindInput {
      constructor(container, contextViewProvider, options, contextKeyService, showFindOptions = false) {
        super(container, contextViewProvider, showFindOptions, options);
        this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);
      }
    };
    ContextScopedFindInput = __decorate43([
      __param43(3, IContextKeyService)
    ], ContextScopedFindInput);
    ContextScopedReplaceInput = class ContextScopedReplaceInput2 extends ReplaceInput {
      constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {
        super(container, contextViewProvider, showReplaceOptions, options);
        this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);
      }
    };
    ContextScopedReplaceInput = __decorate43([
      __param43(3, IContextKeyService)
    ], ContextScopedReplaceInput);
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "history.showPrevious",
      weight: 200,
      when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationBackwardsEnablementContext, true), Context.Visible.isEqualTo(false)),
      primary: 16,
      secondary: [
        512 | 16
        /* UpArrow */
      ],
      handler: (accessor) => {
        const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);
        if (widget) {
          const historyInputBox = widget.historyNavigator;
          historyInputBox.showPreviousValue();
        }
      }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
      id: "history.showNext",
      weight: 200,
      when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationForwardsEnablementContext, true), Context.Visible.isEqualTo(false)),
      primary: 18,
      secondary: [
        512 | 18
        /* DownArrow */
      ],
      handler: (accessor) => {
        const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);
        if (widget) {
          const historyInputBox = widget.historyNavigator;
          historyInputBox.showNextValue();
        }
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/platform/browser/historyWidgetKeybindingHint.js
function showHistoryKeybindingHint(keybindingService) {
  var _a5, _b2;
  return ((_a5 = keybindingService.lookupKeybinding("history.showPrevious")) === null || _a5 === void 0 ? void 0 : _a5.getElectronAccelerator()) === "Up" && ((_b2 = keybindingService.lookupKeybinding("history.showNext")) === null || _b2 === void 0 ? void 0 : _b2.getElectronAccelerator()) === "Down";
}
var init_historyWidgetKeybindingHint = __esm({
  "node_modules/monaco-editor/esm/vs/platform/browser/historyWidgetKeybindingHint.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findWidget.js
function stopPropagationForMultiLineUpwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionStart > 0) {
    event.stopPropagation();
    return;
  }
}
function stopPropagationForMultiLineDownwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
    event.stopPropagation();
    return;
  }
}
var __awaiter30, findSelectionIcon, findCollapsedIcon, findExpandedIcon, findReplaceIcon, findReplaceAllIcon, findPreviousMatchIcon, findNextMatchIcon, NLS_FIND_INPUT_LABEL, NLS_FIND_INPUT_PLACEHOLDER, NLS_PREVIOUS_MATCH_BTN_LABEL, NLS_NEXT_MATCH_BTN_LABEL, NLS_TOGGLE_SELECTION_FIND_TITLE, NLS_CLOSE_BTN_LABEL, NLS_REPLACE_INPUT_LABEL, NLS_REPLACE_INPUT_PLACEHOLDER, NLS_REPLACE_BTN_LABEL, NLS_REPLACE_ALL_BTN_LABEL, NLS_TOGGLE_REPLACE_MODE_BTN_LABEL, NLS_MATCHES_COUNT_LIMIT_TITLE, NLS_MATCHES_LOCATION, NLS_NO_RESULTS, FIND_WIDGET_INITIAL_WIDTH, PART_WIDTH, FIND_INPUT_AREA_WIDTH, MAX_MATCHES_COUNT_WIDTH, FIND_INPUT_AREA_HEIGHT, ctrlEnterReplaceAllWarningPromptedKey, ctrlKeyMod, FindWidgetViewZone, FindWidget, SimpleButton;
var init_findWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/findWidget.js"() {
    init_dom();
    init_aria();
    init_checkbox();
    init_sash();
    init_widget();
    init_async();
    init_codicons();
    init_errors();
    init_lifecycle();
    init_platform();
    init_strings();
    init_range();
    init_findModel();
    init_nls();
    init_contextScopedHistoryWidget();
    init_historyWidgetKeybindingHint();
    init_colorRegistry();
    init_iconRegistry();
    init_themeService();
    __awaiter30 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    findSelectionIcon = registerIcon("find-selection", Codicon.selection, localize("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget."));
    findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight, localize("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed."));
    findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown, localize("findExpandedIcon", "Icon to indicate that the editor find widget is expanded."));
    findReplaceIcon = registerIcon("find-replace", Codicon.replace, localize("findReplaceIcon", "Icon for 'Replace' in the editor find widget."));
    findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll, localize("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget."));
    findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp, localize("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget."));
    findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown, localize("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget."));
    NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
    NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find");
    NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous Match");
    NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next Match");
    NLS_TOGGLE_SELECTION_FIND_TITLE = localize("label.toggleSelectionFind", "Find in Selection");
    NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
    NLS_REPLACE_INPUT_LABEL = localize("label.replace", "Replace");
    NLS_REPLACE_INPUT_PLACEHOLDER = localize("placeholder.replace", "Replace");
    NLS_REPLACE_BTN_LABEL = localize("label.replaceButton", "Replace");
    NLS_REPLACE_ALL_BTN_LABEL = localize("label.replaceAllButton", "Replace All");
    NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize("label.toggleReplaceButton", "Toggle Replace");
    NLS_MATCHES_COUNT_LIMIT_TITLE = localize("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
    NLS_MATCHES_LOCATION = localize("label.matchesLocation", "{0} of {1}");
    NLS_NO_RESULTS = localize("label.noResults", "No results");
    FIND_WIDGET_INITIAL_WIDTH = 419;
    PART_WIDTH = 275;
    FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
    MAX_MATCHES_COUNT_WIDTH = 69;
    FIND_INPUT_AREA_HEIGHT = 33;
    ctrlEnterReplaceAllWarningPromptedKey = "ctrlEnterReplaceAll.windows.donotask";
    ctrlKeyMod = isMacintosh ? 256 : 2048;
    FindWidgetViewZone = class {
      constructor(afterLineNumber) {
        this.afterLineNumber = afterLineNumber;
        this.heightInPx = FIND_INPUT_AREA_HEIGHT;
        this.suppressMouseDown = false;
        this.domNode = document.createElement("div");
        this.domNode.className = "dock-find-viewzone";
      }
    };
    FindWidget = class _FindWidget extends Widget {
      constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService) {
        super();
        this._cachedHeight = null;
        this._revealTimeouts = [];
        this._codeEditor = codeEditor;
        this._controller = controller;
        this._state = state;
        this._contextViewProvider = contextViewProvider;
        this._keybindingService = keybindingService;
        this._contextKeyService = contextKeyService;
        this._storageService = storageService;
        this._notificationService = notificationService;
        this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(
          ctrlEnterReplaceAllWarningPromptedKey,
          0
          /* GLOBAL */
        );
        this._isVisible = false;
        this._isReplaceVisible = false;
        this._ignoreChangeEvent = false;
        this._updateHistoryDelayer = new Delayer(500);
        this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
        this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
        this._buildDomNode();
        this._updateButtons();
        this._tryUpdateWidgetWidth();
        this._findInput.inputBox.layout();
        this._register(this._codeEditor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            80
            /* readOnly */
          )) {
            if (this._codeEditor.getOption(
              80
              /* readOnly */
            )) {
              this._state.change({ isReplaceRevealed: false }, false);
            }
            this._updateButtons();
          }
          if (e.hasChanged(
            129
            /* layoutInfo */
          )) {
            this._tryUpdateWidgetWidth();
          }
          if (e.hasChanged(
            2
            /* accessibilitySupport */
          )) {
            this.updateAccessibilitySupport();
          }
          if (e.hasChanged(
            35
            /* find */
          )) {
            const addExtraSpaceOnTop = this._codeEditor.getOption(
              35
              /* find */
            ).addExtraSpaceOnTop;
            if (addExtraSpaceOnTop && !this._viewZone) {
              this._viewZone = new FindWidgetViewZone(0);
              this._showViewZone();
            }
            if (!addExtraSpaceOnTop && this._viewZone) {
              this._removeViewZone();
            }
          }
        }));
        this.updateAccessibilitySupport();
        this._register(this._codeEditor.onDidChangeCursorSelection(() => {
          if (this._isVisible) {
            this._updateToggleSelectionFindButton();
          }
        }));
        this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter30(this, void 0, void 0, function* () {
          if (this._isVisible) {
            let globalBufferTerm = yield this._controller.getGlobalBufferTerm();
            if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
              this._state.change({ searchString: globalBufferTerm }, false);
              this._findInput.select();
            }
          }
        })));
        this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
        this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
        this._register(this._findFocusTracker.onDidFocus(() => {
          this._findInputFocused.set(true);
          this._updateSearchScope();
        }));
        this._register(this._findFocusTracker.onDidBlur(() => {
          this._findInputFocused.set(false);
        }));
        this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
        this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
        this._register(this._replaceFocusTracker.onDidFocus(() => {
          this._replaceInputFocused.set(true);
          this._updateSearchScope();
        }));
        this._register(this._replaceFocusTracker.onDidBlur(() => {
          this._replaceInputFocused.set(false);
        }));
        this._codeEditor.addOverlayWidget(this);
        if (this._codeEditor.getOption(
          35
          /* find */
        ).addExtraSpaceOnTop) {
          this._viewZone = new FindWidgetViewZone(0);
        }
        this._applyTheme(themeService.getColorTheme());
        this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
        this._register(this._codeEditor.onDidChangeModel(() => {
          if (!this._isVisible) {
            return;
          }
          this._viewZoneId = void 0;
        }));
        this._register(this._codeEditor.onDidScrollChange((e) => {
          if (e.scrollTopChanged) {
            this._layoutViewZone();
            return;
          }
          setTimeout(() => {
            this._layoutViewZone();
          }, 0);
        }));
      }
      // ----- IOverlayWidget API
      getId() {
        return _FindWidget.ID;
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        if (this._isVisible) {
          return {
            preference: 0
            /* TOP_RIGHT_CORNER */
          };
        }
        return null;
      }
      // ----- React to state changes
      _onStateChanged(e) {
        if (e.searchString) {
          try {
            this._ignoreChangeEvent = true;
            this._findInput.setValue(this._state.searchString);
          } finally {
            this._ignoreChangeEvent = false;
          }
          this._updateButtons();
        }
        if (e.replaceString) {
          this._replaceInput.inputBox.value = this._state.replaceString;
        }
        if (e.isRevealed) {
          if (this._state.isRevealed) {
            this._reveal();
          } else {
            this._hide(true);
          }
        }
        if (e.isReplaceRevealed) {
          if (this._state.isReplaceRevealed) {
            if (!this._codeEditor.getOption(
              80
              /* readOnly */
            ) && !this._isReplaceVisible) {
              this._isReplaceVisible = true;
              this._replaceInput.width = getTotalWidth(this._findInput.domNode);
              this._updateButtons();
              this._replaceInput.inputBox.layout();
            }
          } else {
            if (this._isReplaceVisible) {
              this._isReplaceVisible = false;
              this._updateButtons();
            }
          }
        }
        if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
          if (this._tryUpdateHeight()) {
            this._showViewZone();
          }
        }
        if (e.isRegex) {
          this._findInput.setRegex(this._state.isRegex);
        }
        if (e.wholeWord) {
          this._findInput.setWholeWords(this._state.wholeWord);
        }
        if (e.matchCase) {
          this._findInput.setCaseSensitive(this._state.matchCase);
        }
        if (e.preserveCase) {
          this._replaceInput.setPreserveCase(this._state.preserveCase);
        }
        if (e.searchScope) {
          if (this._state.searchScope) {
            this._toggleSelectionFind.checked = true;
          } else {
            this._toggleSelectionFind.checked = false;
          }
          this._updateToggleSelectionFindButton();
        }
        if (e.searchString || e.matchesCount || e.matchesPosition) {
          let showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
          this._domNode.classList.toggle("no-results", showRedOutline);
          this._updateMatchesCount();
          this._updateButtons();
        }
        if (e.searchString || e.currentMatch) {
          this._layoutViewZone();
        }
        if (e.updateHistory) {
          this._delayedUpdateHistory();
        }
        if (e.loop) {
          this._updateButtons();
        }
      }
      _delayedUpdateHistory() {
        this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, onUnexpectedError);
      }
      _updateHistory() {
        if (this._state.searchString) {
          this._findInput.inputBox.addToHistory();
        }
        if (this._state.replaceString) {
          this._replaceInput.inputBox.addToHistory();
        }
      }
      _updateMatchesCount() {
        this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
        if (this._state.matchesCount >= MATCHES_LIMIT) {
          this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
        } else {
          this._matchesCount.title = "";
        }
        if (this._matchesCount.firstChild) {
          this._matchesCount.removeChild(this._matchesCount.firstChild);
        }
        let label;
        if (this._state.matchesCount > 0) {
          let matchesCount = String(this._state.matchesCount);
          if (this._state.matchesCount >= MATCHES_LIMIT) {
            matchesCount += "+";
          }
          let matchesPosition = String(this._state.matchesPosition);
          if (matchesPosition === "0") {
            matchesPosition = "?";
          }
          label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
        } else {
          label = NLS_NO_RESULTS;
        }
        this._matchesCount.appendChild(document.createTextNode(label));
        alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
        MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
      }
      // ----- actions
      _getAriaLabel(label, currentMatch, searchString) {
        if (label === NLS_NO_RESULTS) {
          return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
        }
        if (currentMatch) {
          const ariaLabel = localize("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
          const model = this._codeEditor.getModel();
          if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) {
            const lineContent = model.getLineContent(currentMatch.startLineNumber);
            return `${lineContent}, ${ariaLabel}`;
          }
          return ariaLabel;
        }
        return localize("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", label, searchString);
      }
      /**
       * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
       * If 'selection find' is OFF we enable the button only if there is a selection.
       */
      _updateToggleSelectionFindButton() {
        let selection = this._codeEditor.getSelection();
        let isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
        let isChecked = this._toggleSelectionFind.checked;
        if (this._isVisible && (isChecked || isSelection)) {
          this._toggleSelectionFind.enable();
        } else {
          this._toggleSelectionFind.disable();
        }
      }
      _updateButtons() {
        this._findInput.setEnabled(this._isVisible);
        this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
        this._updateToggleSelectionFindButton();
        this._closeBtn.setEnabled(this._isVisible);
        let findInputIsNonEmpty = this._state.searchString.length > 0;
        let matchesCount = this._state.matchesCount ? true : false;
        this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
        this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
        this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
        this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
        this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible);
        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
        let canReplace = !this._codeEditor.getOption(
          80
          /* readOnly */
        );
        this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
      }
      _reveal() {
        this._revealTimeouts.forEach((e) => {
          clearTimeout(e);
        });
        this._revealTimeouts = [];
        if (!this._isVisible) {
          this._isVisible = true;
          const selection = this._codeEditor.getSelection();
          switch (this._codeEditor.getOption(
            35
            /* find */
          ).autoFindInSelection) {
            case "always":
              this._toggleSelectionFind.checked = true;
              break;
            case "never":
              this._toggleSelectionFind.checked = false;
              break;
            case "multiline":
              const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
              this._toggleSelectionFind.checked = isSelectionMultipleLine;
              break;
            default:
              break;
          }
          this._tryUpdateWidgetWidth();
          this._updateButtons();
          this._revealTimeouts.push(setTimeout(() => {
            this._domNode.classList.add("visible");
            this._domNode.setAttribute("aria-hidden", "false");
          }, 0));
          this._revealTimeouts.push(setTimeout(() => {
            this._findInput.validate();
          }, 200));
          this._codeEditor.layoutOverlayWidget(this);
          let adjustEditorScrollTop = true;
          if (this._codeEditor.getOption(
            35
            /* find */
          ).seedSearchStringFromSelection && selection) {
            const domNode = this._codeEditor.getDomNode();
            if (domNode) {
              const editorCoords = getDomNodePagePosition(domNode);
              const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
              const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
              const startTop = startCoords ? startCoords.top : 0;
              if (this._viewZone && startTop < this._viewZone.heightInPx) {
                if (selection.endLineNumber > selection.startLineNumber) {
                  adjustEditorScrollTop = false;
                }
                const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
                if (startLeft > leftOfFindWidget) {
                  adjustEditorScrollTop = false;
                }
                const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
                const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);
                if (endLeft > leftOfFindWidget) {
                  adjustEditorScrollTop = false;
                }
              }
            }
          }
          this._showViewZone(adjustEditorScrollTop);
        }
      }
      _hide(focusTheEditor) {
        this._revealTimeouts.forEach((e) => {
          clearTimeout(e);
        });
        this._revealTimeouts = [];
        if (this._isVisible) {
          this._isVisible = false;
          this._updateButtons();
          this._domNode.classList.remove("visible");
          this._domNode.setAttribute("aria-hidden", "true");
          this._findInput.clearMessage();
          if (focusTheEditor) {
            this._codeEditor.focus();
          }
          this._codeEditor.layoutOverlayWidget(this);
          this._removeViewZone();
        }
      }
      _layoutViewZone(targetScrollTop) {
        const addExtraSpaceOnTop = this._codeEditor.getOption(
          35
          /* find */
        ).addExtraSpaceOnTop;
        if (!addExtraSpaceOnTop) {
          this._removeViewZone();
          return;
        }
        if (!this._isVisible) {
          return;
        }
        const viewZone = this._viewZone;
        if (this._viewZoneId !== void 0 || !viewZone) {
          return;
        }
        this._codeEditor.changeViewZones((accessor) => {
          viewZone.heightInPx = this._getHeight();
          this._viewZoneId = accessor.addZone(viewZone);
          this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);
        });
      }
      _showViewZone(adjustScroll = true) {
        if (!this._isVisible) {
          return;
        }
        const addExtraSpaceOnTop = this._codeEditor.getOption(
          35
          /* find */
        ).addExtraSpaceOnTop;
        if (!addExtraSpaceOnTop) {
          return;
        }
        if (this._viewZone === void 0) {
          this._viewZone = new FindWidgetViewZone(0);
        }
        const viewZone = this._viewZone;
        this._codeEditor.changeViewZones((accessor) => {
          if (this._viewZoneId !== void 0) {
            const newHeight = this._getHeight();
            if (newHeight === viewZone.heightInPx) {
              return;
            }
            let scrollAdjustment = newHeight - viewZone.heightInPx;
            viewZone.heightInPx = newHeight;
            accessor.layoutZone(this._viewZoneId);
            if (adjustScroll) {
              this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
            }
            return;
          } else {
            let scrollAdjustment = this._getHeight();
            scrollAdjustment -= this._codeEditor.getOption(
              74
              /* padding */
            ).top;
            if (scrollAdjustment <= 0) {
              return;
            }
            viewZone.heightInPx = scrollAdjustment;
            this._viewZoneId = accessor.addZone(viewZone);
            if (adjustScroll) {
              this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
            }
          }
        });
      }
      _removeViewZone() {
        this._codeEditor.changeViewZones((accessor) => {
          if (this._viewZoneId !== void 0) {
            accessor.removeZone(this._viewZoneId);
            this._viewZoneId = void 0;
            if (this._viewZone) {
              this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
              this._viewZone = void 0;
            }
          }
        });
      }
      _applyTheme(theme) {
        let inputStyles = {
          inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),
          inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground),
          inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),
          inputBackground: theme.getColor(inputBackground),
          inputForeground: theme.getColor(inputForeground),
          inputBorder: theme.getColor(inputBorder),
          inputValidationInfoBackground: theme.getColor(inputValidationInfoBackground),
          inputValidationInfoForeground: theme.getColor(inputValidationInfoForeground),
          inputValidationInfoBorder: theme.getColor(inputValidationInfoBorder),
          inputValidationWarningBackground: theme.getColor(inputValidationWarningBackground),
          inputValidationWarningForeground: theme.getColor(inputValidationWarningForeground),
          inputValidationWarningBorder: theme.getColor(inputValidationWarningBorder),
          inputValidationErrorBackground: theme.getColor(inputValidationErrorBackground),
          inputValidationErrorForeground: theme.getColor(inputValidationErrorForeground),
          inputValidationErrorBorder: theme.getColor(inputValidationErrorBorder)
        };
        this._findInput.style(inputStyles);
        this._replaceInput.style(inputStyles);
        this._toggleSelectionFind.style(inputStyles);
      }
      _tryUpdateWidgetWidth() {
        if (!this._isVisible) {
          return;
        }
        if (!isInDOM(this._domNode)) {
          return;
        }
        const layoutInfo = this._codeEditor.getLayoutInfo();
        const editorContentWidth = layoutInfo.contentWidth;
        if (editorContentWidth <= 0) {
          this._domNode.classList.add("hiddenEditor");
          return;
        } else if (this._domNode.classList.contains("hiddenEditor")) {
          this._domNode.classList.remove("hiddenEditor");
        }
        const editorWidth = layoutInfo.width;
        const minimapWidth = layoutInfo.minimap.minimapWidth;
        let collapsedFindWidget = false;
        let reducedFindWidget = false;
        let narrowFindWidget = false;
        if (this._resized) {
          let widgetWidth = getTotalWidth(this._domNode);
          if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
            this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
            this._replaceInput.width = getTotalWidth(this._findInput.domNode);
            return;
          }
        }
        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
          reducedFindWidget = true;
        }
        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
          narrowFindWidget = true;
        }
        if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
          collapsedFindWidget = true;
        }
        this._domNode.classList.toggle("collapsed-find-widget", collapsedFindWidget);
        this._domNode.classList.toggle("narrow-find-widget", narrowFindWidget);
        this._domNode.classList.toggle("reduced-find-widget", reducedFindWidget);
        if (!narrowFindWidget && !collapsedFindWidget) {
          this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
        }
        if (this._resized) {
          this._findInput.inputBox.layout();
          let findInputWidth = this._findInput.inputBox.element.clientWidth;
          if (findInputWidth > 0) {
            this._replaceInput.width = findInputWidth;
          }
        } else if (this._isReplaceVisible) {
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
        }
      }
      _getHeight() {
        let totalheight = 0;
        totalheight += 4;
        totalheight += this._findInput.inputBox.height + 2;
        if (this._isReplaceVisible) {
          totalheight += 4;
          totalheight += this._replaceInput.inputBox.height + 2;
        }
        totalheight += 4;
        return totalheight;
      }
      _tryUpdateHeight() {
        const totalHeight = this._getHeight();
        if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {
          return false;
        }
        this._cachedHeight = totalHeight;
        this._domNode.style.height = `${totalHeight}px`;
        return true;
      }
      // ----- Public
      focusFindInput() {
        this._findInput.select();
        this._findInput.focus();
      }
      focusReplaceInput() {
        this._replaceInput.select();
        this._replaceInput.focus();
      }
      highlightFindOptions() {
        this._findInput.highlightFindOptions();
      }
      _updateSearchScope() {
        if (!this._codeEditor.hasModel()) {
          return;
        }
        if (this._toggleSelectionFind.checked) {
          let selections = this._codeEditor.getSelections();
          selections.map((selection) => {
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
              selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
            }
            const currentMatch = this._state.currentMatch;
            if (selection.startLineNumber !== selection.endLineNumber) {
              if (!Range.equalsRange(selection, currentMatch)) {
                return selection;
              }
            }
            return null;
          }).filter((element) => !!element);
          if (selections.length) {
            this._state.change({ searchScope: selections }, true);
          }
        }
      }
      _onFindInputMouseDown(e) {
        if (e.middleButton) {
          e.stopPropagation();
        }
      }
      _onFindInputKeyDown(e) {
        if (e.equals(
          ctrlKeyMod | 3
          /* Enter */
        )) {
          if (this._keybindingService.dispatchEvent(e, e.target)) {
            e.preventDefault();
            return;
          } else {
            this._findInput.inputBox.insertAtCursor("\n");
            e.preventDefault();
            return;
          }
        }
        if (e.equals(
          2
          /* Tab */
        )) {
          if (this._isReplaceVisible) {
            this._replaceInput.focus();
          } else {
            this._findInput.focusOnCaseSensitive();
          }
          e.preventDefault();
          return;
        }
        if (e.equals(
          2048 | 18
          /* DownArrow */
        )) {
          this._codeEditor.focus();
          e.preventDefault();
          return;
        }
        if (e.equals(
          16
          /* UpArrow */
        )) {
          return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
        }
        if (e.equals(
          18
          /* DownArrow */
        )) {
          return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
        }
      }
      _onReplaceInputKeyDown(e) {
        if (e.equals(
          ctrlKeyMod | 3
          /* Enter */
        )) {
          if (this._keybindingService.dispatchEvent(e, e.target)) {
            e.preventDefault();
            return;
          } else {
            if (isWindows && isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
              this._notificationService.info(localize("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior."));
              this._ctrlEnterReplaceAllWarningPrompted = true;
              this._storageService.store(
                ctrlEnterReplaceAllWarningPromptedKey,
                true,
                0,
                0
                /* USER */
              );
            }
            this._replaceInput.inputBox.insertAtCursor("\n");
            e.preventDefault();
            return;
          }
        }
        if (e.equals(
          2
          /* Tab */
        )) {
          this._findInput.focusOnCaseSensitive();
          e.preventDefault();
          return;
        }
        if (e.equals(
          1024 | 2
          /* Tab */
        )) {
          this._findInput.focus();
          e.preventDefault();
          return;
        }
        if (e.equals(
          2048 | 18
          /* DownArrow */
        )) {
          this._codeEditor.focus();
          e.preventDefault();
          return;
        }
        if (e.equals(
          16
          /* UpArrow */
        )) {
          return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
        }
        if (e.equals(
          18
          /* DownArrow */
        )) {
          return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
        }
      }
      // ----- sash
      getVerticalSashLeft(_sash) {
        return 0;
      }
      // ----- initialization
      _keybindingLabelFor(actionId) {
        let kb = this._keybindingService.lookupKeybinding(actionId);
        if (!kb) {
          return "";
        }
        return ` (${kb.getLabel()})`;
      }
      _buildDomNode() {
        const flexibleHeight = true;
        const flexibleWidth = true;
        this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
          width: FIND_INPUT_AREA_WIDTH,
          label: NLS_FIND_INPUT_LABEL,
          placeholder: NLS_FIND_INPUT_PLACEHOLDER,
          appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
          appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
          appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
          validation: (value) => {
            if (value.length === 0 || !this._findInput.getRegex()) {
              return null;
            }
            try {
              new RegExp(value, "gu");
              return null;
            } catch (e) {
              return { content: e.message };
            }
          },
          flexibleHeight,
          flexibleWidth,
          flexibleMaxHeight: 118,
          showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)
        }, this._contextKeyService, true));
        this._findInput.setRegex(!!this._state.isRegex);
        this._findInput.setCaseSensitive(!!this._state.matchCase);
        this._findInput.setWholeWords(!!this._state.wholeWord);
        this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));
        this._register(this._findInput.inputBox.onDidChange(() => {
          if (this._ignoreChangeEvent) {
            return;
          }
          this._state.change({ searchString: this._findInput.getValue() }, true);
        }));
        this._register(this._findInput.onDidOptionChange(() => {
          this._state.change({
            isRegex: this._findInput.getRegex(),
            wholeWord: this._findInput.getWholeWords(),
            matchCase: this._findInput.getCaseSensitive()
          }, true);
        }));
        this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
          if (e.equals(
            1024 | 2
            /* Tab */
          )) {
            if (this._isReplaceVisible) {
              this._replaceInput.focus();
              e.preventDefault();
            }
          }
        }));
        this._register(this._findInput.onRegexKeyDown((e) => {
          if (e.equals(
            2
            /* Tab */
          )) {
            if (this._isReplaceVisible) {
              this._replaceInput.focusOnPreserve();
              e.preventDefault();
            }
          }
        }));
        this._register(this._findInput.inputBox.onDidHeightChange((e) => {
          if (this._tryUpdateHeight()) {
            this._showViewZone();
          }
        }));
        if (isLinux) {
          this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
        }
        this._matchesCount = document.createElement("div");
        this._matchesCount.className = "matchesCount";
        this._updateMatchesCount();
        this._prevBtn = this._register(new SimpleButton({
          label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
          icon: findPreviousMatchIcon,
          onTrigger: () => {
            this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction).run().then(void 0, onUnexpectedError);
          }
        }));
        this._nextBtn = this._register(new SimpleButton({
          label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
          icon: findNextMatchIcon,
          onTrigger: () => {
            this._codeEditor.getAction(FIND_IDS.NextMatchFindAction).run().then(void 0, onUnexpectedError);
          }
        }));
        let findPart = document.createElement("div");
        findPart.className = "find-part";
        findPart.appendChild(this._findInput.domNode);
        const actionsContainer = document.createElement("div");
        actionsContainer.className = "find-actions";
        findPart.appendChild(actionsContainer);
        actionsContainer.appendChild(this._matchesCount);
        actionsContainer.appendChild(this._prevBtn.domNode);
        actionsContainer.appendChild(this._nextBtn.domNode);
        this._toggleSelectionFind = this._register(new Checkbox({
          icon: findSelectionIcon,
          title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
          isChecked: false
        }));
        this._register(this._toggleSelectionFind.onChange(() => {
          if (this._toggleSelectionFind.checked) {
            if (this._codeEditor.hasModel()) {
              let selections = this._codeEditor.getSelections();
              selections.map((selection) => {
                if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                  selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
                }
                if (!selection.isEmpty()) {
                  return selection;
                }
                return null;
              }).filter((element) => !!element);
              if (selections.length) {
                this._state.change({ searchScope: selections }, true);
              }
            }
          } else {
            this._state.change({ searchScope: null }, true);
          }
        }));
        actionsContainer.appendChild(this._toggleSelectionFind.domNode);
        this._closeBtn = this._register(new SimpleButton({
          label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
          icon: widgetClose,
          onTrigger: () => {
            this._state.change({ isRevealed: false, searchScope: null }, false);
          },
          onKeyDown: (e) => {
            if (e.equals(
              2
              /* Tab */
            )) {
              if (this._isReplaceVisible) {
                if (this._replaceBtn.isEnabled()) {
                  this._replaceBtn.focus();
                } else {
                  this._codeEditor.focus();
                }
                e.preventDefault();
              }
            }
          }
        }));
        actionsContainer.appendChild(this._closeBtn.domNode);
        this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
          label: NLS_REPLACE_INPUT_LABEL,
          placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
          appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),
          history: [],
          flexibleHeight,
          flexibleWidth,
          flexibleMaxHeight: 118,
          showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)
        }, this._contextKeyService, true));
        this._replaceInput.setPreserveCase(!!this._state.preserveCase);
        this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
        this._register(this._replaceInput.inputBox.onDidChange(() => {
          this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);
        }));
        this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
          if (this._isReplaceVisible && this._tryUpdateHeight()) {
            this._showViewZone();
          }
        }));
        this._register(this._replaceInput.onDidOptionChange(() => {
          this._state.change({
            preserveCase: this._replaceInput.getPreserveCase()
          }, true);
        }));
        this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
          if (e.equals(
            2
            /* Tab */
          )) {
            if (this._prevBtn.isEnabled()) {
              this._prevBtn.focus();
            } else if (this._nextBtn.isEnabled()) {
              this._nextBtn.focus();
            } else if (this._toggleSelectionFind.enabled) {
              this._toggleSelectionFind.focus();
            } else if (this._closeBtn.isEnabled()) {
              this._closeBtn.focus();
            }
            e.preventDefault();
          }
        }));
        this._replaceBtn = this._register(new SimpleButton({
          label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
          icon: findReplaceIcon,
          onTrigger: () => {
            this._controller.replace();
          },
          onKeyDown: (e) => {
            if (e.equals(
              1024 | 2
              /* Tab */
            )) {
              this._closeBtn.focus();
              e.preventDefault();
            }
          }
        }));
        this._replaceAllBtn = this._register(new SimpleButton({
          label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
          icon: findReplaceAllIcon,
          onTrigger: () => {
            this._controller.replaceAll();
          }
        }));
        let replacePart = document.createElement("div");
        replacePart.className = "replace-part";
        replacePart.appendChild(this._replaceInput.domNode);
        const replaceActionsContainer = document.createElement("div");
        replaceActionsContainer.className = "replace-actions";
        replacePart.appendChild(replaceActionsContainer);
        replaceActionsContainer.appendChild(this._replaceBtn.domNode);
        replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
        this._toggleReplaceBtn = this._register(new SimpleButton({
          label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
          className: "codicon toggle left",
          onTrigger: () => {
            this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);
            if (this._isReplaceVisible) {
              this._replaceInput.width = getTotalWidth(this._findInput.domNode);
              this._replaceInput.inputBox.layout();
            }
            this._showViewZone();
          }
        }));
        this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
        this._domNode = document.createElement("div");
        this._domNode.className = "editor-widget find-widget";
        this._domNode.setAttribute("aria-hidden", "true");
        this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
        this._domNode.appendChild(this._toggleReplaceBtn.domNode);
        this._domNode.appendChild(findPart);
        this._domNode.appendChild(replacePart);
        this._resizeSash = new Sash(this._domNode, this, { orientation: 0, size: 2 });
        this._resized = false;
        let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
        this._register(this._resizeSash.onDidStart(() => {
          originalWidth = getTotalWidth(this._domNode);
        }));
        this._register(this._resizeSash.onDidChange((evt) => {
          this._resized = true;
          let width = originalWidth + evt.startX - evt.currentX;
          if (width < FIND_WIDGET_INITIAL_WIDTH) {
            return;
          }
          const maxWidth = parseFloat(getComputedStyle(this._domNode).maxWidth) || 0;
          if (width > maxWidth) {
            return;
          }
          this._domNode.style.width = `${width}px`;
          if (this._isReplaceVisible) {
            this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          }
          this._findInput.inputBox.layout();
          this._tryUpdateHeight();
        }));
        this._register(this._resizeSash.onDidReset(() => {
          const currentWidth = getTotalWidth(this._domNode);
          if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {
            return;
          }
          let width = FIND_WIDGET_INITIAL_WIDTH;
          if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
            const layoutInfo = this._codeEditor.getLayoutInfo();
            width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
            this._resized = true;
          } else {
          }
          this._domNode.style.width = `${width}px`;
          if (this._isReplaceVisible) {
            this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          }
          this._findInput.inputBox.layout();
        }));
      }
      updateAccessibilitySupport() {
        const value = this._codeEditor.getOption(
          2
          /* accessibilitySupport */
        );
        this._findInput.setFocusInputOnOptionClick(
          value !== 2
          /* Enabled */
        );
      }
    };
    FindWidget.ID = "editor.contrib.findWidget";
    SimpleButton = class extends Widget {
      constructor(opts) {
        super();
        this._opts = opts;
        let className = "button";
        if (this._opts.className) {
          className = className + " " + this._opts.className;
        }
        if (this._opts.icon) {
          className = className + " " + ThemeIcon.asClassName(this._opts.icon);
        }
        this._domNode = document.createElement("div");
        this._domNode.title = this._opts.label;
        this._domNode.tabIndex = 0;
        this._domNode.className = className;
        this._domNode.setAttribute("role", "button");
        this._domNode.setAttribute("aria-label", this._opts.label);
        this.onclick(this._domNode, (e) => {
          this._opts.onTrigger();
          e.preventDefault();
        });
        this.onkeydown(this._domNode, (e) => {
          if (e.equals(
            10
            /* Space */
          ) || e.equals(
            3
            /* Enter */
          )) {
            this._opts.onTrigger();
            e.preventDefault();
            return;
          }
          if (this._opts.onKeyDown) {
            this._opts.onKeyDown(e);
          }
        });
      }
      get domNode() {
        return this._domNode;
      }
      isEnabled() {
        return this._domNode.tabIndex >= 0;
      }
      focus() {
        this._domNode.focus();
      }
      setEnabled(enabled) {
        this._domNode.classList.toggle("disabled", !enabled);
        this._domNode.setAttribute("aria-disabled", String(!enabled));
        this._domNode.tabIndex = enabled ? 0 : -1;
      }
      setExpanded(expanded) {
        this._domNode.setAttribute("aria-expanded", String(!!expanded));
        if (expanded) {
          this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));
          this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));
        } else {
          this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));
          this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));
        }
      }
    };
    registerThemingParticipant((theme, collector) => {
      const addBackgroundColorRule = (selector, color) => {
        if (color) {
          collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
        }
      };
      addBackgroundColorRule(".findMatch", theme.getColor(editorFindMatchHighlight));
      addBackgroundColorRule(".currentFindMatch", theme.getColor(editorFindMatch));
      addBackgroundColorRule(".findScope", theme.getColor(editorFindRangeHighlight));
      const widgetBackground = theme.getColor(editorWidgetBackground);
      addBackgroundColorRule(".find-widget", widgetBackground);
      const widgetShadowColor = theme.getColor(widgetShadow);
      if (widgetShadowColor) {
        collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
      }
      const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
      if (findMatchHighlightBorder) {
        collector.addRule(`.monaco-editor .findMatch { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
      }
      const findMatchBorder = theme.getColor(editorFindMatchBorder);
      if (findMatchBorder) {
        collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);
      }
      const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
      if (findRangeHighlightBorder) {
        collector.addRule(`.monaco-editor .findScope { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
      }
      const hcBorder = theme.getColor(contrastBorder);
      if (hcBorder) {
        collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
      }
      const foreground2 = theme.getColor(editorWidgetForeground);
      if (foreground2) {
        collector.addRule(`.monaco-editor .find-widget { color: ${foreground2}; }`);
      }
      const error = theme.getColor(errorForeground);
      if (error) {
        collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);
      }
      const resizeBorderBackground = theme.getColor(editorWidgetResizeBorder);
      if (resizeBorderBackground) {
        collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);
      } else {
        const border = theme.getColor(editorWidgetBorder);
        if (border) {
          collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);
        }
      }
      const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);
      if (toolbarHoverBackgroundColor) {
        collector.addRule(`
		.monaco-editor .find-widget .button:not(.disabled):hover,
		.monaco-editor .find-widget .codicon-find-selection:hover {
			background-color: ${toolbarHoverBackgroundColor} !important;
		}
	`);
      }
      const focusOutline = theme.getColor(focusBorder);
      if (focusOutline) {
        collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findController.js
function getSelectionSearchString(editor2, seedSearchStringFromSelection = "single", seedSearchStringFromNonEmptySelection = false) {
  if (!editor2.hasModel()) {
    return null;
  }
  const selection = editor2.getSelection();
  if (seedSearchStringFromSelection === "single" && selection.startLineNumber === selection.endLineNumber || seedSearchStringFromSelection === "multiple") {
    if (selection.isEmpty()) {
      const wordAtPosition = editor2.getConfiguredWordAtPosition(selection.getStartPosition());
      if (wordAtPosition && false === seedSearchStringFromNonEmptySelection) {
        return wordAtPosition.word;
      }
    } else {
      if (editor2.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {
        return editor2.getModel().getValueInRange(selection);
      }
    }
  }
  return null;
}
var __decorate44, __param44, __awaiter31, SEARCH_STRING_MAX_LENGTH, CommonFindController, FindController, StartFindAction, StartFindWithSelectionAction, MatchFindAction, NextMatchFindAction, PreviousMatchFindAction, SelectionMatchFindAction, NextSelectionMatchFindAction, PreviousSelectionMatchFindAction, StartFindReplaceAction, FindCommand;
var init_findController = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/find/findController.js"() {
    init_async();
    init_lifecycle();
    init_strings();
    init_editorExtensions();
    init_editorContextKeys();
    init_findModel();
    init_findOptionsWidget();
    init_findState();
    init_findWidget();
    init_nls();
    init_actions2();
    init_clipboardService();
    init_contextkey();
    init_contextView();
    init_keybinding();
    init_notification();
    init_storage();
    init_themeService();
    __decorate44 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param44 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter31 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    SEARCH_STRING_MAX_LENGTH = 524288;
    CommonFindController = class CommonFindController2 extends Disposable {
      constructor(editor2, contextKeyService, storageService, clipboardService) {
        super();
        this._editor = editor2;
        this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
        this._contextKeyService = contextKeyService;
        this._storageService = storageService;
        this._clipboardService = clipboardService;
        this._updateHistoryDelayer = new Delayer(500);
        this._state = this._register(new FindReplaceState());
        this.loadQueryState();
        this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
        this._model = null;
        this._register(this._editor.onDidChangeModel(() => {
          let shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
          this.disposeModel();
          this._state.change({
            searchScope: null,
            matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
            wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
            isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
            preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
          }, false);
          if (shouldRestartFind) {
            this._start({
              forceRevealReplace: false,
              seedSearchStringFromSelection: "none",
              seedSearchStringFromNonEmptySelection: false,
              seedSearchStringFromGlobalClipboard: false,
              shouldFocus: 0,
              shouldAnimate: false,
              updateSearchScope: false,
              loop: this._editor.getOption(
                35
                /* find */
              ).loop
            });
          }
        }));
      }
      get editor() {
        return this._editor;
      }
      static get(editor2) {
        return editor2.getContribution(CommonFindController2.ID);
      }
      dispose() {
        this.disposeModel();
        super.dispose();
      }
      disposeModel() {
        if (this._model) {
          this._model.dispose();
          this._model = null;
        }
      }
      _onStateChanged(e) {
        this.saveQueryState(e);
        if (e.isRevealed) {
          if (this._state.isRevealed) {
            this._findWidgetVisible.set(true);
          } else {
            this._findWidgetVisible.reset();
            this.disposeModel();
          }
        }
        if (e.searchString) {
          this.setGlobalBufferTerm(this._state.searchString);
        }
      }
      saveQueryState(e) {
        if (e.isRegex) {
          this._storageService.store(
            "editor.isRegex",
            this._state.actualIsRegex,
            1,
            0
            /* USER */
          );
        }
        if (e.wholeWord) {
          this._storageService.store(
            "editor.wholeWord",
            this._state.actualWholeWord,
            1,
            0
            /* USER */
          );
        }
        if (e.matchCase) {
          this._storageService.store(
            "editor.matchCase",
            this._state.actualMatchCase,
            1,
            0
            /* USER */
          );
        }
        if (e.preserveCase) {
          this._storageService.store(
            "editor.preserveCase",
            this._state.actualPreserveCase,
            1,
            0
            /* USER */
          );
        }
      }
      loadQueryState() {
        this._state.change({
          matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
          wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
          isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
          preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
        }, false);
      }
      isFindInputFocused() {
        return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
      }
      getState() {
        return this._state;
      }
      closeFindWidget() {
        this._state.change({
          isRevealed: false,
          searchScope: null
        }, false);
        this._editor.focus();
      }
      toggleCaseSensitive() {
        this._state.change({ matchCase: !this._state.matchCase }, false);
        if (!this._state.isRevealed) {
          this.highlightFindOptions();
        }
      }
      toggleWholeWords() {
        this._state.change({ wholeWord: !this._state.wholeWord }, false);
        if (!this._state.isRevealed) {
          this.highlightFindOptions();
        }
      }
      toggleRegex() {
        this._state.change({ isRegex: !this._state.isRegex }, false);
        if (!this._state.isRevealed) {
          this.highlightFindOptions();
        }
      }
      togglePreserveCase() {
        this._state.change({ preserveCase: !this._state.preserveCase }, false);
        if (!this._state.isRevealed) {
          this.highlightFindOptions();
        }
      }
      toggleSearchScope() {
        if (this._state.searchScope) {
          this._state.change({ searchScope: null }, true);
        } else {
          if (this._editor.hasModel()) {
            let selections = this._editor.getSelections();
            selections.map((selection) => {
              if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
              }
              if (!selection.isEmpty()) {
                return selection;
              }
              return null;
            }).filter((element) => !!element);
            if (selections.length) {
              this._state.change({ searchScope: selections }, true);
            }
          }
        }
      }
      setSearchString(searchString) {
        if (this._state.isRegex) {
          searchString = escapeRegExpCharacters(searchString);
        }
        this._state.change({ searchString }, false);
      }
      highlightFindOptions(ignoreWhenVisible = false) {
      }
      _start(opts) {
        return __awaiter31(this, void 0, void 0, function* () {
          this.disposeModel();
          if (!this._editor.hasModel()) {
            return;
          }
          let stateChanges = {
            isRevealed: true
          };
          if (opts.seedSearchStringFromSelection === "single") {
            let selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
            if (selectionSearchString) {
              if (this._state.isRegex) {
                stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
              } else {
                stateChanges.searchString = selectionSearchString;
              }
            }
          } else if (opts.seedSearchStringFromSelection === "multiple" && !opts.updateSearchScope) {
            let selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
            if (selectionSearchString) {
              stateChanges.searchString = selectionSearchString;
            }
          }
          if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
            let selectionSearchString = yield this.getGlobalBufferTerm();
            if (!this._editor.hasModel()) {
              return;
            }
            if (selectionSearchString) {
              stateChanges.searchString = selectionSearchString;
            }
          }
          if (opts.forceRevealReplace) {
            stateChanges.isReplaceRevealed = true;
          } else if (!this._findWidgetVisible.get()) {
            stateChanges.isReplaceRevealed = false;
          }
          if (opts.updateSearchScope) {
            let currentSelections = this._editor.getSelections();
            if (currentSelections.some((selection) => !selection.isEmpty())) {
              stateChanges.searchScope = currentSelections;
            }
          }
          stateChanges.loop = opts.loop;
          this._state.change(stateChanges, false);
          if (!this._model) {
            this._model = new FindModelBoundToEditorModel(this._editor, this._state);
          }
        });
      }
      start(opts) {
        return this._start(opts);
      }
      moveToNextMatch() {
        if (this._model) {
          this._model.moveToNextMatch();
          return true;
        }
        return false;
      }
      moveToPrevMatch() {
        if (this._model) {
          this._model.moveToPrevMatch();
          return true;
        }
        return false;
      }
      replace() {
        if (this._model) {
          this._model.replace();
          return true;
        }
        return false;
      }
      replaceAll() {
        if (this._model) {
          this._model.replaceAll();
          return true;
        }
        return false;
      }
      selectAllMatches() {
        if (this._model) {
          this._model.selectAllMatches();
          this._editor.focus();
          return true;
        }
        return false;
      }
      getGlobalBufferTerm() {
        return __awaiter31(this, void 0, void 0, function* () {
          if (this._editor.getOption(
            35
            /* find */
          ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
            return this._clipboardService.readFindText();
          }
          return "";
        });
      }
      setGlobalBufferTerm(text2) {
        if (this._editor.getOption(
          35
          /* find */
        ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
          this._clipboardService.writeFindText(text2);
        }
      }
    };
    CommonFindController.ID = "editor.contrib.findController";
    CommonFindController = __decorate44([
      __param44(1, IContextKeyService),
      __param44(2, IStorageService),
      __param44(3, IClipboardService)
    ], CommonFindController);
    FindController = class FindController2 extends CommonFindController {
      constructor(editor2, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, clipboardService) {
        super(editor2, _contextKeyService, _storageService, clipboardService);
        this._contextViewService = _contextViewService;
        this._keybindingService = _keybindingService;
        this._themeService = _themeService;
        this._notificationService = _notificationService;
        this._widget = null;
        this._findOptionsWidget = null;
      }
      _start(opts) {
        const _super = Object.create(null, {
          _start: { get: () => super._start }
        });
        return __awaiter31(this, void 0, void 0, function* () {
          if (!this._widget) {
            this._createFindWidget();
          }
          const selection = this._editor.getSelection();
          let updateSearchScope = false;
          switch (this._editor.getOption(
            35
            /* find */
          ).autoFindInSelection) {
            case "always":
              updateSearchScope = true;
              break;
            case "never":
              updateSearchScope = false;
              break;
            case "multiline":
              const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
              updateSearchScope = isSelectionMultipleLine;
              break;
            default:
              break;
          }
          opts.updateSearchScope = updateSearchScope;
          yield _super._start.call(this, opts);
          if (this._widget) {
            if (opts.shouldFocus === 2) {
              this._widget.focusReplaceInput();
            } else if (opts.shouldFocus === 1) {
              this._widget.focusFindInput();
            }
          }
        });
      }
      highlightFindOptions(ignoreWhenVisible = false) {
        if (!this._widget) {
          this._createFindWidget();
        }
        if (this._state.isRevealed && !ignoreWhenVisible) {
          this._widget.highlightFindOptions();
        } else {
          this._findOptionsWidget.highlightFindOptions();
        }
      }
      _createFindWidget() {
        this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
        this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService, this._themeService));
      }
    };
    FindController = __decorate44([
      __param44(1, IContextViewService),
      __param44(2, IContextKeyService),
      __param44(3, IKeybindingService),
      __param44(4, IThemeService),
      __param44(5, INotificationService),
      __param44(6, IStorageService),
      __param44(7, IClipboardService)
    ], FindController);
    StartFindAction = registerMultiEditorAction(new MultiEditorAction({
      id: FIND_IDS.StartFindAction,
      label: localize("startFindAction", "Find"),
      alias: "Find",
      precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
      kbOpts: {
        kbExpr: null,
        primary: 2048 | 36,
        weight: 100
        /* EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "3_find",
        title: localize({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
        order: 1
      }
    }));
    StartFindAction.addImplementation(0, (accessor, editor2, args) => {
      const controller = CommonFindController.get(editor2);
      if (!controller) {
        return false;
      }
      return controller.start({
        forceRevealReplace: false,
        seedSearchStringFromSelection: editor2.getOption(
          35
          /* find */
        ).seedSearchStringFromSelection !== "never" ? "single" : "none",
        seedSearchStringFromNonEmptySelection: editor2.getOption(
          35
          /* find */
        ).seedSearchStringFromSelection === "selection",
        seedSearchStringFromGlobalClipboard: editor2.getOption(
          35
          /* find */
        ).globalFindClipboard,
        shouldFocus: 1,
        shouldAnimate: true,
        updateSearchScope: false,
        loop: editor2.getOption(
          35
          /* find */
        ).loop
      });
    });
    StartFindWithSelectionAction = class extends EditorAction {
      constructor() {
        super({
          id: FIND_IDS.StartFindWithSelection,
          label: localize("startFindWithSelectionAction", "Find With Selection"),
          alias: "Find With Selection",
          precondition: void 0,
          kbOpts: {
            kbExpr: null,
            primary: 0,
            mac: {
              primary: 2048 | 35
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter31(this, void 0, void 0, function* () {
          let controller = CommonFindController.get(editor2);
          if (controller) {
            yield controller.start({
              forceRevealReplace: false,
              seedSearchStringFromSelection: "multiple",
              seedSearchStringFromNonEmptySelection: false,
              seedSearchStringFromGlobalClipboard: false,
              shouldFocus: 0,
              shouldAnimate: true,
              updateSearchScope: false,
              loop: editor2.getOption(
                35
                /* find */
              ).loop
            });
            controller.setGlobalBufferTerm(controller.getState().searchString);
          }
        });
      }
    };
    MatchFindAction = class extends EditorAction {
      run(accessor, editor2) {
        return __awaiter31(this, void 0, void 0, function* () {
          let controller = CommonFindController.get(editor2);
          if (controller && !this._run(controller)) {
            yield controller.start({
              forceRevealReplace: false,
              seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(
                35
                /* find */
              ).seedSearchStringFromSelection !== "never" ? "single" : "none",
              seedSearchStringFromNonEmptySelection: editor2.getOption(
                35
                /* find */
              ).seedSearchStringFromSelection === "selection",
              seedSearchStringFromGlobalClipboard: true,
              shouldFocus: 0,
              shouldAnimate: true,
              updateSearchScope: false,
              loop: editor2.getOption(
                35
                /* find */
              ).loop
            });
            this._run(controller);
          }
        });
      }
    };
    NextMatchFindAction = class extends MatchFindAction {
      constructor() {
        super({
          id: FIND_IDS.NextMatchFindAction,
          label: localize("findNextMatchAction", "Find Next"),
          alias: "Find Next",
          precondition: void 0,
          kbOpts: [{
            kbExpr: EditorContextKeys.focus,
            primary: 61,
            mac: { primary: 2048 | 37, secondary: [
              61
              /* F3 */
            ] },
            weight: 100
            /* EditorContrib */
          }, {
            kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
            primary: 3,
            weight: 100
            /* EditorContrib */
          }]
        });
      }
      _run(controller) {
        const result = controller.moveToNextMatch();
        if (result) {
          controller.editor.pushUndoStop();
          return true;
        }
        return false;
      }
    };
    PreviousMatchFindAction = class extends MatchFindAction {
      constructor() {
        super({
          id: FIND_IDS.PreviousMatchFindAction,
          label: localize("findPreviousMatchAction", "Find Previous"),
          alias: "Find Previous",
          precondition: void 0,
          kbOpts: [
            {
              kbExpr: EditorContextKeys.focus,
              primary: 1024 | 61,
              mac: { primary: 2048 | 1024 | 37, secondary: [
                1024 | 61
                /* F3 */
              ] },
              weight: 100
              /* EditorContrib */
            },
            {
              kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
              primary: 1024 | 3,
              weight: 100
              /* EditorContrib */
            }
          ]
        });
      }
      _run(controller) {
        return controller.moveToPrevMatch();
      }
    };
    SelectionMatchFindAction = class extends EditorAction {
      run(accessor, editor2) {
        return __awaiter31(this, void 0, void 0, function* () {
          let controller = CommonFindController.get(editor2);
          if (!controller) {
            return;
          }
          const seedSearchStringFromNonEmptySelection = editor2.getOption(
            35
            /* find */
          ).seedSearchStringFromSelection === "selection";
          let selectionSearchString = null;
          if (editor2.getOption(
            35
            /* find */
          ).seedSearchStringFromSelection !== "never") {
            selectionSearchString = getSelectionSearchString(editor2, "single", seedSearchStringFromNonEmptySelection);
          }
          if (selectionSearchString) {
            controller.setSearchString(selectionSearchString);
          }
          if (!this._run(controller)) {
            yield controller.start({
              forceRevealReplace: false,
              seedSearchStringFromSelection: editor2.getOption(
                35
                /* find */
              ).seedSearchStringFromSelection !== "never" ? "single" : "none",
              seedSearchStringFromNonEmptySelection,
              seedSearchStringFromGlobalClipboard: false,
              shouldFocus: 0,
              shouldAnimate: true,
              updateSearchScope: false,
              loop: editor2.getOption(
                35
                /* find */
              ).loop
            });
            this._run(controller);
          }
        });
      }
    };
    NextSelectionMatchFindAction = class extends SelectionMatchFindAction {
      constructor() {
        super({
          id: FIND_IDS.NextSelectionMatchFindAction,
          label: localize("nextSelectionMatchFindAction", "Find Next Selection"),
          alias: "Find Next Selection",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 2048 | 61,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      _run(controller) {
        return controller.moveToNextMatch();
      }
    };
    PreviousSelectionMatchFindAction = class extends SelectionMatchFindAction {
      constructor() {
        super({
          id: FIND_IDS.PreviousSelectionMatchFindAction,
          label: localize("previousSelectionMatchFindAction", "Find Previous Selection"),
          alias: "Find Previous Selection",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 2048 | 1024 | 61,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      _run(controller) {
        return controller.moveToPrevMatch();
      }
    };
    StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
      id: FIND_IDS.StartFindReplaceAction,
      label: localize("startReplace", "Replace"),
      alias: "Replace",
      precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
      kbOpts: {
        kbExpr: null,
        primary: 2048 | 38,
        mac: {
          primary: 2048 | 512 | 36
          /* KEY_F */
        },
        weight: 100
        /* EditorContrib */
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "3_find",
        title: localize({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
        order: 2
      }
    }));
    StartFindReplaceAction.addImplementation(0, (accessor, editor2, args) => {
      if (!editor2.hasModel() || editor2.getOption(
        80
        /* readOnly */
      )) {
        return false;
      }
      const controller = CommonFindController.get(editor2);
      if (!controller) {
        return false;
      }
      const currentSelection = editor2.getSelection();
      const findInputFocused = controller.isFindInputFocused();
      const seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor2.getOption(
        35
        /* find */
      ).seedSearchStringFromSelection !== "never" && !findInputFocused;
      const shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
      return controller.start({
        forceRevealReplace: true,
        seedSearchStringFromSelection: seedSearchStringFromSelection ? "single" : "none",
        seedSearchStringFromNonEmptySelection: editor2.getOption(
          35
          /* find */
        ).seedSearchStringFromSelection === "selection",
        seedSearchStringFromGlobalClipboard: editor2.getOption(
          35
          /* find */
        ).seedSearchStringFromSelection !== "never",
        shouldFocus,
        shouldAnimate: true,
        updateSearchScope: false,
        loop: editor2.getOption(
          35
          /* find */
        ).loop
      });
    });
    registerEditorContribution(CommonFindController.ID, FindController);
    registerEditorAction(StartFindWithSelectionAction);
    registerEditorAction(NextMatchFindAction);
    registerEditorAction(PreviousMatchFindAction);
    registerEditorAction(NextSelectionMatchFindAction);
    registerEditorAction(PreviousSelectionMatchFindAction);
    FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.CloseFindWidgetCommand,
      precondition: CONTEXT_FIND_WIDGET_VISIBLE,
      handler: (x) => x.closeFindWidget(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ToggleCaseSensitiveCommand,
      precondition: void 0,
      handler: (x) => x.toggleCaseSensitive(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: ToggleCaseSensitiveKeybinding.primary,
        mac: ToggleCaseSensitiveKeybinding.mac,
        win: ToggleCaseSensitiveKeybinding.win,
        linux: ToggleCaseSensitiveKeybinding.linux
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ToggleWholeWordCommand,
      precondition: void 0,
      handler: (x) => x.toggleWholeWords(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: ToggleWholeWordKeybinding.primary,
        mac: ToggleWholeWordKeybinding.mac,
        win: ToggleWholeWordKeybinding.win,
        linux: ToggleWholeWordKeybinding.linux
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ToggleRegexCommand,
      precondition: void 0,
      handler: (x) => x.toggleRegex(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: ToggleRegexKeybinding.primary,
        mac: ToggleRegexKeybinding.mac,
        win: ToggleRegexKeybinding.win,
        linux: ToggleRegexKeybinding.linux
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ToggleSearchScopeCommand,
      precondition: void 0,
      handler: (x) => x.toggleSearchScope(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: ToggleSearchScopeKeybinding.primary,
        mac: ToggleSearchScopeKeybinding.mac,
        win: ToggleSearchScopeKeybinding.win,
        linux: ToggleSearchScopeKeybinding.linux
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.TogglePreserveCaseCommand,
      precondition: void 0,
      handler: (x) => x.togglePreserveCase(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: TogglePreserveCaseKeybinding.primary,
        mac: TogglePreserveCaseKeybinding.mac,
        win: TogglePreserveCaseKeybinding.win,
        linux: TogglePreserveCaseKeybinding.linux
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ReplaceOneAction,
      precondition: CONTEXT_FIND_WIDGET_VISIBLE,
      handler: (x) => x.replace(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 22
        /* KEY_1 */
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ReplaceOneAction,
      precondition: CONTEXT_FIND_WIDGET_VISIBLE,
      handler: (x) => x.replace(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
        primary: 3
        /* Enter */
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ReplaceAllAction,
      precondition: CONTEXT_FIND_WIDGET_VISIBLE,
      handler: (x) => x.replaceAll(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 512 | 3
        /* Enter */
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.ReplaceAllAction,
      precondition: CONTEXT_FIND_WIDGET_VISIBLE,
      handler: (x) => x.replaceAll(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
        primary: void 0,
        mac: {
          primary: 2048 | 3
        }
      }
    }));
    registerEditorCommand(new FindCommand({
      id: FIND_IDS.SelectAllMatchesAction,
      precondition: CONTEXT_FIND_WIDGET_VISIBLE,
      handler: (x) => x.selectAllMatches(),
      kbOpts: {
        weight: 100 + 5,
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 3
        /* Enter */
      }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingRanges.js
var MAX_FOLDING_REGIONS, MAX_LINE_NUMBER, MASK_INDENT, FoldingRegions, FoldingRegion;
var init_foldingRanges = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingRanges.js"() {
    MAX_FOLDING_REGIONS = 65535;
    MAX_LINE_NUMBER = 16777215;
    MASK_INDENT = 4278190080;
    FoldingRegions = class {
      constructor(startIndexes, endIndexes, types) {
        if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
          throw new Error("invalid startIndexes or endIndexes size");
        }
        this._startIndexes = startIndexes;
        this._endIndexes = endIndexes;
        this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));
        this._types = types;
        this._parentsComputed = false;
      }
      ensureParentIndices() {
        if (!this._parentsComputed) {
          this._parentsComputed = true;
          let parentIndexes = [];
          let isInsideLast = (startLineNumber, endLineNumber) => {
            let index = parentIndexes[parentIndexes.length - 1];
            return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;
          };
          for (let i = 0, len = this._startIndexes.length; i < len; i++) {
            let startLineNumber = this._startIndexes[i];
            let endLineNumber = this._endIndexes[i];
            if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
              throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
            }
            while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
              parentIndexes.pop();
            }
            let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
            parentIndexes.push(i);
            this._startIndexes[i] = startLineNumber + ((parentIndex & 255) << 24);
            this._endIndexes[i] = endLineNumber + ((parentIndex & 65280) << 16);
          }
        }
      }
      get length() {
        return this._startIndexes.length;
      }
      getStartLineNumber(index) {
        return this._startIndexes[index] & MAX_LINE_NUMBER;
      }
      getEndLineNumber(index) {
        return this._endIndexes[index] & MAX_LINE_NUMBER;
      }
      getType(index) {
        return this._types ? this._types[index] : void 0;
      }
      hasTypes() {
        return !!this._types;
      }
      isCollapsed(index) {
        let arrayIndex = index / 32 | 0;
        let bit = index % 32;
        return (this._collapseStates[arrayIndex] & 1 << bit) !== 0;
      }
      setCollapsed(index, newState) {
        let arrayIndex = index / 32 | 0;
        let bit = index % 32;
        let value = this._collapseStates[arrayIndex];
        if (newState) {
          this._collapseStates[arrayIndex] = value | 1 << bit;
        } else {
          this._collapseStates[arrayIndex] = value & ~(1 << bit);
        }
      }
      setCollapsedAllOfType(type, newState) {
        let hasChanged = false;
        if (this._types) {
          for (let i = 0; i < this._types.length; i++) {
            if (this._types[i] === type) {
              this.setCollapsed(i, newState);
              hasChanged = true;
            }
          }
        }
        return hasChanged;
      }
      toRegion(index) {
        return new FoldingRegion(this, index);
      }
      getParentIndex(index) {
        this.ensureParentIndices();
        let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);
        if (parent === MAX_FOLDING_REGIONS) {
          return -1;
        }
        return parent;
      }
      contains(index, line) {
        return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;
      }
      findIndex(line) {
        let low = 0, high = this._startIndexes.length;
        if (high === 0) {
          return -1;
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (line < this.getStartLineNumber(mid)) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        return low - 1;
      }
      findRange(line) {
        let index = this.findIndex(line);
        if (index >= 0) {
          let endLineNumber = this.getEndLineNumber(index);
          if (endLineNumber >= line) {
            return index;
          }
          index = this.getParentIndex(index);
          while (index !== -1) {
            if (this.contains(index, line)) {
              return index;
            }
            index = this.getParentIndex(index);
          }
        }
        return -1;
      }
      toString() {
        let res = [];
        for (let i = 0; i < this.length; i++) {
          res[i] = `[${this.isCollapsed(i) ? "+" : "-"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;
        }
        return res.join(", ");
      }
    };
    FoldingRegion = class {
      constructor(ranges, index) {
        this.ranges = ranges;
        this.index = index;
      }
      get startLineNumber() {
        return this.ranges.getStartLineNumber(this.index);
      }
      get endLineNumber() {
        return this.ranges.getEndLineNumber(this.index);
      }
      get regionIndex() {
        return this.index;
      }
      get parentIndex() {
        return this.ranges.getParentIndex(this.index);
      }
      get isCollapsed() {
        return this.ranges.isCollapsed(this.index);
      }
      containedBy(range) {
        return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;
      }
      containsLine(lineNumber) {
        return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingModel.js
function toggleCollapseState(foldingModel, levels, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let region = foldingModel.getRegionAtLine(lineNumber);
    if (region) {
      const doCollapse = !region.isCollapsed;
      toToggle.push(region);
      if (levels > 1) {
        let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
        toToggle.push(...regionsInside);
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {
  let toToggle = [];
  if (lineNumbers && lineNumbers.length > 0) {
    for (let lineNumber of lineNumbers) {
      let region = foldingModel.getRegionAtLine(lineNumber);
      if (region) {
        if (region.isCollapsed !== doCollapse) {
          toToggle.push(region);
        }
        if (levels > 1) {
          let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
          toToggle.push(...regionsInside);
        }
      }
    }
  } else {
    let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);
    toToggle.push(...regionsInside);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);
    toToggle.push(...regions);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);
    if (regions.length > 0) {
      toToggle.push(regions[0]);
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
  let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some((line) => region.containsLine(line));
  let toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {
  let filteredRegions = [];
  for (let lineNumber of blockedLineNumbers) {
    filteredRegions.push(foldingModel.getAllRegionsAtLine(lineNumber, void 0)[0]);
  }
  let filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;
  let toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
  let editorModel = foldingModel.textModel;
  let regions = foldingModel.regions;
  let toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i)) {
      let startLineNumber = regions.getStartLineNumber(i);
      if (regExp.test(editorModel.getLineContent(startLineNumber))) {
        toToggle.push(regions.toRegion(i));
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForType(foldingModel, type, doCollapse) {
  let regions = foldingModel.regions;
  let toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {
      toToggle.push(regions.toRegion(i));
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function getParentFoldLine(lineNumber, foldingModel) {
  let startLineNumber = null;
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null) {
    startLineNumber = foldingRegion.startLineNumber;
    if (lineNumber === startLineNumber) {
      let parentFoldingIdx = foldingRegion.parentIndex;
      if (parentFoldingIdx !== -1) {
        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);
      } else {
        startLineNumber = null;
      }
    }
  }
  return startLineNumber;
}
function getPreviousFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    if (lineNumber !== foldingRegion.startLineNumber) {
      return foldingRegion.startLineNumber;
    } else {
      let expectedParentIndex = foldingRegion.parentIndex;
      let minLineNumber = 0;
      if (expectedParentIndex !== -1) {
        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);
      }
      while (foldingRegion !== null) {
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
          if (foldingRegion.startLineNumber <= minLineNumber) {
            return null;
          } else if (foldingRegion.parentIndex === expectedParentIndex) {
            return foldingRegion.startLineNumber;
          }
        } else {
          return null;
        }
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber < lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
function getNextFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    let expectedParentIndex = foldingRegion.parentIndex;
    let maxLineNumber = 0;
    if (expectedParentIndex !== -1) {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);
    } else if (foldingModel.regions.length === 0) {
      return null;
    } else {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);
    }
    while (foldingRegion !== null) {
      if (foldingRegion.regionIndex < foldingModel.regions.length) {
        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        if (foldingRegion.startLineNumber >= maxLineNumber) {
          return null;
        } else if (foldingRegion.parentIndex === expectedParentIndex) {
          return foldingRegion.startLineNumber;
        }
      } else {
        return null;
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(0);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber > lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex < foldingModel.regions.length) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
var FoldingModel;
var init_foldingModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingModel.js"() {
    init_event();
    init_foldingRanges();
    FoldingModel = class {
      constructor(textModel, decorationProvider) {
        this._updateEventEmitter = new Emitter();
        this.onDidChange = this._updateEventEmitter.event;
        this._textModel = textModel;
        this._decorationProvider = decorationProvider;
        this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
        this._editorDecorationIds = [];
        this._isInitialized = false;
      }
      get regions() {
        return this._regions;
      }
      get textModel() {
        return this._textModel;
      }
      get isInitialized() {
        return this._isInitialized;
      }
      toggleCollapseState(toggledRegions) {
        if (!toggledRegions.length) {
          return;
        }
        toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
        const processed = {};
        this._decorationProvider.changeDecorations((accessor) => {
          let k = 0;
          let dirtyRegionEndLine = -1;
          let lastHiddenLine = -1;
          const updateDecorationsUntil = (index) => {
            while (k < index) {
              const endLineNumber = this._regions.getEndLineNumber(k);
              const isCollapsed = this._regions.isCollapsed(k);
              if (endLineNumber <= dirtyRegionEndLine) {
                accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));
              }
              if (isCollapsed && endLineNumber > lastHiddenLine) {
                lastHiddenLine = endLineNumber;
              }
              k++;
            }
          };
          for (let region of toggledRegions) {
            let index = region.regionIndex;
            let editorDecorationId = this._editorDecorationIds[index];
            if (editorDecorationId && !processed[editorDecorationId]) {
              processed[editorDecorationId] = true;
              updateDecorationsUntil(index);
              let newCollapseState = !this._regions.isCollapsed(index);
              this._regions.setCollapsed(index, newCollapseState);
              dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));
            }
          }
          updateDecorationsUntil(this._regions.length);
        });
        this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });
      }
      update(newRegions, blockedLineNumers = []) {
        let newEditorDecorations = [];
        let isBlocked = (startLineNumber, endLineNumber) => {
          for (let blockedLineNumber of blockedLineNumers) {
            if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {
              return true;
            }
          }
          return false;
        };
        let lastHiddenLine = -1;
        let initRange = (index, isCollapsed) => {
          const startLineNumber = newRegions.getStartLineNumber(index);
          const endLineNumber = newRegions.getEndLineNumber(index);
          if (!isCollapsed) {
            isCollapsed = newRegions.isCollapsed(index);
          }
          if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {
            isCollapsed = false;
          }
          newRegions.setCollapsed(index, isCollapsed);
          const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);
          const decorationRange = {
            startLineNumber,
            startColumn: Math.max(maxColumn - 1, 1),
            endLineNumber: startLineNumber,
            endColumn: maxColumn
          };
          newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine) });
          if (isCollapsed && endLineNumber > lastHiddenLine) {
            lastHiddenLine = endLineNumber;
          }
        };
        let i = 0;
        let nextCollapsed = () => {
          while (i < this._regions.length) {
            let isCollapsed = this._regions.isCollapsed(i);
            i++;
            if (isCollapsed) {
              return i - 1;
            }
          }
          return -1;
        };
        let k = 0;
        let collapsedIndex = nextCollapsed();
        while (collapsedIndex !== -1 && k < newRegions.length) {
          let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);
          if (decRange) {
            let collapsedStartLineNumber = decRange.startLineNumber;
            if (decRange.startColumn === Math.max(decRange.endColumn - 1, 1) && this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.endColumn) {
              while (k < newRegions.length) {
                let startLineNumber = newRegions.getStartLineNumber(k);
                if (collapsedStartLineNumber >= startLineNumber) {
                  initRange(k, collapsedStartLineNumber === startLineNumber);
                  k++;
                } else {
                  break;
                }
              }
            }
          }
          collapsedIndex = nextCollapsed();
        }
        while (k < newRegions.length) {
          initRange(k, false);
          k++;
        }
        this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);
        this._regions = newRegions;
        this._isInitialized = true;
        this._updateEventEmitter.fire({ model: this });
      }
      /**
       * Collapse state memento, for persistence only
       */
      getMemento() {
        let collapsedRanges = [];
        for (let i = 0; i < this._regions.length; i++) {
          if (this._regions.isCollapsed(i)) {
            let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
            if (range) {
              let startLineNumber = range.startLineNumber;
              let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);
              collapsedRanges.push({ startLineNumber, endLineNumber });
            }
          }
        }
        if (collapsedRanges.length > 0) {
          return collapsedRanges;
        }
        return void 0;
      }
      /**
       * Apply persisted state, for persistence only
       */
      applyMemento(state) {
        if (!Array.isArray(state)) {
          return;
        }
        let toToogle = [];
        for (let range of state) {
          let region = this.getRegionAtLine(range.startLineNumber);
          if (region && !region.isCollapsed) {
            toToogle.push(region);
          }
        }
        this.toggleCollapseState(toToogle);
      }
      dispose() {
        this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);
      }
      getAllRegionsAtLine(lineNumber, filter) {
        let result = [];
        if (this._regions) {
          let index = this._regions.findRange(lineNumber);
          let level = 1;
          while (index >= 0) {
            let current = this._regions.toRegion(index);
            if (!filter || filter(current, level)) {
              result.push(current);
            }
            level++;
            index = current.parentIndex;
          }
        }
        return result;
      }
      getRegionAtLine(lineNumber) {
        if (this._regions) {
          let index = this._regions.findRange(lineNumber);
          if (index >= 0) {
            return this._regions.toRegion(index);
          }
        }
        return null;
      }
      getRegionsInside(region, filter) {
        let result = [];
        let index = region ? region.regionIndex + 1 : 0;
        let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
        if (filter && filter.length === 2) {
          const levelStack = [];
          for (let i = index, len = this._regions.length; i < len; i++) {
            let current = this._regions.toRegion(i);
            if (this._regions.getStartLineNumber(i) < endLineNumber) {
              while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {
                levelStack.pop();
              }
              levelStack.push(current);
              if (filter(current, levelStack.length)) {
                result.push(current);
              }
            } else {
              break;
            }
          }
        } else {
          for (let i = index, len = this._regions.length; i < len; i++) {
            let current = this._regions.toRegion(i);
            if (this._regions.getStartLineNumber(i) < endLineNumber) {
              if (!filter || filter(current)) {
                result.push(current);
              }
            } else {
              break;
            }
          }
        }
        return result;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/hiddenRangeModel.js
function isInside(line, range) {
  return line >= range.startLineNumber && line <= range.endLineNumber;
}
function findRange(ranges, line) {
  let i = findFirstInSorted(ranges, (r) => line < r.startLineNumber) - 1;
  if (i >= 0 && ranges[i].endLineNumber >= line) {
    return ranges[i];
  }
  return null;
}
var HiddenRangeModel;
var init_hiddenRangeModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/hiddenRangeModel.js"() {
    init_arrays();
    init_event();
    init_range();
    HiddenRangeModel = class {
      constructor(model) {
        this._updateEventEmitter = new Emitter();
        this._foldingModel = model;
        this._foldingModelListener = model.onDidChange((_) => this.updateHiddenRanges());
        this._hiddenRanges = [];
        if (model.regions.length) {
          this.updateHiddenRanges();
        }
      }
      get onDidChange() {
        return this._updateEventEmitter.event;
      }
      get hiddenRanges() {
        return this._hiddenRanges;
      }
      updateHiddenRanges() {
        let updateHiddenAreas = false;
        let newHiddenAreas = [];
        let i = 0;
        let k = 0;
        let lastCollapsedStart = Number.MAX_VALUE;
        let lastCollapsedEnd = -1;
        let ranges = this._foldingModel.regions;
        for (; i < ranges.length; i++) {
          if (!ranges.isCollapsed(i)) {
            continue;
          }
          let startLineNumber = ranges.getStartLineNumber(i) + 1;
          let endLineNumber = ranges.getEndLineNumber(i);
          if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
            continue;
          }
          if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
            newHiddenAreas.push(this._hiddenRanges[k]);
            k++;
          } else {
            updateHiddenAreas = true;
            newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));
          }
          lastCollapsedStart = startLineNumber;
          lastCollapsedEnd = endLineNumber;
        }
        if (updateHiddenAreas || k < this._hiddenRanges.length) {
          this.applyHiddenRanges(newHiddenAreas);
        }
      }
      applyMemento(state) {
        if (!Array.isArray(state) || state.length === 0) {
          return false;
        }
        let hiddenRanges = [];
        for (let r of state) {
          if (!r.startLineNumber || !r.endLineNumber) {
            return false;
          }
          hiddenRanges.push(new Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));
        }
        this.applyHiddenRanges(hiddenRanges);
        return true;
      }
      /**
       * Collapse state memento, for persistence only, only used if folding model is not yet initialized
       */
      getMemento() {
        return this._hiddenRanges.map((r) => ({ startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber }));
      }
      applyHiddenRanges(newHiddenAreas) {
        this._hiddenRanges = newHiddenAreas;
        this._updateEventEmitter.fire(newHiddenAreas);
      }
      hasRanges() {
        return this._hiddenRanges.length > 0;
      }
      isHidden(line) {
        return findRange(this._hiddenRanges, line) !== null;
      }
      adjustSelections(selections) {
        let hasChanges = false;
        let editorModel = this._foldingModel.textModel;
        let lastRange = null;
        let adjustLine = (line) => {
          if (!lastRange || !isInside(line, lastRange)) {
            lastRange = findRange(this._hiddenRanges, line);
          }
          if (lastRange) {
            return lastRange.startLineNumber - 1;
          }
          return null;
        };
        for (let i = 0, len = selections.length; i < len; i++) {
          let selection = selections[i];
          let adjustedStartLine = adjustLine(selection.startLineNumber);
          if (adjustedStartLine) {
            selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
            hasChanges = true;
          }
          let adjustedEndLine = adjustLine(selection.endLineNumber);
          if (adjustedEndLine) {
            selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
            hasChanges = true;
          }
          selections[i] = selection;
        }
        return hasChanges;
      }
      dispose() {
        if (this.hiddenRanges.length > 0) {
          this._hiddenRanges = [];
          this._updateEventEmitter.fire(this._hiddenRanges);
        }
        if (this._foldingModelListener) {
          this._foldingModelListener.dispose();
          this._foldingModelListener = null;
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/indentRangeProvider.js
function computeRanges(model, offSide, markers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT) {
  const tabSize = model.getOptions().tabSize;
  let result = new RangesCollector(foldingRangesLimit);
  let pattern = void 0;
  if (markers) {
    pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);
  }
  let previousRegions = [];
  let line = model.getLineCount() + 1;
  previousRegions.push({ indent: -1, endAbove: line, line });
  for (let line2 = model.getLineCount(); line2 > 0; line2--) {
    let lineContent = model.getLineContent(line2);
    let indent = TextModel.computeIndentLevel(lineContent, tabSize);
    let previous = previousRegions[previousRegions.length - 1];
    if (indent === -1) {
      if (offSide) {
        previous.endAbove = line2;
      }
      continue;
    }
    let m;
    if (pattern && (m = lineContent.match(pattern))) {
      if (m[1]) {
        let i = previousRegions.length - 1;
        while (i > 0 && previousRegions[i].indent !== -2) {
          i--;
        }
        if (i > 0) {
          previousRegions.length = i + 1;
          previous = previousRegions[i];
          result.insertFirst(line2, previous.line, indent);
          previous.line = line2;
          previous.indent = indent;
          previous.endAbove = line2;
          continue;
        } else {
        }
      } else {
        previousRegions.push({ indent: -2, endAbove: line2, line: line2 });
        continue;
      }
    }
    if (previous.indent > indent) {
      do {
        previousRegions.pop();
        previous = previousRegions[previousRegions.length - 1];
      } while (previous.indent > indent);
      let endLineNumber = previous.endAbove - 1;
      if (endLineNumber - line2 >= 1) {
        result.insertFirst(line2, endLineNumber, indent);
      }
    }
    if (previous.indent === indent) {
      previous.endAbove = line2;
    } else {
      previousRegions.push({ indent, endAbove: line2, line: line2 });
    }
  }
  return result.toIndentRanges(model);
}
var MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT, ID_INDENT_PROVIDER, IndentRangeProvider, RangesCollector;
var init_indentRangeProvider = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/indentRangeProvider.js"() {
    init_textModel();
    init_languageConfigurationRegistry();
    init_foldingRanges();
    MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5e3;
    ID_INDENT_PROVIDER = "indent";
    IndentRangeProvider = class {
      constructor(editorModel) {
        this.editorModel = editorModel;
        this.id = ID_INDENT_PROVIDER;
      }
      dispose() {
      }
      compute(cancelationToken) {
        let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageIdentifier().id);
        let offSide = foldingRules && !!foldingRules.offSide;
        let markers = foldingRules && foldingRules.markers;
        return Promise.resolve(computeRanges(this.editorModel, offSide, markers));
      }
    };
    RangesCollector = class {
      constructor(foldingRangesLimit) {
        this._startIndexes = [];
        this._endIndexes = [];
        this._indentOccurrences = [];
        this._length = 0;
        this._foldingRangesLimit = foldingRangesLimit;
      }
      insertFirst(startLineNumber, endLineNumber, indent) {
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          return;
        }
        let index = this._length;
        this._startIndexes[index] = startLineNumber;
        this._endIndexes[index] = endLineNumber;
        this._length++;
        if (indent < 1e3) {
          this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
        }
      }
      toIndentRanges(model) {
        if (this._length <= this._foldingRangesLimit) {
          let startIndexes = new Uint32Array(this._length);
          let endIndexes = new Uint32Array(this._length);
          for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
            startIndexes[k] = this._startIndexes[i];
            endIndexes[k] = this._endIndexes[i];
          }
          return new FoldingRegions(startIndexes, endIndexes);
        } else {
          let entries = 0;
          let maxIndent = this._indentOccurrences.length;
          for (let i = 0; i < this._indentOccurrences.length; i++) {
            let n = this._indentOccurrences[i];
            if (n) {
              if (n + entries > this._foldingRangesLimit) {
                maxIndent = i;
                break;
              }
              entries += n;
            }
          }
          const tabSize = model.getOptions().tabSize;
          let startIndexes = new Uint32Array(this._foldingRangesLimit);
          let endIndexes = new Uint32Array(this._foldingRangesLimit);
          for (let i = this._length - 1, k = 0; i >= 0; i--) {
            let startIndex = this._startIndexes[i];
            let lineContent = model.getLineContent(startIndex);
            let indent = TextModel.computeIndentLevel(lineContent, tabSize);
            if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {
              startIndexes[k] = startIndex;
              endIndexes[k] = this._endIndexes[i];
              k++;
            }
          }
          return new FoldingRegions(startIndexes, endIndexes);
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/syntaxRangeProvider.js
function collectSyntaxRanges(providers, model, cancellationToken) {
  let rangeData = null;
  let promises = providers.map((provider, i) => {
    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then((ranges) => {
      if (cancellationToken.isCancellationRequested) {
        return;
      }
      if (Array.isArray(ranges)) {
        if (!Array.isArray(rangeData)) {
          rangeData = [];
        }
        let nLines = model.getLineCount();
        for (let r of ranges) {
          if (r.start > 0 && r.end > r.start && r.end <= nLines) {
            rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
          }
        }
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then((_) => {
    return rangeData;
  });
}
function sanitizeRanges(rangeData, limit) {
  let sorted = rangeData.sort((d1, d2) => {
    let diff = d1.start - d2.start;
    if (diff === 0) {
      diff = d1.rank - d2.rank;
    }
    return diff;
  });
  let collector = new RangesCollector2(limit);
  let top = void 0;
  let previous = [];
  for (let entry of sorted) {
    if (!top) {
      top = entry;
      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
    } else {
      if (entry.start > top.start) {
        if (entry.end <= top.end) {
          previous.push(top);
          top = entry;
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        } else {
          if (entry.start > top.end) {
            do {
              top = previous.pop();
            } while (top && entry.start > top.end);
            if (top) {
              previous.push(top);
            }
            top = entry;
          }
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        }
      }
    }
  }
  return collector.toIndentRanges();
}
var MAX_FOLDING_REGIONS2, foldingContext, ID_SYNTAX_PROVIDER, SyntaxRangeProvider, RangesCollector2;
var init_syntaxRangeProvider = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/syntaxRangeProvider.js"() {
    init_errors();
    init_lifecycle();
    init_foldingRanges();
    MAX_FOLDING_REGIONS2 = 5e3;
    foldingContext = {};
    ID_SYNTAX_PROVIDER = "syntax";
    SyntaxRangeProvider = class {
      constructor(editorModel, providers, handleFoldingRangesChange, limit = MAX_FOLDING_REGIONS2) {
        this.editorModel = editorModel;
        this.providers = providers;
        this.limit = limit;
        this.id = ID_SYNTAX_PROVIDER;
        for (const provider of providers) {
          if (typeof provider.onDidChange === "function") {
            if (!this.disposables) {
              this.disposables = new DisposableStore();
            }
            this.disposables.add(provider.onDidChange(handleFoldingRangesChange));
          }
        }
      }
      compute(cancellationToken) {
        return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then((ranges) => {
          if (ranges) {
            let res = sanitizeRanges(ranges, this.limit);
            return res;
          }
          return null;
        });
      }
      dispose() {
        var _a5;
        (_a5 = this.disposables) === null || _a5 === void 0 ? void 0 : _a5.dispose();
      }
    };
    RangesCollector2 = class {
      constructor(foldingRangesLimit) {
        this._startIndexes = [];
        this._endIndexes = [];
        this._nestingLevels = [];
        this._nestingLevelCounts = [];
        this._types = [];
        this._length = 0;
        this._foldingRangesLimit = foldingRangesLimit;
      }
      add(startLineNumber, endLineNumber, type, nestingLevel) {
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          return;
        }
        let index = this._length;
        this._startIndexes[index] = startLineNumber;
        this._endIndexes[index] = endLineNumber;
        this._nestingLevels[index] = nestingLevel;
        this._types[index] = type;
        this._length++;
        if (nestingLevel < 30) {
          this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
        }
      }
      toIndentRanges() {
        if (this._length <= this._foldingRangesLimit) {
          let startIndexes = new Uint32Array(this._length);
          let endIndexes = new Uint32Array(this._length);
          for (let i = 0; i < this._length; i++) {
            startIndexes[i] = this._startIndexes[i];
            endIndexes[i] = this._endIndexes[i];
          }
          return new FoldingRegions(startIndexes, endIndexes, this._types);
        } else {
          let entries = 0;
          let maxLevel = this._nestingLevelCounts.length;
          for (let i = 0; i < this._nestingLevelCounts.length; i++) {
            let n = this._nestingLevelCounts[i];
            if (n) {
              if (n + entries > this._foldingRangesLimit) {
                maxLevel = i;
                break;
              }
              entries += n;
            }
          }
          let startIndexes = new Uint32Array(this._foldingRangesLimit);
          let endIndexes = new Uint32Array(this._foldingRangesLimit);
          let types = [];
          for (let i = 0, k = 0; i < this._length; i++) {
            let level = this._nestingLevels[i];
            if (level < maxLevel || level === maxLevel && entries++ < this._foldingRangesLimit) {
              startIndexes[k] = this._startIndexes[i];
              endIndexes[k] = this._endIndexes[i];
              types[k] = this._types[i];
              k++;
            }
          }
          return new FoldingRegions(startIndexes, endIndexes, types);
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/intializingRangeProvider.js
var ID_INIT_PROVIDER, InitializingRangeProvider;
var init_intializingRangeProvider = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/intializingRangeProvider.js"() {
    init_syntaxRangeProvider();
    ID_INIT_PROVIDER = "init";
    InitializingRangeProvider = class {
      constructor(editorModel, initialRanges, onTimeout, timeoutTime) {
        this.editorModel = editorModel;
        this.id = ID_INIT_PROVIDER;
        if (initialRanges.length) {
          let toDecorationRange = (range) => {
            return {
              range: {
                startLineNumber: range.startLineNumber,
                startColumn: 0,
                endLineNumber: range.endLineNumber,
                endColumn: editorModel.getLineLength(range.endLineNumber)
              },
              options: {
                description: "folding-initializing-range-provider",
                stickiness: 1
                /* NeverGrowsWhenTypingAtEdges */
              }
            };
          };
          this.decorationIds = editorModel.deltaDecorations([], initialRanges.map(toDecorationRange));
          this.timeout = setTimeout(onTimeout, timeoutTime);
        }
      }
      dispose() {
        if (this.decorationIds) {
          this.editorModel.deltaDecorations(this.decorationIds, []);
          this.decorationIds = void 0;
        }
        if (typeof this.timeout === "number") {
          clearTimeout(this.timeout);
          this.timeout = void 0;
        }
      }
      compute(cancelationToken) {
        let foldingRangeData = [];
        if (this.decorationIds) {
          for (let id of this.decorationIds) {
            let range = this.editorModel.getDecorationRange(id);
            if (range) {
              foldingRangeData.push({ start: range.startLineNumber, end: range.endLineNumber, rank: 1 });
            }
          }
        }
        return Promise.resolve(sanitizeRanges(foldingRangeData, Number.MAX_VALUE));
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingDecorations.js
var foldingExpandedIcon, foldingCollapsedIcon, FoldingDecorationProvider;
var init_foldingDecorations = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingDecorations.js"() {
    init_codicons();
    init_textModel();
    init_nls();
    init_iconRegistry();
    init_themeService();
    foldingExpandedIcon = registerIcon("folding-expanded", Codicon.chevronDown, localize("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin."));
    foldingCollapsedIcon = registerIcon("folding-collapsed", Codicon.chevronRight, localize("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin."));
    FoldingDecorationProvider = class _FoldingDecorationProvider {
      constructor(editor2) {
        this.editor = editor2;
        this.autoHideFoldingControls = true;
        this.showFoldingHighlights = true;
      }
      getDecorationOption(isCollapsed, isHidden) {
        if (isHidden) {
          return _FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;
        }
        if (isCollapsed) {
          return this.showFoldingHighlights ? _FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : _FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
        } else if (this.autoHideFoldingControls) {
          return _FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
        } else {
          return _FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
        }
      }
      deltaDecorations(oldDecorations, newDecorations) {
        return this.editor.deltaDecorations(oldDecorations, newDecorations);
      }
      changeDecorations(callback) {
        return this.editor.changeDecorations(callback);
      }
    };
    FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
      description: "folding-collapsed-visual-decoration",
      stickiness: 1,
      afterContentClassName: "inline-folded",
      isWholeLine: true,
      firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
    });
    FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
      description: "folding-collapsed-highlighted-visual-decoration",
      stickiness: 1,
      afterContentClassName: "inline-folded",
      className: "folded-background",
      isWholeLine: true,
      firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
    });
    FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
      description: "folding-expanded-auto-hide-visual-decoration",
      stickiness: 1,
      isWholeLine: true,
      firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon)
    });
    FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
      description: "folding-expanded-visual-decoration",
      stickiness: 1,
      isWholeLine: true,
      firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingExpandedIcon)
    });
    FoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({
      description: "folding-hidden-range-decoration",
      stickiness: 1
      /* NeverGrowsWhenTypingAtEdges */
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/folding.js
function foldingArgumentsConstraint(args) {
  if (!isUndefined(args)) {
    if (!isObject(args)) {
      return false;
    }
    const foldingArgs = args;
    if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) {
      return false;
    }
    if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) {
      return false;
    }
    if (!isUndefined(foldingArgs.selectionLines) && (!isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) {
      return false;
    }
  }
  return true;
}
var __decorate45, __param45, CONTEXT_FOLDING_ENABLED, FoldingController, FoldingAction, UnfoldAction, UnFoldRecursivelyAction, FoldAction, ToggleFoldAction, FoldRecursivelyAction, FoldAllBlockCommentsAction, FoldAllRegionsAction, UnfoldAllRegionsAction, FoldAllRegionsExceptAction, UnfoldAllRegionsExceptAction, FoldAllAction, UnfoldAllAction, FoldLevelAction, GotoParentFoldAction, GotoPreviousFoldAction, GotoNextFoldAction, foldBackgroundBackground, editorFoldForeground;
var init_folding = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/folding/folding.js"() {
    init_async();
    init_errors();
    init_keyCodes();
    init_lifecycle();
    init_strings();
    init_types();
    init_editorState();
    init_editorExtensions();
    init_editorContextKeys();
    init_modes();
    init_languageConfigurationRegistry();
    init_foldingModel();
    init_hiddenRangeModel();
    init_indentRangeProvider();
    init_intializingRangeProvider();
    init_nls();
    init_contextkey();
    init_colorRegistry();
    init_themeService();
    init_foldingDecorations();
    init_syntaxRangeProvider();
    __decorate45 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param45 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    CONTEXT_FOLDING_ENABLED = new RawContextKey("foldingEnabled", false);
    FoldingController = class FoldingController2 extends Disposable {
      constructor(editor2, contextKeyService) {
        super();
        this.contextKeyService = contextKeyService;
        this.localToDispose = this._register(new DisposableStore());
        this.editor = editor2;
        const options = this.editor.getOptions();
        this._isEnabled = options.get(
          37
          /* folding */
        );
        this._useFoldingProviders = options.get(
          38
          /* foldingStrategy */
        ) !== "indentation";
        this._unfoldOnClickAfterEndOfLine = options.get(
          41
          /* unfoldOnClickAfterEndOfLine */
        );
        this._restoringViewState = false;
        this._currentModelHasFoldedImports = false;
        this._foldingImportsByDefault = options.get(
          40
          /* foldingImportsByDefault */
        );
        this.foldingModel = null;
        this.hiddenRangeModel = null;
        this.rangeProvider = null;
        this.foldingRegionPromise = null;
        this.foldingStateMemento = null;
        this.foldingModelPromise = null;
        this.updateScheduler = null;
        this.cursorChangedScheduler = null;
        this.mouseDownInfo = null;
        this.foldingDecorationProvider = new FoldingDecorationProvider(editor2);
        this.foldingDecorationProvider.autoHideFoldingControls = options.get(
          98
          /* showFoldingControls */
        ) === "mouseover";
        this.foldingDecorationProvider.showFoldingHighlights = options.get(
          39
          /* foldingHighlight */
        );
        this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);
        this.foldingEnabled.set(this._isEnabled);
        this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
        this._register(this.editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            37
            /* folding */
          )) {
            this._isEnabled = this.editor.getOptions().get(
              37
              /* folding */
            );
            this.foldingEnabled.set(this._isEnabled);
            this.onModelChanged();
          }
          if (e.hasChanged(
            98
            /* showFoldingControls */
          ) || e.hasChanged(
            39
            /* foldingHighlight */
          )) {
            const options2 = this.editor.getOptions();
            this.foldingDecorationProvider.autoHideFoldingControls = options2.get(
              98
              /* showFoldingControls */
            ) === "mouseover";
            this.foldingDecorationProvider.showFoldingHighlights = options2.get(
              39
              /* foldingHighlight */
            );
            this.onModelContentChanged();
          }
          if (e.hasChanged(
            38
            /* foldingStrategy */
          )) {
            this._useFoldingProviders = this.editor.getOptions().get(
              38
              /* foldingStrategy */
            ) !== "indentation";
            this.onFoldingStrategyChanged();
          }
          if (e.hasChanged(
            41
            /* unfoldOnClickAfterEndOfLine */
          )) {
            this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(
              41
              /* unfoldOnClickAfterEndOfLine */
            );
          }
          if (e.hasChanged(
            40
            /* foldingImportsByDefault */
          )) {
            this._foldingImportsByDefault = this.editor.getOptions().get(
              40
              /* foldingImportsByDefault */
            );
          }
        }));
        this.onModelChanged();
      }
      static get(editor2) {
        return editor2.getContribution(FoldingController2.ID);
      }
      /**
       * Store view state.
       */
      saveViewState() {
        let model = this.editor.getModel();
        if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
          return {};
        }
        if (this.foldingModel) {
          let collapsedRegions = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento();
          let provider = this.rangeProvider ? this.rangeProvider.id : void 0;
          return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };
        }
        return void 0;
      }
      /**
       * Restore view state.
       */
      restoreViewState(state) {
        let model = this.editor.getModel();
        if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {
          return;
        }
        if (!state || state.lineCount !== model.getLineCount()) {
          return;
        }
        this._currentModelHasFoldedImports = !!state.foldedImports;
        if (!state.collapsedRegions) {
          return;
        }
        if (state.provider === ID_SYNTAX_PROVIDER || state.provider === ID_INIT_PROVIDER) {
          this.foldingStateMemento = state;
        }
        const collapsedRegions = state.collapsedRegions;
        if (this.hiddenRangeModel.applyMemento(collapsedRegions)) {
          const foldingModel = this.getFoldingModel();
          if (foldingModel) {
            foldingModel.then((foldingModel2) => {
              if (foldingModel2) {
                this._restoringViewState = true;
                try {
                  foldingModel2.applyMemento(collapsedRegions);
                } finally {
                  this._restoringViewState = false;
                }
              }
            }).then(void 0, onUnexpectedError);
          }
        }
      }
      onModelChanged() {
        this.localToDispose.clear();
        let model = this.editor.getModel();
        if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {
          return;
        }
        this._currentModelHasFoldedImports = false;
        this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
        this.localToDispose.add(this.foldingModel);
        this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
        this.localToDispose.add(this.hiddenRangeModel);
        this.localToDispose.add(this.hiddenRangeModel.onDidChange((hr) => this.onHiddenRangesChanges(hr)));
        this.updateScheduler = new Delayer(200);
        this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);
        this.localToDispose.add(this.cursorChangedScheduler);
        this.localToDispose.add(FoldingRangeProviderRegistry.onDidChange(() => this.onFoldingStrategyChanged()));
        this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged()));
        this.localToDispose.add(this.editor.onDidChangeModelContent(() => this.onModelContentChanged()));
        this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));
        this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
        this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
        this.localToDispose.add({
          dispose: () => {
            if (this.foldingRegionPromise) {
              this.foldingRegionPromise.cancel();
              this.foldingRegionPromise = null;
            }
            if (this.updateScheduler) {
              this.updateScheduler.cancel();
            }
            this.updateScheduler = null;
            this.foldingModel = null;
            this.foldingModelPromise = null;
            this.hiddenRangeModel = null;
            this.cursorChangedScheduler = null;
            this.foldingStateMemento = null;
            if (this.rangeProvider) {
              this.rangeProvider.dispose();
            }
            this.rangeProvider = null;
          }
        });
        this.onModelContentChanged();
      }
      onFoldingStrategyChanged() {
        if (this.rangeProvider) {
          this.rangeProvider.dispose();
        }
        this.rangeProvider = null;
        this.onModelContentChanged();
      }
      getRangeProvider(editorModel) {
        if (this.rangeProvider) {
          return this.rangeProvider;
        }
        this.rangeProvider = new IndentRangeProvider(editorModel);
        if (this._useFoldingProviders && this.foldingModel) {
          let foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);
          if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
            const rangeProvider = this.rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, () => {
              this.foldingStateMemento = null;
              this.onFoldingStrategyChanged();
            }, 3e4);
            return rangeProvider;
          } else if (foldingProviders.length > 0) {
            this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, () => this.onModelContentChanged());
          }
        }
        this.foldingStateMemento = null;
        return this.rangeProvider;
      }
      getFoldingModel() {
        return this.foldingModelPromise;
      }
      onModelContentChanged() {
        if (this.updateScheduler) {
          if (this.foldingRegionPromise) {
            this.foldingRegionPromise.cancel();
            this.foldingRegionPromise = null;
          }
          this.foldingModelPromise = this.updateScheduler.trigger(() => {
            const foldingModel = this.foldingModel;
            if (!foldingModel) {
              return null;
            }
            const provider = this.getRangeProvider(foldingModel.textModel);
            let foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise((token) => provider.compute(token));
            return foldingRegionPromise.then((foldingRanges) => {
              if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) {
                let scrollState;
                if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
                  const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);
                  if (hasChanges) {
                    scrollState = StableEditorScrollState.capture(this.editor);
                    this._currentModelHasFoldedImports = hasChanges;
                  }
                }
                let selections = this.editor.getSelections();
                let selectionLineNumbers = selections ? selections.map((s) => s.startLineNumber) : [];
                foldingModel.update(foldingRanges, selectionLineNumbers);
                if (scrollState) {
                  scrollState.restore(this.editor);
                }
              }
              return foldingModel;
            });
          }).then(void 0, (err) => {
            onUnexpectedError(err);
            return null;
          });
        }
      }
      onHiddenRangesChanges(hiddenRanges) {
        if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {
          let selections = this.editor.getSelections();
          if (selections) {
            if (this.hiddenRangeModel.adjustSelections(selections)) {
              this.editor.setSelections(selections);
            }
          }
        }
        this.editor.setHiddenAreas(hiddenRanges);
      }
      onCursorPositionChanged() {
        if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {
          this.cursorChangedScheduler.schedule();
        }
      }
      revealCursor() {
        const foldingModel = this.getFoldingModel();
        if (!foldingModel) {
          return;
        }
        foldingModel.then((foldingModel2) => {
          if (foldingModel2) {
            let selections = this.editor.getSelections();
            if (selections && selections.length > 0) {
              let toToggle = [];
              for (let selection of selections) {
                let lineNumber = selection.selectionStartLineNumber;
                if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {
                  toToggle.push(...foldingModel2.getAllRegionsAtLine(lineNumber, (r) => r.isCollapsed && lineNumber > r.startLineNumber));
                }
              }
              if (toToggle.length) {
                foldingModel2.toggleCollapseState(toToggle);
                this.reveal(selections[0].getPosition());
              }
            }
          }
        }).then(void 0, onUnexpectedError);
      }
      onEditorMouseDown(e) {
        this.mouseDownInfo = null;
        if (!this.hiddenRangeModel || !e.target || !e.target.range) {
          return;
        }
        if (!e.event.leftButton && !e.event.middleButton) {
          return;
        }
        const range = e.target.range;
        let iconClicked = false;
        switch (e.target.type) {
          case 4:
            const data = e.target.detail;
            const offsetLeftInGutter = e.target.element.offsetLeft;
            const gutterOffsetX = data.offsetX - offsetLeftInGutter;
            if (gutterOffsetX < 5) {
              return;
            }
            iconClicked = true;
            break;
          case 7: {
            if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {
              const data2 = e.target.detail;
              if (!data2.isAfterLines) {
                break;
              }
            }
            return;
          }
          case 6: {
            if (this.hiddenRangeModel.hasRanges()) {
              let model = this.editor.getModel();
              if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
                break;
              }
            }
            return;
          }
          default:
            return;
        }
        this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };
      }
      onEditorMouseUp(e) {
        const foldingModel = this.getFoldingModel();
        if (!foldingModel || !this.mouseDownInfo || !e.target) {
          return;
        }
        let lineNumber = this.mouseDownInfo.lineNumber;
        let iconClicked = this.mouseDownInfo.iconClicked;
        let range = e.target.range;
        if (!range || range.startLineNumber !== lineNumber) {
          return;
        }
        if (iconClicked) {
          if (e.target.type !== 4) {
            return;
          }
        } else {
          let model = this.editor.getModel();
          if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {
            return;
          }
        }
        foldingModel.then((foldingModel2) => {
          if (foldingModel2) {
            let region = foldingModel2.getRegionAtLine(lineNumber);
            if (region && region.startLineNumber === lineNumber) {
              let isCollapsed = region.isCollapsed;
              if (iconClicked || isCollapsed) {
                let surrounding = e.event.altKey;
                let toToggle = [];
                if (surrounding) {
                  let filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);
                  let toMaybeToggle = foldingModel2.getRegionsInside(null, filter);
                  for (const r of toMaybeToggle) {
                    if (r.isCollapsed) {
                      toToggle.push(r);
                    }
                  }
                  if (toToggle.length === 0) {
                    toToggle = toMaybeToggle;
                  }
                } else {
                  let recursive = e.event.middleButton || e.event.shiftKey;
                  if (recursive) {
                    for (const r of foldingModel2.getRegionsInside(region)) {
                      if (r.isCollapsed === isCollapsed) {
                        toToggle.push(r);
                      }
                    }
                  }
                  if (isCollapsed || !recursive || toToggle.length === 0) {
                    toToggle.push(region);
                  }
                }
                foldingModel2.toggleCollapseState(toToggle);
                this.reveal({ lineNumber, column: 1 });
              }
            }
          }
        }).then(void 0, onUnexpectedError);
      }
      reveal(position) {
        this.editor.revealPositionInCenterIfOutsideViewport(
          position,
          0
          /* Smooth */
        );
      }
    };
    FoldingController.ID = "editor.contrib.folding";
    FoldingController = __decorate45([
      __param45(1, IContextKeyService)
    ], FoldingController);
    FoldingAction = class extends EditorAction {
      runEditorCommand(accessor, editor2, args) {
        let foldingController = FoldingController.get(editor2);
        if (!foldingController) {
          return;
        }
        let foldingModelPromise = foldingController.getFoldingModel();
        if (foldingModelPromise) {
          this.reportTelemetry(accessor, editor2);
          return foldingModelPromise.then((foldingModel) => {
            if (foldingModel) {
              this.invoke(foldingController, foldingModel, editor2, args);
              const selection = editor2.getSelection();
              if (selection) {
                foldingController.reveal(selection.getStartPosition());
              }
            }
          });
        }
      }
      getSelectedLines(editor2) {
        let selections = editor2.getSelections();
        return selections ? selections.map((s) => s.startLineNumber) : [];
      }
      getLineNumbers(args, editor2) {
        if (args && args.selectionLines) {
          return args.selectionLines.map((l) => l + 1);
        }
        return this.getSelectedLines(editor2);
      }
      run(_accessor, _editor2) {
      }
    };
    UnfoldAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.unfold",
          label: localize("unfoldAction.label", "Unfold"),
          alias: "Unfold",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 89,
            mac: {
              primary: 2048 | 512 | 89
              /* US_CLOSE_SQUARE_BRACKET */
            },
            weight: 100
            /* EditorContrib */
          },
          description: {
            description: "Unfold the content in the editor",
            args: [
              {
                name: "Unfold editor argument",
                description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
                constraint: foldingArgumentsConstraint,
                schema: {
                  "type": "object",
                  "properties": {
                    "levels": {
                      "type": "number",
                      "default": 1
                    },
                    "direction": {
                      "type": "string",
                      "enum": ["up", "down"],
                      "default": "down"
                    },
                    "selectionLines": {
                      "type": "array",
                      "items": {
                        "type": "number"
                      }
                    }
                  }
                }
              }
            ]
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2, args) {
        let levels = args && args.levels || 1;
        let lineNumbers = this.getLineNumbers(args, editor2);
        if (args && args.direction === "up") {
          setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
        } else {
          setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
        }
      }
    };
    UnFoldRecursivelyAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.unfoldRecursively",
          label: localize("unFoldRecursivelyAction.label", "Unfold Recursively"),
          alias: "Unfold Recursively",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 89
              /* US_CLOSE_SQUARE_BRACKET */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2, _args) {
        setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor2));
      }
    };
    FoldAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.fold",
          label: localize("foldAction.label", "Fold"),
          alias: "Fold",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 87,
            mac: {
              primary: 2048 | 512 | 87
              /* US_OPEN_SQUARE_BRACKET */
            },
            weight: 100
            /* EditorContrib */
          },
          description: {
            description: "Fold the content in the editor",
            args: [
              {
                name: "Fold editor argument",
                description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
                constraint: foldingArgumentsConstraint,
                schema: {
                  "type": "object",
                  "properties": {
                    "levels": {
                      "type": "number"
                    },
                    "direction": {
                      "type": "string",
                      "enum": ["up", "down"]
                    },
                    "selectionLines": {
                      "type": "array",
                      "items": {
                        "type": "number"
                      }
                    }
                  }
                }
              }
            ]
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2, args) {
        let lineNumbers = this.getLineNumbers(args, editor2);
        const levels = args && args.levels;
        const direction = args && args.direction;
        if (typeof levels !== "number" && typeof direction !== "string") {
          setCollapseStateUp(foldingModel, true, lineNumbers);
        } else {
          if (direction === "up") {
            setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);
          } else {
            setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);
          }
        }
      }
    };
    ToggleFoldAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.toggleFold",
          label: localize("toggleFoldAction.label", "Toggle Fold"),
          alias: "Toggle Fold",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 42
              /* KEY_L */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        let selectedLines = this.getSelectedLines(editor2);
        toggleCollapseState(foldingModel, 1, selectedLines);
      }
    };
    FoldRecursivelyAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.foldRecursively",
          label: localize("foldRecursivelyAction.label", "Fold Recursively"),
          alias: "Fold Recursively",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 87
              /* US_OPEN_SQUARE_BRACKET */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        let selectedLines = this.getSelectedLines(editor2);
        setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
      }
    };
    FoldAllBlockCommentsAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.foldAllBlockComments",
          label: localize("foldAllBlockComments.label", "Fold All Block Comments"),
          alias: "Fold All Block Comments",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 85
              /* US_SLASH */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        if (foldingModel.regions.hasTypes()) {
          setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);
        } else {
          const editorModel = editor2.getModel();
          if (!editorModel) {
            return;
          }
          let comments = LanguageConfigurationRegistry.getComments(editorModel.getLanguageIdentifier().id);
          if (comments && comments.blockCommentStartToken) {
            let regExp = new RegExp("^\\s*" + escapeRegExpCharacters(comments.blockCommentStartToken));
            setCollapseStateForMatchingLines(foldingModel, regExp, true);
          }
        }
      }
    };
    FoldAllRegionsAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.foldAllMarkerRegions",
          label: localize("foldAllMarkerRegions.label", "Fold All Regions"),
          alias: "Fold All Regions",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 29
              /* KEY_8 */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        if (foldingModel.regions.hasTypes()) {
          setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);
        } else {
          const editorModel = editor2.getModel();
          if (!editorModel) {
            return;
          }
          let foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);
          if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
            let regExp = new RegExp(foldingRules.markers.start);
            setCollapseStateForMatchingLines(foldingModel, regExp, true);
          }
        }
      }
    };
    UnfoldAllRegionsAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.unfoldAllMarkerRegions",
          label: localize("unfoldAllMarkerRegions.label", "Unfold All Regions"),
          alias: "Unfold All Regions",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 30
              /* KEY_9 */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        if (foldingModel.regions.hasTypes()) {
          setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);
        } else {
          const editorModel = editor2.getModel();
          if (!editorModel) {
            return;
          }
          let foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageIdentifier().id);
          if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
            let regExp = new RegExp(foldingRules.markers.start);
            setCollapseStateForMatchingLines(foldingModel, regExp, false);
          }
        }
      }
    };
    FoldAllRegionsExceptAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.foldAllExcept",
          label: localize("foldAllExcept.label", "Fold All Regions Except Selected"),
          alias: "Fold All Regions Except Selected",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 83
              /* US_MINUS */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        let selectedLines = this.getSelectedLines(editor2);
        setCollapseStateForRest(foldingModel, true, selectedLines);
      }
    };
    UnfoldAllRegionsExceptAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.unfoldAllExcept",
          label: localize("unfoldAllExcept.label", "Unfold All Regions Except Selected"),
          alias: "Unfold All Regions Except Selected",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 81
              /* US_EQUAL */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        let selectedLines = this.getSelectedLines(editor2);
        setCollapseStateForRest(foldingModel, false, selectedLines);
      }
    };
    FoldAllAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.foldAll",
          label: localize("foldAllAction.label", "Fold All"),
          alias: "Fold All",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 21
              /* KEY_0 */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, _editor2) {
        setCollapseStateLevelsDown(foldingModel, true);
      }
    };
    UnfoldAllAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.unfoldAll",
          label: localize("unfoldAllAction.label", "Unfold All"),
          alias: "Unfold All",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 40
              /* KEY_J */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, _editor2) {
        setCollapseStateLevelsDown(foldingModel, false);
      }
    };
    FoldLevelAction = class _FoldLevelAction extends FoldingAction {
      getFoldingLevel() {
        return parseInt(this.id.substr(_FoldLevelAction.ID_PREFIX.length));
      }
      invoke(_foldingController, foldingModel, editor2) {
        setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor2));
      }
    };
    FoldLevelAction.ID_PREFIX = "editor.foldLevel";
    FoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;
    GotoParentFoldAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.gotoParentFold",
          label: localize("gotoParentFold.label", "Go to Parent Fold"),
          alias: "Go to Parent Fold",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        let selectedLines = this.getSelectedLines(editor2);
        if (selectedLines.length > 0) {
          let startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);
          if (startLineNumber !== null) {
            editor2.setSelection({
              startLineNumber,
              startColumn: 1,
              endLineNumber: startLineNumber,
              endColumn: 1
            });
          }
        }
      }
    };
    GotoPreviousFoldAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.gotoPreviousFold",
          label: localize("gotoPreviousFold.label", "Go to Previous Folding Range"),
          alias: "Go to Previous Folding Range",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        let selectedLines = this.getSelectedLines(editor2);
        if (selectedLines.length > 0) {
          let startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);
          if (startLineNumber !== null) {
            editor2.setSelection({
              startLineNumber,
              startColumn: 1,
              endLineNumber: startLineNumber,
              endColumn: 1
            });
          }
        }
      }
    };
    GotoNextFoldAction = class extends FoldingAction {
      constructor() {
        super({
          id: "editor.gotoNextFold",
          label: localize("gotoNextFold.label", "Go to Next Folding Range"),
          alias: "Go to Next Folding Range",
          precondition: CONTEXT_FOLDING_ENABLED,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      invoke(_foldingController, foldingModel, editor2) {
        let selectedLines = this.getSelectedLines(editor2);
        if (selectedLines.length > 0) {
          let startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);
          if (startLineNumber !== null) {
            editor2.setSelection({
              startLineNumber,
              startColumn: 1,
              endLineNumber: startLineNumber,
              endColumn: 1
            });
          }
        }
      }
    };
    registerEditorContribution(FoldingController.ID, FoldingController);
    registerEditorAction(UnfoldAction);
    registerEditorAction(UnFoldRecursivelyAction);
    registerEditorAction(FoldAction);
    registerEditorAction(FoldRecursivelyAction);
    registerEditorAction(FoldAllAction);
    registerEditorAction(UnfoldAllAction);
    registerEditorAction(FoldAllBlockCommentsAction);
    registerEditorAction(FoldAllRegionsAction);
    registerEditorAction(UnfoldAllRegionsAction);
    registerEditorAction(FoldAllRegionsExceptAction);
    registerEditorAction(UnfoldAllRegionsExceptAction);
    registerEditorAction(ToggleFoldAction);
    registerEditorAction(GotoParentFoldAction);
    registerEditorAction(GotoPreviousFoldAction);
    registerEditorAction(GotoNextFoldAction);
    for (let i = 1; i <= 7; i++) {
      registerInstantiatedEditorAction(new FoldLevelAction({
        id: FoldLevelAction.ID(i),
        label: localize("foldLevelAction.label", "Fold Level {0}", i),
        alias: `Fold Level ${i}`,
        precondition: CONTEXT_FOLDING_ENABLED,
        kbOpts: {
          kbExpr: EditorContextKeys.editorTextFocus,
          primary: KeyChord(2048 | 41, 2048 | 21 + i),
          weight: 100
          /* EditorContrib */
        }
      }));
    }
    foldBackgroundBackground = registerColor("editor.foldBackground", { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hc: null }, localize("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
    editorFoldForeground = registerColor("editorGutter.foldingControlForeground", { dark: iconForeground, light: iconForeground, hc: iconForeground }, localize("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
    registerThemingParticipant((theme, collector) => {
      const foldBackground = theme.getColor(foldBackgroundBackground);
      if (foldBackground) {
        collector.addRule(`.monaco-editor .folded-background { background-color: ${foldBackground}; }`);
      }
      const editorFoldColor = theme.getColor(editorFoldForeground);
      if (editorFoldColor) {
        collector.addRule(`
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingExpandedIcon)},
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingCollapsedIcon)} {
			color: ${editorFoldColor} !important;
		}
		`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/fontZoom.js
var EditorFontZoomIn, EditorFontZoomOut, EditorFontZoomReset;
var init_fontZoom = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/fontZoom.js"() {
    init_editorExtensions();
    init_editorZoom();
    init_nls();
    EditorFontZoomIn = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.fontZoomIn",
          label: localize("EditorFontZoomIn.label", "Editor Font Zoom In"),
          alias: "Editor Font Zoom In",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
      }
    };
    EditorFontZoomOut = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.fontZoomOut",
          label: localize("EditorFontZoomOut.label", "Editor Font Zoom Out"),
          alias: "Editor Font Zoom Out",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
      }
    };
    EditorFontZoomReset = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.fontZoomReset",
          label: localize("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
          alias: "Editor Font Zoom Reset",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        EditorZoom.setZoomLevel(0);
      }
    };
    registerEditorAction(EditorFontZoomIn);
    registerEditorAction(EditorFontZoomOut);
    registerEditorAction(EditorFontZoomReset);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/format/formatActions.js
var require_formatActions = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/format/formatActions.js"(exports2) {
    init_arrays();
    init_cancellation();
    init_errors();
    init_keyCodes();
    init_lifecycle();
    init_editorExtensions();
    init_codeEditorService();
    init_characterClassifier();
    init_range();
    init_editorContextKeys();
    init_modes();
    init_editorWorkerService();
    init_format();
    init_formattingEdit();
    init_nls();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_progress();
    var __decorate61 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param61 = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter46 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var FormatOnType = class FormatOnType {
      constructor(editor2, _workerService) {
        this._workerService = _workerService;
        this._callOnDispose = new DisposableStore();
        this._callOnModel = new DisposableStore();
        this._editor = editor2;
        this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
        this._callOnDispose.add(OnTypeFormattingEditProviderRegistry.onDidChange(this._update, this));
      }
      dispose() {
        this._callOnDispose.dispose();
        this._callOnModel.dispose();
      }
      _update() {
        this._callOnModel.clear();
        if (!this._editor.getOption(
          48
          /* formatOnType */
        )) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        const [support] = OnTypeFormattingEditProviderRegistry.ordered(model);
        if (!support || !support.autoFormatTriggerCharacters) {
          return;
        }
        let triggerChars = new CharacterSet();
        for (let ch of support.autoFormatTriggerCharacters) {
          triggerChars.add(ch.charCodeAt(0));
        }
        this._callOnModel.add(this._editor.onDidType((text2) => {
          let lastCharCode = text2.charCodeAt(text2.length - 1);
          if (triggerChars.has(lastCharCode)) {
            this._trigger(String.fromCharCode(lastCharCode));
          }
        }));
      }
      _trigger(ch) {
        if (!this._editor.hasModel()) {
          return;
        }
        if (this._editor.getSelections().length > 1) {
          return;
        }
        const model = this._editor.getModel();
        const position = this._editor.getPosition();
        let canceled2 = false;
        const unbind = this._editor.onDidChangeModelContent((e) => {
          if (e.isFlush) {
            canceled2 = true;
            unbind.dispose();
            return;
          }
          for (let i = 0, len = e.changes.length; i < len; i++) {
            const change = e.changes[i];
            if (change.range.endLineNumber <= position.lineNumber) {
              canceled2 = true;
              unbind.dispose();
              return;
            }
          }
        });
        getOnTypeFormattingEdits(this._workerService, model, position, ch, model.getFormattingOptions()).then((edits) => {
          unbind.dispose();
          if (canceled2) {
            return;
          }
          if (isNonEmptyArray(edits)) {
            FormattingEdit.execute(this._editor, edits, true);
            alertFormattingEdits(edits);
          }
        }, (err) => {
          unbind.dispose();
          throw err;
        });
      }
    };
    FormatOnType.ID = "editor.contrib.autoFormat";
    FormatOnType = __decorate61([
      __param61(1, IEditorWorkerService)
    ], FormatOnType);
    var FormatOnPaste = class FormatOnPaste {
      constructor(editor2, _instantiationService) {
        this.editor = editor2;
        this._instantiationService = _instantiationService;
        this._callOnDispose = new DisposableStore();
        this._callOnModel = new DisposableStore();
        this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
        this._callOnDispose.add(DocumentRangeFormattingEditProviderRegistry.onDidChange(this._update, this));
      }
      dispose() {
        this._callOnDispose.dispose();
        this._callOnModel.dispose();
      }
      _update() {
        this._callOnModel.clear();
        if (!this.editor.getOption(
          47
          /* formatOnPaste */
        )) {
          return;
        }
        if (!this.editor.hasModel()) {
          return;
        }
        if (!DocumentRangeFormattingEditProviderRegistry.has(this.editor.getModel())) {
          return;
        }
        this._callOnModel.add(this.editor.onDidPaste(({ range }) => this._trigger(range)));
      }
      _trigger(range) {
        if (!this.editor.hasModel()) {
          return;
        }
        if (this.editor.getSelections().length > 1) {
          return;
        }
        this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None).catch(onUnexpectedError);
      }
    };
    FormatOnPaste.ID = "editor.contrib.formatOnPaste";
    FormatOnPaste = __decorate61([
      __param61(1, IInstantiationService)
    ], FormatOnPaste);
    var FormatDocumentAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.formatDocument",
          label: localize("formatDocument.label", "Format Document"),
          alias: "Format Document",
          precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 36,
            linux: {
              primary: 2048 | 1024 | 39
              /* KEY_I */
            },
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "1_modification",
            order: 1.3
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter46(this, void 0, void 0, function* () {
          if (editor2.hasModel()) {
            const instaService = accessor.get(IInstantiationService);
            const progressService = accessor.get(IEditorProgressService);
            yield progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor2, 1, Progress.None, CancellationToken.None), 250);
          }
        });
      }
    };
    var FormatSelectionAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.formatSelection",
          label: localize("formatSelection.label", "Format Selection"),
          alias: "Format Selection",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 36
              /* KEY_F */
            ),
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            when: EditorContextKeys.hasNonEmptySelection,
            group: "1_modification",
            order: 1.31
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter46(this, void 0, void 0, function* () {
          if (!editor2.hasModel()) {
            return;
          }
          const instaService = accessor.get(IInstantiationService);
          const model = editor2.getModel();
          const ranges = editor2.getSelections().map((range) => {
            return range.isEmpty() ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
          });
          const progressService = accessor.get(IEditorProgressService);
          yield progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor2, ranges, 1, Progress.None, CancellationToken.None), 250);
        });
      }
    };
    registerEditorContribution(FormatOnType.ID, FormatOnType);
    registerEditorContribution(FormatOnPaste.ID, FormatOnPaste);
    registerEditorAction(FormatDocumentAction);
    registerEditorAction(FormatSelectionAction);
    CommandsRegistry.registerCommand("editor.action.format", (accessor) => __awaiter46(void 0, void 0, void 0, function* () {
      const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
      if (!editor2 || !editor2.hasModel()) {
        return;
      }
      const commandService = accessor.get(ICommandService);
      if (editor2.getSelection().isEmpty()) {
        yield commandService.executeCommand("editor.action.formatDocument");
      } else {
        yield commandService.executeCommand("editor.action.formatSelection");
      }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/outlineModel.js
var TreeElement, OutlineElement, OutlineGroup, OutlineModel;
var init_outlineModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/outlineModel.js"() {
    init_arrays();
    init_cancellation();
    init_errors();
    init_iterator();
    init_map();
    init_range();
    init_modes();
    init_languageFeatureRegistry();
    TreeElement = class {
      remove() {
        if (this.parent) {
          this.parent.children.delete(this.id);
        }
      }
      static findId(candidate, container) {
        let candidateId;
        if (typeof candidate === "string") {
          candidateId = `${container.id}/${candidate}`;
        } else {
          candidateId = `${container.id}/${candidate.name}`;
          if (container.children.get(candidateId) !== void 0) {
            candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
          }
        }
        let id = candidateId;
        for (let i = 0; container.children.get(id) !== void 0; i++) {
          id = `${candidateId}_${i}`;
        }
        return id;
      }
      static empty(element) {
        return element.children.size === 0;
      }
    };
    OutlineElement = class extends TreeElement {
      constructor(id, parent, symbol) {
        super();
        this.id = id;
        this.parent = parent;
        this.symbol = symbol;
        this.children = /* @__PURE__ */ new Map();
      }
    };
    OutlineGroup = class extends TreeElement {
      constructor(id, parent, label, order) {
        super();
        this.id = id;
        this.parent = parent;
        this.label = label;
        this.order = order;
        this.children = /* @__PURE__ */ new Map();
      }
    };
    OutlineModel = class _OutlineModel extends TreeElement {
      constructor(uri) {
        super();
        this.uri = uri;
        this.id = "root";
        this.parent = void 0;
        this._groups = /* @__PURE__ */ new Map();
        this.children = /* @__PURE__ */ new Map();
        this.id = "root";
        this.parent = void 0;
      }
      static create(textModel, token) {
        let key = this._keys.for(textModel, true);
        let data = _OutlineModel._requests.get(key);
        if (!data) {
          let source = new CancellationTokenSource();
          data = {
            promiseCnt: 0,
            source,
            promise: _OutlineModel._create(textModel, source.token),
            model: void 0
          };
          _OutlineModel._requests.set(key, data);
          const now = Date.now();
          data.promise.then(() => {
            this._requestDurations.update(textModel, Date.now() - now);
          });
        }
        if (data.model) {
          return Promise.resolve(data.model);
        }
        data.promiseCnt += 1;
        token.onCancellationRequested(() => {
          if (--data.promiseCnt === 0) {
            data.source.cancel();
            _OutlineModel._requests.delete(key);
          }
        });
        return new Promise((resolve, reject) => {
          data.promise.then((model) => {
            data.model = model;
            resolve(model);
          }, (err) => {
            _OutlineModel._requests.delete(key);
            reject(err);
          });
        });
      }
      static _create(textModel, token) {
        const cts = new CancellationTokenSource(token);
        const result = new _OutlineModel(textModel.uri);
        const provider = DocumentSymbolProviderRegistry.ordered(textModel);
        const promises = provider.map((provider2, index) => {
          var _a5;
          let id = TreeElement.findId(`provider_${index}`, result);
          let group = new OutlineGroup(id, result, (_a5 = provider2.displayName) !== null && _a5 !== void 0 ? _a5 : "Unknown Outline Provider", index);
          return Promise.resolve(provider2.provideDocumentSymbols(textModel, cts.token)).then((result2) => {
            for (const info of result2 || []) {
              _OutlineModel._makeOutlineElement(info, group);
            }
            return group;
          }, (err) => {
            onUnexpectedExternalError(err);
            return group;
          }).then((group2) => {
            if (!TreeElement.empty(group2)) {
              result._groups.set(id, group2);
            } else {
              group2.remove();
            }
          });
        });
        const listener = DocumentSymbolProviderRegistry.onDidChange(() => {
          const newProvider = DocumentSymbolProviderRegistry.ordered(textModel);
          if (!equals(newProvider, provider)) {
            cts.cancel();
          }
        });
        return Promise.all(promises).then(() => {
          if (cts.token.isCancellationRequested && !token.isCancellationRequested) {
            return _OutlineModel._create(textModel, token);
          } else {
            return result._compact();
          }
        }).finally(() => {
          listener.dispose();
        });
      }
      static _makeOutlineElement(info, container) {
        let id = TreeElement.findId(info, container);
        let res = new OutlineElement(id, container, info);
        if (info.children) {
          for (const childInfo of info.children) {
            _OutlineModel._makeOutlineElement(childInfo, res);
          }
        }
        container.children.set(res.id, res);
      }
      _compact() {
        let count = 0;
        for (const [key, group] of this._groups) {
          if (group.children.size === 0) {
            this._groups.delete(key);
          } else {
            count += 1;
          }
        }
        if (count !== 1) {
          this.children = this._groups;
        } else {
          let group = Iterable.first(this._groups.values());
          for (let [, child] of group.children) {
            child.parent = this;
            this.children.set(child.id, child);
          }
        }
        return this;
      }
      getTopLevelSymbols() {
        const roots = [];
        for (const child of this.children.values()) {
          if (child instanceof OutlineElement) {
            roots.push(child.symbol);
          } else {
            roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
          }
        }
        return roots.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
      }
      asListOfDocumentSymbols() {
        const roots = this.getTopLevelSymbols();
        const bucket = [];
        _OutlineModel._flattenDocumentSymbols(bucket, roots, "");
        return bucket.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
      }
      static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
        for (const entry of entries) {
          bucket.push({
            kind: entry.kind,
            tags: entry.tags,
            name: entry.name,
            detail: entry.detail,
            containerName: entry.containerName || overrideContainerLabel,
            range: entry.range,
            selectionRange: entry.selectionRange,
            children: void 0
            // we flatten it...
          });
          if (entry.children) {
            _OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
          }
        }
      }
    };
    OutlineModel._requestDurations = new LanguageFeatureRequestDelays(DocumentSymbolProviderRegistry, 350);
    OutlineModel._requests = new LRUCache(9, 0.75);
    OutlineModel._keys = new class {
      constructor() {
        this._counter = 1;
        this._data = /* @__PURE__ */ new WeakMap();
      }
      for(textModel, version) {
        return `${textModel.id}/${version ? textModel.getVersionId() : ""}/${this._hash(DocumentSymbolProviderRegistry.all(textModel))}`;
      }
      _hash(providers) {
        let result = "";
        for (const provider of providers) {
          let n = this._data.get(provider);
          if (typeof n === "undefined") {
            n = this._counter++;
            this._data.set(provider, n);
          }
          result += n;
        }
        return result;
      }
    }();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/documentSymbols.js
function getDocumentSymbols(document2, flat, token) {
  return __awaiter32(this, void 0, void 0, function* () {
    const model = yield OutlineModel.create(document2, token);
    return flat ? model.asListOfDocumentSymbols() : model.getTopLevelSymbols();
  });
}
var __awaiter32;
var init_documentSymbols = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/documentSymbols.js"() {
    init_cancellation();
    init_types();
    init_uri();
    init_modelService();
    init_resolverService();
    init_outlineModel();
    init_commands();
    __awaiter32 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", function(accessor, ...args) {
      return __awaiter32(this, void 0, void 0, function* () {
        const [resource] = args;
        assertType(URI.isUri(resource));
        const model = accessor.get(IModelService).getModel(resource);
        if (model) {
          return getDocumentSymbols(model, false, CancellationToken.None);
        }
        const reference = yield accessor.get(ITextModelService).createModelReference(resource);
        try {
          return yield getDocumentSymbols(reference.object.textEditorModel, false, CancellationToken.None);
        } finally {
          reference.dispose();
        }
      });
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentUtils.js
function getSpaceCnt(str, tabSize) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt += tabSize;
    } else {
      spacesCnt++;
    }
  }
  return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
  spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
  let result = "";
  if (!insertSpaces) {
    let tabsCnt = Math.floor(spacesCnt / tabSize);
    spacesCnt = spacesCnt % tabSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}
var init_indentUtils = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentUtils.js"() {
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentation.js
function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return [];
  }
  let indentationRules = LanguageConfigurationRegistry.getIndentationRules(model.getLanguageIdentifier().id);
  if (!indentationRules) {
    return [];
  }
  endLineNumber = Math.min(endLineNumber, model.getLineCount());
  while (startLineNumber <= endLineNumber) {
    if (!indentationRules.unIndentedLinePattern) {
      break;
    }
    let text2 = model.getLineContent(startLineNumber);
    if (!indentationRules.unIndentedLinePattern.test(text2)) {
      break;
    }
    startLineNumber++;
  }
  if (startLineNumber > endLineNumber - 1) {
    return [];
  }
  const { tabSize, indentSize, insertSpaces } = model.getOptions();
  const shiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const unshiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  let indentEdits = [];
  let globalIndent;
  let currentLineText = model.getLineContent(startLineNumber);
  let adjustedLineContent = currentLineText;
  if (inheritedIndent !== void 0 && inheritedIndent !== null) {
    globalIndent = inheritedIndent;
    let oldIndentation = getLeadingWhitespace(currentLineText);
    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
      globalIndent = unshiftIndent(globalIndent);
      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    }
    if (currentLineText !== adjustedLineContent) {
      indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));
    }
  } else {
    globalIndent = getLeadingWhitespace(currentLineText);
  }
  let idealIndentForNextLine = globalIndent;
  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    globalIndent = shiftIndent(globalIndent);
  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
  }
  startLineNumber++;
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    let text2 = model.getLineContent(lineNumber);
    let oldIndentation = getLeadingWhitespace(text2);
    let adjustedLineContent2 = idealIndentForNextLine + text2.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
      globalIndent = unshiftIndent(globalIndent);
    }
    if (oldIndentation !== idealIndentForNextLine) {
      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
    }
    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text2)) {
      continue;
    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent2)) {
      globalIndent = shiftIndent(globalIndent);
      idealIndentForNextLine = globalIndent;
    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    } else {
      idealIndentForNextLine = globalIndent;
    }
  }
  return indentEdits;
}
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return;
  }
  let spaces = "";
  for (let i = 0; i < tabSize; i++) {
    spaces += " ";
  }
  let spacesRegExp = new RegExp(spaces, "gi");
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (lastIndentationColumn === 0) {
      lastIndentationColumn = model.getLineMaxColumn(lineNumber);
    }
    if (lastIndentationColumn === 1) {
      continue;
    }
    const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);
    const originalIndentation = model.getValueInRange(originalIndentationRange);
    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/ig, spaces) : originalIndentation.replace(spacesRegExp, "	");
    builder.addEditOperation(originalIndentationRange, newIndentation);
  }
}
var IndentationToSpacesAction, IndentationToTabsAction, ChangeIndentationSizeAction, IndentUsingTabs, IndentUsingSpaces, DetectIndentation, ReindentLinesAction, ReindentSelectedLinesAction, AutoIndentOnPasteCommand, AutoIndentOnPaste, IndentationToSpacesCommand, IndentationToTabsCommand;
var init_indentation = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentation.js"() {
    init_lifecycle();
    init_strings();
    init_editorExtensions();
    init_shiftCommand();
    init_editOperation();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_textModel();
    init_languageConfigurationRegistry();
    init_modelService();
    init_indentUtils();
    init_nls();
    init_quickInput();
    IndentationToSpacesAction = class _IndentationToSpacesAction extends EditorAction {
      constructor() {
        super({
          id: _IndentationToSpacesAction.ID,
          label: localize("indentationToSpaces", "Convert Indentation to Spaces"),
          alias: "Convert Indentation to Spaces",
          precondition: EditorContextKeys.writable
        });
      }
      run(accessor, editor2) {
        let model = editor2.getModel();
        if (!model) {
          return;
        }
        let modelOpts = model.getOptions();
        let selection = editor2.getSelection();
        if (!selection) {
          return;
        }
        const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, [command]);
        editor2.pushUndoStop();
        model.updateOptions({
          insertSpaces: true
        });
      }
    };
    IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
    IndentationToTabsAction = class _IndentationToTabsAction extends EditorAction {
      constructor() {
        super({
          id: _IndentationToTabsAction.ID,
          label: localize("indentationToTabs", "Convert Indentation to Tabs"),
          alias: "Convert Indentation to Tabs",
          precondition: EditorContextKeys.writable
        });
      }
      run(accessor, editor2) {
        let model = editor2.getModel();
        if (!model) {
          return;
        }
        let modelOpts = model.getOptions();
        let selection = editor2.getSelection();
        if (!selection) {
          return;
        }
        const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, [command]);
        editor2.pushUndoStop();
        model.updateOptions({
          insertSpaces: false
        });
      }
    };
    IndentationToTabsAction.ID = "editor.action.indentationToTabs";
    ChangeIndentationSizeAction = class extends EditorAction {
      constructor(insertSpaces, opts) {
        super(opts);
        this.insertSpaces = insertSpaces;
      }
      run(accessor, editor2) {
        const quickInputService = accessor.get(IQuickInputService);
        const modelService = accessor.get(IModelService);
        let model = editor2.getModel();
        if (!model) {
          return;
        }
        let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);
        const picks = [1, 2, 3, 4, 5, 6, 7, 8].map((n) => ({
          id: n.toString(),
          label: n.toString(),
          // add description for tabSize value set in the configuration
          description: n === creationOpts.tabSize ? localize("configuredTabSize", "Configured Tab Size") : void 0
        }));
        const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
        setTimeout(
          () => {
            quickInputService.pick(picks, { placeHolder: localize({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then((pick) => {
              if (pick) {
                if (model && !model.isDisposed()) {
                  model.updateOptions({
                    tabSize: parseInt(pick.label, 10),
                    insertSpaces: this.insertSpaces
                  });
                }
              }
            });
          },
          50
          /* quick input is sensitive to being opened so soon after another */
        );
      }
    };
    IndentUsingTabs = class _IndentUsingTabs extends ChangeIndentationSizeAction {
      constructor() {
        super(false, {
          id: _IndentUsingTabs.ID,
          label: localize("indentUsingTabs", "Indent Using Tabs"),
          alias: "Indent Using Tabs",
          precondition: void 0
        });
      }
    };
    IndentUsingTabs.ID = "editor.action.indentUsingTabs";
    IndentUsingSpaces = class _IndentUsingSpaces extends ChangeIndentationSizeAction {
      constructor() {
        super(true, {
          id: _IndentUsingSpaces.ID,
          label: localize("indentUsingSpaces", "Indent Using Spaces"),
          alias: "Indent Using Spaces",
          precondition: void 0
        });
      }
    };
    IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
    DetectIndentation = class _DetectIndentation extends EditorAction {
      constructor() {
        super({
          id: _DetectIndentation.ID,
          label: localize("detectIndentation", "Detect Indentation from Content"),
          alias: "Detect Indentation from Content",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        const modelService = accessor.get(IModelService);
        let model = editor2.getModel();
        if (!model) {
          return;
        }
        let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);
        model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
      }
    };
    DetectIndentation.ID = "editor.action.detectIndentation";
    ReindentLinesAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.reindentlines",
          label: localize("editor.reindentlines", "Reindent Lines"),
          alias: "Reindent Lines",
          precondition: EditorContextKeys.writable
        });
      }
      run(accessor, editor2) {
        let model = editor2.getModel();
        if (!model) {
          return;
        }
        let edits = getReindentEditOperations(model, 1, model.getLineCount());
        if (edits.length > 0) {
          editor2.pushUndoStop();
          editor2.executeEdits(this.id, edits);
          editor2.pushUndoStop();
        }
      }
    };
    ReindentSelectedLinesAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.reindentselectedlines",
          label: localize("editor.reindentselectedlines", "Reindent Selected Lines"),
          alias: "Reindent Selected Lines",
          precondition: EditorContextKeys.writable
        });
      }
      run(accessor, editor2) {
        let model = editor2.getModel();
        if (!model) {
          return;
        }
        let selections = editor2.getSelections();
        if (selections === null) {
          return;
        }
        let edits = [];
        for (let selection of selections) {
          let startLineNumber = selection.startLineNumber;
          let endLineNumber = selection.endLineNumber;
          if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
            endLineNumber--;
          }
          if (startLineNumber === 1) {
            if (startLineNumber === endLineNumber) {
              continue;
            }
          } else {
            startLineNumber--;
          }
          let editOperations = getReindentEditOperations(model, startLineNumber, endLineNumber);
          edits.push(...editOperations);
        }
        if (edits.length > 0) {
          editor2.pushUndoStop();
          editor2.executeEdits(this.id, edits);
          editor2.pushUndoStop();
        }
      }
    };
    AutoIndentOnPasteCommand = class {
      constructor(edits, initialSelection) {
        this._initialSelection = initialSelection;
        this._edits = [];
        this._selectionId = null;
        for (let edit of edits) {
          if (edit.range && typeof edit.text === "string") {
            this._edits.push(edit);
          }
        }
      }
      getEditOperations(model, builder) {
        for (let edit of this._edits) {
          builder.addEditOperation(Range.lift(edit.range), edit.text);
        }
        let selectionIsSet = false;
        if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
          if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
            selectionIsSet = true;
            this._selectionId = builder.trackSelection(this._initialSelection, true);
          } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
            selectionIsSet = true;
            this._selectionId = builder.trackSelection(this._initialSelection, false);
          }
        }
        if (!selectionIsSet) {
          this._selectionId = builder.trackSelection(this._initialSelection);
        }
      }
      computeCursorState(model, helper) {
        return helper.getTrackedSelection(this._selectionId);
      }
    };
    AutoIndentOnPaste = class {
      constructor(editor2) {
        this.callOnDispose = new DisposableStore();
        this.callOnModel = new DisposableStore();
        this.editor = editor2;
        this.callOnDispose.add(editor2.onDidChangeConfiguration(() => this.update()));
        this.callOnDispose.add(editor2.onDidChangeModel(() => this.update()));
        this.callOnDispose.add(editor2.onDidChangeModelLanguage(() => this.update()));
      }
      update() {
        this.callOnModel.clear();
        if (this.editor.getOption(
          9
          /* autoIndent */
        ) < 4 || this.editor.getOption(
          47
          /* formatOnPaste */
        )) {
          return;
        }
        if (!this.editor.hasModel()) {
          return;
        }
        this.callOnModel.add(this.editor.onDidPaste(({ range }) => {
          this.trigger(range);
        }));
      }
      trigger(range) {
        let selections = this.editor.getSelections();
        if (selections === null || selections.length > 1) {
          return;
        }
        const model = this.editor.getModel();
        if (!model) {
          return;
        }
        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {
          return;
        }
        const autoIndent = this.editor.getOption(
          9
          /* autoIndent */
        );
        const { tabSize, indentSize, insertSpaces } = model.getOptions();
        let textEdits = [];
        let indentConverter = {
          shiftIndent: (indentation) => {
            return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
          },
          unshiftIndent: (indentation) => {
            return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
          }
        };
        let startLineNumber = range.startLineNumber;
        while (startLineNumber <= range.endLineNumber) {
          if (this.shouldIgnoreLine(model, startLineNumber)) {
            startLineNumber++;
            continue;
          }
          break;
        }
        if (startLineNumber > range.endLineNumber) {
          return;
        }
        let firstLineText = model.getLineContent(startLineNumber);
        if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
          let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, model, model.getLanguageIdentifier().id, startLineNumber, indentConverter);
          if (indentOfFirstLine !== null) {
            let oldIndentation = getLeadingWhitespace(firstLineText);
            let newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
            let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
            if (newSpaceCnt !== oldSpaceCnt) {
              let newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
              textEdits.push({
                range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
                text: newIndent
              });
              firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
            } else {
              let indentMetadata = LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);
              if (indentMetadata === 0 || indentMetadata === 8) {
                return;
              }
            }
          }
        }
        const firstLineNumber = startLineNumber;
        while (startLineNumber < range.endLineNumber) {
          if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
            startLineNumber++;
            continue;
          }
          break;
        }
        if (startLineNumber !== range.endLineNumber) {
          let virtualModel = {
            getLineTokens: (lineNumber) => {
              return model.getLineTokens(lineNumber);
            },
            getLanguageIdentifier: () => {
              return model.getLanguageIdentifier();
            },
            getLanguageIdAtPosition: (lineNumber, column) => {
              return model.getLanguageIdAtPosition(lineNumber, column);
            },
            getLineContent: (lineNumber) => {
              if (lineNumber === firstLineNumber) {
                return firstLineText;
              } else {
                return model.getLineContent(lineNumber);
              }
            }
          };
          let indentOfSecondLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageIdentifier().id, startLineNumber + 1, indentConverter);
          if (indentOfSecondLine !== null) {
            let newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
            let oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
            if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
              let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
              for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {
                let lineContent = model.getLineContent(i);
                let originalIndent = getLeadingWhitespace(lineContent);
                let originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
                let newSpacesCnt = originalSpacesCnt + spaceCntOffset;
                let newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
                if (newIndent !== originalIndent) {
                  textEdits.push({
                    range: new Range(i, 1, i, originalIndent.length + 1),
                    text: newIndent
                  });
                }
              }
            }
          }
        }
        if (textEdits.length > 0) {
          this.editor.pushUndoStop();
          let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
          this.editor.executeCommand("autoIndentOnPaste", cmd);
          this.editor.pushUndoStop();
        }
      }
      shouldIgnoreLine(model, lineNumber) {
        model.forceTokenization(lineNumber);
        let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
        if (nonWhitespaceColumn === 0) {
          return true;
        }
        let tokens = model.getLineTokens(lineNumber);
        if (tokens.getCount() > 0) {
          let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);
          if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1) {
            return true;
          }
        }
        return false;
      }
      dispose() {
        this.callOnDispose.dispose();
        this.callOnModel.dispose();
      }
    };
    AutoIndentOnPaste.ID = "editor.contrib.autoIndentOnPaste";
    IndentationToSpacesCommand = class {
      constructor(selection, tabSize) {
        this.selection = selection;
        this.tabSize = tabSize;
        this.selectionId = null;
      }
      getEditOperations(model, builder) {
        this.selectionId = builder.trackSelection(this.selection);
        getIndentationEditOperations(model, builder, this.tabSize, true);
      }
      computeCursorState(model, helper) {
        return helper.getTrackedSelection(this.selectionId);
      }
    };
    IndentationToTabsCommand = class {
      constructor(selection, tabSize) {
        this.selection = selection;
        this.tabSize = tabSize;
        this.selectionId = null;
      }
      getEditOperations(model, builder) {
        this.selectionId = builder.trackSelection(this.selection);
        getIndentationEditOperations(model, builder, this.tabSize, false);
      }
      computeCursorState(model, helper) {
        return helper.getTrackedSelection(this.selectionId);
      }
    };
    registerEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);
    registerEditorAction(IndentationToSpacesAction);
    registerEditorAction(IndentationToTabsAction);
    registerEditorAction(IndentUsingTabs);
    registerEditorAction(IndentUsingSpaces);
    registerEditorAction(DetectIndentation);
    registerEditorAction(ReindentLinesAction);
    registerEditorAction(ReindentSelectedLinesAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/inlayHintsController.js
function getInlayHints(model, ranges, token) {
  return __awaiter33(this, void 0, void 0, function* () {
    const all = [];
    const providers = InlayHintsProviderRegistry.ordered(model).reverse();
    const promises = providers.map((provider) => ranges.map((range) => __awaiter33(this, void 0, void 0, function* () {
      try {
        const result = yield provider.provideInlayHints(model, range, token);
        if (result === null || result === void 0 ? void 0 : result.length) {
          all.push(result.filter((hint) => range.containsPosition(hint.position)));
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    })));
    yield Promise.all(promises.flat());
    return all.flat().sort((a, b) => Position.compare(a.position, b.position));
  });
}
function wordToRange(word, lineNumber) {
  return new Range(lineNumber, word.startColumn, lineNumber, word.endColumn);
}
function fixSpace(str) {
  const noBreakWhitespace = "\xA0";
  return str.replace(/[ \t]/g, noBreakWhitespace);
}
var __decorate46, __param46, __awaiter33, MAX_DECORATORS2, InlayHintsCache, InlayHintsController;
var init_inlayHintsController = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/inlayHintsController.js"() {
    init_async();
    init_cancellation();
    init_errors();
    init_hash();
    init_lifecycle();
    init_map();
    init_types();
    init_uri();
    init_editorExtensions();
    init_codeEditorService();
    init_position();
    init_range();
    init_modes();
    init_languageFeatureRegistry();
    init_resolverService();
    init_commands();
    init_colorRegistry();
    init_themeService();
    __decorate46 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param46 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter33 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    MAX_DECORATORS2 = 1500;
    InlayHintsCache = class _InlayHintsCache {
      constructor() {
        this._entries = new LRUCache(50);
      }
      get(model) {
        const key = _InlayHintsCache._key(model);
        return this._entries.get(key);
      }
      set(model, value) {
        const key = _InlayHintsCache._key(model);
        this._entries.set(key, value);
      }
      static _key(model) {
        return `${model.uri.toString()}/${model.getVersionId()}`;
      }
    };
    InlayHintsController = class InlayHintsController2 {
      constructor(_editor2, _codeEditorService) {
        this._editor = _editor2;
        this._codeEditorService = _codeEditorService;
        this._decorationOwnerId = ++InlayHintsController2._decorationOwnerIdPool;
        this._disposables = new DisposableStore();
        this._sessionDisposables = new DisposableStore();
        this._getInlayHintsDelays = new LanguageFeatureRequestDelays(InlayHintsProviderRegistry, 25, 500);
        this._cache = new InlayHintsCache();
        this._decorations = /* @__PURE__ */ new Map();
        this._disposables.add(InlayHintsProviderRegistry.onDidChange(() => this._update()));
        this._disposables.add(_editor2.onDidChangeModel(() => this._update()));
        this._disposables.add(_editor2.onDidChangeModelLanguage(() => this._update()));
        this._disposables.add(_editor2.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            125
            /* inlayHints */
          )) {
            this._update();
          }
        }));
        this._update();
      }
      dispose() {
        this._sessionDisposables.dispose();
        this._removeAllDecorations();
        this._disposables.dispose();
      }
      _update() {
        this._sessionDisposables.clear();
        this._removeAllDecorations();
        if (!this._editor.getOption(
          125
          /* inlayHints */
        ).enabled) {
          return;
        }
        const model = this._editor.getModel();
        if (!model || !InlayHintsProviderRegistry.has(model)) {
          return;
        }
        const cached = this._cache.get(model);
        if (cached) {
          this._updateHintsDecorators([model.getFullModelRange()], cached);
        }
        const scheduler = new RunOnceScheduler(() => __awaiter33(this, void 0, void 0, function* () {
          const t1 = Date.now();
          const cts = new CancellationTokenSource();
          this._sessionDisposables.add(toDisposable(() => cts.dispose(true)));
          const ranges = this._getHintsRanges();
          const result = yield getInlayHints(model, ranges, cts.token);
          scheduler.delay = this._getInlayHintsDelays.update(model, Date.now() - t1);
          if (cts.token.isCancellationRequested) {
            return;
          }
          this._updateHintsDecorators(ranges, result);
          this._cache.set(model, Array.from(this._decorations.values()).map((obj) => obj.hint));
        }), this._getInlayHintsDelays.get(model));
        this._sessionDisposables.add(scheduler);
        this._sessionDisposables.add(this._editor.onDidChangeModelContent(() => scheduler.schedule()));
        this._disposables.add(this._editor.onDidScrollChange(() => scheduler.schedule()));
        scheduler.schedule();
        const providerListener = new DisposableStore();
        this._sessionDisposables.add(providerListener);
        for (const provider of InlayHintsProviderRegistry.all(model)) {
          if (typeof provider.onDidChangeInlayHints === "function") {
            providerListener.add(provider.onDidChangeInlayHints(() => scheduler.schedule()));
          }
        }
      }
      _getHintsRanges() {
        const extra = 30;
        const model = this._editor.getModel();
        const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
        const result = [];
        for (const range of visibleRanges.sort(Range.compareRangesUsingStarts)) {
          const extendedRange = model.validateRange(new Range(range.startLineNumber - extra, range.startColumn, range.endLineNumber + extra, range.endColumn));
          if (result.length === 0 || !Range.areIntersectingOrTouching(result[result.length - 1], extendedRange)) {
            result.push(extendedRange);
          } else {
            result[result.length - 1] = Range.plusRange(result[result.length - 1], extendedRange);
          }
        }
        return result;
      }
      _updateHintsDecorators(ranges, hints) {
        const { fontSize, fontFamily } = this._getLayoutInfo();
        const model = this._editor.getModel();
        const newDecorationsTypeIds = [];
        const newDecorationsData = [];
        const fontFamilyVar = "--code-editorInlayHintsFontFamily";
        this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily);
        for (const hint of hints) {
          const { text: text2, position, whitespaceBefore, whitespaceAfter } = hint;
          const marginBefore = whitespaceBefore ? fontSize / 3 | 0 : 0;
          const marginAfter = whitespaceAfter ? fontSize / 3 | 0 : 0;
          const contentOptions = {
            contentText: fixSpace(text2),
            fontSize: `${fontSize}px`,
            margin: `0px ${marginAfter}px 0px ${marginBefore}px`,
            fontFamily: `var(${fontFamilyVar})`,
            padding: `1px ${Math.max(1, fontSize / 4) | 0}px`,
            borderRadius: `${fontSize / 4 | 0}px`,
            verticalAlign: "middle",
            backgroundColor: themeColorFromId(editorInlayHintBackground),
            color: themeColorFromId(editorInlayHintForeground)
          };
          if (hint.kind === InlayHintKind.Parameter) {
            contentOptions.backgroundColor = themeColorFromId(editorInlayHintParameterBackground);
            contentOptions.color = themeColorFromId(editorInlayHintParameterForeground);
          } else if (hint.kind === InlayHintKind.Type) {
            contentOptions.backgroundColor = themeColorFromId(editorInlayHintTypeBackground);
            contentOptions.color = themeColorFromId(editorInlayHintTypeForeground);
          }
          let renderOptions = { beforeInjectedText: Object.assign(Object.assign({}, contentOptions), { affectsLetterSpacing: true }) };
          let range = Range.fromPositions(position);
          let word = model.getWordAtPosition(position);
          let usesWordRange = false;
          if (word) {
            if (word.endColumn === position.column) {
              renderOptions.afterInjectedText = renderOptions.beforeInjectedText;
              renderOptions.beforeInjectedText = void 0;
              usesWordRange = true;
              range = wordToRange(word, position.lineNumber);
            } else if (word.startColumn === position.column) {
              usesWordRange = true;
              range = wordToRange(word, position.lineNumber);
            }
          }
          const key = "inlayHints-" + hash(renderOptions).toString(16);
          this._codeEditorService.registerDecorationType("inlay-hints-controller", key, renderOptions, void 0, this._editor);
          newDecorationsTypeIds.push(key);
          const newLen = newDecorationsData.push({
            range,
            options: Object.assign(Object.assign({}, this._codeEditorService.resolveDecorationOptions(key, true)), {
              showIfCollapsed: !usesWordRange,
              stickiness: 0
              /* AlwaysGrowsWhenTypingAtEdges */
            })
          });
          if (newLen > MAX_DECORATORS2) {
            break;
          }
        }
        const decorationIdsToUpdate = [];
        for (const range of ranges) {
          for (const { id } of model.getDecorationsInRange(range, this._decorationOwnerId, true)) {
            const obj = this._decorations.get(id);
            if (obj) {
              decorationIdsToUpdate.push(id);
              this._codeEditorService.removeDecorationType(obj.decorationTypeId);
              this._decorations.delete(id);
            }
          }
        }
        const newDecorationIds = model.deltaDecorations(decorationIdsToUpdate, newDecorationsData, this._decorationOwnerId);
        for (let i = 0; i < newDecorationIds.length; i++) {
          this._decorations.set(newDecorationIds[i], { hint: hints[i], decorationTypeId: newDecorationsTypeIds[i] });
        }
      }
      _getLayoutInfo() {
        const options = this._editor.getOption(
          125
          /* inlayHints */
        );
        const editorFontSize = this._editor.getOption(
          45
          /* fontSize */
        );
        let fontSize = options.fontSize;
        if (!fontSize || fontSize < 5 || fontSize > editorFontSize) {
          fontSize = editorFontSize * 0.9 | 0;
        }
        const fontFamily = options.fontFamily || this._editor.getOption(
          42
          /* fontFamily */
        );
        return { fontSize, fontFamily };
      }
      _removeAllDecorations() {
        this._editor.deltaDecorations(Array.from(this._decorations.keys()), []);
        for (let obj of this._decorations.values()) {
          this._codeEditorService.removeDecorationType(obj.decorationTypeId);
        }
        this._decorations.clear();
      }
    };
    InlayHintsController.ID = "editor.contrib.InlayHints";
    InlayHintsController._decorationOwnerIdPool = 0;
    InlayHintsController = __decorate46([
      __param46(1, ICodeEditorService)
    ], InlayHintsController);
    registerEditorContribution(InlayHintsController.ID, InlayHintsController);
    CommandsRegistry.registerCommand("_executeInlayHintProvider", (accessor, ...args) => __awaiter33(void 0, void 0, void 0, function* () {
      const [uri, range] = args;
      assertType(URI.isUri(uri));
      assertType(Range.isIRange(range));
      const ref = yield accessor.get(ITextModelService).createModelReference(uri);
      try {
        const data = yield getInlayHints(ref.object.textEditorModel, [Range.lift(range)], CancellationToken.None);
        return data;
      } finally {
        ref.dispose();
      }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplaceCommand.js
var InPlaceReplaceCommand;
var init_inPlaceReplaceCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplaceCommand.js"() {
    init_selection();
    InPlaceReplaceCommand = class {
      constructor(editRange, originalSelection, text2) {
        this._editRange = editRange;
        this._originalSelection = originalSelection;
        this._text = text2;
      }
      getEditOperations(model, builder) {
        builder.addTrackedEditOperation(this._editRange, this._text);
      }
      computeCursorState(model, helper) {
        const inverseEditOperations = helper.getInverseEditOperations();
        const srcRange = inverseEditOperations[0].range;
        if (!this._originalSelection.isEmpty()) {
          return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
        }
        return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplace.js
var require_inPlaceReplace = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplace.js"(exports2) {
    init_async();
    init_errors();
    init_editorState();
    init_editorExtensions();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_textModel();
    init_editorWorkerService();
    init_editorColorRegistry();
    init_nls();
    init_themeService();
    init_inPlaceReplaceCommand();
    var __decorate61 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param61 = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var InPlaceReplaceController = class InPlaceReplaceController2 {
      constructor(editor2, editorWorkerService) {
        this.decorationIds = [];
        this.editor = editor2;
        this.editorWorkerService = editorWorkerService;
      }
      static get(editor2) {
        return editor2.getContribution(InPlaceReplaceController2.ID);
      }
      dispose() {
      }
      run(source, up) {
        if (this.currentRequest) {
          this.currentRequest.cancel();
        }
        const editorSelection = this.editor.getSelection();
        const model = this.editor.getModel();
        if (!model || !editorSelection) {
          return void 0;
        }
        let selection = editorSelection;
        if (selection.startLineNumber !== selection.endLineNumber) {
          return void 0;
        }
        const state = new EditorState(
          this.editor,
          1 | 4
          /* Position */
        );
        const modelURI = model.uri;
        if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
          return Promise.resolve(void 0);
        }
        this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
        return this.currentRequest.then((result) => {
          if (!result || !result.range || !result.value) {
            return;
          }
          if (!state.validate(this.editor)) {
            return;
          }
          let editRange = Range.lift(result.range);
          let highlightRange = result.range;
          let diff = result.value.length - (selection.endColumn - selection.startColumn);
          highlightRange = {
            startLineNumber: highlightRange.startLineNumber,
            startColumn: highlightRange.startColumn,
            endLineNumber: highlightRange.endLineNumber,
            endColumn: highlightRange.startColumn + result.value.length
          };
          if (diff > 1) {
            selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
          }
          const command = new InPlaceReplaceCommand(editRange, selection, result.value);
          this.editor.pushUndoStop();
          this.editor.executeCommand(source, command);
          this.editor.pushUndoStop();
          this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [{
            range: highlightRange,
            options: InPlaceReplaceController2.DECORATION
          }]);
          if (this.decorationRemover) {
            this.decorationRemover.cancel();
          }
          this.decorationRemover = timeout(350);
          this.decorationRemover.then(() => this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [])).catch(onUnexpectedError);
        }).catch(onUnexpectedError);
      }
    };
    InPlaceReplaceController.ID = "editor.contrib.inPlaceReplaceController";
    InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
      description: "in-place-replace",
      className: "valueSetReplacement"
    });
    InPlaceReplaceController = __decorate61([
      __param61(1, IEditorWorkerService)
    ], InPlaceReplaceController);
    var InPlaceReplaceUp = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.up",
          label: localize("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
          alias: "Replace with Previous Value",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 82,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, true);
      }
    };
    var InPlaceReplaceDown = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.down",
          label: localize("InPlaceReplaceAction.next.label", "Replace with Next Value"),
          alias: "Replace with Next Value",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 84,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, false);
      }
    };
    registerEditorContribution(InPlaceReplaceController.ID, InPlaceReplaceController);
    registerEditorAction(InPlaceReplaceUp);
    registerEditorAction(InPlaceReplaceDown);
    registerThemingParticipant((theme, collector) => {
      const border = theme.getColor(editorBracketMatchBorder);
      if (border) {
        collector.addRule(`.monaco-editor.vs .valueSetReplacement { outline: solid 2px ${border}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js
function trimTrailingWhitespace(model, cursors) {
  cursors.sort((a, b) => {
    if (a.lineNumber === b.lineNumber) {
      return a.column - b.column;
    }
    return a.lineNumber - b.lineNumber;
  });
  for (let i = cursors.length - 2; i >= 0; i--) {
    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
      cursors.splice(i, 1);
    }
  }
  let r = [];
  let rLen = 0;
  let cursorIndex = 0;
  let cursorLen = cursors.length;
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lineContent = model.getLineContent(lineNumber);
    let maxLineColumn = lineContent.length + 1;
    let minEditColumn = 0;
    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
      minEditColumn = cursors[cursorIndex].column;
      cursorIndex++;
      if (minEditColumn === maxLineColumn) {
        continue;
      }
    }
    if (lineContent.length === 0) {
      continue;
    }
    let lastNonWhitespaceIndex2 = lastNonWhitespaceIndex(lineContent);
    let fromColumn = 0;
    if (lastNonWhitespaceIndex2 === -1) {
      fromColumn = 1;
    } else if (lastNonWhitespaceIndex2 !== lineContent.length - 1) {
      fromColumn = lastNonWhitespaceIndex2 + 2;
    } else {
      continue;
    }
    fromColumn = Math.max(minEditColumn, fromColumn);
    r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));
  }
  return r;
}
var TrimTrailingWhitespaceCommand;
var init_trimTrailingWhitespaceCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js"() {
    init_strings();
    init_editOperation();
    init_range();
    TrimTrailingWhitespaceCommand = class {
      constructor(selection, cursors) {
        this._selection = selection;
        this._cursors = cursors;
        this._selectionId = null;
      }
      getEditOperations(model, builder) {
        let ops = trimTrailingWhitespace(model, this._cursors);
        for (let i = 0, len = ops.length; i < len; i++) {
          let op = ops[i];
          builder.addEditOperation(op.range, op.text);
        }
        this._selectionId = builder.trackSelection(this._selection);
      }
      computeCursorState(model, helper) {
        return helper.getTrackedSelection(this._selectionId);
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/copyLinesCommand.js
var CopyLinesCommand;
var init_copyLinesCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/copyLinesCommand.js"() {
    init_range();
    init_selection();
    CopyLinesCommand = class {
      constructor(selection, isCopyingDown, noop) {
        this._selection = selection;
        this._isCopyingDown = isCopyingDown;
        this._noop = noop || false;
        this._selectionDirection = 0;
        this._selectionId = null;
        this._startLineNumberDelta = 0;
        this._endLineNumberDelta = 0;
      }
      getEditOperations(model, builder) {
        let s = this._selection;
        this._startLineNumberDelta = 0;
        this._endLineNumberDelta = 0;
        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
          this._endLineNumberDelta = 1;
          s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
        }
        let sourceLines = [];
        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
          sourceLines.push(model.getLineContent(i));
        }
        const sourceText = sourceLines.join("\n");
        if (sourceText === "") {
          if (this._isCopyingDown) {
            this._startLineNumberDelta++;
            this._endLineNumberDelta++;
          }
        }
        if (this._noop) {
          builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? "" : "\n");
        } else {
          if (!this._isCopyingDown) {
            builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
          } else {
            builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
          }
        }
        this._selectionId = builder.trackSelection(s);
        this._selectionDirection = this._selection.getDirection();
      }
      computeCursorState(model, helper) {
        let result = helper.getTrackedSelection(this._selectionId);
        if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
          let startLineNumber = result.startLineNumber;
          let startColumn = result.startColumn;
          let endLineNumber = result.endLineNumber;
          let endColumn = result.endColumn;
          if (this._startLineNumberDelta !== 0) {
            startLineNumber = startLineNumber + this._startLineNumberDelta;
            startColumn = 1;
          }
          if (this._endLineNumberDelta !== 0) {
            endLineNumber = endLineNumber + this._endLineNumberDelta;
            endColumn = 1;
          }
          result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
        }
        return result;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/moveLinesCommand.js
var MoveLinesCommand;
var init_moveLinesCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/moveLinesCommand.js"() {
    init_strings();
    init_shiftCommand();
    init_range();
    init_selection();
    init_languageConfiguration();
    init_languageConfigurationRegistry();
    init_indentUtils();
    MoveLinesCommand = class {
      constructor(selection, isMovingDown, autoIndent) {
        this._selection = selection;
        this._isMovingDown = isMovingDown;
        this._autoIndent = autoIndent;
        this._selectionId = null;
        this._moveEndLineSelectionShrink = false;
      }
      getEditOperations(model, builder) {
        let modelLineCount = model.getLineCount();
        if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
          this._selectionId = builder.trackSelection(this._selection);
          return;
        }
        if (!this._isMovingDown && this._selection.startLineNumber === 1) {
          this._selectionId = builder.trackSelection(this._selection);
          return;
        }
        this._moveEndPositionDown = false;
        let s = this._selection;
        if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
          this._moveEndPositionDown = true;
          s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
        }
        const { tabSize, indentSize, insertSpaces } = model.getOptions();
        let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
        let virtualModel = {
          getLineTokens: (lineNumber) => {
            return model.getLineTokens(lineNumber);
          },
          getLanguageIdentifier: () => {
            return model.getLanguageIdentifier();
          },
          getLanguageIdAtPosition: (lineNumber, column) => {
            return model.getLanguageIdAtPosition(lineNumber, column);
          },
          getLineContent: null
        };
        if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
          let lineNumber = s.startLineNumber;
          let otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
          if (model.getLineMaxColumn(otherLineNumber) === 1) {
            builder.addEditOperation(new Range(1, 1, 1, 1), null);
          } else {
            builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
            builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
          }
          s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
        } else {
          let movingLineNumber;
          let movingLineText;
          if (this._isMovingDown) {
            movingLineNumber = s.endLineNumber + 1;
            movingLineText = model.getLineContent(movingLineNumber);
            builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
            let insertingText = movingLineText;
            if (this.shouldAutoIndent(model, s)) {
              let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
              if (movingLineMatchResult !== null) {
                let oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
                let newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
                let newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                insertingText = newIndentation + this.trimLeft(movingLineText);
              } else {
                virtualModel.getLineContent = (lineNumber) => {
                  if (lineNumber === s.startLineNumber) {
                    return model.getLineContent(movingLineNumber);
                  } else {
                    return model.getLineContent(lineNumber);
                  }
                };
                let indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);
                if (indentOfMovingLine !== null) {
                  let oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
                  let newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
                  let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
                  if (newSpaceCnt !== oldSpaceCnt) {
                    let newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                    insertingText = newIndentation + this.trimLeft(movingLineText);
                  }
                }
              }
              builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
              let ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);
              if (ret !== null) {
                if (ret !== 0) {
                  this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
                }
              } else {
                virtualModel.getLineContent = (lineNumber) => {
                  if (lineNumber === s.startLineNumber) {
                    return insertingText;
                  } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                    return model.getLineContent(lineNumber - 1);
                  } else {
                    return model.getLineContent(lineNumber);
                  }
                };
                let newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);
                if (newIndentatOfMovingBlock !== null) {
                  const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
                  const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
                  const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
                  if (newSpaceCnt !== oldSpaceCnt) {
                    const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                    this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
                  }
                }
              }
            } else {
              builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
            }
          } else {
            movingLineNumber = s.startLineNumber - 1;
            movingLineText = model.getLineContent(movingLineNumber);
            builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
            builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
            if (this.shouldAutoIndent(model, s)) {
              virtualModel.getLineContent = (lineNumber) => {
                if (lineNumber === movingLineNumber) {
                  return model.getLineContent(s.startLineNumber);
                } else {
                  return model.getLineContent(lineNumber);
                }
              };
              let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
              if (ret !== null) {
                if (ret !== 0) {
                  this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
                }
              } else {
                let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);
                if (indentOfFirstLine !== null) {
                  let oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
                  let newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
                  let oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
                  if (newSpaceCnt !== oldSpaceCnt) {
                    let spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                    this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
                  }
                }
              }
            }
          }
        }
        this._selectionId = builder.trackSelection(s);
      }
      buildIndentConverter(tabSize, indentSize, insertSpaces) {
        return {
          shiftIndent: (indentation) => {
            return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
          },
          unshiftIndent: (indentation) => {
            return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
          }
        };
      }
      parseEnterResult(model, indentConverter, tabSize, line, enter) {
        if (enter) {
          let enterPrefix = enter.indentation;
          if (enter.indentAction === IndentAction.None) {
            enterPrefix = enter.indentation + enter.appendText;
          } else if (enter.indentAction === IndentAction.Indent) {
            enterPrefix = enter.indentation + enter.appendText;
          } else if (enter.indentAction === IndentAction.IndentOutdent) {
            enterPrefix = enter.indentation;
          } else if (enter.indentAction === IndentAction.Outdent) {
            enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
          }
          let movingLineText = model.getLineContent(line);
          if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {
            let oldIndentation = getLeadingWhitespace(model.getLineContent(line));
            let newIndentation = getLeadingWhitespace(enterPrefix);
            let indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);
            if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) {
              newIndentation = indentConverter.unshiftIndent(newIndentation);
            }
            let newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
            let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
            return newSpaceCnt - oldSpaceCnt;
          }
        }
        return null;
      }
      /**
       *
       * @param model
       * @param indentConverter
       * @param tabSize
       * @param line the line moving down
       * @param futureAboveLineNumber the line which will be at the `line` position
       * @param futureAboveLineText
       */
      matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {
        if (lastNonWhitespaceIndex(futureAboveLineText) >= 0) {
          let maxColumn = model.getLineMaxColumn(futureAboveLineNumber);
          let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn));
          return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
        } else {
          let validPrecedingLine = line - 1;
          while (validPrecedingLine >= 1) {
            let lineContent = model.getLineContent(validPrecedingLine);
            let nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
            if (nonWhitespaceIdx >= 0) {
              break;
            }
            validPrecedingLine--;
          }
          if (validPrecedingLine < 1 || line > model.getLineCount()) {
            return null;
          }
          let maxColumn = model.getLineMaxColumn(validPrecedingLine);
          let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));
          return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
        }
      }
      matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {
        let validPrecedingLine = oneLineAbove;
        while (validPrecedingLine >= 1) {
          let lineContent;
          if (validPrecedingLine === oneLineAbove && previousLineText !== void 0) {
            lineContent = previousLineText;
          } else {
            lineContent = model.getLineContent(validPrecedingLine);
          }
          let nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
          if (nonWhitespaceIdx >= 0) {
            break;
          }
          validPrecedingLine--;
        }
        if (validPrecedingLine < 1 || line > model.getLineCount()) {
          return null;
        }
        let maxColumn = model.getLineMaxColumn(validPrecedingLine);
        let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));
        return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
      }
      trimLeft(str) {
        return str.replace(/^\s+/, "");
      }
      shouldAutoIndent(model, selection) {
        if (this._autoIndent < 4) {
          return false;
        }
        if (!model.isCheapToTokenize(selection.startLineNumber)) {
          return false;
        }
        let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
        let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
        if (languageAtSelectionStart !== languageAtSelectionEnd) {
          return false;
        }
        if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {
          return false;
        }
        return true;
      }
      getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
        for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
          let lineContent = model.getLineContent(i);
          let originalIndent = getLeadingWhitespace(lineContent);
          let originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
          let newSpacesCnt = originalSpacesCnt + offset;
          let newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
          if (newIndent !== originalIndent) {
            builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);
            if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") {
              this._moveEndLineSelectionShrink = true;
            }
          }
        }
      }
      computeCursorState(model, helper) {
        let result = helper.getTrackedSelection(this._selectionId);
        if (this._moveEndPositionDown) {
          result = result.setEndPosition(result.endLineNumber + 1, 1);
        }
        if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
          result = result.setEndPosition(result.endLineNumber, 2);
        }
        return result;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/sortLinesCommand.js
function getSortData(model, selection, descending) {
  let startLineNumber = selection.startLineNumber;
  let endLineNumber = selection.endLineNumber;
  if (selection.endColumn === 1) {
    endLineNumber--;
  }
  if (startLineNumber >= endLineNumber) {
    return null;
  }
  let linesToSort = [];
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    linesToSort.push(model.getLineContent(lineNumber));
  }
  let sorted = linesToSort.slice(0);
  sorted.sort(SortLinesCommand.getCollator().compare);
  if (descending === true) {
    sorted = sorted.reverse();
  }
  return {
    startLineNumber,
    endLineNumber,
    before: linesToSort,
    after: sorted
  };
}
function sortLines(model, selection, descending) {
  let data = getSortData(model, selection, descending);
  if (!data) {
    return null;
  }
  return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}
var SortLinesCommand;
var init_sortLinesCommand = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/sortLinesCommand.js"() {
    init_editOperation();
    init_range();
    SortLinesCommand = class _SortLinesCommand {
      constructor(selection, descending) {
        this.selection = selection;
        this.descending = descending;
        this.selectionId = null;
      }
      static getCollator() {
        if (!_SortLinesCommand._COLLATOR) {
          _SortLinesCommand._COLLATOR = new Intl.Collator();
        }
        return _SortLinesCommand._COLLATOR;
      }
      getEditOperations(model, builder) {
        let op = sortLines(model, this.selection, this.descending);
        if (op) {
          builder.addEditOperation(op.range, op.text);
        }
        this.selectionId = builder.trackSelection(this.selection);
      }
      computeCursorState(model, helper) {
        return helper.getTrackedSelection(this.selectionId);
      }
      static canRun(model, selection, descending) {
        if (model === null) {
          return false;
        }
        let data = getSortData(model, selection, descending);
        if (!data) {
          return false;
        }
        for (let i = 0, len = data.before.length; i < len; i++) {
          if (data.before[i] !== data.after[i]) {
            return true;
          }
        }
        return false;
      }
    };
    SortLinesCommand._COLLATOR = null;
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/linesOperations.js
var AbstractCopyLinesAction, CopyLinesUpAction, CopyLinesDownAction, DuplicateSelectionAction, AbstractMoveLinesAction, MoveLinesUpAction, MoveLinesDownAction, AbstractSortLinesAction, SortLinesAscendingAction, SortLinesDescendingAction, TrimTrailingWhitespaceAction, DeleteLinesAction, IndentLinesAction, OutdentLinesAction, InsertLineBeforeAction, InsertLineAfterAction, AbstractDeleteAllToBoundaryAction, DeleteAllLeftAction, DeleteAllRightAction, JoinLinesAction, TransposeAction, AbstractCaseAction, UpperCaseAction, LowerCaseAction, TitleCaseAction, BackwardsCompatibleRegExp, SnakeCaseAction;
var init_linesOperations = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/linesOperations.js"() {
    init_keyCodes();
    init_coreCommands();
    init_editorExtensions();
    init_replaceCommand();
    init_trimTrailingWhitespaceCommand();
    init_cursorTypeOperations();
    init_editOperation();
    init_position();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_copyLinesCommand();
    init_moveLinesCommand();
    init_sortLinesCommand();
    init_nls();
    init_actions2();
    AbstractCopyLinesAction = class extends EditorAction {
      constructor(down, opts) {
        super(opts);
        this.down = down;
      }
      run(_accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignore: false }));
        selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
        let prev = selections[0];
        for (let i = 1; i < selections.length; i++) {
          const curr = selections[i];
          if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
            if (prev.index < curr.index) {
              curr.ignore = true;
            } else {
              prev.ignore = true;
              prev = curr;
            }
          }
        }
        const commands = [];
        for (const selection of selections) {
          commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    CopyLinesUpAction = class extends AbstractCopyLinesAction {
      constructor() {
        super(false, {
          id: "editor.action.copyLinesUpAction",
          label: localize("lines.copyUp", "Copy Line Up"),
          alias: "Copy Line Up",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 512 | 1024 | 16,
            linux: {
              primary: 2048 | 512 | 1024 | 16
              /* UpArrow */
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "2_line",
            title: localize({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
            order: 1
          }
        });
      }
    };
    CopyLinesDownAction = class extends AbstractCopyLinesAction {
      constructor() {
        super(true, {
          id: "editor.action.copyLinesDownAction",
          label: localize("lines.copyDown", "Copy Line Down"),
          alias: "Copy Line Down",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 512 | 1024 | 18,
            linux: {
              primary: 2048 | 512 | 1024 | 18
              /* DownArrow */
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "2_line",
            title: localize({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
            order: 2
          }
        });
      }
    };
    DuplicateSelectionAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.duplicateSelection",
          label: localize("duplicateSelection", "Duplicate Selection"),
          alias: "Duplicate Selection",
          precondition: EditorContextKeys.writable,
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "2_line",
            title: localize({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
            order: 5
          }
        });
      }
      run(accessor, editor2, args) {
        if (!editor2.hasModel()) {
          return;
        }
        const commands = [];
        const selections = editor2.getSelections();
        const model = editor2.getModel();
        for (const selection of selections) {
          if (selection.isEmpty()) {
            commands.push(new CopyLinesCommand(selection, true));
          } else {
            const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
            commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
          }
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    AbstractMoveLinesAction = class extends EditorAction {
      constructor(down, opts) {
        super(opts);
        this.down = down;
      }
      run(_accessor, editor2) {
        let commands = [];
        let selections = editor2.getSelections() || [];
        const autoIndent = editor2.getOption(
          9
          /* autoIndent */
        );
        for (const selection of selections) {
          commands.push(new MoveLinesCommand(selection, this.down, autoIndent));
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    MoveLinesUpAction = class extends AbstractMoveLinesAction {
      constructor() {
        super(false, {
          id: "editor.action.moveLinesUpAction",
          label: localize("lines.moveUp", "Move Line Up"),
          alias: "Move Line Up",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 512 | 16,
            linux: {
              primary: 512 | 16
              /* UpArrow */
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "2_line",
            title: localize({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
            order: 3
          }
        });
      }
    };
    MoveLinesDownAction = class extends AbstractMoveLinesAction {
      constructor() {
        super(true, {
          id: "editor.action.moveLinesDownAction",
          label: localize("lines.moveDown", "Move Line Down"),
          alias: "Move Line Down",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 512 | 18,
            linux: {
              primary: 512 | 18
              /* DownArrow */
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "2_line",
            title: localize({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
            order: 4
          }
        });
      }
    };
    AbstractSortLinesAction = class extends EditorAction {
      constructor(descending, opts) {
        super(opts);
        this.descending = descending;
      }
      run(_accessor, editor2) {
        const selections = editor2.getSelections() || [];
        for (const selection of selections) {
          if (!SortLinesCommand.canRun(editor2.getModel(), selection, this.descending)) {
            return;
          }
        }
        let commands = [];
        for (let i = 0, len = selections.length; i < len; i++) {
          commands[i] = new SortLinesCommand(selections[i], this.descending);
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    SortLinesAscendingAction = class extends AbstractSortLinesAction {
      constructor() {
        super(false, {
          id: "editor.action.sortLinesAscending",
          label: localize("lines.sortAscending", "Sort Lines Ascending"),
          alias: "Sort Lines Ascending",
          precondition: EditorContextKeys.writable
        });
      }
    };
    SortLinesDescendingAction = class extends AbstractSortLinesAction {
      constructor() {
        super(true, {
          id: "editor.action.sortLinesDescending",
          label: localize("lines.sortDescending", "Sort Lines Descending"),
          alias: "Sort Lines Descending",
          precondition: EditorContextKeys.writable
        });
      }
    };
    TrimTrailingWhitespaceAction = class _TrimTrailingWhitespaceAction extends EditorAction {
      constructor() {
        super({
          id: _TrimTrailingWhitespaceAction.ID,
          label: localize("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
          alias: "Trim Trailing Whitespace",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(
              2048 | 41,
              2048 | 54
              /* KEY_X */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2, args) {
        let cursors = [];
        if (args.reason === "auto-save") {
          cursors = (editor2.getSelections() || []).map((s) => new Position(s.positionLineNumber, s.positionColumn));
        }
        let selection = editor2.getSelection();
        if (selection === null) {
          return;
        }
        let command = new TrimTrailingWhitespaceCommand(selection, cursors);
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, [command]);
        editor2.pushUndoStop();
      }
    };
    TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
    DeleteLinesAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.deleteLines",
          label: localize("lines.delete", "Delete Line"),
          alias: "Delete Line",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 | 1024 | 41,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        let ops = this._getLinesToRemove(editor2);
        let model = editor2.getModel();
        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
          return;
        }
        let linesDeleted = 0;
        let edits = [];
        let cursorState = [];
        for (let i = 0, len = ops.length; i < len; i++) {
          const op = ops[i];
          let startLineNumber = op.startLineNumber;
          let endLineNumber = op.endLineNumber;
          let startColumn = 1;
          let endColumn = model.getLineMaxColumn(endLineNumber);
          if (endLineNumber < model.getLineCount()) {
            endLineNumber += 1;
            endColumn = 1;
          } else if (startLineNumber > 1) {
            startLineNumber -= 1;
            startColumn = model.getLineMaxColumn(startLineNumber);
          }
          edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ""));
          cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
          linesDeleted += op.endLineNumber - op.startLineNumber + 1;
        }
        editor2.pushUndoStop();
        editor2.executeEdits(this.id, edits, cursorState);
        editor2.pushUndoStop();
      }
      _getLinesToRemove(editor2) {
        let operations = editor2.getSelections().map((s) => {
          let endLineNumber = s.endLineNumber;
          if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
            endLineNumber -= 1;
          }
          return {
            startLineNumber: s.startLineNumber,
            selectionStartColumn: s.selectionStartColumn,
            endLineNumber,
            positionColumn: s.positionColumn
          };
        });
        operations.sort((a, b) => {
          if (a.startLineNumber === b.startLineNumber) {
            return a.endLineNumber - b.endLineNumber;
          }
          return a.startLineNumber - b.startLineNumber;
        });
        let mergedOperations = [];
        let previousOperation = operations[0];
        for (let i = 1; i < operations.length; i++) {
          if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {
            previousOperation.endLineNumber = operations[i].endLineNumber;
          } else {
            mergedOperations.push(previousOperation);
            previousOperation = operations[i];
          }
        }
        mergedOperations.push(previousOperation);
        return mergedOperations;
      }
    };
    IndentLinesAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.indentLines",
          label: localize("lines.indent", "Indent Line"),
          alias: "Indent Line",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 89,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        const viewModel = editor2._getViewModel();
        if (!viewModel) {
          return;
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
        editor2.pushUndoStop();
      }
    };
    OutdentLinesAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.outdentLines",
          label: localize("lines.outdent", "Outdent Line"),
          alias: "Outdent Line",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 87,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor2, null);
      }
    };
    InsertLineBeforeAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.insertLineBefore",
          label: localize("lines.insertBefore", "Insert Line Above"),
          alias: "Insert Line Above",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 3,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        const viewModel = editor2._getViewModel();
        if (!viewModel) {
          return;
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
      }
    };
    InsertLineAfterAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.insertLineAfter",
          label: localize("lines.insertAfter", "Insert Line Below"),
          alias: "Insert Line Below",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 3,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        const viewModel = editor2._getViewModel();
        if (!viewModel) {
          return;
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
      }
    };
    AbstractDeleteAllToBoundaryAction = class extends EditorAction {
      run(_accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const primaryCursor = editor2.getSelection();
        let rangesToDelete = this._getRangesToDelete(editor2);
        let effectiveRanges = [];
        for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {
          let range = rangesToDelete[i];
          let nextRange = rangesToDelete[i + 1];
          if (Range.intersectRanges(range, nextRange) === null) {
            effectiveRanges.push(range);
          } else {
            rangesToDelete[i + 1] = Range.plusRange(range, nextRange);
          }
        }
        effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
        let endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
        let edits = effectiveRanges.map((range) => {
          return EditOperation.replace(range, "");
        });
        editor2.pushUndoStop();
        editor2.executeEdits(this.id, edits, endCursorState);
        editor2.pushUndoStop();
      }
    };
    DeleteAllLeftAction = class extends AbstractDeleteAllToBoundaryAction {
      constructor() {
        super({
          id: "deleteAllLeft",
          label: localize("lines.deleteAllLeft", "Delete All Left"),
          alias: "Delete All Left",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 2048 | 1
              /* Backspace */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      _getEndCursorState(primaryCursor, rangesToDelete) {
        let endPrimaryCursor = null;
        let endCursorState = [];
        let deletedLines = 0;
        rangesToDelete.forEach((range) => {
          let endCursor;
          if (range.endColumn === 1 && deletedLines > 0) {
            let newStartLine = range.startLineNumber - deletedLines;
            endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);
          } else {
            endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
          }
          deletedLines += range.endLineNumber - range.startLineNumber;
          if (range.intersectRanges(primaryCursor)) {
            endPrimaryCursor = endCursor;
          } else {
            endCursorState.push(endCursor);
          }
        });
        if (endPrimaryCursor) {
          endCursorState.unshift(endPrimaryCursor);
        }
        return endCursorState;
      }
      _getRangesToDelete(editor2) {
        let selections = editor2.getSelections();
        if (selections === null) {
          return [];
        }
        let rangesToDelete = selections;
        let model = editor2.getModel();
        if (model === null) {
          return [];
        }
        rangesToDelete.sort(Range.compareRangesUsingStarts);
        rangesToDelete = rangesToDelete.map((selection) => {
          if (selection.isEmpty()) {
            if (selection.startColumn === 1) {
              let deleteFromLine = Math.max(1, selection.startLineNumber - 1);
              let deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;
              return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);
            } else {
              return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
            }
          } else {
            return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
          }
        });
        return rangesToDelete;
      }
    };
    DeleteAllRightAction = class extends AbstractDeleteAllToBoundaryAction {
      constructor() {
        super({
          id: "deleteAllRight",
          label: localize("lines.deleteAllRight", "Delete All Right"),
          alias: "Delete All Right",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: { primary: 256 | 41, secondary: [
              2048 | 20
              /* Delete */
            ] },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      _getEndCursorState(primaryCursor, rangesToDelete) {
        let endPrimaryCursor = null;
        let endCursorState = [];
        for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
          let range = rangesToDelete[i];
          let endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
          if (range.intersectRanges(primaryCursor)) {
            endPrimaryCursor = endCursor;
          } else {
            endCursorState.push(endCursor);
          }
        }
        if (endPrimaryCursor) {
          endCursorState.unshift(endPrimaryCursor);
        }
        return endCursorState;
      }
      _getRangesToDelete(editor2) {
        let model = editor2.getModel();
        if (model === null) {
          return [];
        }
        let selections = editor2.getSelections();
        if (selections === null) {
          return [];
        }
        let rangesToDelete = selections.map((sel) => {
          if (sel.isEmpty()) {
            const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
            if (sel.startColumn === maxColumn) {
              return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
            } else {
              return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
            }
          }
          return sel;
        });
        rangesToDelete.sort(Range.compareRangesUsingStarts);
        return rangesToDelete;
      }
    };
    JoinLinesAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.joinLines",
          label: localize("lines.joinLines", "Join Lines"),
          alias: "Join Lines",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 0,
            mac: {
              primary: 256 | 40
              /* KEY_J */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(_accessor, editor2) {
        let selections = editor2.getSelections();
        if (selections === null) {
          return;
        }
        let primaryCursor = editor2.getSelection();
        if (primaryCursor === null) {
          return;
        }
        selections.sort(Range.compareRangesUsingStarts);
        let reducedSelections = [];
        let lastSelection = selections.reduce((previousValue, currentValue) => {
          if (previousValue.isEmpty()) {
            if (previousValue.endLineNumber === currentValue.startLineNumber) {
              if (primaryCursor.equalsSelection(previousValue)) {
                primaryCursor = currentValue;
              }
              return currentValue;
            }
            if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
              reducedSelections.push(previousValue);
              return currentValue;
            } else {
              return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
            }
          } else {
            if (currentValue.startLineNumber > previousValue.endLineNumber) {
              reducedSelections.push(previousValue);
              return currentValue;
            } else {
              return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
            }
          }
        });
        reducedSelections.push(lastSelection);
        let model = editor2.getModel();
        if (model === null) {
          return;
        }
        let edits = [];
        let endCursorState = [];
        let endPrimaryCursor = primaryCursor;
        let lineOffset = 0;
        for (let i = 0, len = reducedSelections.length; i < len; i++) {
          let selection = reducedSelections[i];
          let startLineNumber = selection.startLineNumber;
          let startColumn = 1;
          let columnDeltaOffset = 0;
          let endLineNumber, endColumn;
          let selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
          if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
            let position = selection.getStartPosition();
            if (position.lineNumber < model.getLineCount()) {
              endLineNumber = startLineNumber + 1;
              endColumn = model.getLineMaxColumn(endLineNumber);
            } else {
              endLineNumber = position.lineNumber;
              endColumn = model.getLineMaxColumn(position.lineNumber);
            }
          } else {
            endLineNumber = selection.endLineNumber;
            endColumn = model.getLineMaxColumn(endLineNumber);
          }
          let trimmedLinesContent = model.getLineContent(startLineNumber);
          for (let i2 = startLineNumber + 1; i2 <= endLineNumber; i2++) {
            let lineText = model.getLineContent(i2);
            let firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i2);
            if (firstNonWhitespaceIdx >= 1) {
              let insertSpace = true;
              if (trimmedLinesContent === "") {
                insertSpace = false;
              }
              if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
                insertSpace = false;
                trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
              }
              let lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
              trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
              if (insertSpace) {
                columnDeltaOffset = lineTextWithoutIndent.length + 1;
              } else {
                columnDeltaOffset = lineTextWithoutIndent.length;
              }
            } else {
              columnDeltaOffset = 0;
            }
          }
          let deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
          if (!deleteSelection.isEmpty()) {
            let resultSelection;
            if (selection.isEmpty()) {
              edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
              resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
            } else {
              if (selection.startLineNumber === selection.endLineNumber) {
                edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
                resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
              } else {
                edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
                resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
              }
            }
            if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {
              endPrimaryCursor = resultSelection;
            } else {
              endCursorState.push(resultSelection);
            }
          }
          lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
        }
        endCursorState.unshift(endPrimaryCursor);
        editor2.pushUndoStop();
        editor2.executeEdits(this.id, edits, endCursorState);
        editor2.pushUndoStop();
      }
    };
    TransposeAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.transpose",
          label: localize("editor.transpose", "Transpose characters around the cursor"),
          alias: "Transpose characters around the cursor",
          precondition: EditorContextKeys.writable
        });
      }
      run(_accessor, editor2) {
        let selections = editor2.getSelections();
        if (selections === null) {
          return;
        }
        let model = editor2.getModel();
        if (model === null) {
          return;
        }
        let commands = [];
        for (let i = 0, len = selections.length; i < len; i++) {
          let selection = selections[i];
          if (!selection.isEmpty()) {
            continue;
          }
          let cursor = selection.getStartPosition();
          let maxColumn = model.getLineMaxColumn(cursor.lineNumber);
          if (cursor.column >= maxColumn) {
            if (cursor.lineNumber === model.getLineCount()) {
              continue;
            }
            let deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
            let chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
            commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
          } else {
            let deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
            let chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
            commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
          }
        }
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    AbstractCaseAction = class extends EditorAction {
      run(_accessor, editor2) {
        const selections = editor2.getSelections();
        if (selections === null) {
          return;
        }
        const model = editor2.getModel();
        if (model === null) {
          return;
        }
        const wordSeparators = editor2.getOption(
          115
          /* wordSeparators */
        );
        const textEdits = [];
        for (const selection of selections) {
          if (selection.isEmpty()) {
            const cursor = selection.getStartPosition();
            const word = editor2.getConfiguredWordAtPosition(cursor);
            if (!word) {
              continue;
            }
            const wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
            const text2 = model.getValueInRange(wordRange);
            textEdits.push(EditOperation.replace(wordRange, this._modifyText(text2, wordSeparators)));
          } else {
            const text2 = model.getValueInRange(selection);
            textEdits.push(EditOperation.replace(selection, this._modifyText(text2, wordSeparators)));
          }
        }
        editor2.pushUndoStop();
        editor2.executeEdits(this.id, textEdits);
        editor2.pushUndoStop();
      }
    };
    UpperCaseAction = class extends AbstractCaseAction {
      constructor() {
        super({
          id: "editor.action.transformToUppercase",
          label: localize("editor.transformToUppercase", "Transform to Uppercase"),
          alias: "Transform to Uppercase",
          precondition: EditorContextKeys.writable
        });
      }
      _modifyText(text2, wordSeparators) {
        return text2.toLocaleUpperCase();
      }
    };
    LowerCaseAction = class extends AbstractCaseAction {
      constructor() {
        super({
          id: "editor.action.transformToLowercase",
          label: localize("editor.transformToLowercase", "Transform to Lowercase"),
          alias: "Transform to Lowercase",
          precondition: EditorContextKeys.writable
        });
      }
      _modifyText(text2, wordSeparators) {
        return text2.toLocaleLowerCase();
      }
    };
    TitleCaseAction = class extends AbstractCaseAction {
      constructor() {
        super({
          id: "editor.action.transformToTitlecase",
          label: localize("editor.transformToTitlecase", "Transform to Title Case"),
          alias: "Transform to Title Case",
          precondition: EditorContextKeys.writable
        });
      }
      _modifyText(text2, wordSeparators) {
        const separators = "\r\n	 " + wordSeparators;
        const excludedChars = separators.split("");
        let title = "";
        let startUpperCase = true;
        for (let i = 0; i < text2.length; i++) {
          let currentChar = text2[i];
          if (excludedChars.indexOf(currentChar) >= 0) {
            startUpperCase = true;
            title += currentChar;
          } else if (startUpperCase) {
            startUpperCase = false;
            title += currentChar.toLocaleUpperCase();
          } else {
            title += currentChar.toLocaleLowerCase();
          }
        }
        return title;
      }
    };
    BackwardsCompatibleRegExp = class {
      constructor(_pattern, _flags) {
        this._pattern = _pattern;
        this._flags = _flags;
        this._actual = null;
        this._evaluated = false;
      }
      get() {
        if (!this._evaluated) {
          this._evaluated = true;
          try {
            this._actual = new RegExp(this._pattern, this._flags);
          } catch (err) {
          }
        }
        return this._actual;
      }
      isSupported() {
        return this.get() !== null;
      }
    };
    SnakeCaseAction = class _SnakeCaseAction extends AbstractCaseAction {
      constructor() {
        super({
          id: "editor.action.transformToSnakecase",
          label: localize("editor.transformToSnakecase", "Transform to Snake Case"),
          alias: "Transform to Snake Case",
          precondition: EditorContextKeys.writable
        });
      }
      _modifyText(text2, wordSeparators) {
        const regExp1 = _SnakeCaseAction.regExp1.get();
        const regExp2 = _SnakeCaseAction.regExp2.get();
        if (!regExp1 || !regExp2) {
          return text2;
        }
        return text2.replace(regExp1, "$1_$2").replace(regExp2, "$1_$2$3").toLocaleLowerCase();
      }
    };
    SnakeCaseAction.regExp1 = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
    SnakeCaseAction.regExp2 = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
    registerEditorAction(CopyLinesUpAction);
    registerEditorAction(CopyLinesDownAction);
    registerEditorAction(DuplicateSelectionAction);
    registerEditorAction(MoveLinesUpAction);
    registerEditorAction(MoveLinesDownAction);
    registerEditorAction(SortLinesAscendingAction);
    registerEditorAction(SortLinesDescendingAction);
    registerEditorAction(TrimTrailingWhitespaceAction);
    registerEditorAction(DeleteLinesAction);
    registerEditorAction(IndentLinesAction);
    registerEditorAction(OutdentLinesAction);
    registerEditorAction(InsertLineBeforeAction);
    registerEditorAction(InsertLineAfterAction);
    registerEditorAction(DeleteAllLeftAction);
    registerEditorAction(DeleteAllRightAction);
    registerEditorAction(JoinLinesAction);
    registerEditorAction(TransposeAction);
    registerEditorAction(UpperCaseAction);
    registerEditorAction(LowerCaseAction);
    registerEditorAction(TitleCaseAction);
    if (SnakeCaseAction.regExp1.isSupported() && SnakeCaseAction.regExp2.isSupported()) {
      registerEditorAction(SnakeCaseAction);
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/linkedEditing.js
function getLinkedEditingRanges(model, position, token) {
  const orderedByScore = LinkedEditingRangeProviderRegistry.ordered(model);
  return first(orderedByScore.map((provider) => () => __awaiter34(this, void 0, void 0, function* () {
    try {
      return yield provider.provideLinkedEditingRanges(model, position, token);
    } catch (e) {
      onUnexpectedExternalError(e);
      return void 0;
    }
  })), (result) => !!result && isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
}
var __decorate47, __param47, __awaiter34, CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE, DECORATION_CLASS_NAME, LinkedEditingContribution, LinkedEditingAction, LinkedEditingCommand, editorLinkedEditingBackground;
var init_linkedEditing = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/linkedEditing.js"() {
    init_arrays();
    init_async();
    init_cancellation();
    init_color();
    init_errors();
    init_lifecycle();
    init_strings();
    init_uri();
    init_editorExtensions();
    init_codeEditorService();
    init_position();
    init_range();
    init_editorContextKeys();
    init_textModel();
    init_modes();
    init_languageConfigurationRegistry();
    init_nls();
    init_contextkey();
    init_colorRegistry();
    init_themeService();
    __decorate47 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param47 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter34 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("LinkedEditingInputVisible", false);
    DECORATION_CLASS_NAME = "linked-editing-decoration";
    LinkedEditingContribution = class LinkedEditingContribution2 extends Disposable {
      constructor(editor2, contextKeyService) {
        super();
        this._debounceDuration = 200;
        this._localToDispose = this._register(new DisposableStore());
        this._editor = editor2;
        this._enabled = false;
        this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
        this._currentDecorations = [];
        this._languageWordPattern = null;
        this._currentWordPattern = null;
        this._ignoreChangeEvent = false;
        this._localToDispose = this._register(new DisposableStore());
        this._rangeUpdateTriggerPromise = null;
        this._rangeSyncTriggerPromise = null;
        this._currentRequest = null;
        this._currentRequestPosition = null;
        this._currentRequestModelVersion = null;
        this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));
        this._register(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            61
            /* linkedEditing */
          ) || e.hasChanged(
            81
            /* renameOnType */
          )) {
            this.reinitialize(false);
          }
        }));
        this._register(LinkedEditingRangeProviderRegistry.onDidChange(() => this.reinitialize(false)));
        this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));
        this.reinitialize(true);
      }
      static get(editor2) {
        return editor2.getContribution(LinkedEditingContribution2.ID);
      }
      reinitialize(forceRefresh) {
        const model = this._editor.getModel();
        const isEnabled = model !== null && (this._editor.getOption(
          61
          /* linkedEditing */
        ) || this._editor.getOption(
          81
          /* renameOnType */
        )) && LinkedEditingRangeProviderRegistry.has(model);
        if (isEnabled === this._enabled && !forceRefresh) {
          return;
        }
        this._enabled = isEnabled;
        this.clearRanges();
        this._localToDispose.clear();
        if (!isEnabled || model === null) {
          return;
        }
        this._languageWordPattern = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
        this._localToDispose.add(model.onDidChangeLanguageConfiguration(() => {
          this._languageWordPattern = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
        }));
        const rangeUpdateScheduler = new Delayer(this._debounceDuration);
        const triggerRangeUpdate = () => {
          this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), this._debounceDuration);
        };
        const rangeSyncScheduler = new Delayer(0);
        const triggerRangeSync = (decorations) => {
          this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(decorations));
        };
        this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
          triggerRangeUpdate();
        }));
        this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
          if (!this._ignoreChangeEvent) {
            if (this._currentDecorations.length > 0) {
              const referenceRange = model.getDecorationRange(this._currentDecorations[0]);
              if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
                triggerRangeSync(this._currentDecorations);
                return;
              }
            }
          }
          triggerRangeUpdate();
        }));
        this._localToDispose.add({
          dispose: () => {
            rangeUpdateScheduler.cancel();
            rangeSyncScheduler.cancel();
          }
        });
        this.updateRanges();
      }
      _syncRanges(decorations) {
        if (!this._editor.hasModel() || decorations !== this._currentDecorations || decorations.length === 0) {
          return;
        }
        const model = this._editor.getModel();
        const referenceRange = model.getDecorationRange(decorations[0]);
        if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {
          return this.clearRanges();
        }
        const referenceValue = model.getValueInRange(referenceRange);
        if (this._currentWordPattern) {
          const match = referenceValue.match(this._currentWordPattern);
          const matchLength = match ? match[0].length : 0;
          if (matchLength !== referenceValue.length) {
            return this.clearRanges();
          }
        }
        let edits = [];
        for (let i = 1, len = decorations.length; i < len; i++) {
          const mirrorRange = model.getDecorationRange(decorations[i]);
          if (!mirrorRange) {
            continue;
          }
          if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {
            edits.push({
              range: mirrorRange,
              text: referenceValue
            });
          } else {
            let oldValue = model.getValueInRange(mirrorRange);
            let newValue = referenceValue;
            let rangeStartColumn = mirrorRange.startColumn;
            let rangeEndColumn = mirrorRange.endColumn;
            const commonPrefixLength2 = commonPrefixLength(oldValue, newValue);
            rangeStartColumn += commonPrefixLength2;
            oldValue = oldValue.substr(commonPrefixLength2);
            newValue = newValue.substr(commonPrefixLength2);
            const commonSuffixLength2 = commonSuffixLength(oldValue, newValue);
            rangeEndColumn -= commonSuffixLength2;
            oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength2);
            newValue = newValue.substr(0, newValue.length - commonSuffixLength2);
            if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {
              edits.push({
                range: new Range(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
                text: newValue
              });
            }
          }
        }
        if (edits.length === 0) {
          return;
        }
        try {
          this._editor.popUndoStop();
          this._ignoreChangeEvent = true;
          const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
          this._editor.executeEdits("linkedEditing", edits);
          this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
        } finally {
          this._ignoreChangeEvent = false;
        }
      }
      dispose() {
        this.clearRanges();
        super.dispose();
      }
      clearRanges() {
        this._visibleContextKey.set(false);
        this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, []);
        if (this._currentRequest) {
          this._currentRequest.cancel();
          this._currentRequest = null;
          this._currentRequestPosition = null;
        }
      }
      updateRanges(force = false) {
        return __awaiter34(this, void 0, void 0, function* () {
          if (!this._editor.hasModel()) {
            this.clearRanges();
            return;
          }
          const position = this._editor.getPosition();
          if (!this._enabled && !force || this._editor.getSelections().length > 1) {
            this.clearRanges();
            return;
          }
          const model = this._editor.getModel();
          const modelVersionId = model.getVersionId();
          if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
            if (position.equals(this._currentRequestPosition)) {
              return;
            }
            if (this._currentDecorations && this._currentDecorations.length > 0) {
              const range = model.getDecorationRange(this._currentDecorations[0]);
              if (range && range.containsPosition(position)) {
                return;
              }
            }
          }
          this._currentRequestPosition = position;
          this._currentRequestModelVersion = modelVersionId;
          const request = createCancelablePromise((token) => __awaiter34(this, void 0, void 0, function* () {
            try {
              const response = yield getLinkedEditingRanges(model, position, token);
              if (request !== this._currentRequest) {
                return;
              }
              this._currentRequest = null;
              if (modelVersionId !== model.getVersionId()) {
                return;
              }
              let ranges = [];
              if (response === null || response === void 0 ? void 0 : response.ranges) {
                ranges = response.ranges;
              }
              this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
              let foundReferenceRange = false;
              for (let i = 0, len = ranges.length; i < len; i++) {
                if (Range.containsPosition(ranges[i], position)) {
                  foundReferenceRange = true;
                  if (i !== 0) {
                    const referenceRange = ranges[i];
                    ranges.splice(i, 1);
                    ranges.unshift(referenceRange);
                  }
                  break;
                }
              }
              if (!foundReferenceRange) {
                this.clearRanges();
                return;
              }
              const decorations = ranges.map((range) => ({ range, options: LinkedEditingContribution2.DECORATION }));
              this._visibleContextKey.set(true);
              this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, decorations);
            } catch (err) {
              if (!isPromiseCanceledError(err)) {
                onUnexpectedError(err);
              }
              if (this._currentRequest === request || !this._currentRequest) {
                this.clearRanges();
              }
            }
          }));
          this._currentRequest = request;
          return request;
        });
      }
    };
    LinkedEditingContribution.ID = "editor.contrib.linkedEditing";
    LinkedEditingContribution.DECORATION = ModelDecorationOptions.register({
      description: "linked-editing",
      stickiness: 0,
      className: DECORATION_CLASS_NAME
    });
    LinkedEditingContribution = __decorate47([
      __param47(1, IContextKeyService)
    ], LinkedEditingContribution);
    LinkedEditingAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.linkedEditing",
          label: localize("linkedEditing.label", "Start Linked Editing"),
          alias: "Start Linked Editing",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 60,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      runCommand(accessor, args) {
        const editorService = accessor.get(ICodeEditorService);
        const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
        if (URI.isUri(uri) && Position.isIPosition(pos)) {
          return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
            if (!editor2) {
              return;
            }
            editor2.setPosition(pos);
            editor2.invokeWithinContext((accessor2) => {
              this.reportTelemetry(accessor2, editor2);
              return this.run(accessor2, editor2);
            });
          }, onUnexpectedError);
        }
        return super.runCommand(accessor, args);
      }
      run(_accessor, editor2) {
        const controller = LinkedEditingContribution.get(editor2);
        if (controller) {
          return Promise.resolve(controller.updateRanges(true));
        }
        return Promise.resolve();
      }
    };
    LinkedEditingCommand = EditorCommand.bindToContribution(LinkedEditingContribution.get);
    registerEditorCommand(new LinkedEditingCommand({
      id: "cancelLinkedEditingInput",
      precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
      handler: (x) => x.clearRanges(),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100 + 99,
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
    editorLinkedEditingBackground = registerColor("editor.linkedEditingBackground", { dark: Color.fromHex("#f00").transparent(0.3), light: Color.fromHex("#f00").transparent(0.3), hc: Color.fromHex("#f00").transparent(0.3) }, localize("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
    registerThemingParticipant((theme, collector) => {
      const editorLinkedEditingBackgroundColor = theme.getColor(editorLinkedEditingBackground);
      if (editorLinkedEditingBackgroundColor) {
        collector.addRule(`.monaco-editor .${DECORATION_CLASS_NAME} { background: ${editorLinkedEditingBackgroundColor}; border-left-color: ${editorLinkedEditingBackgroundColor}; }`);
      }
    });
    registerModelAndPositionCommand("_executeLinkedEditingProvider", (model, position) => getLinkedEditingRanges(model, position, CancellationToken.None));
    registerEditorContribution(LinkedEditingContribution.ID, LinkedEditingContribution);
    registerEditorAction(LinkedEditingAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/links/getLinks.js
function getLinks(model, token) {
  const lists = [];
  const promises = LinkProviderRegistry.ordered(model).reverse().map((provider, i) => {
    return Promise.resolve(provider.provideLinks(model, token)).then((result) => {
      if (result) {
        lists[i] = [result, provider];
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    const result = new LinksList(coalesce(lists));
    if (!token.isCancellationRequested) {
      return result;
    }
    result.dispose();
    return new LinksList([]);
  });
}
var __awaiter35, Link, LinksList;
var init_getLinks = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/links/getLinks.js"() {
    init_arrays();
    init_cancellation();
    init_errors();
    init_lifecycle();
    init_types();
    init_uri();
    init_range();
    init_modes();
    init_modelService();
    init_commands();
    __awaiter35 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Link = class {
      constructor(link, provider) {
        this._link = link;
        this._provider = provider;
      }
      toJSON() {
        return {
          range: this.range,
          url: this.url,
          tooltip: this.tooltip
        };
      }
      get range() {
        return this._link.range;
      }
      get url() {
        return this._link.url;
      }
      get tooltip() {
        return this._link.tooltip;
      }
      resolve(token) {
        return __awaiter35(this, void 0, void 0, function* () {
          if (this._link.url) {
            return this._link.url;
          }
          if (typeof this._provider.resolveLink === "function") {
            return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
              this._link = value || this._link;
              if (this._link.url) {
                return this.resolve(token);
              }
              return Promise.reject(new Error("missing"));
            });
          }
          return Promise.reject(new Error("missing"));
        });
      }
    };
    LinksList = class _LinksList {
      constructor(tuples) {
        this._disposables = new DisposableStore();
        let links = [];
        for (const [list, provider] of tuples) {
          const newLinks = list.links.map((link) => new Link(link, provider));
          links = _LinksList._union(links, newLinks);
          if (isDisposable(list)) {
            this._disposables.add(list);
          }
        }
        this.links = links;
      }
      dispose() {
        this._disposables.dispose();
        this.links.length = 0;
      }
      static _union(oldLinks, newLinks) {
        let result = [];
        let oldIndex;
        let oldLen;
        let newIndex;
        let newLen;
        for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen; ) {
          const oldLink = oldLinks[oldIndex];
          const newLink = newLinks[newIndex];
          if (Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
            oldIndex++;
            continue;
          }
          const comparisonResult = Range.compareRangesUsingStarts(oldLink.range, newLink.range);
          if (comparisonResult < 0) {
            result.push(oldLink);
            oldIndex++;
          } else {
            result.push(newLink);
            newIndex++;
          }
        }
        for (; oldIndex < oldLen; oldIndex++) {
          result.push(oldLinks[oldIndex]);
        }
        for (; newIndex < newLen; newIndex++) {
          result.push(newLinks[newIndex]);
        }
        return result;
      }
    };
    CommandsRegistry.registerCommand("_executeLinkProvider", (accessor, ...args) => __awaiter35(void 0, void 0, void 0, function* () {
      let [uri, resolveCount] = args;
      assertType(uri instanceof URI);
      if (typeof resolveCount !== "number") {
        resolveCount = 0;
      }
      const model = accessor.get(IModelService).getModel(uri);
      if (!model) {
        return [];
      }
      const list = yield getLinks(model, CancellationToken.None);
      if (!list) {
        return [];
      }
      for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) {
        yield list.links[i].resolve(CancellationToken.None);
      }
      const result = list.links.slice(0);
      list.dispose();
      return result;
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/links/links.js
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localize("links.navigate.executeCmd", "Execute command") : localize("links.navigate.follow", "Follow link");
  const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
  if (link.url) {
    let nativeLabel = "";
    if (/^command:/i.test(link.url.toString())) {
      const match = link.url.toString().match(/^command:([^?#]+)/);
      if (match) {
        const commandId = match[1];
        const nativeLabelText = localize("tooltip.explanation", "Execute command {0}", commandId);
        nativeLabel = ` "${nativeLabelText}"`;
      }
    }
    const hoverMessage = new MarkdownString("", true).appendMarkdown(`[${label}](${link.url.toString(true).replace(/ /g, "%20")}${nativeLabel}) (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
var __decorate48, __param48, __awaiter36, decoration, LinkOccurrence, LinkDetector, OpenLinkAction;
var init_links = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/links/links.js"() {
    init_async();
    init_cancellation();
    init_errors();
    init_htmlContent();
    init_lifecycle();
    init_network();
    init_platform();
    init_resources();
    init_uri();
    init_editorExtensions();
    init_textModel();
    init_modes();
    init_clickLinkGesture();
    init_getLinks();
    init_nls();
    init_notification();
    init_opener();
    init_colorRegistry();
    init_themeService();
    __decorate48 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param48 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter36 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    decoration = {
      general: ModelDecorationOptions.register({
        description: "detected-link",
        stickiness: 1,
        collapseOnReplaceEdit: true,
        inlineClassName: "detected-link"
      }),
      active: ModelDecorationOptions.register({
        description: "detected-link-active",
        stickiness: 1,
        collapseOnReplaceEdit: true,
        inlineClassName: "detected-link-active"
      })
    };
    LinkOccurrence = class _LinkOccurrence {
      constructor(link, decorationId) {
        this.link = link;
        this.decorationId = decorationId;
      }
      static decoration(link, useMetaKey) {
        return {
          range: link.range,
          options: _LinkOccurrence._getOptions(link, useMetaKey, false)
        };
      }
      static _getOptions(link, useMetaKey, isActive) {
        const options = Object.assign({}, isActive ? decoration.active : decoration.general);
        options.hoverMessage = getHoverMessage(link, useMetaKey);
        return options;
      }
      activate(changeAccessor, useMetaKey) {
        changeAccessor.changeDecorationOptions(this.decorationId, _LinkOccurrence._getOptions(this.link, useMetaKey, true));
      }
      deactivate(changeAccessor, useMetaKey) {
        changeAccessor.changeDecorationOptions(this.decorationId, _LinkOccurrence._getOptions(this.link, useMetaKey, false));
      }
    };
    LinkDetector = class LinkDetector2 {
      constructor(editor2, openerService, notificationService) {
        this.listenersToRemove = new DisposableStore();
        this.editor = editor2;
        this.openerService = openerService;
        this.notificationService = notificationService;
        let clickLinkGesture = new ClickLinkGesture(editor2);
        this.listenersToRemove.add(clickLinkGesture);
        this.listenersToRemove.add(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
          this._onEditorMouseMove(mouseEvent, keyboardEvent);
        }));
        this.listenersToRemove.add(clickLinkGesture.onExecute((e) => {
          this.onEditorMouseUp(e);
        }));
        this.listenersToRemove.add(clickLinkGesture.onCancel((e) => {
          this.cleanUpActiveLinkDecoration();
        }));
        this.enabled = editor2.getOption(
          62
          /* links */
        );
        this.listenersToRemove.add(editor2.onDidChangeConfiguration((e) => {
          const enabled = editor2.getOption(
            62
            /* links */
          );
          if (this.enabled === enabled) {
            return;
          }
          this.enabled = enabled;
          this.updateDecorations([]);
          this.stop();
          this.beginCompute();
        }));
        this.listenersToRemove.add(editor2.onDidChangeModelContent((e) => this.onChange()));
        this.listenersToRemove.add(editor2.onDidChangeModel((e) => this.onModelChanged()));
        this.listenersToRemove.add(editor2.onDidChangeModelLanguage((e) => this.onModelModeChanged()));
        this.listenersToRemove.add(LinkProviderRegistry.onDidChange((e) => this.onModelModeChanged()));
        this.timeout = new TimeoutTimer();
        this.computePromise = null;
        this.activeLinksList = null;
        this.currentOccurrences = {};
        this.activeLinkDecorationId = null;
        this.beginCompute();
      }
      static get(editor2) {
        return editor2.getContribution(LinkDetector2.ID);
      }
      onModelChanged() {
        this.currentOccurrences = {};
        this.activeLinkDecorationId = null;
        this.stop();
        this.beginCompute();
      }
      onModelModeChanged() {
        this.stop();
        this.beginCompute();
      }
      onChange() {
        this.timeout.setIfNotSet(() => this.beginCompute(), LinkDetector2.RECOMPUTE_TIME);
      }
      beginCompute() {
        return __awaiter36(this, void 0, void 0, function* () {
          if (!this.editor.hasModel() || !this.enabled) {
            return;
          }
          const model = this.editor.getModel();
          if (!LinkProviderRegistry.has(model)) {
            return;
          }
          if (this.activeLinksList) {
            this.activeLinksList.dispose();
            this.activeLinksList = null;
          }
          this.computePromise = createCancelablePromise((token) => getLinks(model, token));
          try {
            this.activeLinksList = yield this.computePromise;
            this.updateDecorations(this.activeLinksList.links);
          } catch (err) {
            onUnexpectedError(err);
          } finally {
            this.computePromise = null;
          }
        });
      }
      updateDecorations(links) {
        const useMetaKey = this.editor.getOption(
          69
          /* multiCursorModifier */
        ) === "altKey";
        let oldDecorations = [];
        let keys = Object.keys(this.currentOccurrences);
        for (let i = 0, len = keys.length; i < len; i++) {
          let decorationId = keys[i];
          let occurance = this.currentOccurrences[decorationId];
          oldDecorations.push(occurance.decorationId);
        }
        let newDecorations = [];
        if (links) {
          for (const link of links) {
            newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
          }
        }
        let decorations = this.editor.deltaDecorations(oldDecorations, newDecorations);
        this.currentOccurrences = {};
        this.activeLinkDecorationId = null;
        for (let i = 0, len = decorations.length; i < len; i++) {
          let occurance = new LinkOccurrence(links[i], decorations[i]);
          this.currentOccurrences[occurance.decorationId] = occurance;
        }
      }
      _onEditorMouseMove(mouseEvent, withKey) {
        const useMetaKey = this.editor.getOption(
          69
          /* multiCursorModifier */
        ) === "altKey";
        if (this.isEnabled(mouseEvent, withKey)) {
          this.cleanUpActiveLinkDecoration();
          const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
          if (occurrence) {
            this.editor.changeDecorations((changeAccessor) => {
              occurrence.activate(changeAccessor, useMetaKey);
              this.activeLinkDecorationId = occurrence.decorationId;
            });
          }
        } else {
          this.cleanUpActiveLinkDecoration();
        }
      }
      cleanUpActiveLinkDecoration() {
        const useMetaKey = this.editor.getOption(
          69
          /* multiCursorModifier */
        ) === "altKey";
        if (this.activeLinkDecorationId) {
          const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
          if (occurrence) {
            this.editor.changeDecorations((changeAccessor) => {
              occurrence.deactivate(changeAccessor, useMetaKey);
            });
          }
          this.activeLinkDecorationId = null;
        }
      }
      onEditorMouseUp(mouseEvent) {
        if (!this.isEnabled(mouseEvent)) {
          return;
        }
        const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
        if (!occurrence) {
          return;
        }
        this.openLinkOccurrence(
          occurrence,
          mouseEvent.hasSideBySideModifier,
          true
          /* from user gesture */
        );
      }
      openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
        if (!this.openerService) {
          return;
        }
        const { link } = occurrence;
        link.resolve(CancellationToken.None).then((uri) => {
          if (typeof uri === "string" && this.editor.hasModel()) {
            const modelUri = this.editor.getModel().uri;
            if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
              const parsedUri = URI.parse(uri);
              if (parsedUri.scheme === Schemas.file) {
                const fsPath = originalFSPath(parsedUri);
                let relativePath = null;
                if (fsPath.startsWith("/./")) {
                  relativePath = `.${fsPath.substr(1)}`;
                } else if (fsPath.startsWith("//./")) {
                  relativePath = `.${fsPath.substr(2)}`;
                }
                if (relativePath) {
                  uri = joinPath(modelUri, relativePath);
                }
              }
            }
          }
          return this.openerService.open(uri, { openToSide, fromUserGesture, allowContributedOpeners: true, allowCommands: true });
        }, (err) => {
          const messageOrError = err instanceof Error ? err.message : err;
          if (messageOrError === "invalid") {
            this.notificationService.warn(localize("invalid.url", "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
          } else if (messageOrError === "missing") {
            this.notificationService.warn(localize("missing.url", "Failed to open this link because its target is missing."));
          } else {
            onUnexpectedError(err);
          }
        });
      }
      getLinkOccurrence(position) {
        if (!this.editor.hasModel() || !position) {
          return null;
        }
        const decorations = this.editor.getModel().getDecorationsInRange({
          startLineNumber: position.lineNumber,
          startColumn: position.column,
          endLineNumber: position.lineNumber,
          endColumn: position.column
        }, 0, true);
        for (const decoration2 of decorations) {
          const currentOccurrence = this.currentOccurrences[decoration2.id];
          if (currentOccurrence) {
            return currentOccurrence;
          }
        }
        return null;
      }
      isEnabled(mouseEvent, withKey) {
        return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
      }
      stop() {
        var _a5;
        this.timeout.cancel();
        if (this.activeLinksList) {
          (_a5 = this.activeLinksList) === null || _a5 === void 0 ? void 0 : _a5.dispose();
          this.activeLinksList = null;
        }
        if (this.computePromise) {
          this.computePromise.cancel();
          this.computePromise = null;
        }
      }
      dispose() {
        this.listenersToRemove.dispose();
        this.stop();
        this.timeout.dispose();
      }
    };
    LinkDetector.ID = "editor.linkDetector";
    LinkDetector.RECOMPUTE_TIME = 1e3;
    LinkDetector = __decorate48([
      __param48(1, IOpenerService),
      __param48(2, INotificationService)
    ], LinkDetector);
    OpenLinkAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.openLink",
          label: localize("label", "Open Link"),
          alias: "Open Link",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        let linkDetector = LinkDetector.get(editor2);
        if (!linkDetector) {
          return;
        }
        if (!editor2.hasModel()) {
          return;
        }
        let selections = editor2.getSelections();
        for (let sel of selections) {
          let link = linkDetector.getLinkOccurrence(sel.getEndPosition());
          if (link) {
            linkDetector.openLinkOccurrence(link, false);
          }
        }
      }
    };
    registerEditorContribution(LinkDetector.ID, LinkDetector);
    registerEditorAction(OpenLinkAction);
    registerThemingParticipant((theme, collector) => {
      const activeLinkForeground = theme.getColor(editorActiveLinkForeground);
      if (activeLinkForeground) {
        collector.addRule(`.monaco-editor .detected-link-active { color: ${activeLinkForeground} !important; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/multicursor.js
function announceCursorChange(previousCursorState, cursorState) {
  const cursorDiff = cursorState.filter((cs) => !previousCursorState.find((pcs) => pcs.equals(cs)));
  if (cursorDiff.length >= 1) {
    const cursorPositions = cursorDiff.map((cs) => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(", ");
    const msg = cursorDiff.length === 1 ? localize("cursorAdded", "Cursor added: {0}", cursorPositions) : localize("cursorsAdded", "Cursors added: {0}", cursorPositions);
    status(msg);
  }
}
function modelRangesContainSameText(model, ranges, matchCase) {
  const selectedText = getValueInRange(model, ranges[0], !matchCase);
  for (let i = 1, len = ranges.length; i < len; i++) {
    const range = ranges[i];
    if (range.isEmpty()) {
      return false;
    }
    const thisSelectedText = getValueInRange(model, range, !matchCase);
    if (selectedText !== thisSelectedText) {
      return false;
    }
  }
  return true;
}
function getValueInRange(model, range, toLowerCase) {
  const text2 = model.getValueInRange(range);
  return toLowerCase ? text2.toLowerCase() : text2;
}
var InsertCursorAbove, InsertCursorBelow, InsertCursorAtEndOfEachLineSelected, InsertCursorAtEndOfLineSelected, InsertCursorAtTopOfLineSelected, MultiCursorSessionResult, MultiCursorSession, MultiCursorSelectionController, MultiCursorSelectionControllerAction, AddSelectionToNextFindMatchAction, AddSelectionToPreviousFindMatchAction, MoveSelectionToNextFindMatchAction, MoveSelectionToPreviousFindMatchAction, SelectHighlightsAction, CompatChangeAll, SelectionHighlighterState, SelectionHighlighter;
var init_multicursor = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/multicursor.js"() {
    init_aria();
    init_async();
    init_keyCodes();
    init_lifecycle();
    init_editorExtensions();
    init_cursorMoveCommands();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_model();
    init_textModel();
    init_modes();
    init_findController();
    init_nls();
    init_actions2();
    init_contextkey();
    init_colorRegistry();
    init_themeService();
    InsertCursorAbove = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.insertCursorAbove",
          label: localize("mutlicursor.insertAbove", "Add Cursor Above"),
          alias: "Add Cursor Above",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 512 | 16,
            linux: {
              primary: 1024 | 512 | 16,
              secondary: [
                2048 | 1024 | 16
                /* UpArrow */
              ]
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "3_multi",
            title: localize({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
            order: 2
          }
        });
      }
      run(accessor, editor2, args) {
        if (!editor2.hasModel()) {
          return;
        }
        const useLogicalLine = args && args.logicalLine === true;
        const viewModel = editor2._getViewModel();
        if (viewModel.cursorConfig.readOnly) {
          return;
        }
        viewModel.pushStackElement();
        const previousCursorState = viewModel.getCursorStates();
        viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));
        viewModel.revealTopMostCursor(args.source);
        announceCursorChange(previousCursorState, viewModel.getCursorStates());
      }
    };
    InsertCursorBelow = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.insertCursorBelow",
          label: localize("mutlicursor.insertBelow", "Add Cursor Below"),
          alias: "Add Cursor Below",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 512 | 18,
            linux: {
              primary: 1024 | 512 | 18,
              secondary: [
                2048 | 1024 | 18
                /* DownArrow */
              ]
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "3_multi",
            title: localize({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
            order: 3
          }
        });
      }
      run(accessor, editor2, args) {
        if (!editor2.hasModel()) {
          return;
        }
        const useLogicalLine = args && args.logicalLine === true;
        const viewModel = editor2._getViewModel();
        if (viewModel.cursorConfig.readOnly) {
          return;
        }
        viewModel.pushStackElement();
        const previousCursorState = viewModel.getCursorStates();
        viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));
        viewModel.revealBottomMostCursor(args.source);
        announceCursorChange(previousCursorState, viewModel.getCursorStates());
      }
    };
    InsertCursorAtEndOfEachLineSelected = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.insertCursorAtEndOfEachLineSelected",
          label: localize("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
          alias: "Add Cursors to Line Ends",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 39,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "3_multi",
            title: localize({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
            order: 4
          }
        });
      }
      getCursorsForSelection(selection, model, result) {
        if (selection.isEmpty()) {
          return;
        }
        for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {
          let currentLineMaxColumn = model.getLineMaxColumn(i);
          result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));
        }
        if (selection.endColumn > 1) {
          result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
        }
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const model = editor2.getModel();
        const selections = editor2.getSelections();
        const viewModel = editor2._getViewModel();
        const previousCursorState = viewModel.getCursorStates();
        let newSelections = [];
        selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
        if (newSelections.length > 0) {
          editor2.setSelections(newSelections);
        }
        announceCursorChange(previousCursorState, viewModel.getCursorStates());
      }
    };
    InsertCursorAtEndOfLineSelected = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.addCursorsToBottom",
          label: localize("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
          alias: "Add Cursors To Bottom",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const selections = editor2.getSelections();
        const lineCount = editor2.getModel().getLineCount();
        let newSelections = [];
        for (let i = selections[0].startLineNumber; i <= lineCount; i++) {
          newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
        }
        const viewModel = editor2._getViewModel();
        const previousCursorState = viewModel.getCursorStates();
        if (newSelections.length > 0) {
          editor2.setSelections(newSelections);
        }
        announceCursorChange(previousCursorState, viewModel.getCursorStates());
      }
    };
    InsertCursorAtTopOfLineSelected = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.addCursorsToTop",
          label: localize("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
          alias: "Add Cursors To Top",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const selections = editor2.getSelections();
        let newSelections = [];
        for (let i = selections[0].startLineNumber; i >= 1; i--) {
          newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
        }
        const viewModel = editor2._getViewModel();
        const previousCursorState = viewModel.getCursorStates();
        if (newSelections.length > 0) {
          editor2.setSelections(newSelections);
        }
        announceCursorChange(previousCursorState, viewModel.getCursorStates());
      }
    };
    MultiCursorSessionResult = class {
      constructor(selections, revealRange, revealScrollType) {
        this.selections = selections;
        this.revealRange = revealRange;
        this.revealScrollType = revealScrollType;
      }
    };
    MultiCursorSession = class _MultiCursorSession {
      constructor(_editor2, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
        this._editor = _editor2;
        this.findController = findController;
        this.isDisconnectedFromFindController = isDisconnectedFromFindController;
        this.searchText = searchText;
        this.wholeWord = wholeWord;
        this.matchCase = matchCase;
        this.currentMatch = currentMatch;
      }
      static create(editor2, findController) {
        if (!editor2.hasModel()) {
          return null;
        }
        const findState = findController.getState();
        if (!editor2.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {
          return new _MultiCursorSession(editor2, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
        }
        let isDisconnectedFromFindController = false;
        let wholeWord;
        let matchCase;
        const selections = editor2.getSelections();
        if (selections.length === 1 && selections[0].isEmpty()) {
          isDisconnectedFromFindController = true;
          wholeWord = true;
          matchCase = true;
        } else {
          wholeWord = findState.wholeWord;
          matchCase = findState.matchCase;
        }
        const s = editor2.getSelection();
        let searchText;
        let currentMatch = null;
        if (s.isEmpty()) {
          const word = editor2.getConfiguredWordAtPosition(s.getStartPosition());
          if (!word) {
            return null;
          }
          searchText = word.word;
          currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
        } else {
          searchText = editor2.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
        }
        return new _MultiCursorSession(editor2, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
      }
      addSelectionToNextFindMatch() {
        if (!this._editor.hasModel()) {
          return null;
        }
        const nextMatch = this._getNextMatch();
        if (!nextMatch) {
          return null;
        }
        const allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(
          allSelections.concat(nextMatch),
          nextMatch,
          0
          /* Smooth */
        );
      }
      moveSelectionToNextFindMatch() {
        if (!this._editor.hasModel()) {
          return null;
        }
        const nextMatch = this._getNextMatch();
        if (!nextMatch) {
          return null;
        }
        const allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(
          allSelections.slice(0, allSelections.length - 1).concat(nextMatch),
          nextMatch,
          0
          /* Smooth */
        );
      }
      _getNextMatch() {
        if (!this._editor.hasModel()) {
          return null;
        }
        if (this.currentMatch) {
          const result = this.currentMatch;
          this.currentMatch = null;
          return result;
        }
        this.findController.highlightFindOptions();
        const allSelections = this._editor.getSelections();
        const lastAddedSelection = allSelections[allSelections.length - 1];
        const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
          115
          /* wordSeparators */
        ) : null, false);
        if (!nextMatch) {
          return null;
        }
        return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
      }
      addSelectionToPreviousFindMatch() {
        if (!this._editor.hasModel()) {
          return null;
        }
        const previousMatch = this._getPreviousMatch();
        if (!previousMatch) {
          return null;
        }
        const allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(
          allSelections.concat(previousMatch),
          previousMatch,
          0
          /* Smooth */
        );
      }
      moveSelectionToPreviousFindMatch() {
        if (!this._editor.hasModel()) {
          return null;
        }
        const previousMatch = this._getPreviousMatch();
        if (!previousMatch) {
          return null;
        }
        const allSelections = this._editor.getSelections();
        return new MultiCursorSessionResult(
          allSelections.slice(0, allSelections.length - 1).concat(previousMatch),
          previousMatch,
          0
          /* Smooth */
        );
      }
      _getPreviousMatch() {
        if (!this._editor.hasModel()) {
          return null;
        }
        if (this.currentMatch) {
          const result = this.currentMatch;
          this.currentMatch = null;
          return result;
        }
        this.findController.highlightFindOptions();
        const allSelections = this._editor.getSelections();
        const lastAddedSelection = allSelections[allSelections.length - 1];
        const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(
          115
          /* wordSeparators */
        ) : null, false);
        if (!previousMatch) {
          return null;
        }
        return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
      }
      selectAll() {
        if (!this._editor.hasModel()) {
          return [];
        }
        this.findController.highlightFindOptions();
        return this._editor.getModel().findMatches(
          this.searchText,
          true,
          false,
          this.matchCase,
          this.wholeWord ? this._editor.getOption(
            115
            /* wordSeparators */
          ) : null,
          false,
          1073741824
          /* MAX_SAFE_SMALL_INTEGER */
        );
      }
    };
    MultiCursorSelectionController = class _MultiCursorSelectionController extends Disposable {
      constructor(editor2) {
        super();
        this._sessionDispose = this._register(new DisposableStore());
        this._editor = editor2;
        this._ignoreSelectionChange = false;
        this._session = null;
      }
      static get(editor2) {
        return editor2.getContribution(_MultiCursorSelectionController.ID);
      }
      dispose() {
        this._endSession();
        super.dispose();
      }
      _beginSessionIfNeeded(findController) {
        if (!this._session) {
          const session = MultiCursorSession.create(this._editor, findController);
          if (!session) {
            return;
          }
          this._session = session;
          const newState = { searchString: this._session.searchText };
          if (this._session.isDisconnectedFromFindController) {
            newState.wholeWordOverride = 1;
            newState.matchCaseOverride = 1;
            newState.isRegexOverride = 2;
          }
          findController.getState().change(newState, false);
          this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
            if (this._ignoreSelectionChange) {
              return;
            }
            this._endSession();
          }));
          this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
            this._endSession();
          }));
          this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
            if (e.matchCase || e.wholeWord) {
              this._endSession();
            }
          }));
        }
      }
      _endSession() {
        this._sessionDispose.clear();
        if (this._session && this._session.isDisconnectedFromFindController) {
          const newState = {
            wholeWordOverride: 0,
            matchCaseOverride: 0,
            isRegexOverride: 0
          };
          this._session.findController.getState().change(newState, false);
        }
        this._session = null;
      }
      _setSelections(selections) {
        this._ignoreSelectionChange = true;
        this._editor.setSelections(selections);
        this._ignoreSelectionChange = false;
      }
      _expandEmptyToWord(model, selection) {
        if (!selection.isEmpty()) {
          return selection;
        }
        const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
        if (!word) {
          return selection;
        }
        return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
      }
      _applySessionResult(result) {
        if (!result) {
          return;
        }
        this._setSelections(result.selections);
        if (result.revealRange) {
          this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
        }
      }
      getSession(findController) {
        return this._session;
      }
      addSelectionToNextFindMatch(findController) {
        if (!this._editor.hasModel()) {
          return;
        }
        if (!this._session) {
          const allSelections = this._editor.getSelections();
          if (allSelections.length > 1) {
            const findState = findController.getState();
            const matchCase = findState.matchCase;
            const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
            if (!selectionsContainSameText) {
              const model = this._editor.getModel();
              let resultingSelections = [];
              for (let i = 0, len = allSelections.length; i < len; i++) {
                resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
              }
              this._editor.setSelections(resultingSelections);
              return;
            }
          }
        }
        this._beginSessionIfNeeded(findController);
        if (this._session) {
          this._applySessionResult(this._session.addSelectionToNextFindMatch());
        }
      }
      addSelectionToPreviousFindMatch(findController) {
        this._beginSessionIfNeeded(findController);
        if (this._session) {
          this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
        }
      }
      moveSelectionToNextFindMatch(findController) {
        this._beginSessionIfNeeded(findController);
        if (this._session) {
          this._applySessionResult(this._session.moveSelectionToNextFindMatch());
        }
      }
      moveSelectionToPreviousFindMatch(findController) {
        this._beginSessionIfNeeded(findController);
        if (this._session) {
          this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
        }
      }
      selectAll(findController) {
        if (!this._editor.hasModel()) {
          return;
        }
        let matches = null;
        const findState = findController.getState();
        if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
          matches = this._editor.getModel().findMatches(
            findState.searchString,
            true,
            findState.isRegex,
            findState.matchCase,
            findState.wholeWord ? this._editor.getOption(
              115
              /* wordSeparators */
            ) : null,
            false,
            1073741824
            /* MAX_SAFE_SMALL_INTEGER */
          );
        } else {
          this._beginSessionIfNeeded(findController);
          if (!this._session) {
            return;
          }
          matches = this._session.selectAll();
        }
        if (findState.searchScope) {
          const states = findState.searchScope;
          let inSelection = [];
          matches.forEach((match) => {
            states.forEach((state) => {
              if (match.range.endLineNumber <= state.endLineNumber && match.range.startLineNumber >= state.startLineNumber) {
                inSelection.push(match);
              }
            });
          });
          matches = inSelection;
        }
        if (matches.length > 0) {
          const editorSelection = this._editor.getSelection();
          for (let i = 0, len = matches.length; i < len; i++) {
            const match = matches[i];
            const intersection = match.range.intersectRanges(editorSelection);
            if (intersection) {
              matches[i] = matches[0];
              matches[0] = match;
              break;
            }
          }
          this._setSelections(matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
        }
      }
    };
    MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
    MultiCursorSelectionControllerAction = class extends EditorAction {
      run(accessor, editor2) {
        const multiCursorController = MultiCursorSelectionController.get(editor2);
        if (!multiCursorController) {
          return;
        }
        const findController = CommonFindController.get(editor2);
        if (!findController) {
          return;
        }
        const viewModel = editor2._getViewModel();
        if (viewModel) {
          const previousCursorState = viewModel.getCursorStates();
          this._run(multiCursorController, findController);
          announceCursorChange(previousCursorState, viewModel.getCursorStates());
        }
      }
    };
    AddSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
      constructor() {
        super({
          id: "editor.action.addSelectionToNextFindMatch",
          label: localize("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
          alias: "Add Selection To Next Find Match",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 2048 | 34,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "3_multi",
            title: localize({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
            order: 5
          }
        });
      }
      _run(multiCursorController, findController) {
        multiCursorController.addSelectionToNextFindMatch(findController);
      }
    };
    AddSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
      constructor() {
        super({
          id: "editor.action.addSelectionToPreviousFindMatch",
          label: localize("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
          alias: "Add Selection To Previous Find Match",
          precondition: void 0,
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "3_multi",
            title: localize({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
            order: 6
          }
        });
      }
      _run(multiCursorController, findController) {
        multiCursorController.addSelectionToPreviousFindMatch(findController);
      }
    };
    MoveSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
      constructor() {
        super({
          id: "editor.action.moveSelectionToNextFindMatch",
          label: localize("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
          alias: "Move Last Selection To Next Find Match",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: KeyChord(
              2048 | 41,
              2048 | 34
              /* KEY_D */
            ),
            weight: 100
            /* EditorContrib */
          }
        });
      }
      _run(multiCursorController, findController) {
        multiCursorController.moveSelectionToNextFindMatch(findController);
      }
    };
    MoveSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
      constructor() {
        super({
          id: "editor.action.moveSelectionToPreviousFindMatch",
          label: localize("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
          alias: "Move Last Selection To Previous Find Match",
          precondition: void 0
        });
      }
      _run(multiCursorController, findController) {
        multiCursorController.moveSelectionToPreviousFindMatch(findController);
      }
    };
    SelectHighlightsAction = class extends MultiCursorSelectionControllerAction {
      constructor() {
        super({
          id: "editor.action.selectHighlights",
          label: localize("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
          alias: "Select All Occurrences of Find Match",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 2048 | 1024 | 42,
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "3_multi",
            title: localize({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
            order: 7
          }
        });
      }
      _run(multiCursorController, findController) {
        multiCursorController.selectAll(findController);
      }
    };
    CompatChangeAll = class extends MultiCursorSelectionControllerAction {
      constructor() {
        super({
          id: "editor.action.changeAll",
          label: localize("changeAll.label", "Change All Occurrences"),
          alias: "Change All Occurrences",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 60,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "1_modification",
            order: 1.2
          }
        });
      }
      _run(multiCursorController, findController) {
        multiCursorController.selectAll(findController);
      }
    };
    SelectionHighlighterState = class {
      constructor(searchText, matchCase, wordSeparators, modelVersionId) {
        this.searchText = searchText;
        this.matchCase = matchCase;
        this.wordSeparators = wordSeparators;
        this.modelVersionId = modelVersionId;
      }
      /**
       * Everything equals except for `lastWordUnderCursor`
       */
      static softEquals(a, b) {
        if (!a && !b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return a.searchText === b.searchText && a.matchCase === b.matchCase && a.wordSeparators === b.wordSeparators && a.modelVersionId === b.modelVersionId;
      }
    };
    SelectionHighlighter = class _SelectionHighlighter extends Disposable {
      constructor(editor2) {
        super();
        this.editor = editor2;
        this._isEnabled = editor2.getOption(
          96
          /* selectionHighlight */
        );
        this.decorations = [];
        this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
        this.state = null;
        this._register(editor2.onDidChangeConfiguration((e) => {
          this._isEnabled = editor2.getOption(
            96
            /* selectionHighlight */
          );
        }));
        this._register(editor2.onDidChangeCursorSelection((e) => {
          if (!this._isEnabled) {
            return;
          }
          if (e.selection.isEmpty()) {
            if (e.reason === 3) {
              if (this.state) {
                this._setState(null);
              }
              this.updateSoon.schedule();
            } else {
              this._setState(null);
            }
          } else {
            this._update();
          }
        }));
        this._register(editor2.onDidChangeModel((e) => {
          this._setState(null);
        }));
        this._register(editor2.onDidChangeModelContent((e) => {
          if (this._isEnabled) {
            this.updateSoon.schedule();
          }
        }));
        this._register(CommonFindController.get(editor2).getState().onFindReplaceStateChange((e) => {
          this._update();
        }));
      }
      _update() {
        this._setState(_SelectionHighlighter._createState(this._isEnabled, this.editor));
      }
      static _createState(isEnabled, editor2) {
        if (!isEnabled) {
          return null;
        }
        if (!editor2.hasModel()) {
          return null;
        }
        const s = editor2.getSelection();
        if (s.startLineNumber !== s.endLineNumber) {
          return null;
        }
        const multiCursorController = MultiCursorSelectionController.get(editor2);
        if (!multiCursorController) {
          return null;
        }
        const findController = CommonFindController.get(editor2);
        if (!findController) {
          return null;
        }
        let r = multiCursorController.getSession(findController);
        if (!r) {
          const allSelections = editor2.getSelections();
          if (allSelections.length > 1) {
            const findState2 = findController.getState();
            const matchCase = findState2.matchCase;
            const selectionsContainSameText = modelRangesContainSameText(editor2.getModel(), allSelections, matchCase);
            if (!selectionsContainSameText) {
              return null;
            }
          }
          r = MultiCursorSession.create(editor2, findController);
        }
        if (!r) {
          return null;
        }
        if (r.currentMatch) {
          return null;
        }
        if (/^[ \t]+$/.test(r.searchText)) {
          return null;
        }
        if (r.searchText.length > 200) {
          return null;
        }
        const findState = findController.getState();
        const caseSensitive = findState.matchCase;
        if (findState.isRevealed) {
          let findStateSearchString = findState.searchString;
          if (!caseSensitive) {
            findStateSearchString = findStateSearchString.toLowerCase();
          }
          let mySearchString = r.searchText;
          if (!caseSensitive) {
            mySearchString = mySearchString.toLowerCase();
          }
          if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
            return null;
          }
        }
        return new SelectionHighlighterState(r.searchText, r.matchCase, r.wholeWord ? editor2.getOption(
          115
          /* wordSeparators */
        ) : null, editor2.getModel().getVersionId());
      }
      _setState(state) {
        if (SelectionHighlighterState.softEquals(this.state, state)) {
          this.state = state;
          return;
        }
        this.state = state;
        if (!this.state) {
          this.decorations = this.editor.deltaDecorations(this.decorations, []);
          return;
        }
        if (!this.editor.hasModel()) {
          return;
        }
        const model = this.editor.getModel();
        if (model.isTooLargeForTokenization()) {
          return;
        }
        const hasFindOccurrences = DocumentHighlightProviderRegistry.has(model) && this.editor.getOption(
          71
          /* occurrencesHighlight */
        );
        let allMatches = model.findMatches(this.state.searchText, true, false, this.state.matchCase, this.state.wordSeparators, false).map((m) => m.range);
        allMatches.sort(Range.compareRangesUsingStarts);
        let selections = this.editor.getSelections();
        selections.sort(Range.compareRangesUsingStarts);
        let matches = [];
        for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len; ) {
          const match = allMatches[i];
          if (j >= lenJ) {
            matches.push(match);
            i++;
          } else {
            const cmp = Range.compareRangesUsingStarts(match, selections[j]);
            if (cmp < 0) {
              if (selections[j].isEmpty() || !Range.areIntersecting(match, selections[j])) {
                matches.push(match);
              }
              i++;
            } else if (cmp > 0) {
              j++;
            } else {
              i++;
              j++;
            }
          }
        }
        const decorations = matches.map((r) => {
          return {
            range: r,
            // Show in overviewRuler only if model has no semantic highlighting
            options: hasFindOccurrences ? _SelectionHighlighter._SELECTION_HIGHLIGHT : _SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW
          };
        });
        this.decorations = this.editor.deltaDecorations(this.decorations, decorations);
      }
      dispose() {
        this._setState(null);
        super.dispose();
      }
    };
    SelectionHighlighter.ID = "editor.contrib.selectionHighlighter";
    SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW = ModelDecorationOptions.register({
      description: "selection-highlight-overview",
      stickiness: 1,
      className: "selectionHighlight",
      minimap: {
        color: themeColorFromId(minimapSelectionOccurrenceHighlight),
        position: MinimapPosition.Inline
      },
      overviewRuler: {
        color: themeColorFromId(overviewRulerSelectionHighlightForeground),
        position: OverviewRulerLane.Center
      }
    });
    SelectionHighlighter._SELECTION_HIGHLIGHT = ModelDecorationOptions.register({
      description: "selection-highlight",
      stickiness: 1,
      className: "selectionHighlight"
    });
    registerEditorContribution(MultiCursorSelectionController.ID, MultiCursorSelectionController);
    registerEditorContribution(SelectionHighlighter.ID, SelectionHighlighter);
    registerEditorAction(InsertCursorAbove);
    registerEditorAction(InsertCursorBelow);
    registerEditorAction(InsertCursorAtEndOfEachLineSelected);
    registerEditorAction(AddSelectionToNextFindMatchAction);
    registerEditorAction(AddSelectionToPreviousFindMatchAction);
    registerEditorAction(MoveSelectionToNextFindMatchAction);
    registerEditorAction(MoveSelectionToPreviousFindMatchAction);
    registerEditorAction(SelectHighlightsAction);
    registerEditorAction(CompatChangeAll);
    registerEditorAction(InsertCursorAtEndOfLineSelected);
    registerEditorAction(InsertCursorAtTopOfLineSelected);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/provideSignatureHelp.js
function provideSignatureHelp(model, position, context, token) {
  return __awaiter37(this, void 0, void 0, function* () {
    const supports = SignatureHelpProviderRegistry.ordered(model);
    for (const support of supports) {
      try {
        const result = yield support.provideSignatureHelp(model, position, token, context);
        if (result) {
          return result;
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }
    return void 0;
  });
}
var __awaiter37, Context2;
var init_provideSignatureHelp = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/provideSignatureHelp.js"() {
    init_cancellation();
    init_errors();
    init_types();
    init_uri();
    init_position();
    init_modes();
    init_resolverService();
    init_commands();
    init_contextkey();
    __awaiter37 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Context2 = {
      Visible: new RawContextKey("parameterHintsVisible", false),
      MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
    };
    CommandsRegistry.registerCommand("_executeSignatureHelpProvider", (accessor, ...args) => __awaiter37(void 0, void 0, void 0, function* () {
      const [uri, position, triggerCharacter] = args;
      assertType(URI.isUri(uri));
      assertType(Position.isIPosition(position));
      assertType(typeof triggerCharacter === "string" || !triggerCharacter);
      const ref = yield accessor.get(ITextModelService).createModelReference(uri);
      try {
        const result = yield provideSignatureHelp(ref.object.textEditorModel, Position.lift(position), {
          triggerKind: SignatureHelpTriggerKind.Invoke,
          isRetrigger: false,
          triggerCharacter
        }, CancellationToken.None);
        if (!result) {
          return void 0;
        }
        setTimeout(() => result.dispose(), 0);
        return result.value;
      } finally {
        ref.dispose();
      }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsModel.js
function mergeTriggerContexts(previous, current) {
  switch (current.triggerKind) {
    case SignatureHelpTriggerKind.Invoke:
      return current;
    case SignatureHelpTriggerKind.ContentChange:
      return previous;
    case SignatureHelpTriggerKind.TriggerCharacter:
    default:
      return current;
  }
}
var __awaiter38, ParameterHintState, ParameterHintsModel;
var init_parameterHintsModel = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsModel.js"() {
    init_async();
    init_errors();
    init_event();
    init_lifecycle();
    init_characterClassifier();
    init_modes();
    init_provideSignatureHelp();
    __awaiter38 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    (function(ParameterHintState2) {
      ParameterHintState2.Default = {
        type: 0
        /* Default */
      };
      class Pending {
        constructor(request, previouslyActiveHints) {
          this.request = request;
          this.previouslyActiveHints = previouslyActiveHints;
          this.type = 2;
        }
      }
      ParameterHintState2.Pending = Pending;
      class Active {
        constructor(hints) {
          this.hints = hints;
          this.type = 1;
        }
      }
      ParameterHintState2.Active = Active;
    })(ParameterHintState || (ParameterHintState = {}));
    ParameterHintsModel = class _ParameterHintsModel extends Disposable {
      constructor(editor2, delay = _ParameterHintsModel.DEFAULT_DELAY) {
        super();
        this._onChangedHints = this._register(new Emitter());
        this.onChangedHints = this._onChangedHints.event;
        this.triggerOnType = false;
        this._state = ParameterHintState.Default;
        this._pendingTriggers = [];
        this._lastSignatureHelpResult = this._register(new MutableDisposable());
        this.triggerChars = new CharacterSet();
        this.retriggerChars = new CharacterSet();
        this.triggerId = 0;
        this.editor = editor2;
        this.throttledDelayer = new Delayer(delay);
        this._register(this.editor.onDidBlurEditorWidget(() => this.cancel()));
        this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
        this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
        this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
        this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
        this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
        this._register(SignatureHelpProviderRegistry.onDidChange(this.onModelChanged, this));
        this._register(this.editor.onDidType((text2) => this.onDidType(text2)));
        this.onEditorConfigurationChange();
        this.onModelChanged();
      }
      get state() {
        return this._state;
      }
      set state(value) {
        if (this._state.type === 2) {
          this._state.request.cancel();
        }
        this._state = value;
      }
      cancel(silent = false) {
        this.state = ParameterHintState.Default;
        this.throttledDelayer.cancel();
        if (!silent) {
          this._onChangedHints.fire(void 0);
        }
      }
      trigger(context, delay) {
        const model = this.editor.getModel();
        if (!model || !SignatureHelpProviderRegistry.has(model)) {
          return;
        }
        const triggerId = ++this.triggerId;
        this._pendingTriggers.push(context);
        this.throttledDelayer.trigger(() => {
          return this.doTrigger(triggerId);
        }, delay).catch(onUnexpectedError);
      }
      next() {
        if (this.state.type !== 1) {
          return;
        }
        const length = this.state.hints.signatures.length;
        const activeSignature = this.state.hints.activeSignature;
        const last = activeSignature % length === length - 1;
        const cycle = this.editor.getOption(
          75
          /* parameterHints */
        ).cycle;
        if ((length < 2 || last) && !cycle) {
          this.cancel();
          return;
        }
        this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
      }
      previous() {
        if (this.state.type !== 1) {
          return;
        }
        const length = this.state.hints.signatures.length;
        const activeSignature = this.state.hints.activeSignature;
        const first2 = activeSignature === 0;
        const cycle = this.editor.getOption(
          75
          /* parameterHints */
        ).cycle;
        if ((length < 2 || first2) && !cycle) {
          this.cancel();
          return;
        }
        this.updateActiveSignature(first2 && cycle ? length - 1 : activeSignature - 1);
      }
      updateActiveSignature(activeSignature) {
        if (this.state.type !== 1) {
          return;
        }
        this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature }));
        this._onChangedHints.fire(this.state.hints);
      }
      doTrigger(triggerId) {
        return __awaiter38(this, void 0, void 0, function* () {
          const isRetrigger = this.state.type === 1 || this.state.type === 2;
          const activeSignatureHelp = this.getLastActiveHints();
          this.cancel(true);
          if (this._pendingTriggers.length === 0) {
            return false;
          }
          const context = this._pendingTriggers.reduce(mergeTriggerContexts);
          this._pendingTriggers = [];
          const triggerContext = {
            triggerKind: context.triggerKind,
            triggerCharacter: context.triggerCharacter,
            isRetrigger,
            activeSignatureHelp
          };
          if (!this.editor.hasModel()) {
            return false;
          }
          const model = this.editor.getModel();
          const position = this.editor.getPosition();
          this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(model, position, triggerContext, token)), activeSignatureHelp);
          try {
            const result = yield this.state.request;
            if (triggerId !== this.triggerId) {
              result === null || result === void 0 ? void 0 : result.dispose();
              return false;
            }
            if (!result || !result.value.signatures || result.value.signatures.length === 0) {
              result === null || result === void 0 ? void 0 : result.dispose();
              this._lastSignatureHelpResult.clear();
              this.cancel();
              return false;
            } else {
              this.state = new ParameterHintState.Active(result.value);
              this._lastSignatureHelpResult.value = result;
              this._onChangedHints.fire(this.state.hints);
              return true;
            }
          } catch (error) {
            if (triggerId === this.triggerId) {
              this.state = ParameterHintState.Default;
            }
            onUnexpectedError(error);
            return false;
          }
        });
      }
      getLastActiveHints() {
        switch (this.state.type) {
          case 1:
            return this.state.hints;
          case 2:
            return this.state.previouslyActiveHints;
          default:
            return void 0;
        }
      }
      get isTriggered() {
        return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
      }
      onModelChanged() {
        this.cancel();
        this.triggerChars = new CharacterSet();
        this.retriggerChars = new CharacterSet();
        const model = this.editor.getModel();
        if (!model) {
          return;
        }
        for (const support of SignatureHelpProviderRegistry.ordered(model)) {
          for (const ch of support.signatureHelpTriggerCharacters || []) {
            this.triggerChars.add(ch.charCodeAt(0));
            this.retriggerChars.add(ch.charCodeAt(0));
          }
          for (const ch of support.signatureHelpRetriggerCharacters || []) {
            this.retriggerChars.add(ch.charCodeAt(0));
          }
        }
      }
      onDidType(text2) {
        if (!this.triggerOnType) {
          return;
        }
        const lastCharIndex = text2.length - 1;
        const triggerCharCode = text2.charCodeAt(lastCharIndex);
        if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {
          this.trigger({
            triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
            triggerCharacter: text2.charAt(lastCharIndex)
          });
        }
      }
      onCursorChange(e) {
        if (e.source === "mouse") {
          this.cancel();
        } else if (this.isTriggered) {
          this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
        }
      }
      onModelContentChange() {
        if (this.isTriggered) {
          this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
        }
      }
      onEditorConfigurationChange() {
        this.triggerOnType = this.editor.getOption(
          75
          /* parameterHints */
        ).enabled;
        if (!this.triggerOnType) {
          this.cancel();
        }
      }
      dispose() {
        this.cancel(true);
        super.dispose();
      }
    };
    ParameterHintsModel.DEFAULT_DELAY = 120;
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsWidget.js
var __decorate49, __param49, $8, parameterHintsNextIcon, parameterHintsPreviousIcon, ParameterHintsWidget;
var init_parameterHintsWidget = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsWidget.js"() {
    init_dom();
    init_aria();
    init_scrollableElement();
    init_codicons();
    init_event();
    init_lifecycle();
    init_strings();
    init_types();
    init_markdownRenderer2();
    init_modeService();
    init_parameterHintsModel();
    init_provideSignatureHelp();
    init_nls();
    init_contextkey();
    init_opener();
    init_colorRegistry();
    init_iconRegistry();
    init_theme();
    init_themeService();
    __decorate49 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param49 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    $8 = $;
    parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown, localize("parameterHintsNextIcon", "Icon for show next parameter hint."));
    parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp, localize("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
    ParameterHintsWidget = class ParameterHintsWidget2 extends Disposable {
      constructor(editor2, contextKeyService, openerService, modeService) {
        super();
        this.editor = editor2;
        this.renderDisposeables = this._register(new DisposableStore());
        this.visible = false;
        this.announcedLabel = null;
        this.allowEditorOverflow = true;
        this.markdownRenderer = this._register(new MarkdownRenderer({ editor: editor2 }, modeService, openerService));
        this.model = this._register(new ParameterHintsModel(editor2));
        this.keyVisible = Context2.Visible.bindTo(contextKeyService);
        this.keyMultipleSignatures = Context2.MultipleSignatures.bindTo(contextKeyService);
        this._register(this.model.onChangedHints((newParameterHints) => {
          if (newParameterHints) {
            this.show();
            this.render(newParameterHints);
          } else {
            this.hide();
          }
        }));
      }
      createParameterHintDOMNodes() {
        const element = $8(".editor-widget.parameter-hints-widget");
        const wrapper = append(element, $8(".phwrapper"));
        wrapper.tabIndex = -1;
        const controls = append(wrapper, $8(".controls"));
        const previous = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
        const overloads = append(controls, $8(".overloads"));
        const next = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
        this._register(addDisposableListener(previous, "click", (e) => {
          EventHelper.stop(e);
          this.previous();
        }));
        this._register(addDisposableListener(next, "click", (e) => {
          EventHelper.stop(e);
          this.next();
        }));
        const body = $8(".body");
        const scrollbar = new DomScrollableElement(body, {});
        this._register(scrollbar);
        wrapper.appendChild(scrollbar.getDomNode());
        const signature = append(body, $8(".signature"));
        const docs = append(body, $8(".docs"));
        element.style.userSelect = "text";
        this.domNodes = {
          element,
          signature,
          overloads,
          docs,
          scrollbar
        };
        this.editor.addContentWidget(this);
        this.hide();
        this._register(this.editor.onDidChangeCursorSelection((e) => {
          if (this.visible) {
            this.editor.layoutContentWidget(this);
          }
        }));
        const updateFont = () => {
          if (!this.domNodes) {
            return;
          }
          const fontInfo = this.editor.getOption(
            43
            /* fontInfo */
          );
          this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
        };
        updateFont();
        this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(
          43
          /* fontInfo */
        )).on(updateFont, null));
        this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
        this.updateMaxHeight();
      }
      show() {
        if (this.visible) {
          return;
        }
        if (!this.domNodes) {
          this.createParameterHintDOMNodes();
        }
        this.keyVisible.set(true);
        this.visible = true;
        setTimeout(() => {
          if (this.domNodes) {
            this.domNodes.element.classList.add("visible");
          }
        }, 100);
        this.editor.layoutContentWidget(this);
      }
      hide() {
        this.renderDisposeables.clear();
        if (!this.visible) {
          return;
        }
        this.keyVisible.reset();
        this.visible = false;
        this.announcedLabel = null;
        if (this.domNodes) {
          this.domNodes.element.classList.remove("visible");
        }
        this.editor.layoutContentWidget(this);
      }
      getPosition() {
        if (this.visible) {
          return {
            position: this.editor.getPosition(),
            preference: [
              1,
              2
              /* BELOW */
            ]
          };
        }
        return null;
      }
      render(hints) {
        var _a5;
        this.renderDisposeables.clear();
        if (!this.domNodes) {
          return;
        }
        const multiple = hints.signatures.length > 1;
        this.domNodes.element.classList.toggle("multiple", multiple);
        this.keyMultipleSignatures.set(multiple);
        this.domNodes.signature.innerText = "";
        this.domNodes.docs.innerText = "";
        const signature = hints.signatures[hints.activeSignature];
        if (!signature) {
          return;
        }
        const code = append(this.domNodes.signature, $8(".code"));
        const fontInfo = this.editor.getOption(
          43
          /* fontInfo */
        );
        code.style.fontSize = `${fontInfo.fontSize}px`;
        code.style.fontFamily = fontInfo.fontFamily;
        const hasParameters = signature.parameters.length > 0;
        const activeParameterIndex = (_a5 = signature.activeParameter) !== null && _a5 !== void 0 ? _a5 : hints.activeParameter;
        if (!hasParameters) {
          const label = append(code, $8("span"));
          label.textContent = signature.label;
        } else {
          this.renderParameters(code, signature, activeParameterIndex);
        }
        const activeParameter = signature.parameters[activeParameterIndex];
        if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
          const documentation = $8("span.documentation");
          if (typeof activeParameter.documentation === "string") {
            documentation.textContent = activeParameter.documentation;
          } else {
            const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
            documentation.appendChild(renderedContents.element);
          }
          append(this.domNodes.docs, $8("p", {}, documentation));
        }
        if (signature.documentation === void 0) {
        } else if (typeof signature.documentation === "string") {
          append(this.domNodes.docs, $8("p", {}, signature.documentation));
        } else {
          const renderedContents = this.renderMarkdownDocs(signature.documentation);
          append(this.domNodes.docs, renderedContents.element);
        }
        const hasDocs = this.hasDocs(signature, activeParameter);
        this.domNodes.signature.classList.toggle("has-docs", hasDocs);
        this.domNodes.docs.classList.toggle("empty", !hasDocs);
        this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, "0") + "/" + hints.signatures.length;
        if (activeParameter) {
          let labelToAnnounce = "";
          const param = signature.parameters[activeParameterIndex];
          if (Array.isArray(param.label)) {
            labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
          } else {
            labelToAnnounce = param.label;
          }
          if (param.documentation) {
            labelToAnnounce += typeof param.documentation === "string" ? `, ${param.documentation}` : `, ${param.documentation.value}`;
          }
          if (signature.documentation) {
            labelToAnnounce += typeof signature.documentation === "string" ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
          }
          if (this.announcedLabel !== labelToAnnounce) {
            alert(localize("hint", "{0}, hint", labelToAnnounce));
            this.announcedLabel = labelToAnnounce;
          }
        }
        this.editor.layoutContentWidget(this);
        this.domNodes.scrollbar.scanDomNode();
      }
      renderMarkdownDocs(markdown) {
        const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
          asyncRenderCallback: () => {
            var _a5;
            (_a5 = this.domNodes) === null || _a5 === void 0 ? void 0 : _a5.scrollbar.scanDomNode();
          }
        }));
        renderedContents.element.classList.add("markdown-docs");
        return renderedContents;
      }
      hasDocs(signature, activeParameter) {
        if (activeParameter && typeof activeParameter.documentation === "string" && assertIsDefined(activeParameter.documentation).length > 0) {
          return true;
        }
        if (activeParameter && typeof activeParameter.documentation === "object" && assertIsDefined(activeParameter.documentation).value.length > 0) {
          return true;
        }
        if (signature.documentation && typeof signature.documentation === "string" && assertIsDefined(signature.documentation).length > 0) {
          return true;
        }
        if (signature.documentation && typeof signature.documentation === "object" && assertIsDefined(signature.documentation.value).length > 0) {
          return true;
        }
        return false;
      }
      renderParameters(parent, signature, activeParameterIndex) {
        const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
        const beforeSpan = document.createElement("span");
        beforeSpan.textContent = signature.label.substring(0, start);
        const paramSpan = document.createElement("span");
        paramSpan.textContent = signature.label.substring(start, end);
        paramSpan.className = "parameter active";
        const afterSpan = document.createElement("span");
        afterSpan.textContent = signature.label.substring(end);
        append(parent, beforeSpan, paramSpan, afterSpan);
      }
      getParameterLabelOffsets(signature, paramIdx) {
        const param = signature.parameters[paramIdx];
        if (!param) {
          return [0, 0];
        } else if (Array.isArray(param.label)) {
          return param.label;
        } else if (!param.label.length) {
          return [0, 0];
        } else {
          const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, "g");
          regex.test(signature.label);
          const idx = regex.lastIndex - param.label.length;
          return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
        }
      }
      next() {
        this.editor.focus();
        this.model.next();
      }
      previous() {
        this.editor.focus();
        this.model.previous();
      }
      cancel() {
        this.model.cancel();
      }
      getDomNode() {
        if (!this.domNodes) {
          this.createParameterHintDOMNodes();
        }
        return this.domNodes.element;
      }
      getId() {
        return ParameterHintsWidget2.ID;
      }
      trigger(context) {
        this.model.trigger(context, 0);
      }
      updateMaxHeight() {
        if (!this.domNodes) {
          return;
        }
        const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
        const maxHeight = `${height}px`;
        this.domNodes.element.style.maxHeight = maxHeight;
        const wrapper = this.domNodes.element.getElementsByClassName("phwrapper");
        if (wrapper.length) {
          wrapper[0].style.maxHeight = maxHeight;
        }
      }
    };
    ParameterHintsWidget.ID = "editor.widget.parameterHintsWidget";
    ParameterHintsWidget = __decorate49([
      __param49(1, IContextKeyService),
      __param49(2, IOpenerService),
      __param49(3, IModeService)
    ], ParameterHintsWidget);
    registerThemingParticipant((theme, collector) => {
      const border = theme.getColor(editorHoverBorder);
      if (border) {
        const borderWidth = theme.type === ColorScheme.HIGH_CONTRAST ? 2 : 1;
        collector.addRule(`.monaco-editor .parameter-hints-widget { border: ${borderWidth}px solid ${border}; }`);
        collector.addRule(`.monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid ${border.transparent(0.5)}; }`);
        collector.addRule(`.monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid ${border.transparent(0.5)}; }`);
      }
      const background = theme.getColor(editorHoverBackground);
      if (background) {
        collector.addRule(`.monaco-editor .parameter-hints-widget { background-color: ${background}; }`);
      }
      const link = theme.getColor(textLinkForeground);
      if (link) {
        collector.addRule(`.monaco-editor .parameter-hints-widget a { color: ${link}; }`);
      }
      const linkHover = theme.getColor(textLinkActiveForeground);
      if (linkHover) {
        collector.addRule(`.monaco-editor .parameter-hints-widget a:hover { color: ${linkHover}; }`);
      }
      const foreground2 = theme.getColor(editorHoverForeground);
      if (foreground2) {
        collector.addRule(`.monaco-editor .parameter-hints-widget { color: ${foreground2}; }`);
      }
      const codeBackground = theme.getColor(textCodeBlockBackground);
      if (codeBackground) {
        collector.addRule(`.monaco-editor .parameter-hints-widget code { background-color: ${codeBackground}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHints.js
var __decorate50, __param50, ParameterHintsController, TriggerParameterHintsAction, weight2, ParameterHintsCommand;
var init_parameterHints = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHints.js"() {
    init_lifecycle();
    init_editorExtensions();
    init_editorContextKeys();
    init_modes();
    init_provideSignatureHelp();
    init_nls();
    init_contextkey();
    init_instantiation();
    init_parameterHintsWidget();
    __decorate50 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param50 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    ParameterHintsController = class ParameterHintsController2 extends Disposable {
      constructor(editor2, instantiationService) {
        super();
        this.editor = editor2;
        this.widget = this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor));
      }
      static get(editor2) {
        return editor2.getContribution(ParameterHintsController2.ID);
      }
      cancel() {
        this.widget.cancel();
      }
      previous() {
        this.widget.previous();
      }
      next() {
        this.widget.next();
      }
      trigger(context) {
        this.widget.trigger(context);
      }
    };
    ParameterHintsController.ID = "editor.controller.parameterHints";
    ParameterHintsController = __decorate50([
      __param50(1, IInstantiationService)
    ], ParameterHintsController);
    TriggerParameterHintsAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.triggerParameterHints",
          label: localize("parameterHints.trigger.label", "Trigger Parameter Hints"),
          alias: "Trigger Parameter Hints",
          precondition: EditorContextKeys.hasSignatureHelpProvider,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 10,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const controller = ParameterHintsController.get(editor2);
        if (controller) {
          controller.trigger({
            triggerKind: SignatureHelpTriggerKind.Invoke
          });
        }
      }
    };
    registerEditorContribution(ParameterHintsController.ID, ParameterHintsController);
    registerEditorAction(TriggerParameterHintsAction);
    weight2 = 100 + 75;
    ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
    registerEditorCommand(new ParameterHintsCommand({
      id: "closeParameterHints",
      precondition: Context2.Visible,
      handler: (x) => x.cancel(),
      kbOpts: {
        weight: weight2,
        kbExpr: EditorContextKeys.focus,
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
    registerEditorCommand(new ParameterHintsCommand({
      id: "showPrevParameterHint",
      precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
      handler: (x) => x.previous(),
      kbOpts: {
        weight: weight2,
        kbExpr: EditorContextKeys.focus,
        primary: 16,
        secondary: [
          512 | 16
          /* UpArrow */
        ],
        mac: { primary: 16, secondary: [
          512 | 16,
          256 | 46
          /* KEY_P */
        ] }
      }
    }));
    registerEditorCommand(new ParameterHintsCommand({
      id: "showNextParameterHint",
      precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
      handler: (x) => x.next(),
      kbOpts: {
        weight: weight2,
        kbExpr: EditorContextKeys.focus,
        primary: 18,
        secondary: [
          512 | 18
          /* DownArrow */
        ],
        mac: { primary: 18, secondary: [
          512 | 18,
          256 | 44
          /* KEY_N */
        ] }
      }
    }));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/renameInputField.js
var __decorate51, __param51, CONTEXT_RENAME_INPUT_VISIBLE, RenameInputField;
var init_renameInputField = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/rename/renameInputField.js"() {
    init_lifecycle();
    init_position();
    init_nls();
    init_contextkey();
    init_keybinding();
    init_colorRegistry();
    init_themeService();
    __decorate51 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param51 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false, localize("renameInputVisible", "Whether the rename input widget is visible"));
    RenameInputField = class RenameInputField2 {
      constructor(_editor2, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
        this._editor = _editor2;
        this._acceptKeybindings = _acceptKeybindings;
        this._themeService = _themeService;
        this._keybindingService = _keybindingService;
        this._disposables = new DisposableStore();
        this.allowEditorOverflow = true;
        this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
        this._editor.addContentWidget(this);
        this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            43
            /* fontInfo */
          )) {
            this._updateFont();
          }
        }));
        this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
      }
      dispose() {
        this._disposables.dispose();
        this._editor.removeContentWidget(this);
      }
      getId() {
        return "__renameInputWidget";
      }
      getDomNode() {
        if (!this._domNode) {
          this._domNode = document.createElement("div");
          this._domNode.className = "monaco-editor rename-box";
          this._input = document.createElement("input");
          this._input.className = "rename-input";
          this._input.type = "text";
          this._input.setAttribute("aria-label", localize("renameAriaLabel", "Rename input. Type new name and press Enter to commit."));
          this._domNode.appendChild(this._input);
          this._label = document.createElement("div");
          this._label.className = "rename-label";
          this._domNode.appendChild(this._label);
          const updateLabel = () => {
            var _a5, _b2;
            const [accept, preview] = this._acceptKeybindings;
            this._keybindingService.lookupKeybinding(accept);
            this._label.innerText = localize({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (_a5 = this._keybindingService.lookupKeybinding(accept)) === null || _a5 === void 0 ? void 0 : _a5.getLabel(), (_b2 = this._keybindingService.lookupKeybinding(preview)) === null || _b2 === void 0 ? void 0 : _b2.getLabel());
          };
          updateLabel();
          this._disposables.add(this._keybindingService.onDidUpdateKeybindings(updateLabel));
          this._updateFont();
          this._updateStyles(this._themeService.getColorTheme());
        }
        return this._domNode;
      }
      _updateStyles(theme) {
        var _a5, _b2, _c2, _d2;
        if (!this._input || !this._domNode) {
          return;
        }
        const widgetShadowColor = theme.getColor(widgetShadow);
        this._domNode.style.backgroundColor = String((_a5 = theme.getColor(editorWidgetBackground)) !== null && _a5 !== void 0 ? _a5 : "");
        this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : "";
        this._domNode.style.color = String((_b2 = theme.getColor(inputForeground)) !== null && _b2 !== void 0 ? _b2 : "");
        this._input.style.backgroundColor = String((_c2 = theme.getColor(inputBackground)) !== null && _c2 !== void 0 ? _c2 : "");
        const border = theme.getColor(inputBorder);
        this._input.style.borderWidth = border ? "1px" : "0px";
        this._input.style.borderStyle = border ? "solid" : "none";
        this._input.style.borderColor = (_d2 = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d2 !== void 0 ? _d2 : "none";
      }
      _updateFont() {
        if (!this._input || !this._label) {
          return;
        }
        const fontInfo = this._editor.getOption(
          43
          /* fontInfo */
        );
        this._input.style.fontFamily = fontInfo.fontFamily;
        this._input.style.fontWeight = fontInfo.fontWeight;
        this._input.style.fontSize = `${fontInfo.fontSize}px`;
        this._label.style.fontSize = `${fontInfo.fontSize * 0.8}px`;
      }
      getPosition() {
        if (!this._visible) {
          return null;
        }
        return {
          position: this._position,
          preference: [
            2,
            1
            /* ABOVE */
          ]
        };
      }
      afterRender(position) {
        if (!position) {
          this.cancelInput(true);
        }
      }
      acceptInput(wantsPreview) {
        if (this._currentAcceptInput) {
          this._currentAcceptInput(wantsPreview);
        }
      }
      cancelInput(focusEditor) {
        if (this._currentCancelInput) {
          this._currentCancelInput(focusEditor);
        }
      }
      getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
        this._domNode.classList.toggle("preview", supportPreview);
        this._position = new Position(where.startLineNumber, where.startColumn);
        this._input.value = value;
        this._input.setAttribute("selectionStart", selectionStart.toString());
        this._input.setAttribute("selectionEnd", selectionEnd.toString());
        this._input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
        const disposeOnDone = new DisposableStore();
        return new Promise((resolve) => {
          this._currentCancelInput = (focusEditor) => {
            this._currentAcceptInput = void 0;
            this._currentCancelInput = void 0;
            resolve(focusEditor);
            return true;
          };
          this._currentAcceptInput = (wantsPreview) => {
            if (this._input.value.trim().length === 0 || this._input.value === value) {
              this.cancelInput(true);
              return;
            }
            this._currentAcceptInput = void 0;
            this._currentCancelInput = void 0;
            resolve({
              newName: this._input.value,
              wantsPreview: supportPreview && wantsPreview
            });
          };
          token.onCancellationRequested(() => this.cancelInput(true));
          disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(false)));
          this._show();
        }).finally(() => {
          disposeOnDone.dispose();
          this._hide();
        });
      }
      _show() {
        this._editor.revealLineInCenterIfOutsideViewport(
          this._position.lineNumber,
          0
          /* Smooth */
        );
        this._visible = true;
        this._visibleContextKey.set(true);
        this._editor.layoutContentWidget(this);
        setTimeout(() => {
          this._input.focus();
          this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
        }, 100);
      }
      _hide() {
        this._visible = false;
        this._visibleContextKey.reset();
        this._editor.layoutContentWidget(this);
      }
    };
    RenameInputField = __decorate51([
      __param51(2, IThemeService),
      __param51(3, IKeybindingService),
      __param51(4, IContextKeyService)
    ], RenameInputField);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/rename.js
function rename(model, position, newName) {
  return __awaiter39(this, void 0, void 0, function* () {
    const skeleton = new RenameSkeleton(model, position);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      return { edits: [], rejectReason: loc.rejectReason };
    }
    return skeleton.provideRenameEdits(newName, CancellationToken.None);
  });
}
var __decorate52, __param52, __awaiter39, RenameSkeleton, RenameController, RenameAction, RenameCommand;
var init_rename = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/rename/rename.js"() {
    init_aria();
    init_async();
    init_cancellation();
    init_errors();
    init_lifecycle();
    init_types();
    init_uri();
    init_editorState();
    init_editorExtensions();
    init_bulkEditService();
    init_codeEditorService();
    init_position();
    init_range();
    init_editorContextKeys();
    init_modes();
    init_textResourceConfigurationService();
    init_messageController();
    init_nls();
    init_configurationRegistry();
    init_contextkey();
    init_instantiation();
    init_log();
    init_notification();
    init_progress();
    init_platform2();
    init_renameInputField();
    __decorate52 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param52 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter39 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    RenameSkeleton = class {
      constructor(model, position) {
        this.model = model;
        this.position = position;
        this._providerRenameIdx = 0;
        this._providers = RenameProviderRegistry.ordered(model);
      }
      hasProvider() {
        return this._providers.length > 0;
      }
      resolveRenameLocation(token) {
        return __awaiter39(this, void 0, void 0, function* () {
          const rejects = [];
          for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
            const provider = this._providers[this._providerRenameIdx];
            if (!provider.resolveRenameLocation) {
              break;
            }
            let res = yield provider.resolveRenameLocation(this.model, this.position, token);
            if (!res) {
              continue;
            }
            if (res.rejectReason) {
              rejects.push(res.rejectReason);
              continue;
            }
            return res;
          }
          const word = this.model.getWordAtPosition(this.position);
          if (!word) {
            return {
              range: Range.fromPositions(this.position),
              text: "",
              rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
            };
          }
          return {
            range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
            text: word.word,
            rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
          };
        });
      }
      provideRenameEdits(newName, token) {
        return __awaiter39(this, void 0, void 0, function* () {
          return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
        });
      }
      _provideRenameEdits(newName, i, rejects, token) {
        return __awaiter39(this, void 0, void 0, function* () {
          const provider = this._providers[i];
          if (!provider) {
            return {
              edits: [],
              rejectReason: rejects.join("\n")
            };
          }
          const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
          if (!result) {
            return this._provideRenameEdits(newName, i + 1, rejects.concat(localize("no result", "No result.")), token);
          } else if (result.rejectReason) {
            return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
          }
          return result;
        });
      }
    };
    RenameController = class RenameController2 {
      constructor(editor2, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService) {
        this.editor = editor2;
        this._instaService = _instaService;
        this._notificationService = _notificationService;
        this._bulkEditService = _bulkEditService;
        this._progressService = _progressService;
        this._logService = _logService;
        this._configService = _configService;
        this._dispoableStore = new DisposableStore();
        this._cts = new CancellationTokenSource();
        this._renameInputField = this._dispoableStore.add(new IdleValue(() => this._dispoableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]))));
      }
      static get(editor2) {
        return editor2.getContribution(RenameController2.ID);
      }
      dispose() {
        this._dispoableStore.dispose();
        this._cts.dispose(true);
      }
      run() {
        return __awaiter39(this, void 0, void 0, function* () {
          this._cts.dispose(true);
          if (!this.editor.hasModel()) {
            return void 0;
          }
          const position = this.editor.getPosition();
          const skeleton = new RenameSkeleton(this.editor.getModel(), position);
          if (!skeleton.hasProvider()) {
            return void 0;
          }
          this._cts = new EditorStateCancellationTokenSource(
            this.editor,
            4 | 1
            /* Value */
          );
          let loc;
          try {
            const resolveLocationOperation = skeleton.resolveRenameLocation(this._cts.token);
            this._progressService.showWhile(resolveLocationOperation, 250);
            loc = yield resolveLocationOperation;
          } catch (e) {
            MessageController.get(this.editor).showMessage(e || localize("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), position);
            return void 0;
          }
          if (!loc) {
            return void 0;
          }
          if (loc.rejectReason) {
            MessageController.get(this.editor).showMessage(loc.rejectReason, position);
            return void 0;
          }
          if (this._cts.token.isCancellationRequested) {
            return void 0;
          }
          this._cts.dispose();
          this._cts = new EditorStateCancellationTokenSource(this.editor, 4 | 1, loc.range);
          let selection = this.editor.getSelection();
          let selectionStart = 0;
          let selectionEnd = loc.text.length;
          if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {
            selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
            selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
          }
          const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
          const inputFieldResult = yield this._renameInputField.value.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, this._cts.token);
          if (typeof inputFieldResult === "boolean") {
            if (inputFieldResult) {
              this.editor.focus();
            }
            return void 0;
          }
          this.editor.focus();
          const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, this._cts.token), this._cts.token).then((renameResult) => __awaiter39(this, void 0, void 0, function* () {
            if (!renameResult || !this.editor.hasModel()) {
              return;
            }
            if (renameResult.rejectReason) {
              this._notificationService.info(renameResult.rejectReason);
              return;
            }
            this._bulkEditService.apply(ResourceEdit.convert(renameResult), {
              editor: this.editor,
              showPreview: inputFieldResult.wantsPreview,
              label: localize("label", "Renaming '{0}'", loc === null || loc === void 0 ? void 0 : loc.text),
              quotableLabel: localize("quotableLabel", "Renaming {0}", loc === null || loc === void 0 ? void 0 : loc.text)
            }).then((result) => {
              if (result.ariaSummary) {
                alert(localize("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
              }
            }).catch((err) => {
              this._notificationService.error(localize("rename.failedApply", "Rename failed to apply edits"));
              this._logService.error(err);
            });
          }), (err) => {
            this._notificationService.error(localize("rename.failed", "Rename failed to compute edits"));
            this._logService.error(err);
          });
          this._progressService.showWhile(renameOperation, 250);
          return renameOperation;
        });
      }
      acceptRenameInput(wantsPreview) {
        this._renameInputField.value.acceptInput(wantsPreview);
      }
      cancelRenameInput() {
        this._renameInputField.value.cancelInput(true);
      }
    };
    RenameController.ID = "editor.contrib.renameController";
    RenameController = __decorate52([
      __param52(1, IInstantiationService),
      __param52(2, INotificationService),
      __param52(3, IBulkEditService),
      __param52(4, IEditorProgressService),
      __param52(5, ILogService),
      __param52(6, ITextResourceConfigurationService)
    ], RenameController);
    RenameAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.rename",
          label: localize("rename.label", "Rename Symbol"),
          alias: "Rename Symbol",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 60,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "1_modification",
            order: 1.1
          }
        });
      }
      runCommand(accessor, args) {
        const editorService = accessor.get(ICodeEditorService);
        const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
        if (URI.isUri(uri) && Position.isIPosition(pos)) {
          return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
            if (!editor2) {
              return;
            }
            editor2.setPosition(pos);
            editor2.invokeWithinContext((accessor2) => {
              this.reportTelemetry(accessor2, editor2);
              return this.run(accessor2, editor2);
            });
          }, onUnexpectedError);
        }
        return super.runCommand(accessor, args);
      }
      run(accessor, editor2) {
        const controller = RenameController.get(editor2);
        if (controller) {
          return controller.run();
        }
        return Promise.resolve();
      }
    };
    registerEditorContribution(RenameController.ID, RenameController);
    registerEditorAction(RenameAction);
    RenameCommand = EditorCommand.bindToContribution(RenameController.get);
    registerEditorCommand(new RenameCommand({
      id: "acceptRenameInput",
      precondition: CONTEXT_RENAME_INPUT_VISIBLE,
      handler: (x) => x.acceptRenameInput(false),
      kbOpts: {
        weight: 100 + 99,
        kbExpr: EditorContextKeys.focus,
        primary: 3
        /* Enter */
      }
    }));
    registerEditorCommand(new RenameCommand({
      id: "acceptRenameInputWithPreview",
      precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
      handler: (x) => x.acceptRenameInput(true),
      kbOpts: {
        weight: 100 + 99,
        kbExpr: EditorContextKeys.focus,
        primary: 1024 + 3
        /* Enter */
      }
    }));
    registerEditorCommand(new RenameCommand({
      id: "cancelRenameInput",
      precondition: CONTEXT_RENAME_INPUT_VISIBLE,
      handler: (x) => x.cancelRenameInput(),
      kbOpts: {
        weight: 100 + 99,
        kbExpr: EditorContextKeys.focus,
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
    registerModelAndPositionCommand("_executeDocumentRenameProvider", function(model, position, ...args) {
      const [newName] = args;
      assertType(typeof newName === "string");
      return rename(model, position, newName);
    });
    registerModelAndPositionCommand("_executePrepareRename", function(model, position) {
      return __awaiter39(this, void 0, void 0, function* () {
        const skeleton = new RenameSkeleton(model, position);
        const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
        if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
          throw new Error(loc.rejectReason);
        }
        return loc;
      });
    });
    Registry.as(Extensions.Configuration).registerConfiguration({
      id: "editor",
      properties: {
        "editor.rename.enablePreview": {
          scope: 5,
          description: localize("enablePreview", "Enable/disable the ability to preview changes before renaming"),
          default: true,
          type: "boolean"
        }
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/wordSelections.js
var WordSelectionRangeProvider;
var init_wordSelections = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/wordSelections.js"() {
    init_strings();
    init_range();
    WordSelectionRangeProvider = class {
      provideSelectionRanges(model, positions) {
        const result = [];
        for (const position of positions) {
          const bucket = [];
          result.push(bucket);
          this._addInWordRanges(bucket, model, position);
          this._addWordRanges(bucket, model, position);
          this._addWhitespaceLine(bucket, model, position);
          bucket.push({ range: model.getFullModelRange() });
        }
        return result;
      }
      _addInWordRanges(bucket, model, pos) {
        const obj = model.getWordAtPosition(pos);
        if (!obj) {
          return;
        }
        let { word, startColumn } = obj;
        let offset = pos.column - startColumn;
        let start = offset;
        let end = offset;
        let lastCh = 0;
        for (; start >= 0; start--) {
          let ch = word.charCodeAt(start);
          if (start !== offset && (ch === 95 || ch === 45)) {
            break;
          } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {
            break;
          }
          lastCh = ch;
        }
        start += 1;
        for (; end < word.length; end++) {
          let ch = word.charCodeAt(end);
          if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {
            break;
          } else if (ch === 95 || ch === 45) {
            break;
          }
          lastCh = ch;
        }
        if (start < end) {
          bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });
        }
      }
      _addWordRanges(bucket, model, pos) {
        const word = model.getWordAtPosition(pos);
        if (word) {
          bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });
        }
      }
      _addWhitespaceLine(bucket, model, pos) {
        if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
          bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/smartSelect.js
function provideSelectionRanges(model, positions, options, token) {
  return __awaiter40(this, void 0, void 0, function* () {
    const providers = SelectionRangeRegistry.all(model);
    if (providers.length === 1) {
      providers.unshift(new BracketSelectionRangeProvider());
    }
    let work = [];
    let allRawRanges = [];
    for (const provider of providers) {
      work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
        if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
          for (let i = 0; i < positions.length; i++) {
            if (!allRawRanges[i]) {
              allRawRanges[i] = [];
            }
            for (const oneProviderRanges of allProviderRanges[i]) {
              if (Range.isIRange(oneProviderRanges.range) && Range.containsPosition(oneProviderRanges.range, positions[i])) {
                allRawRanges[i].push(Range.lift(oneProviderRanges.range));
              }
            }
          }
        }
      }, onUnexpectedExternalError));
    }
    yield Promise.all(work);
    return allRawRanges.map((oneRawRanges) => {
      if (oneRawRanges.length === 0) {
        return [];
      }
      oneRawRanges.sort((a, b) => {
        if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
          return 1;
        } else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
          return -1;
        } else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
          return -1;
        } else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
          return 1;
        } else {
          return 0;
        }
      });
      let oneRanges = [];
      let last;
      for (const range of oneRawRanges) {
        if (!last || Range.containsRange(range, last) && !Range.equalsRange(range, last)) {
          oneRanges.push(range);
          last = range;
        }
      }
      if (!options.selectLeadingAndTrailingWhitespace) {
        return oneRanges;
      }
      let oneRangesWithTrivia = [oneRanges[0]];
      for (let i = 1; i < oneRanges.length; i++) {
        const prev = oneRanges[i - 1];
        const cur = oneRanges[i];
        if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
          const rangeNoWhitespace = new Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
          if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
            oneRangesWithTrivia.push(rangeNoWhitespace);
          }
          const rangeFull = new Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
          if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
            oneRangesWithTrivia.push(rangeFull);
          }
        }
        oneRangesWithTrivia.push(cur);
      }
      return oneRangesWithTrivia;
    });
  });
}
var __awaiter40, SelectionRanges, SmartSelectController, AbstractSmartSelect, GrowSelectionAction, ShrinkSelectionAction;
var init_smartSelect = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/smartSelect.js"() {
    init_arrays();
    init_cancellation();
    init_errors();
    init_editorExtensions();
    init_position();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_modes();
    init_bracketSelections();
    init_wordSelections();
    init_nls();
    init_actions2();
    init_commands();
    __awaiter40 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    SelectionRanges = class _SelectionRanges {
      constructor(index, ranges) {
        this.index = index;
        this.ranges = ranges;
      }
      mov(fwd) {
        let index = this.index + (fwd ? 1 : -1);
        if (index < 0 || index >= this.ranges.length) {
          return this;
        }
        const res = new _SelectionRanges(index, this.ranges);
        if (res.ranges[index].equalsRange(this.ranges[this.index])) {
          return res.mov(fwd);
        }
        return res;
      }
    };
    SmartSelectController = class _SmartSelectController {
      constructor(_editor2) {
        this._editor = _editor2;
        this._ignoreSelection = false;
      }
      static get(editor2) {
        return editor2.getContribution(_SmartSelectController.ID);
      }
      dispose() {
        var _a5;
        (_a5 = this._selectionListener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
      }
      run(forward) {
        return __awaiter40(this, void 0, void 0, function* () {
          if (!this._editor.hasModel()) {
            return;
          }
          const selections = this._editor.getSelections();
          const model = this._editor.getModel();
          if (!SelectionRangeRegistry.has(model)) {
            return;
          }
          if (!this._state) {
            yield provideSelectionRanges(model, selections.map((s) => s.getPosition()), this._editor.getOption(
              101
              /* smartSelect */
            ), CancellationToken.None).then((ranges) => {
              var _a5;
              if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) {
                return;
              }
              if (!this._editor.hasModel() || !equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
                return;
              }
              for (let i = 0; i < ranges.length; i++) {
                ranges[i] = ranges[i].filter((range) => {
                  return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
                });
                ranges[i].unshift(selections[i]);
              }
              this._state = ranges.map((ranges2) => new SelectionRanges(0, ranges2));
              (_a5 = this._selectionListener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
              this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
                var _a6;
                if (!this._ignoreSelection) {
                  (_a6 = this._selectionListener) === null || _a6 === void 0 ? void 0 : _a6.dispose();
                  this._state = void 0;
                }
              });
            });
          }
          if (!this._state) {
            return;
          }
          this._state = this._state.map((state) => state.mov(forward));
          const newSelections = this._state.map((state) => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
          this._ignoreSelection = true;
          try {
            this._editor.setSelections(newSelections);
          } finally {
            this._ignoreSelection = false;
          }
        });
      }
    };
    SmartSelectController.ID = "editor.contrib.smartSelectController";
    AbstractSmartSelect = class extends EditorAction {
      constructor(forward, opts) {
        super(opts);
        this._forward = forward;
      }
      run(_accessor, editor2) {
        return __awaiter40(this, void 0, void 0, function* () {
          let controller = SmartSelectController.get(editor2);
          if (controller) {
            yield controller.run(this._forward);
          }
        });
      }
    };
    GrowSelectionAction = class extends AbstractSmartSelect {
      constructor() {
        super(true, {
          id: "editor.action.smartSelect.expand",
          label: localize("smartSelect.expand", "Expand Selection"),
          alias: "Expand Selection",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 17,
            mac: {
              primary: 2048 | 256 | 1024 | 17,
              secondary: [
                256 | 1024 | 17
                /* RightArrow */
              ]
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "1_basic",
            title: localize({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
            order: 2
          }
        });
      }
    };
    CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
    ShrinkSelectionAction = class extends AbstractSmartSelect {
      constructor() {
        super(false, {
          id: "editor.action.smartSelect.shrink",
          label: localize("smartSelect.shrink", "Shrink Selection"),
          alias: "Shrink Selection",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 15,
            mac: {
              primary: 2048 | 256 | 1024 | 15,
              secondary: [
                256 | 1024 | 15
                /* LeftArrow */
              ]
            },
            weight: 100
            /* EditorContrib */
          },
          menuOpts: {
            menuId: MenuId.MenubarSelectionMenu,
            group: "1_basic",
            title: localize({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
            order: 3
          }
        });
      }
    };
    registerEditorContribution(SmartSelectController.ID, SmartSelectController);
    registerEditorAction(GrowSelectionAction);
    registerEditorAction(ShrinkSelectionAction);
    SelectionRangeRegistry.register("*", new WordSelectionRangeProvider());
    registerModelCommand("_executeSelectionRangeProvider", function(model, ...args) {
      const [positions] = args;
      return provideSelectionRanges(model, positions, { selectLeadingAndTrailingWhitespace: true }, CancellationToken.None);
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/tokenization.js
var ForceRetokenizeAction;
var init_tokenization = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/tokenization.js"() {
    init_stopwatch();
    init_editorExtensions();
    init_nls();
    ForceRetokenizeAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.forceRetokenize",
          label: localize("forceRetokenize", "Developer: Force Retokenize"),
          alias: "Developer: Force Retokenize",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        if (!editor2.hasModel()) {
          return;
        }
        const model = editor2.getModel();
        model.resetTokenization();
        const sw = new StopWatch(true);
        model.forceTokenization(model.getLineCount());
        sw.stop();
        console.log(`tokenization took ${sw.elapsed()}`);
      }
    };
    registerEditorAction(ForceRetokenizeAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/toggleTabFocusMode.js
var ToggleTabFocusModeAction;
var init_toggleTabFocusMode = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/toggleTabFocusMode.js"() {
    init_aria();
    init_editorExtensions();
    init_commonEditorConfig();
    init_nls();
    ToggleTabFocusModeAction = class _ToggleTabFocusModeAction extends EditorAction {
      constructor() {
        super({
          id: _ToggleTabFocusModeAction.ID,
          label: localize({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"),
          alias: "Toggle Tab Key Moves Focus",
          precondition: void 0,
          kbOpts: {
            kbExpr: null,
            primary: 2048 | 43,
            mac: {
              primary: 256 | 1024 | 43
              /* KEY_M */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2) {
        const oldValue = TabFocus.getTabFocusMode();
        const newValue = !oldValue;
        TabFocus.setTabFocusMode(newValue);
        if (newValue) {
          alert(localize("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element"));
        } else {
          alert(localize("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
        }
      }
    };
    ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
    registerEditorAction(ToggleTabFocusModeAction);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/unusualLineTerminators.js
function writeIgnoreState(codeEditorService, model, state) {
  codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
function readIgnoreState(codeEditorService, model) {
  return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
var __decorate53, __param53, __awaiter41, ignoreUnusualLineTerminators, UnusualLineTerminatorsDetector;
var init_unusualLineTerminators = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/unusualLineTerminators.js"() {
    init_lifecycle();
    init_resources();
    init_editorExtensions();
    init_codeEditorService();
    init_nls();
    init_dialogs();
    __decorate53 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param53 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter41 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
    UnusualLineTerminatorsDetector = class UnusualLineTerminatorsDetector2 extends Disposable {
      constructor(_editor2, _dialogService, _codeEditorService) {
        super();
        this._editor = _editor2;
        this._dialogService = _dialogService;
        this._codeEditorService = _codeEditorService;
        this._config = this._editor.getOption(
          112
          /* unusualLineTerminators */
        );
        this._register(this._editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(
            112
            /* unusualLineTerminators */
          )) {
            this._config = this._editor.getOption(
              112
              /* unusualLineTerminators */
            );
            this._checkForUnusualLineTerminators();
          }
        }));
        this._register(this._editor.onDidChangeModel(() => {
          this._checkForUnusualLineTerminators();
        }));
        this._register(this._editor.onDidChangeModelContent((e) => {
          if (e.isUndoing) {
            return;
          }
          this._checkForUnusualLineTerminators();
        }));
      }
      _checkForUnusualLineTerminators() {
        return __awaiter41(this, void 0, void 0, function* () {
          if (this._config === "off") {
            return;
          }
          if (!this._editor.hasModel()) {
            return;
          }
          const model = this._editor.getModel();
          if (!model.mightContainUnusualLineTerminators()) {
            return;
          }
          const ignoreState = readIgnoreState(this._codeEditorService, model);
          if (ignoreState === true) {
            return;
          }
          if (this._editor.getOption(
            80
            /* readOnly */
          )) {
            return;
          }
          if (this._config === "auto") {
            model.removeUnusualLineTerminators(this._editor.getSelections());
            return;
          }
          const result = yield this._dialogService.confirm({
            title: localize("unusualLineTerminators.title", "Unusual Line Terminators"),
            message: localize("unusualLineTerminators.message", "Detected unusual line terminators"),
            detail: localize("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename2(model.uri)),
            primaryButton: localize("unusualLineTerminators.fix", "Remove Unusual Line Terminators"),
            secondaryButton: localize("unusualLineTerminators.ignore", "Ignore")
          });
          if (!result.confirmed) {
            writeIgnoreState(this._codeEditorService, model, true);
            return;
          }
          model.removeUnusualLineTerminators(this._editor.getSelections());
        });
      }
    };
    UnusualLineTerminatorsDetector.ID = "editor.contrib.unusualLineTerminatorsDetector";
    UnusualLineTerminatorsDetector = __decorate53([
      __param53(1, IDialogService),
      __param53(2, ICodeEditorService)
    ], UnusualLineTerminatorsDetector);
    registerEditorContribution(UnusualLineTerminatorsDetector.ID, UnusualLineTerminatorsDetector);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/viewportSemanticTokens/viewportSemanticTokens.js
var require_viewportSemanticTokens = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/contrib/viewportSemanticTokens/viewportSemanticTokens.js"(exports2) {
    init_async();
    init_lifecycle();
    init_editorExtensions();
    init_modes();
    init_getSemanticTokens();
    init_modelService();
    init_modelServiceImpl();
    init_semanticTokensProviderStyling();
    init_configuration();
    init_themeService();
    var __decorate61 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param61 = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var ViewportSemanticTokensContribution = class ViewportSemanticTokensContribution extends Disposable {
      constructor(editor2, _modelService, _themeService, _configurationService) {
        super();
        this._modelService = _modelService;
        this._themeService = _themeService;
        this._configurationService = _configurationService;
        this._editor = editor2;
        this._tokenizeViewport = new RunOnceScheduler(() => this._tokenizeViewportNow(), 100);
        this._outstandingRequests = [];
        this._register(this._editor.onDidScrollChange(() => {
          this._tokenizeViewport.schedule();
        }));
        this._register(this._editor.onDidChangeModel(() => {
          this._cancelAll();
          this._tokenizeViewport.schedule();
        }));
        this._register(this._editor.onDidChangeModelContent((e) => {
          this._cancelAll();
          this._tokenizeViewport.schedule();
        }));
        this._register(DocumentRangeSemanticTokensProviderRegistry.onDidChange(() => {
          this._cancelAll();
          this._tokenizeViewport.schedule();
        }));
        this._register(this._configurationService.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
            this._cancelAll();
            this._tokenizeViewport.schedule();
          }
        }));
        this._register(this._themeService.onDidColorThemeChange(() => {
          this._cancelAll();
          this._tokenizeViewport.schedule();
        }));
      }
      _cancelAll() {
        for (const request of this._outstandingRequests) {
          request.cancel();
        }
        this._outstandingRequests = [];
      }
      _removeOutstandingRequest(req) {
        for (let i = 0, len = this._outstandingRequests.length; i < len; i++) {
          if (this._outstandingRequests[i] === req) {
            this._outstandingRequests.splice(i, 1);
            return;
          }
        }
      }
      _tokenizeViewportNow() {
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        if (model.hasCompleteSemanticTokens()) {
          return;
        }
        if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
          if (model.hasSomeSemanticTokens()) {
            model.setSemanticTokens(null, false);
          }
          return;
        }
        const provider = getDocumentRangeSemanticTokensProvider(model);
        if (!provider) {
          if (model.hasSomeSemanticTokens()) {
            model.setSemanticTokens(null, false);
          }
          return;
        }
        const styling = this._modelService.getSemanticTokensProviderStyling(provider);
        const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
        this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range) => this._requestRange(model, range, provider, styling)));
      }
      _requestRange(model, range, provider, styling) {
        const requestVersionId = model.getVersionId();
        const request = createCancelablePromise((token) => Promise.resolve(provider.provideDocumentRangeSemanticTokens(model, range, token)));
        request.then((r) => {
          if (!r || model.isDisposed() || model.getVersionId() !== requestVersionId) {
            return;
          }
          model.setPartialSemanticTokens(range, toMultilineTokens2(r, styling, model.getLanguageIdentifier()));
        }).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
        return request;
      }
    };
    ViewportSemanticTokensContribution.ID = "editor.contrib.viewportSemanticTokens";
    ViewportSemanticTokensContribution = __decorate61([
      __param61(1, IModelService),
      __param61(2, IThemeService),
      __param61(3, IConfigurationService)
    ], ViewportSemanticTokensContribution);
    registerEditorContribution(ViewportSemanticTokensContribution.ID, ViewportSemanticTokensContribution);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/wordHighlighter.js
function getOccurrencesAtPosition(model, position, token) {
  const orderedByScore = DocumentHighlightProviderRegistry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
  }), isNonEmptyArray);
}
function computeOccurencesAtPosition(model, selection, wordSeparators) {
  if (DocumentHighlightProviderRegistry.has(model)) {
    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators);
  }
  return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);
}
var __decorate54, __param54, editorWordHighlight, editorWordHighlightStrong, editorWordHighlightBorder, editorWordHighlightStrongBorder, overviewRulerWordHighlightForeground, overviewRulerWordHighlightStrongForeground, ctxHasWordHighlights, OccurenceAtPositionRequest, SemanticOccurenceAtPositionRequest, TextualOccurenceAtPositionRequest, WordHighlighter, WordHighlighterContribution, WordHighlightNavigationAction, NextWordHighlightAction, PrevWordHighlightAction, TriggerWordHighlightAction;
var init_wordHighlighter = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/wordHighlighter.js"() {
    init_aria();
    init_arrays();
    init_async();
    init_cancellation();
    init_errors();
    init_lifecycle();
    init_editorExtensions();
    init_range();
    init_editorContextKeys();
    init_model();
    init_textModel();
    init_modes();
    init_nls();
    init_contextkey();
    init_colorRegistry();
    init_themeService();
    __decorate54 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param54 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    editorWordHighlight = registerColor("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hc: null }, localize("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
    editorWordHighlightStrong = registerColor("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hc: null }, localize("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
    editorWordHighlightBorder = registerColor("editor.wordHighlightBorder", { light: null, dark: null, hc: activeContrastBorder }, localize("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
    editorWordHighlightStrongBorder = registerColor("editor.wordHighlightStrongBorder", { light: null, dark: null, hc: activeContrastBorder }, localize("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
    overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC" }, localize("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
    overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hc: "#C0A0C0CC" }, localize("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
    ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
    OccurenceAtPositionRequest = class {
      constructor(model, selection, wordSeparators) {
        this._wordRange = this._getCurrentWordRange(model, selection);
        this.result = createCancelablePromise((token) => this._compute(model, selection, wordSeparators, token));
      }
      _getCurrentWordRange(model, selection) {
        const word = model.getWordAtPosition(selection.getPosition());
        if (word) {
          return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
        }
        return null;
      }
      isValid(model, selection, decorationIds) {
        const lineNumber = selection.startLineNumber;
        const startColumn = selection.startColumn;
        const endColumn = selection.endColumn;
        const currentWordRange = this._getCurrentWordRange(model, selection);
        let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));
        for (let i = 0, len = decorationIds.length; !requestIsValid && i < len; i++) {
          let range = model.getDecorationRange(decorationIds[i]);
          if (range && range.startLineNumber === lineNumber) {
            if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
              requestIsValid = true;
            }
          }
        }
        return requestIsValid;
      }
      cancel() {
        this.result.cancel();
      }
    };
    SemanticOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
      _compute(model, selection, wordSeparators, token) {
        return getOccurrencesAtPosition(model, selection.getPosition(), token).then((value) => value || []);
      }
    };
    TextualOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
      constructor(model, selection, wordSeparators) {
        super(model, selection, wordSeparators);
        this._selectionIsEmpty = selection.isEmpty();
      }
      _compute(model, selection, wordSeparators, token) {
        return timeout(250, token).then(() => {
          if (!selection.isEmpty()) {
            return [];
          }
          const word = model.getWordAtPosition(selection.getPosition());
          if (!word || word.word.length > 1e3) {
            return [];
          }
          const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);
          return matches.map((m) => {
            return {
              range: m.range,
              kind: DocumentHighlightKind.Text
            };
          });
        });
      }
      isValid(model, selection, decorationIds) {
        const currentSelectionIsEmpty = selection.isEmpty();
        if (this._selectionIsEmpty !== currentSelectionIsEmpty) {
          return false;
        }
        return super.isValid(model, selection, decorationIds);
      }
    };
    registerModelAndPositionCommand("_executeDocumentHighlights", (model, position) => getOccurrencesAtPosition(model, position, CancellationToken.None));
    WordHighlighter = class _WordHighlighter {
      constructor(editor2, contextKeyService) {
        this.toUnhook = new DisposableStore();
        this.workerRequestTokenId = 0;
        this.workerRequestCompleted = false;
        this.workerRequestValue = [];
        this.lastCursorPositionChangeTime = 0;
        this.renderDecorationsTimer = -1;
        this.editor = editor2;
        this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
        this._ignorePositionChangeEvent = false;
        this.occurrencesHighlight = this.editor.getOption(
          71
          /* occurrencesHighlight */
        );
        this.model = this.editor.getModel();
        this.toUnhook.add(editor2.onDidChangeCursorPosition((e) => {
          if (this._ignorePositionChangeEvent) {
            return;
          }
          if (!this.occurrencesHighlight) {
            return;
          }
          this._onPositionChanged(e);
        }));
        this.toUnhook.add(editor2.onDidChangeModelContent((e) => {
          this._stopAll();
        }));
        this.toUnhook.add(editor2.onDidChangeConfiguration((e) => {
          let newValue = this.editor.getOption(
            71
            /* occurrencesHighlight */
          );
          if (this.occurrencesHighlight !== newValue) {
            this.occurrencesHighlight = newValue;
            this._stopAll();
          }
        }));
        this._decorationIds = [];
        this.workerRequestTokenId = 0;
        this.workerRequest = null;
        this.workerRequestCompleted = false;
        this.lastCursorPositionChangeTime = 0;
        this.renderDecorationsTimer = -1;
      }
      hasDecorations() {
        return this._decorationIds.length > 0;
      }
      restore() {
        if (!this.occurrencesHighlight) {
          return;
        }
        this._run();
      }
      _getSortedHighlights() {
        return coalesce(this._decorationIds.map((id) => this.model.getDecorationRange(id)).sort(Range.compareRangesUsingStarts));
      }
      moveNext() {
        let highlights = this._getSortedHighlights();
        let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
        let newIndex = (index + 1) % highlights.length;
        let dest = highlights[newIndex];
        try {
          this._ignorePositionChangeEvent = true;
          this.editor.setPosition(dest.getStartPosition());
          this.editor.revealRangeInCenterIfOutsideViewport(dest);
          const word = this._getWord();
          if (word) {
            const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
            alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
          }
        } finally {
          this._ignorePositionChangeEvent = false;
        }
      }
      moveBack() {
        let highlights = this._getSortedHighlights();
        let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
        let newIndex = (index - 1 + highlights.length) % highlights.length;
        let dest = highlights[newIndex];
        try {
          this._ignorePositionChangeEvent = true;
          this.editor.setPosition(dest.getStartPosition());
          this.editor.revealRangeInCenterIfOutsideViewport(dest);
          const word = this._getWord();
          if (word) {
            const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
            alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
          }
        } finally {
          this._ignorePositionChangeEvent = false;
        }
      }
      _removeDecorations() {
        if (this._decorationIds.length > 0) {
          this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);
          this._hasWordHighlights.set(false);
        }
      }
      _stopAll() {
        this._removeDecorations();
        if (this.renderDecorationsTimer !== -1) {
          clearTimeout(this.renderDecorationsTimer);
          this.renderDecorationsTimer = -1;
        }
        if (this.workerRequest !== null) {
          this.workerRequest.cancel();
          this.workerRequest = null;
        }
        if (!this.workerRequestCompleted) {
          this.workerRequestTokenId++;
          this.workerRequestCompleted = true;
        }
      }
      _onPositionChanged(e) {
        if (!this.occurrencesHighlight) {
          this._stopAll();
          return;
        }
        if (e.reason !== 3) {
          this._stopAll();
          return;
        }
        this._run();
      }
      _getWord() {
        let editorSelection = this.editor.getSelection();
        let lineNumber = editorSelection.startLineNumber;
        let startColumn = editorSelection.startColumn;
        return this.model.getWordAtPosition({
          lineNumber,
          column: startColumn
        });
      }
      _run() {
        let editorSelection = this.editor.getSelection();
        if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
          this._stopAll();
          return;
        }
        let startColumn = editorSelection.startColumn;
        let endColumn = editorSelection.endColumn;
        const word = this._getWord();
        if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
          this._stopAll();
          return;
        }
        const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this._decorationIds);
        this.lastCursorPositionChangeTime = (/* @__PURE__ */ new Date()).getTime();
        if (workerRequestIsValid) {
          if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
            clearTimeout(this.renderDecorationsTimer);
            this.renderDecorationsTimer = -1;
            this._beginRenderDecorations();
          }
        } else {
          this._stopAll();
          let myRequestId = ++this.workerRequestTokenId;
          this.workerRequestCompleted = false;
          this.workerRequest = computeOccurencesAtPosition(this.model, this.editor.getSelection(), this.editor.getOption(
            115
            /* wordSeparators */
          ));
          this.workerRequest.result.then((data) => {
            if (myRequestId === this.workerRequestTokenId) {
              this.workerRequestCompleted = true;
              this.workerRequestValue = data || [];
              this._beginRenderDecorations();
            }
          }, onUnexpectedError);
        }
      }
      _beginRenderDecorations() {
        let currentTime = (/* @__PURE__ */ new Date()).getTime();
        let minimumRenderTime = this.lastCursorPositionChangeTime + 250;
        if (currentTime >= minimumRenderTime) {
          this.renderDecorationsTimer = -1;
          this.renderDecorations();
        } else {
          this.renderDecorationsTimer = setTimeout(() => {
            this.renderDecorations();
          }, minimumRenderTime - currentTime);
        }
      }
      renderDecorations() {
        this.renderDecorationsTimer = -1;
        let decorations = [];
        for (const info of this.workerRequestValue) {
          if (info.range) {
            decorations.push({
              range: info.range,
              options: _WordHighlighter._getDecorationOptions(info.kind)
            });
          }
        }
        this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);
        this._hasWordHighlights.set(this.hasDecorations());
      }
      static _getDecorationOptions(kind) {
        if (kind === DocumentHighlightKind.Write) {
          return this._WRITE_OPTIONS;
        } else if (kind === DocumentHighlightKind.Text) {
          return this._TEXT_OPTIONS;
        } else {
          return this._REGULAR_OPTIONS;
        }
      }
      dispose() {
        this._stopAll();
        this.toUnhook.dispose();
      }
    };
    WordHighlighter._WRITE_OPTIONS = ModelDecorationOptions.register({
      description: "word-highlight-strong",
      stickiness: 1,
      className: "wordHighlightStrong",
      overviewRuler: {
        color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
        position: OverviewRulerLane.Center
      },
      minimap: {
        color: themeColorFromId(minimapSelectionOccurrenceHighlight),
        position: MinimapPosition.Inline
      }
    });
    WordHighlighter._TEXT_OPTIONS = ModelDecorationOptions.register({
      description: "selection-highlight",
      stickiness: 1,
      className: "selectionHighlight",
      overviewRuler: {
        color: themeColorFromId(overviewRulerSelectionHighlightForeground),
        position: OverviewRulerLane.Center
      },
      minimap: {
        color: themeColorFromId(minimapSelectionOccurrenceHighlight),
        position: MinimapPosition.Inline
      }
    });
    WordHighlighter._REGULAR_OPTIONS = ModelDecorationOptions.register({
      description: "word-highlight",
      stickiness: 1,
      className: "wordHighlight",
      overviewRuler: {
        color: themeColorFromId(overviewRulerWordHighlightForeground),
        position: OverviewRulerLane.Center
      },
      minimap: {
        color: themeColorFromId(minimapSelectionOccurrenceHighlight),
        position: MinimapPosition.Inline
      }
    });
    WordHighlighterContribution = class WordHighlighterContribution2 extends Disposable {
      constructor(editor2, contextKeyService) {
        super();
        this.wordHighlighter = null;
        const createWordHighlighterIfPossible = () => {
          if (editor2.hasModel()) {
            this.wordHighlighter = new WordHighlighter(editor2, contextKeyService);
          }
        };
        this._register(editor2.onDidChangeModel((e) => {
          if (this.wordHighlighter) {
            this.wordHighlighter.dispose();
            this.wordHighlighter = null;
          }
          createWordHighlighterIfPossible();
        }));
        createWordHighlighterIfPossible();
      }
      static get(editor2) {
        return editor2.getContribution(WordHighlighterContribution2.ID);
      }
      saveViewState() {
        if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {
          return true;
        }
        return false;
      }
      moveNext() {
        if (this.wordHighlighter) {
          this.wordHighlighter.moveNext();
        }
      }
      moveBack() {
        if (this.wordHighlighter) {
          this.wordHighlighter.moveBack();
        }
      }
      restoreViewState(state) {
        if (this.wordHighlighter && state) {
          this.wordHighlighter.restore();
        }
      }
      dispose() {
        if (this.wordHighlighter) {
          this.wordHighlighter.dispose();
          this.wordHighlighter = null;
        }
        super.dispose();
      }
    };
    WordHighlighterContribution.ID = "editor.contrib.wordHighlighter";
    WordHighlighterContribution = __decorate54([
      __param54(1, IContextKeyService)
    ], WordHighlighterContribution);
    WordHighlightNavigationAction = class extends EditorAction {
      constructor(next, opts) {
        super(opts);
        this._isNext = next;
      }
      run(accessor, editor2) {
        const controller = WordHighlighterContribution.get(editor2);
        if (!controller) {
          return;
        }
        if (this._isNext) {
          controller.moveNext();
        } else {
          controller.moveBack();
        }
      }
    };
    NextWordHighlightAction = class extends WordHighlightNavigationAction {
      constructor() {
        super(true, {
          id: "editor.action.wordHighlight.next",
          label: localize("wordHighlight.next.label", "Go to Next Symbol Highlight"),
          alias: "Go to Next Symbol Highlight",
          precondition: ctxHasWordHighlights,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 65,
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    PrevWordHighlightAction = class extends WordHighlightNavigationAction {
      constructor() {
        super(false, {
          id: "editor.action.wordHighlight.prev",
          label: localize("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
          alias: "Go to Previous Symbol Highlight",
          precondition: ctxHasWordHighlights,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 65,
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    TriggerWordHighlightAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.wordHighlight.trigger",
          label: localize("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
          alias: "Trigger Symbol Highlight",
          precondition: ctxHasWordHighlights.toNegated(),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 0,
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor, editor2, args) {
        const controller = WordHighlighterContribution.get(editor2);
        if (!controller) {
          return;
        }
        controller.restoreViewState(true);
      }
    };
    registerEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution);
    registerEditorAction(NextWordHighlightAction);
    registerEditorAction(PrevWordHighlightAction);
    registerEditorAction(TriggerWordHighlightAction);
    registerThemingParticipant((theme, collector) => {
      const selectionHighlight = theme.getColor(editorSelectionHighlight);
      if (selectionHighlight) {
        collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);
        collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);
      }
      const wordHighlight = theme.getColor(editorWordHighlight);
      if (wordHighlight) {
        collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);
      }
      const wordHighlightStrong = theme.getColor(editorWordHighlightStrong);
      if (wordHighlightStrong) {
        collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);
      }
      const selectionHighlightBorder = theme.getColor(editorSelectionHighlightBorder);
      if (selectionHighlightBorder) {
        collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${selectionHighlightBorder}; box-sizing: border-box; }`);
      }
      const wordHighlightBorder = theme.getColor(editorWordHighlightBorder);
      if (wordHighlightBorder) {
        collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${wordHighlightBorder}; box-sizing: border-box; }`);
      }
      const wordHighlightStrongBorder = theme.getColor(editorWordHighlightStrongBorder);
      if (wordHighlightStrongBorder) {
        collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/wordOperations.js
var MoveWordCommand, WordLeftCommand, WordRightCommand, CursorWordStartLeft, CursorWordEndLeft, CursorWordLeft, CursorWordStartLeftSelect, CursorWordEndLeftSelect, CursorWordLeftSelect, CursorWordAccessibilityLeft, CursorWordAccessibilityLeftSelect, CursorWordStartRight, CursorWordEndRight, CursorWordRight, CursorWordStartRightSelect, CursorWordEndRightSelect, CursorWordRightSelect, CursorWordAccessibilityRight, CursorWordAccessibilityRightSelect, DeleteWordCommand, DeleteWordLeftCommand, DeleteWordRightCommand, DeleteWordStartLeft, DeleteWordEndLeft, DeleteWordLeft, DeleteWordStartRight, DeleteWordEndRight, DeleteWordRight, DeleteInsideWord;
var init_wordOperations = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/wordOperations.js"() {
    init_editorExtensions();
    init_replaceCommand();
    init_editorOptions();
    init_cursorCommon();
    init_cursorWordOperations();
    init_wordCharacterClassifier();
    init_position();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_languageConfigurationRegistry();
    init_nls();
    init_accessibility();
    init_contextkey();
    init_contextkeys();
    MoveWordCommand = class extends EditorCommand {
      constructor(opts) {
        super(opts);
        this._inSelectionMode = opts.inSelectionMode;
        this._wordNavigationType = opts.wordNavigationType;
      }
      runEditorCommand(accessor, editor2, args) {
        if (!editor2.hasModel()) {
          return;
        }
        const wordSeparators = getMapForWordSeparators(editor2.getOption(
          115
          /* wordSeparators */
        ));
        const model = editor2.getModel();
        const selections = editor2.getSelections();
        const result = selections.map((sel) => {
          const inPosition = new Position(sel.positionLineNumber, sel.positionColumn);
          const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType);
          return this._moveTo(sel, outPosition, this._inSelectionMode);
        });
        model.pushStackElement();
        editor2._getViewModel().setCursorStates("moveWordCommand", 3, result.map((r) => CursorState.fromModelSelection(r)));
        if (result.length === 1) {
          const pos = new Position(result[0].positionLineNumber, result[0].positionColumn);
          editor2.revealPosition(
            pos,
            0
            /* Smooth */
          );
        }
      }
      _moveTo(from, to, inSelectionMode) {
        if (inSelectionMode) {
          return new Selection(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
        } else {
          return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
        }
      }
    };
    WordLeftCommand = class extends MoveWordCommand {
      _move(wordSeparators, model, position, wordNavigationType) {
        return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
      }
    };
    WordRightCommand = class extends MoveWordCommand {
      _move(wordSeparators, model, position, wordNavigationType) {
        return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
      }
    };
    CursorWordStartLeft = class extends WordLeftCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 0,
          id: "cursorWordStartLeft",
          precondition: void 0
        });
      }
    };
    CursorWordEndLeft = class extends WordLeftCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 2,
          id: "cursorWordEndLeft",
          precondition: void 0
        });
      }
    };
    CursorWordLeft = class extends WordLeftCommand {
      constructor() {
        var _a5;
        super({
          inSelectionMode: false,
          wordNavigationType: 1,
          id: "cursorWordLeft",
          precondition: void 0,
          kbOpts: {
            kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
            primary: 2048 | 15,
            mac: {
              primary: 512 | 15
              /* LeftArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    CursorWordStartLeftSelect = class extends WordLeftCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 0,
          id: "cursorWordStartLeftSelect",
          precondition: void 0
        });
      }
    };
    CursorWordEndLeftSelect = class extends WordLeftCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 2,
          id: "cursorWordEndLeftSelect",
          precondition: void 0
        });
      }
    };
    CursorWordLeftSelect = class extends WordLeftCommand {
      constructor() {
        var _a5;
        super({
          inSelectionMode: true,
          wordNavigationType: 1,
          id: "cursorWordLeftSelect",
          precondition: void 0,
          kbOpts: {
            kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
            primary: 2048 | 1024 | 15,
            mac: {
              primary: 512 | 1024 | 15
              /* LeftArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    CursorWordAccessibilityLeft = class extends WordLeftCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 3,
          id: "cursorWordAccessibilityLeft",
          precondition: void 0
        });
      }
      _move(_, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
      }
    };
    CursorWordAccessibilityLeftSelect = class extends WordLeftCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 3,
          id: "cursorWordAccessibilityLeftSelect",
          precondition: void 0
        });
      }
      _move(_, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
      }
    };
    CursorWordStartRight = class extends WordRightCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 0,
          id: "cursorWordStartRight",
          precondition: void 0
        });
      }
    };
    CursorWordEndRight = class extends WordRightCommand {
      constructor() {
        var _a5;
        super({
          inSelectionMode: false,
          wordNavigationType: 2,
          id: "cursorWordEndRight",
          precondition: void 0,
          kbOpts: {
            kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
            primary: 2048 | 17,
            mac: {
              primary: 512 | 17
              /* RightArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    CursorWordRight = class extends WordRightCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 2,
          id: "cursorWordRight",
          precondition: void 0
        });
      }
    };
    CursorWordStartRightSelect = class extends WordRightCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 0,
          id: "cursorWordStartRightSelect",
          precondition: void 0
        });
      }
    };
    CursorWordEndRightSelect = class extends WordRightCommand {
      constructor() {
        var _a5;
        super({
          inSelectionMode: true,
          wordNavigationType: 2,
          id: "cursorWordEndRightSelect",
          precondition: void 0,
          kbOpts: {
            kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
            primary: 2048 | 1024 | 17,
            mac: {
              primary: 512 | 1024 | 17
              /* RightArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    CursorWordRightSelect = class extends WordRightCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 2,
          id: "cursorWordRightSelect",
          precondition: void 0
        });
      }
    };
    CursorWordAccessibilityRight = class extends WordRightCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 3,
          id: "cursorWordAccessibilityRight",
          precondition: void 0
        });
      }
      _move(_, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
      }
    };
    CursorWordAccessibilityRightSelect = class extends WordRightCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 3,
          id: "cursorWordAccessibilityRightSelect",
          precondition: void 0
        });
      }
      _move(_, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
      }
    };
    DeleteWordCommand = class extends EditorCommand {
      constructor(opts) {
        super(opts);
        this._whitespaceHeuristics = opts.whitespaceHeuristics;
        this._wordNavigationType = opts.wordNavigationType;
      }
      runEditorCommand(accessor, editor2, args) {
        if (!editor2.hasModel()) {
          return;
        }
        const wordSeparators = getMapForWordSeparators(editor2.getOption(
          115
          /* wordSeparators */
        ));
        const model = editor2.getModel();
        const selections = editor2.getSelections();
        const autoClosingBrackets = editor2.getOption(
          5
          /* autoClosingBrackets */
        );
        const autoClosingQuotes = editor2.getOption(
          8
          /* autoClosingQuotes */
        );
        const autoClosingPairs = LanguageConfigurationRegistry.getAutoClosingPairs(model.getLanguageIdentifier().id);
        const viewModel = editor2._getViewModel();
        const commands = selections.map((sel) => {
          const deleteRange = this._delete({
            wordSeparators,
            model,
            selection: sel,
            whitespaceHeuristics: this._whitespaceHeuristics,
            autoClosingDelete: editor2.getOption(
              6
              /* autoClosingDelete */
            ),
            autoClosingBrackets,
            autoClosingQuotes,
            autoClosingPairs,
            autoClosedCharacters: viewModel.getCursorAutoClosedCharacters()
          }, this._wordNavigationType);
          return new ReplaceCommand(deleteRange, "");
        });
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    DeleteWordLeftCommand = class extends DeleteWordCommand {
      _delete(ctx, wordNavigationType) {
        let r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
        if (r) {
          return r;
        }
        return new Range(1, 1, 1, 1);
      }
    };
    DeleteWordRightCommand = class extends DeleteWordCommand {
      _delete(ctx, wordNavigationType) {
        let r = WordOperations.deleteWordRight(ctx, wordNavigationType);
        if (r) {
          return r;
        }
        const lineCount = ctx.model.getLineCount();
        const maxColumn = ctx.model.getLineMaxColumn(lineCount);
        return new Range(lineCount, maxColumn, lineCount, maxColumn);
      }
    };
    DeleteWordStartLeft = class extends DeleteWordLeftCommand {
      constructor() {
        super({
          whitespaceHeuristics: false,
          wordNavigationType: 0,
          id: "deleteWordStartLeft",
          precondition: EditorContextKeys.writable
        });
      }
    };
    DeleteWordEndLeft = class extends DeleteWordLeftCommand {
      constructor() {
        super({
          whitespaceHeuristics: false,
          wordNavigationType: 2,
          id: "deleteWordEndLeft",
          precondition: EditorContextKeys.writable
        });
      }
    };
    DeleteWordLeft = class extends DeleteWordLeftCommand {
      constructor() {
        super({
          whitespaceHeuristics: true,
          wordNavigationType: 0,
          id: "deleteWordLeft",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 | 1,
            mac: {
              primary: 512 | 1
              /* Backspace */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    DeleteWordStartRight = class extends DeleteWordRightCommand {
      constructor() {
        super({
          whitespaceHeuristics: false,
          wordNavigationType: 0,
          id: "deleteWordStartRight",
          precondition: EditorContextKeys.writable
        });
      }
    };
    DeleteWordEndRight = class extends DeleteWordRightCommand {
      constructor() {
        super({
          whitespaceHeuristics: false,
          wordNavigationType: 2,
          id: "deleteWordEndRight",
          precondition: EditorContextKeys.writable
        });
      }
    };
    DeleteWordRight = class extends DeleteWordRightCommand {
      constructor() {
        super({
          whitespaceHeuristics: true,
          wordNavigationType: 2,
          id: "deleteWordRight",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 2048 | 20,
            mac: {
              primary: 512 | 20
              /* Delete */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    DeleteInsideWord = class extends EditorAction {
      constructor() {
        super({
          id: "deleteInsideWord",
          precondition: EditorContextKeys.writable,
          label: localize("deleteInsideWord", "Delete Word"),
          alias: "Delete Word"
        });
      }
      run(accessor, editor2, args) {
        if (!editor2.hasModel()) {
          return;
        }
        const wordSeparators = getMapForWordSeparators(editor2.getOption(
          115
          /* wordSeparators */
        ));
        const model = editor2.getModel();
        const selections = editor2.getSelections();
        const commands = selections.map((sel) => {
          const deleteRange = WordOperations.deleteInsideWord(wordSeparators, model, sel);
          return new ReplaceCommand(deleteRange, "");
        });
        editor2.pushUndoStop();
        editor2.executeCommands(this.id, commands);
        editor2.pushUndoStop();
      }
    };
    registerEditorCommand(new CursorWordStartLeft());
    registerEditorCommand(new CursorWordEndLeft());
    registerEditorCommand(new CursorWordLeft());
    registerEditorCommand(new CursorWordStartLeftSelect());
    registerEditorCommand(new CursorWordEndLeftSelect());
    registerEditorCommand(new CursorWordLeftSelect());
    registerEditorCommand(new CursorWordStartRight());
    registerEditorCommand(new CursorWordEndRight());
    registerEditorCommand(new CursorWordRight());
    registerEditorCommand(new CursorWordStartRightSelect());
    registerEditorCommand(new CursorWordEndRightSelect());
    registerEditorCommand(new CursorWordRightSelect());
    registerEditorCommand(new CursorWordAccessibilityLeft());
    registerEditorCommand(new CursorWordAccessibilityLeftSelect());
    registerEditorCommand(new CursorWordAccessibilityRight());
    registerEditorCommand(new CursorWordAccessibilityRightSelect());
    registerEditorCommand(new DeleteWordStartLeft());
    registerEditorCommand(new DeleteWordEndLeft());
    registerEditorCommand(new DeleteWordLeft());
    registerEditorCommand(new DeleteWordStartRight());
    registerEditorCommand(new DeleteWordEndRight());
    registerEditorCommand(new DeleteWordRight());
    registerEditorAction(DeleteInsideWord);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/wordPartOperations.js
var DeleteWordPartLeft, DeleteWordPartRight, WordPartLeftCommand, CursorWordPartLeft, CursorWordPartLeftSelect, WordPartRightCommand, CursorWordPartRight, CursorWordPartRightSelect;
var init_wordPartOperations = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/wordPartOperations.js"() {
    init_editorExtensions();
    init_cursorWordOperations();
    init_range();
    init_editorContextKeys();
    init_wordOperations();
    init_commands();
    DeleteWordPartLeft = class extends DeleteWordCommand {
      constructor() {
        super({
          whitespaceHeuristics: true,
          wordNavigationType: 0,
          id: "deleteWordPartLeft",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 256 | 512 | 1
              /* Backspace */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      _delete(ctx, wordNavigationType) {
        let r = WordPartOperations.deleteWordPartLeft(ctx);
        if (r) {
          return r;
        }
        return new Range(1, 1, 1, 1);
      }
    };
    DeleteWordPartRight = class extends DeleteWordCommand {
      constructor() {
        super({
          whitespaceHeuristics: true,
          wordNavigationType: 2,
          id: "deleteWordPartRight",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 256 | 512 | 20
              /* Delete */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      _delete(ctx, wordNavigationType) {
        let r = WordPartOperations.deleteWordPartRight(ctx);
        if (r) {
          return r;
        }
        const lineCount = ctx.model.getLineCount();
        const maxColumn = ctx.model.getLineMaxColumn(lineCount);
        return new Range(lineCount, maxColumn, lineCount, maxColumn);
      }
    };
    WordPartLeftCommand = class extends MoveWordCommand {
      _move(wordSeparators, model, position, wordNavigationType) {
        return WordPartOperations.moveWordPartLeft(wordSeparators, model, position);
      }
    };
    CursorWordPartLeft = class extends WordPartLeftCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 0,
          id: "cursorWordPartLeft",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 256 | 512 | 15
              /* LeftArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
    CursorWordPartLeftSelect = class extends WordPartLeftCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 0,
          id: "cursorWordPartLeftSelect",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 256 | 512 | 1024 | 15
              /* LeftArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
    WordPartRightCommand = class extends MoveWordCommand {
      _move(wordSeparators, model, position, wordNavigationType) {
        return WordPartOperations.moveWordPartRight(wordSeparators, model, position);
      }
    };
    CursorWordPartRight = class extends WordPartRightCommand {
      constructor() {
        super({
          inSelectionMode: false,
          wordNavigationType: 2,
          id: "cursorWordPartRight",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 256 | 512 | 17
              /* RightArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    CursorWordPartRightSelect = class extends WordPartRightCommand {
      constructor() {
        super({
          inSelectionMode: true,
          wordNavigationType: 2,
          id: "cursorWordPartRightSelect",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.textInputFocus,
            primary: 0,
            mac: {
              primary: 256 | 512 | 1024 | 17
              /* RightArrow */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
    };
    registerEditorCommand(new DeleteWordPartLeft());
    registerEditorCommand(new DeleteWordPartRight());
    registerEditorCommand(new CursorWordPartLeft());
    registerEditorCommand(new CursorWordPartLeftSelect());
    registerEditorCommand(new CursorWordPartRight());
    registerEditorCommand(new CursorWordPartRightSelect());
  }
});

// node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_formatActions, import_inPlaceReplace, import_viewportSemanticTokens;
var init_editor_all = __esm({
  "node_modules/monaco-editor/esm/vs/editor/editor.all.js"() {
    init_coreCommands();
    init_codeEditorWidget();
    init_diffEditorWidget();
    init_diffNavigator();
    init_anchorSelect();
    init_bracketMatching();
    init_caretOperations();
    init_transpose();
    init_clipboard();
    init_codeActionContributions();
    init_codelensController();
    init_colorContributions();
    init_comment();
    init_contextmenu();
    init_cursorUndo();
    init_dnd();
    init_findController();
    init_folding();
    init_fontZoom();
    import_formatActions = __toESM(require_formatActions());
    init_documentSymbols();
    init_ghostTextController();
    init_goToCommands();
    init_goToDefinitionAtPosition();
    init_gotoError();
    init_hover();
    init_indentation();
    init_inlayHintsController();
    import_inPlaceReplace = __toESM(require_inPlaceReplace());
    init_linesOperations();
    init_linkedEditing();
    init_links();
    init_multicursor();
    init_parameterHints();
    init_rename();
    init_smartSelect();
    init_snippetController2();
    init_suggestController();
    init_tokenization();
    init_toggleTabFocusMode();
    init_unusualLineTerminators();
    import_viewportSemanticTokens = __toESM(require_viewportSemanticTokens());
    init_wordHighlighter();
    init_wordOperations();
    init_wordPartOperations();
    init_standaloneStrings();
    init_codiconStyles();
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.js
var require_accessibilityHelp = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.js"(exports2) {
    init_dom();
    init_fastDomNode();
    init_formattedTextRenderer();
    init_aria();
    init_widget();
    init_lifecycle();
    init_platform();
    init_strings();
    init_uri();
    init_editorExtensions();
    init_editorContextKeys();
    init_toggleTabFocusMode();
    init_contextkey();
    init_instantiation();
    init_keybinding();
    init_opener();
    init_colorRegistry();
    init_themeService();
    init_standaloneStrings();
    var __decorate61 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param61 = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = new RawContextKey("accessibilityHelpWidgetVisible", false);
    var AccessibilityHelpController = class AccessibilityHelpController2 extends Disposable {
      constructor(editor2, instantiationService) {
        super();
        this._editor = editor2;
        this._widget = this._register(instantiationService.createInstance(AccessibilityHelpWidget, this._editor));
      }
      static get(editor2) {
        return editor2.getContribution(AccessibilityHelpController2.ID);
      }
      show() {
        this._widget.show();
      }
      hide() {
        this._widget.hide();
      }
    };
    AccessibilityHelpController.ID = "editor.contrib.accessibilityHelpController";
    AccessibilityHelpController = __decorate61([
      __param61(1, IInstantiationService)
    ], AccessibilityHelpController);
    function getSelectionLabel(selections, charactersSelected) {
      if (!selections || selections.length === 0) {
        return AccessibilityHelpNLS.noSelection;
      }
      if (selections.length === 1) {
        if (charactersSelected) {
          return format(AccessibilityHelpNLS.singleSelectionRange, selections[0].positionLineNumber, selections[0].positionColumn, charactersSelected);
        }
        return format(AccessibilityHelpNLS.singleSelection, selections[0].positionLineNumber, selections[0].positionColumn);
      }
      if (charactersSelected) {
        return format(AccessibilityHelpNLS.multiSelectionRange, selections.length, charactersSelected);
      }
      if (selections.length > 0) {
        return format(AccessibilityHelpNLS.multiSelection, selections.length);
      }
      return "";
    }
    var AccessibilityHelpWidget = class AccessibilityHelpWidget2 extends Widget {
      constructor(editor2, _contextKeyService, _keybindingService, _openerService) {
        super();
        this._contextKeyService = _contextKeyService;
        this._keybindingService = _keybindingService;
        this._openerService = _openerService;
        this._editor = editor2;
        this._isVisibleKey = CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE.bindTo(this._contextKeyService);
        this._domNode = createFastDomNode(document.createElement("div"));
        this._domNode.setClassName("accessibilityHelpWidget");
        this._domNode.setDisplay("none");
        this._domNode.setAttribute("role", "dialog");
        this._domNode.setAttribute("aria-hidden", "true");
        this._contentDomNode = createFastDomNode(document.createElement("div"));
        this._contentDomNode.setAttribute("role", "document");
        this._domNode.appendChild(this._contentDomNode);
        this._isVisible = false;
        this._register(this._editor.onDidLayoutChange(() => {
          if (this._isVisible) {
            this._layout();
          }
        }));
        this._register(addStandardDisposableListener(this._contentDomNode.domNode, "keydown", (e) => {
          if (!this._isVisible) {
            return;
          }
          if (e.equals(
            2048 | 35
            /* KEY_E */
          )) {
            alert(AccessibilityHelpNLS.emergencyConfOn);
            this._editor.updateOptions({
              accessibilitySupport: "on"
            });
            clearNode(this._contentDomNode.domNode);
            this._buildContent();
            this._contentDomNode.domNode.focus();
            e.preventDefault();
            e.stopPropagation();
          }
          if (e.equals(
            2048 | 38
            /* KEY_H */
          )) {
            alert(AccessibilityHelpNLS.openingDocs);
            let url = this._editor.getRawOptions().accessibilityHelpUrl;
            if (typeof url === "undefined") {
              url = "https://go.microsoft.com/fwlink/?linkid=852450";
            }
            this._openerService.open(URI.parse(url));
            e.preventDefault();
            e.stopPropagation();
          }
        }));
        this.onblur(this._contentDomNode.domNode, () => {
          this.hide();
        });
        this._editor.addOverlayWidget(this);
      }
      dispose() {
        this._editor.removeOverlayWidget(this);
        super.dispose();
      }
      getId() {
        return AccessibilityHelpWidget2.ID;
      }
      getDomNode() {
        return this._domNode.domNode;
      }
      getPosition() {
        return {
          preference: null
        };
      }
      show() {
        if (this._isVisible) {
          return;
        }
        this._isVisible = true;
        this._isVisibleKey.set(true);
        this._layout();
        this._domNode.setDisplay("block");
        this._domNode.setAttribute("aria-hidden", "false");
        this._contentDomNode.domNode.tabIndex = 0;
        this._buildContent();
        this._contentDomNode.domNode.focus();
      }
      _descriptionForCommand(commandId, msg, noKbMsg) {
        let kb = this._keybindingService.lookupKeybinding(commandId);
        if (kb) {
          return format(msg, kb.getAriaLabel());
        }
        return format(noKbMsg, commandId);
      }
      _buildContent() {
        const options = this._editor.getOptions();
        const selections = this._editor.getSelections();
        let charactersSelected = 0;
        if (selections) {
          const model = this._editor.getModel();
          if (model) {
            selections.forEach((selection) => {
              charactersSelected += model.getValueLengthInRange(selection);
            });
          }
        }
        let text2 = getSelectionLabel(selections, charactersSelected);
        if (options.get(
          53
          /* inDiffEditor */
        )) {
          if (options.get(
            80
            /* readOnly */
          )) {
            text2 += AccessibilityHelpNLS.readonlyDiffEditor;
          } else {
            text2 += AccessibilityHelpNLS.editableDiffEditor;
          }
        } else {
          if (options.get(
            80
            /* readOnly */
          )) {
            text2 += AccessibilityHelpNLS.readonlyEditor;
          } else {
            text2 += AccessibilityHelpNLS.editableEditor;
          }
        }
        const turnOnMessage = isMacintosh ? AccessibilityHelpNLS.changeConfigToOnMac : AccessibilityHelpNLS.changeConfigToOnWinLinux;
        switch (options.get(
          2
          /* accessibilitySupport */
        )) {
          case 0:
            text2 += "\n\n - " + turnOnMessage;
            break;
          case 2:
            text2 += "\n\n - " + AccessibilityHelpNLS.auto_on;
            break;
          case 1:
            text2 += "\n\n - " + AccessibilityHelpNLS.auto_off;
            text2 += " " + turnOnMessage;
            break;
        }
        if (options.get(
          128
          /* tabFocusMode */
        )) {
          text2 += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOnMsg, AccessibilityHelpNLS.tabFocusModeOnMsgNoKb);
        } else {
          text2 += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOffMsg, AccessibilityHelpNLS.tabFocusModeOffMsgNoKb);
        }
        const openDocMessage = isMacintosh ? AccessibilityHelpNLS.openDocMac : AccessibilityHelpNLS.openDocWinLinux;
        text2 += "\n\n - " + openDocMessage;
        text2 += "\n\n" + AccessibilityHelpNLS.outroMsg;
        this._contentDomNode.domNode.appendChild(renderFormattedText(text2));
        this._contentDomNode.domNode.setAttribute("aria-label", text2);
      }
      hide() {
        if (!this._isVisible) {
          return;
        }
        this._isVisible = false;
        this._isVisibleKey.reset();
        this._domNode.setDisplay("none");
        this._domNode.setAttribute("aria-hidden", "true");
        this._contentDomNode.domNode.tabIndex = -1;
        clearNode(this._contentDomNode.domNode);
        this._editor.focus();
      }
      _layout() {
        let editorLayout = this._editor.getLayoutInfo();
        let w = Math.max(5, Math.min(AccessibilityHelpWidget2.WIDTH, editorLayout.width - 40));
        let h = Math.max(5, Math.min(AccessibilityHelpWidget2.HEIGHT, editorLayout.height - 40));
        this._domNode.setWidth(w);
        this._domNode.setHeight(h);
        let top = Math.round((editorLayout.height - h) / 2);
        this._domNode.setTop(top);
        let left = Math.round((editorLayout.width - w) / 2);
        this._domNode.setLeft(left);
      }
    };
    AccessibilityHelpWidget.ID = "editor.contrib.accessibilityHelpWidget";
    AccessibilityHelpWidget.WIDTH = 500;
    AccessibilityHelpWidget.HEIGHT = 300;
    AccessibilityHelpWidget = __decorate61([
      __param61(1, IContextKeyService),
      __param61(2, IKeybindingService),
      __param61(3, IOpenerService)
    ], AccessibilityHelpWidget);
    var ShowAccessibilityHelpAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.showAccessibilityHelp",
          label: AccessibilityHelpNLS.showAccessibilityHelpAction,
          alias: "Show Accessibility Help",
          precondition: void 0,
          kbOpts: {
            primary: 512 | 59,
            weight: 100,
            linux: {
              primary: 512 | 1024 | 59,
              secondary: [
                512 | 59
                /* F1 */
              ]
            }
          }
        });
      }
      run(accessor, editor2) {
        let controller = AccessibilityHelpController.get(editor2);
        if (controller) {
          controller.show();
        }
      }
    };
    registerEditorContribution(AccessibilityHelpController.ID, AccessibilityHelpController);
    registerEditorAction(ShowAccessibilityHelpAction);
    var AccessibilityHelpCommand = EditorCommand.bindToContribution(AccessibilityHelpController.get);
    registerEditorCommand(new AccessibilityHelpCommand({
      id: "closeAccessibilityHelp",
      precondition: CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE,
      handler: (x) => x.hide(),
      kbOpts: {
        weight: 100 + 100,
        kbExpr: EditorContextKeys.focus,
        primary: 9,
        secondary: [
          1024 | 9
          /* Escape */
        ]
      }
    }));
    registerThemingParticipant((theme, collector) => {
      const widgetBackground = theme.getColor(editorWidgetBackground);
      if (widgetBackground) {
        collector.addRule(`.monaco-editor .accessibilityHelpWidget { background-color: ${widgetBackground}; }`);
      }
      const widgetForeground = theme.getColor(editorWidgetForeground);
      if (widgetForeground) {
        collector.addRule(`.monaco-editor .accessibilityHelpWidget { color: ${widgetForeground}; }`);
      }
      const widgetShadowColor = theme.getColor(widgetShadow);
      if (widgetShadowColor) {
        collector.addRule(`.monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);
      }
      const hcBorder = theme.getColor(contrastBorder);
      if (hcBorder) {
        collector.addRule(`.monaco-editor .accessibilityHelpWidget { border: 2px solid ${hcBorder}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js
var IPadShowKeyboard, ShowKeyboardWidget;
var init_iPadShowKeyboard = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js"() {
    init_dom();
    init_lifecycle();
    init_editorExtensions();
    init_platform();
    IPadShowKeyboard = class extends Disposable {
      constructor(editor2) {
        super();
        this.editor = editor2;
        this.widget = null;
        if (isIOS) {
          this._register(editor2.onDidChangeConfiguration(() => this.update()));
          this.update();
        }
      }
      update() {
        const shouldHaveWidget = !this.editor.getOption(
          80
          /* readOnly */
        );
        if (!this.widget && shouldHaveWidget) {
          this.widget = new ShowKeyboardWidget(this.editor);
        } else if (this.widget && !shouldHaveWidget) {
          this.widget.dispose();
          this.widget = null;
        }
      }
      dispose() {
        super.dispose();
        if (this.widget) {
          this.widget.dispose();
          this.widget = null;
        }
      }
    };
    IPadShowKeyboard.ID = "editor.contrib.iPadShowKeyboard";
    ShowKeyboardWidget = class _ShowKeyboardWidget extends Disposable {
      constructor(editor2) {
        super();
        this.editor = editor2;
        this._domNode = document.createElement("textarea");
        this._domNode.className = "iPadShowKeyboard";
        this._register(addDisposableListener(this._domNode, "touchstart", (e) => {
          this.editor.focus();
        }));
        this._register(addDisposableListener(this._domNode, "focus", (e) => {
          this.editor.focus();
        }));
        this.editor.addOverlayWidget(this);
      }
      dispose() {
        this.editor.removeOverlayWidget(this);
        super.dispose();
      }
      // ----- IOverlayWidget API
      getId() {
        return _ShowKeyboardWidget.ID;
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        return {
          preference: 1
          /* BOTTOM_RIGHT_CORNER */
        };
      }
    };
    ShowKeyboardWidget.ID = "editor.contrib.ShowKeyboardWidget";
    registerEditorContribution(IPadShowKeyboard.ID, IPadShowKeyboard);
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.js
var require_inspectTokens = __commonJS({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.js"(exports2) {
    init_dom();
    init_color();
    init_lifecycle();
    init_editorExtensions();
    init_modes();
    init_nullMode();
    init_modeService();
    init_standaloneThemeService();
    init_colorRegistry();
    init_themeService();
    init_standaloneStrings();
    init_theme();
    var __decorate61 = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param61 = exports2 && exports2.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var InspectTokensController = class InspectTokensController2 extends Disposable {
      constructor(editor2, standaloneColorService, modeService) {
        super();
        this._editor = editor2;
        this._modeService = modeService;
        this._widget = null;
        this._register(this._editor.onDidChangeModel((e) => this.stop()));
        this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
        this._register(TokenizationRegistry.onDidChange((e) => this.stop()));
        this._register(this._editor.onKeyUp((e) => e.keyCode === 9 && this.stop()));
      }
      static get(editor2) {
        return editor2.getContribution(InspectTokensController2.ID);
      }
      dispose() {
        this.stop();
        super.dispose();
      }
      launch() {
        if (this._widget) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        this._widget = new InspectTokensWidget(this._editor, this._modeService);
      }
      stop() {
        if (this._widget) {
          this._widget.dispose();
          this._widget = null;
        }
      }
    };
    InspectTokensController.ID = "editor.contrib.inspectTokens";
    InspectTokensController = __decorate61([
      __param61(1, IStandaloneThemeService),
      __param61(2, IModeService)
    ], InspectTokensController);
    var InspectTokens = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inspectTokens",
          label: InspectTokensNLS.inspectTokensAction,
          alias: "Developer: Inspect Tokens",
          precondition: void 0
        });
      }
      run(accessor, editor2) {
        let controller = InspectTokensController.get(editor2);
        if (controller) {
          controller.launch();
        }
      }
    };
    function renderTokenText(tokenText) {
      let result = "";
      for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
        let charCode = tokenText.charCodeAt(charIndex);
        switch (charCode) {
          case 9:
            result += "\u2192";
            break;
          case 32:
            result += "\xB7";
            break;
          default:
            result += String.fromCharCode(charCode);
        }
      }
      return result;
    }
    function getSafeTokenizationSupport(languageIdentifier) {
      let tokenizationSupport = TokenizationRegistry.get(languageIdentifier.language);
      if (tokenizationSupport) {
        return tokenizationSupport;
      }
      return {
        getInitialState: () => NULL_STATE,
        tokenize: (line, hasEOL, state, deltaOffset) => nullTokenize(languageIdentifier.language, line, state, deltaOffset),
        tokenize2: (line, hasEOL, state, deltaOffset) => nullTokenize2(languageIdentifier.id, line, state, deltaOffset)
      };
    }
    var InspectTokensWidget = class _InspectTokensWidget extends Disposable {
      constructor(editor2, modeService) {
        super();
        this.allowEditorOverflow = true;
        this._editor = editor2;
        this._modeService = modeService;
        this._model = this._editor.getModel();
        this._domNode = document.createElement("div");
        this._domNode.className = "tokens-inspect-widget";
        this._tokenizationSupport = getSafeTokenizationSupport(this._model.getLanguageIdentifier());
        this._compute(this._editor.getPosition());
        this._register(this._editor.onDidChangeCursorPosition((e) => this._compute(this._editor.getPosition())));
        this._editor.addContentWidget(this);
      }
      dispose() {
        this._editor.removeContentWidget(this);
        super.dispose();
      }
      getId() {
        return _InspectTokensWidget._ID;
      }
      _compute(position) {
        let data = this._getTokensAtLine(position.lineNumber);
        let token1Index = 0;
        for (let i = data.tokens1.length - 1; i >= 0; i--) {
          let t = data.tokens1[i];
          if (position.column - 1 >= t.offset) {
            token1Index = i;
            break;
          }
        }
        let token2Index = 0;
        for (let i = data.tokens2.length >>> 1; i >= 0; i--) {
          if (position.column - 1 >= data.tokens2[i << 1]) {
            token2Index = i;
            break;
          }
        }
        let lineContent = this._model.getLineContent(position.lineNumber);
        let tokenText = "";
        if (token1Index < data.tokens1.length) {
          let tokenStartIndex = data.tokens1[token1Index].offset;
          let tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
          tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
        }
        reset(this._domNode, $("h2.tm-token", void 0, renderTokenText(tokenText), $("span.tm-token-length", void 0, `${tokenText.length} ${tokenText.length === 1 ? "char" : "chars"}`)));
        append(this._domNode, $("hr.tokens-inspect-separator", { "style": "clear:both" }));
        const metadata = (token2Index << 1) + 1 < data.tokens2.length ? this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]) : null;
        append(this._domNode, $("table.tm-metadata-table", void 0, $("tbody", void 0, $("tr", void 0, $("td.tm-metadata-key", void 0, "language"), $("td.tm-metadata-value", void 0, `${metadata ? metadata.languageIdentifier.language : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "token type"), $("td.tm-metadata-value", void 0, `${metadata ? this._tokenTypeToString(metadata.tokenType) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "font style"), $("td.tm-metadata-value", void 0, `${metadata ? this._fontStyleToString(metadata.fontStyle) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "foreground"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.foreground) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "background"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.background) : "-?-"}`)))));
        append(this._domNode, $("hr.tokens-inspect-separator"));
        if (token1Index < data.tokens1.length) {
          append(this._domNode, $("span.tm-token-type", void 0, data.tokens1[token1Index].type));
        }
        this._editor.layoutContentWidget(this);
      }
      _decodeMetadata(metadata) {
        let colorMap = TokenizationRegistry.getColorMap();
        let languageId = TokenMetadata.getLanguageId(metadata);
        let tokenType = TokenMetadata.getTokenType(metadata);
        let fontStyle = TokenMetadata.getFontStyle(metadata);
        let foreground2 = TokenMetadata.getForeground(metadata);
        let background = TokenMetadata.getBackground(metadata);
        return {
          languageIdentifier: this._modeService.getLanguageIdentifier(languageId),
          tokenType,
          fontStyle,
          foreground: colorMap[foreground2],
          background: colorMap[background]
        };
      }
      _tokenTypeToString(tokenType) {
        switch (tokenType) {
          case 0:
            return "Other";
          case 1:
            return "Comment";
          case 2:
            return "String";
          case 4:
            return "RegEx";
          default:
            return "??";
        }
      }
      _fontStyleToString(fontStyle) {
        let r = "";
        if (fontStyle & 1) {
          r += "italic ";
        }
        if (fontStyle & 2) {
          r += "bold ";
        }
        if (fontStyle & 4) {
          r += "underline ";
        }
        if (r.length === 0) {
          r = "---";
        }
        return r;
      }
      _getTokensAtLine(lineNumber) {
        let stateBeforeLine = this._getStateBeforeLine(lineNumber);
        let tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), true, stateBeforeLine, 0);
        let tokenizationResult2 = this._tokenizationSupport.tokenize2(this._model.getLineContent(lineNumber), true, stateBeforeLine, 0);
        return {
          startState: stateBeforeLine,
          tokens1: tokenizationResult1.tokens,
          tokens2: tokenizationResult2.tokens,
          endState: tokenizationResult1.endState
        };
      }
      _getStateBeforeLine(lineNumber) {
        let state = this._tokenizationSupport.getInitialState();
        for (let i = 1; i < lineNumber; i++) {
          let tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i), true, state, 0);
          state = tokenizationResult.endState;
        }
        return state;
      }
      getDomNode() {
        return this._domNode;
      }
      getPosition() {
        return {
          position: this._editor.getPosition(),
          preference: [
            2,
            1
            /* ABOVE */
          ]
        };
      }
    };
    InspectTokensWidget._ID = "editor.contrib.inspectTokensWidget";
    registerEditorContribution(InspectTokensController.ID, InspectTokensController);
    registerEditorAction(InspectTokens);
    registerThemingParticipant((theme, collector) => {
      const border = theme.getColor(editorHoverBorder);
      if (border) {
        let borderWidth = theme.type === ColorScheme.HIGH_CONTRAST ? 2 : 1;
        collector.addRule(`.monaco-editor .tokens-inspect-widget { border: ${borderWidth}px solid ${border}; }`);
        collector.addRule(`.monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: ${border}; }`);
      }
      const background = theme.getColor(editorHoverBackground);
      if (background) {
        collector.addRule(`.monaco-editor .tokens-inspect-widget { background-color: ${background}; }`);
      }
      const foreground2 = theme.getColor(editorHoverForeground);
      if (foreground2) {
        collector.addRule(`.monaco-editor .tokens-inspect-widget { color: ${foreground2}; }`);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/helpQuickAccess.js
var __decorate55, __param55, HelpQuickAccessProvider;
var init_helpQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/platform/quickinput/browser/helpQuickAccess.js"() {
    init_lifecycle();
    init_nls();
    init_quickAccess();
    init_quickInput();
    init_platform2();
    __decorate55 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param55 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    HelpQuickAccessProvider = class HelpQuickAccessProvider2 {
      constructor(quickInputService) {
        this.quickInputService = quickInputService;
        this.registry = Registry.as(Extensions2.Quickaccess);
      }
      provide(picker) {
        const disposables = new DisposableStore();
        disposables.add(picker.onDidAccept(() => {
          const [item] = picker.selectedItems;
          if (item) {
            this.quickInputService.quickAccess.show(item.prefix, { preserveValue: true });
          }
        }));
        disposables.add(picker.onDidChangeValue((value) => {
          const providerDescriptor = this.registry.getQuickAccessProvider(value.substr(HelpQuickAccessProvider2.PREFIX.length));
          if (providerDescriptor && providerDescriptor.prefix && providerDescriptor.prefix !== HelpQuickAccessProvider2.PREFIX) {
            this.quickInputService.quickAccess.show(providerDescriptor.prefix, { preserveValue: true });
          }
        }));
        const { editorProviders, globalProviders } = this.getQuickAccessProviders();
        picker.items = editorProviders.length === 0 || globalProviders.length === 0 ? (
          // Without groups
          [
            ...editorProviders.length === 0 ? globalProviders : editorProviders
          ]
        ) : (
          // With groups
          [
            { label: localize("globalCommands", "global commands"), type: "separator" },
            ...globalProviders,
            { label: localize("editorCommands", "editor commands"), type: "separator" },
            ...editorProviders
          ]
        );
        return disposables;
      }
      getQuickAccessProviders() {
        const globalProviders = [];
        const editorProviders = [];
        for (const provider of this.registry.getQuickAccessProviders().sort((providerA, providerB) => providerA.prefix.localeCompare(providerB.prefix))) {
          if (provider.prefix === HelpQuickAccessProvider2.PREFIX) {
            continue;
          }
          for (const helpEntry of provider.helpEntries) {
            const prefix = helpEntry.prefix || provider.prefix;
            const label = prefix || "\u2026";
            (helpEntry.needsEditor ? editorProviders : globalProviders).push({
              prefix,
              label,
              ariaLabel: localize("helpPickAriaLabel", "{0}, {1}", label, helpEntry.description),
              description: helpEntry.description
            });
          }
        }
        return { editorProviders, globalProviders };
      }
    };
    HelpQuickAccessProvider.PREFIX = "?";
    HelpQuickAccessProvider = __decorate55([
      __param55(0, IQuickInputService)
    ], HelpQuickAccessProvider);
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js
var init_standaloneHelpQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js"() {
    init_platform2();
    init_quickAccess();
    init_standaloneStrings();
    init_helpQuickAccess();
    Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
      ctor: HelpQuickAccessProvider,
      prefix: "",
      helpEntries: [{ description: QuickHelpNLS.helpQuickAccessActionLabel, needsEditor: true }]
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/editorNavigationQuickAccess.js
var AbstractEditorNavigationQuickAccessProvider;
var init_editorNavigationQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/editorNavigationQuickAccess.js"() {
    init_functional();
    init_lifecycle();
    init_types();
    init_editorBrowser();
    init_model();
    init_editorColorRegistry();
    init_themeService();
    AbstractEditorNavigationQuickAccessProvider = class {
      constructor(options) {
        this.options = options;
        this.rangeHighlightDecorationId = void 0;
      }
      //#region Provider methods
      provide(picker, token) {
        var _a5;
        const disposables = new DisposableStore();
        picker.canAcceptInBackground = !!((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.canAcceptInBackground);
        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
        const pickerDisposable = disposables.add(new MutableDisposable());
        pickerDisposable.value = this.doProvide(picker, token);
        disposables.add(this.onDidActiveTextEditorControlChange(() => {
          pickerDisposable.value = void 0;
          pickerDisposable.value = this.doProvide(picker, token);
        }));
        return disposables;
      }
      doProvide(picker, token) {
        const disposables = new DisposableStore();
        const editor2 = this.activeTextEditorControl;
        if (editor2 && this.canProvideWithTextEditor(editor2)) {
          const context = { editor: editor2 };
          const codeEditor = getCodeEditor(editor2);
          if (codeEditor) {
            let lastKnownEditorViewState = withNullAsUndefined(editor2.saveViewState());
            disposables.add(codeEditor.onDidChangeCursorPosition(() => {
              lastKnownEditorViewState = withNullAsUndefined(editor2.saveViewState());
            }));
            context.restoreViewState = () => {
              if (lastKnownEditorViewState && editor2 === this.activeTextEditorControl) {
                editor2.restoreViewState(lastKnownEditorViewState);
              }
            };
            disposables.add(once(token.onCancellationRequested)(() => {
              var _a5;
              return (_a5 = context.restoreViewState) === null || _a5 === void 0 ? void 0 : _a5.call(context);
            }));
          }
          disposables.add(toDisposable(() => this.clearDecorations(editor2)));
          disposables.add(this.provideWithTextEditor(context, picker, token));
        } else {
          disposables.add(this.provideWithoutTextEditor(picker, token));
        }
        return disposables;
      }
      /**
       * Subclasses to implement if they can operate on the text editor.
       */
      canProvideWithTextEditor(editor2) {
        return true;
      }
      gotoLocation({ editor: editor2 }, options) {
        editor2.setSelection(options.range);
        editor2.revealRangeInCenter(
          options.range,
          0
          /* Smooth */
        );
        if (!options.preserveFocus) {
          editor2.focus();
        }
      }
      getModel(editor2) {
        var _a5;
        return isDiffEditor(editor2) ? (_a5 = editor2.getModel()) === null || _a5 === void 0 ? void 0 : _a5.modified : editor2.getModel();
      }
      addDecorations(editor2, range) {
        editor2.changeDecorations((changeAccessor) => {
          const deleteDecorations = [];
          if (this.rangeHighlightDecorationId) {
            deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);
            deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);
            this.rangeHighlightDecorationId = void 0;
          }
          const newDecorations = [
            // highlight the entire line on the range
            {
              range,
              options: {
                description: "quick-access-range-highlight",
                className: "rangeHighlight",
                isWholeLine: true
              }
            },
            // also add overview ruler highlight
            {
              range,
              options: {
                description: "quick-access-range-highlight-overview",
                overviewRuler: {
                  color: themeColorFromId(overviewRulerRangeHighlight),
                  position: OverviewRulerLane.Full
                }
              }
            }
          ];
          const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
          this.rangeHighlightDecorationId = { rangeHighlightId, overviewRulerDecorationId };
        });
      }
      clearDecorations(editor2) {
        const rangeHighlightDecorationId = this.rangeHighlightDecorationId;
        if (rangeHighlightDecorationId) {
          editor2.changeDecorations((changeAccessor) => {
            changeAccessor.deltaDecorations([
              rangeHighlightDecorationId.overviewRulerDecorationId,
              rangeHighlightDecorationId.rangeHighlightId
            ], []);
          });
          this.rangeHighlightDecorationId = void 0;
        }
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoLineQuickAccess.js
var AbstractGotoLineQuickAccessProvider;
var init_gotoLineQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoLineQuickAccess.js"() {
    init_lifecycle();
    init_editorBrowser();
    init_editorNavigationQuickAccess();
    init_nls();
    AbstractGotoLineQuickAccessProvider = class _AbstractGotoLineQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
      constructor() {
        super({ canAcceptInBackground: true });
      }
      provideWithoutTextEditor(picker) {
        const label = localize("cannotRunGotoLine", "Open a text editor first to go to a line.");
        picker.items = [{ label }];
        picker.ariaLabel = label;
        return Disposable.None;
      }
      provideWithTextEditor(context, picker, token) {
        const editor2 = context.editor;
        const disposables = new DisposableStore();
        disposables.add(picker.onDidAccept((event) => {
          const [item] = picker.selectedItems;
          if (item) {
            if (!this.isValidLineNumber(editor2, item.lineNumber)) {
              return;
            }
            this.gotoLocation(context, { range: this.toRange(item.lineNumber, item.column), keyMods: picker.keyMods, preserveFocus: event.inBackground });
            if (!event.inBackground) {
              picker.hide();
            }
          }
        }));
        const updatePickerAndEditor = () => {
          const position = this.parsePosition(editor2, picker.value.trim().substr(_AbstractGotoLineQuickAccessProvider.PREFIX.length));
          const label = this.getPickLabel(editor2, position.lineNumber, position.column);
          picker.items = [{
            lineNumber: position.lineNumber,
            column: position.column,
            label
          }];
          picker.ariaLabel = label;
          if (!this.isValidLineNumber(editor2, position.lineNumber)) {
            this.clearDecorations(editor2);
            return;
          }
          const range = this.toRange(position.lineNumber, position.column);
          editor2.revealRangeInCenter(
            range,
            0
            /* Smooth */
          );
          this.addDecorations(editor2, range);
        };
        updatePickerAndEditor();
        disposables.add(picker.onDidChangeValue(() => updatePickerAndEditor()));
        const codeEditor = getCodeEditor(editor2);
        if (codeEditor) {
          const options = codeEditor.getOptions();
          const lineNumbers = options.get(
            59
            /* lineNumbers */
          );
          if (lineNumbers.renderType === 2) {
            codeEditor.updateOptions({ lineNumbers: "on" });
            disposables.add(toDisposable(() => codeEditor.updateOptions({ lineNumbers: "relative" })));
          }
        }
        return disposables;
      }
      toRange(lineNumber = 1, column = 1) {
        return {
          startLineNumber: lineNumber,
          startColumn: column,
          endLineNumber: lineNumber,
          endColumn: column
        };
      }
      parsePosition(editor2, value) {
        const numbers = value.split(/,|:|#/).map((part) => parseInt(part, 10)).filter((part) => !isNaN(part));
        const endLine = this.lineCount(editor2) + 1;
        return {
          lineNumber: numbers[0] > 0 ? numbers[0] : endLine + numbers[0],
          column: numbers[1]
        };
      }
      getPickLabel(editor2, lineNumber, column) {
        if (this.isValidLineNumber(editor2, lineNumber)) {
          if (this.isValidColumn(editor2, lineNumber, column)) {
            return localize("gotoLineColumnLabel", "Go to line {0} and character {1}.", lineNumber, column);
          }
          return localize("gotoLineLabel", "Go to line {0}.", lineNumber);
        }
        const position = editor2.getPosition() || { lineNumber: 1, column: 1 };
        const lineCount = this.lineCount(editor2);
        if (lineCount > 1) {
          return localize("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", position.lineNumber, position.column, lineCount);
        }
        return localize("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", position.lineNumber, position.column);
      }
      isValidLineNumber(editor2, lineNumber) {
        if (!lineNumber || typeof lineNumber !== "number") {
          return false;
        }
        return lineNumber > 0 && lineNumber <= this.lineCount(editor2);
      }
      isValidColumn(editor2, lineNumber, column) {
        if (!column || typeof column !== "number") {
          return false;
        }
        const model = this.getModel(editor2);
        if (!model) {
          return false;
        }
        const positionCandidate = { lineNumber, column };
        return model.validatePosition(positionCandidate).equals(positionCandidate);
      }
      lineCount(editor2) {
        var _a5, _b2;
        return (_b2 = (_a5 = this.getModel(editor2)) === null || _a5 === void 0 ? void 0 : _a5.getLineCount()) !== null && _b2 !== void 0 ? _b2 : 0;
      }
    };
    AbstractGotoLineQuickAccessProvider.PREFIX = ":";
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js
var __decorate56, __param56, StandaloneGotoLineQuickAccessProvider, GotoLineAction;
var init_standaloneGotoLineQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js"() {
    init_gotoLineQuickAccess();
    init_platform2();
    init_quickAccess();
    init_codeEditorService();
    init_types();
    init_standaloneStrings();
    init_event();
    init_editorExtensions();
    init_editorContextKeys();
    init_quickInput();
    __decorate56 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param56 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    StandaloneGotoLineQuickAccessProvider = class StandaloneGotoLineQuickAccessProvider2 extends AbstractGotoLineQuickAccessProvider {
      constructor(editorService) {
        super();
        this.editorService = editorService;
        this.onDidActiveTextEditorControlChange = Event.None;
      }
      get activeTextEditorControl() {
        return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
      }
    };
    StandaloneGotoLineQuickAccessProvider = __decorate56([
      __param56(0, ICodeEditorService)
    ], StandaloneGotoLineQuickAccessProvider);
    Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
      ctor: StandaloneGotoLineQuickAccessProvider,
      prefix: StandaloneGotoLineQuickAccessProvider.PREFIX,
      helpEntries: [{ description: GoToLineNLS.gotoLineActionLabel, needsEditor: true }]
    });
    GotoLineAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.gotoLine",
          label: GoToLineNLS.gotoLineActionLabel,
          alias: "Go to Line/Column...",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 2048 | 37,
            mac: {
              primary: 256 | 37
              /* KEY_G */
            },
            weight: 100
            /* EditorContrib */
          }
        });
      }
      run(accessor) {
        accessor.get(IQuickInputService).quickAccess.show(StandaloneGotoLineQuickAccessProvider.PREFIX);
      }
    };
    registerEditorAction(GotoLineAction);
  }
});

// node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js
function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
  const preparedQuery = query;
  if (preparedQuery.values && preparedQuery.values.length > 1) {
    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);
  }
  return doScoreFuzzy2Single(target, query, patternStart, wordStart);
}
function doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {
  let totalScore = 0;
  const totalMatches = [];
  for (const queryPiece of query) {
    const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);
    if (typeof score !== "number") {
      return NO_SCORE2;
    }
    totalScore += score;
    totalMatches.push(...matches);
  }
  return [totalScore, normalizeMatches(totalMatches)];
}
function doScoreFuzzy2Single(target, query, patternStart, wordStart) {
  const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);
  if (!score) {
    return NO_SCORE2;
  }
  return [score[0], createMatches(score)];
}
function normalizeMatches(matches) {
  const sortedMatches = matches.sort((matchA, matchB) => {
    return matchA.start - matchB.start;
  });
  const normalizedMatches = [];
  let currentMatch = void 0;
  for (const match of sortedMatches) {
    if (!currentMatch || !matchOverlaps(currentMatch, match)) {
      currentMatch = match;
      normalizedMatches.push(match);
    } else {
      currentMatch.start = Math.min(currentMatch.start, match.start);
      currentMatch.end = Math.max(currentMatch.end, match.end);
    }
  }
  return normalizedMatches;
}
function matchOverlaps(matchA, matchB) {
  if (matchA.end < matchB.start) {
    return false;
  }
  if (matchB.end < matchA.start) {
    return false;
  }
  return true;
}
function queryExpectsExactMatch(query) {
  return query.startsWith('"') && query.endsWith('"');
}
function prepareQuery(original) {
  if (typeof original !== "string") {
    original = "";
  }
  const originalLowercase = original.toLowerCase();
  const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);
  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;
  const expectExactMatch = queryExpectsExactMatch(original);
  let values = void 0;
  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);
  if (originalSplit.length > 1) {
    for (const originalPiece of originalSplit) {
      const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);
      const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);
      if (normalizedPiece) {
        if (!values) {
          values = [];
        }
        values.push({
          original: originalPiece,
          originalLowercase: originalPiece.toLowerCase(),
          pathNormalized: pathNormalizedPiece,
          normalized: normalizedPiece,
          normalizedLowercase: normalizedLowercasePiece,
          expectContiguousMatch: expectExactMatchPiece
        });
      }
    }
  }
  return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };
}
function normalizeQuery(original) {
  let pathNormalized;
  if (isWindows) {
    pathNormalized = original.replace(/\//g, sep);
  } else {
    pathNormalized = original.replace(/\\/g, sep);
  }
  const normalized = stripWildcards(pathNormalized).replace(/\s|"/g, "");
  return {
    pathNormalized,
    normalized,
    normalizedLowercase: normalized.toLowerCase()
  };
}
function pieceToQuery(arg1) {
  if (Array.isArray(arg1)) {
    return prepareQuery(arg1.map((piece) => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));
  }
  return prepareQuery(arg1.original);
}
var NO_SCORE2, MULTIPLE_QUERY_VALUES_SEPARATOR;
var init_fuzzyScorer = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js"() {
    init_filters();
    init_path();
    init_platform();
    init_strings();
    NO_SCORE2 = [void 0, []];
    MULTIPLE_QUERY_VALUES_SEPARATOR = " ";
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoSymbolQuickAccess.js
var __awaiter42, AbstractGotoSymbolQuickAccessProvider, FALLBACK_NLS_SYMBOL_KIND, NLS_SYMBOL_KIND_CACHE;
var init_gotoSymbolQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoSymbolQuickAccess.js"() {
    init_cancellation();
    init_codicons();
    init_fuzzyScorer();
    init_lifecycle();
    init_strings();
    init_range();
    init_modes();
    init_outlineModel();
    init_editorNavigationQuickAccess();
    init_nls();
    __awaiter42 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    AbstractGotoSymbolQuickAccessProvider = class _AbstractGotoSymbolQuickAccessProvider extends AbstractEditorNavigationQuickAccessProvider {
      constructor(options = /* @__PURE__ */ Object.create(null)) {
        super(options);
        this.options = options;
        this.options.canAcceptInBackground = true;
      }
      provideWithoutTextEditor(picker) {
        this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information."));
        return Disposable.None;
      }
      provideWithTextEditor(context, picker, token) {
        const editor2 = context.editor;
        const model = this.getModel(editor2);
        if (!model) {
          return Disposable.None;
        }
        if (DocumentSymbolProviderRegistry.has(model)) {
          return this.doProvideWithEditorSymbols(context, model, picker, token);
        }
        return this.doProvideWithoutEditorSymbols(context, model, picker, token);
      }
      doProvideWithoutEditorSymbols(context, model, picker, token) {
        const disposables = new DisposableStore();
        this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information."));
        (() => __awaiter42(this, void 0, void 0, function* () {
          const result = yield this.waitForLanguageSymbolRegistry(model, disposables);
          if (!result || token.isCancellationRequested) {
            return;
          }
          disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));
        }))();
        return disposables;
      }
      provideLabelPick(picker, label) {
        picker.items = [{
          label,
          index: 0,
          kind: 14
          /* String */
        }];
        picker.ariaLabel = label;
      }
      waitForLanguageSymbolRegistry(model, disposables) {
        return __awaiter42(this, void 0, void 0, function* () {
          if (DocumentSymbolProviderRegistry.has(model)) {
            return true;
          }
          let symbolProviderRegistryPromiseResolve;
          const symbolProviderRegistryPromise = new Promise((resolve) => symbolProviderRegistryPromiseResolve = resolve);
          const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {
            if (DocumentSymbolProviderRegistry.has(model)) {
              symbolProviderListener.dispose();
              symbolProviderRegistryPromiseResolve(true);
            }
          }));
          disposables.add(toDisposable(() => symbolProviderRegistryPromiseResolve(false)));
          return symbolProviderRegistryPromise;
        });
      }
      doProvideWithEditorSymbols(context, model, picker, token) {
        const editor2 = context.editor;
        const disposables = new DisposableStore();
        disposables.add(picker.onDidAccept((event) => {
          const [item] = picker.selectedItems;
          if (item && item.range) {
            this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });
            if (!event.inBackground) {
              picker.hide();
            }
          }
        }));
        disposables.add(picker.onDidTriggerItemButton(({ item }) => {
          if (item && item.range) {
            this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });
            picker.hide();
          }
        }));
        const symbolsPromise = this.getDocumentSymbols(model, token);
        let picksCts = void 0;
        const updatePickerItems = () => __awaiter42(this, void 0, void 0, function* () {
          picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
          picker.busy = false;
          picksCts = new CancellationTokenSource(token);
          picker.busy = true;
          try {
            const query = prepareQuery(picker.value.substr(_AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());
            const items = yield this.doGetSymbolPicks(symbolsPromise, query, void 0, picksCts.token);
            if (token.isCancellationRequested) {
              return;
            }
            if (items.length > 0) {
              picker.items = items;
            } else {
              if (query.original.length > 0) {
                this.provideLabelPick(picker, localize("noMatchingSymbolResults", "No matching editor symbols"));
              } else {
                this.provideLabelPick(picker, localize("noSymbolResults", "No editor symbols"));
              }
            }
          } finally {
            if (!token.isCancellationRequested) {
              picker.busy = false;
            }
          }
        });
        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
        updatePickerItems();
        let ignoreFirstActiveEvent = true;
        disposables.add(picker.onDidChangeActive(() => {
          const [item] = picker.activeItems;
          if (item && item.range) {
            if (ignoreFirstActiveEvent) {
              ignoreFirstActiveEvent = false;
              return;
            }
            editor2.revealRangeInCenter(
              item.range.selection,
              0
              /* Smooth */
            );
            this.addDecorations(editor2, item.range.decoration);
          }
        }));
        return disposables;
      }
      doGetSymbolPicks(symbolsPromise, query, options, token) {
        return __awaiter42(this, void 0, void 0, function* () {
          const symbols = yield symbolsPromise;
          if (token.isCancellationRequested) {
            return [];
          }
          const filterBySymbolKind = query.original.indexOf(_AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;
          const filterPos = filterBySymbolKind ? 1 : 0;
          let symbolQuery;
          let containerQuery;
          if (query.values && query.values.length > 1) {
            symbolQuery = pieceToQuery(query.values[0]);
            containerQuery = pieceToQuery(query.values.slice(1));
          } else {
            symbolQuery = query;
          }
          const filteredSymbolPicks = [];
          for (let index = 0; index < symbols.length; index++) {
            const symbol = symbols[index];
            const symbolLabel = trim(symbol.name);
            const symbolLabelWithIcon = `$(symbol-${SymbolKinds.toString(symbol.kind) || "property"}) ${symbolLabel}`;
            const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
            let containerLabel = symbol.containerName;
            if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {
              if (containerLabel) {
                containerLabel = `${options.extraContainerLabel} \u2022 ${containerLabel}`;
              } else {
                containerLabel = options.extraContainerLabel;
              }
            }
            let symbolScore = void 0;
            let symbolMatches = void 0;
            let containerScore = void 0;
            let containerMatches = void 0;
            if (query.original.length > filterPos) {
              let skipContainerQuery = false;
              if (symbolQuery !== query) {
                [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), {
                  values: void 0
                  /* disable multi-query support */
                }), filterPos, symbolLabelIconOffset);
                if (typeof symbolScore === "number") {
                  skipContainerQuery = true;
                }
              }
              if (typeof symbolScore !== "number") {
                [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
                if (typeof symbolScore !== "number") {
                  continue;
                }
              }
              if (!skipContainerQuery && containerQuery) {
                if (containerLabel && containerQuery.original.length > 0) {
                  [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
                }
                if (typeof containerScore !== "number") {
                  continue;
                }
                if (typeof symbolScore === "number") {
                  symbolScore += containerScore;
                }
              }
            }
            const deprecated = symbol.tags && symbol.tags.indexOf(
              1
              /* Deprecated */
            ) >= 0;
            filteredSymbolPicks.push({
              index,
              kind: symbol.kind,
              score: symbolScore,
              label: symbolLabelWithIcon,
              ariaLabel: symbolLabel,
              description: containerLabel,
              highlights: deprecated ? void 0 : {
                label: symbolMatches,
                description: containerMatches
              },
              range: {
                selection: Range.collapseToStart(symbol.selectionRange),
                decoration: symbol.range
              },
              strikethrough: deprecated,
              buttons: (() => {
                var _a5, _b2;
                const openSideBySideDirection = ((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.openSideBySideDirection) ? (_b2 = this.options) === null || _b2 === void 0 ? void 0 : _b2.openSideBySideDirection() : void 0;
                if (!openSideBySideDirection) {
                  return void 0;
                }
                return [
                  {
                    iconClass: openSideBySideDirection === "right" ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,
                    tooltip: openSideBySideDirection === "right" ? localize("openToSide", "Open to the Side") : localize("openToBottom", "Open to the Bottom")
                  }
                ];
              })()
            });
          }
          const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));
          let symbolPicks = [];
          if (filterBySymbolKind) {
            let updateLastSeparatorLabel = function() {
              if (lastSeparator && typeof lastSymbolKind === "number" && lastSymbolKindCounter > 0) {
                lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
              }
            };
            let lastSymbolKind = void 0;
            let lastSeparator = void 0;
            let lastSymbolKindCounter = 0;
            for (const symbolPick of sortedFilteredSymbolPicks) {
              if (lastSymbolKind !== symbolPick.kind) {
                updateLastSeparatorLabel();
                lastSymbolKind = symbolPick.kind;
                lastSymbolKindCounter = 1;
                lastSeparator = { type: "separator" };
                symbolPicks.push(lastSeparator);
              } else {
                lastSymbolKindCounter++;
              }
              symbolPicks.push(symbolPick);
            }
            updateLastSeparatorLabel();
          } else if (sortedFilteredSymbolPicks.length > 0) {
            symbolPicks = [
              { label: localize("symbols", "symbols ({0})", filteredSymbolPicks.length), type: "separator" },
              ...sortedFilteredSymbolPicks
            ];
          }
          return symbolPicks;
        });
      }
      compareByScore(symbolA, symbolB) {
        if (typeof symbolA.score !== "number" && typeof symbolB.score === "number") {
          return 1;
        } else if (typeof symbolA.score === "number" && typeof symbolB.score !== "number") {
          return -1;
        }
        if (typeof symbolA.score === "number" && typeof symbolB.score === "number") {
          if (symbolA.score > symbolB.score) {
            return -1;
          } else if (symbolA.score < symbolB.score) {
            return 1;
          }
        }
        if (symbolA.index < symbolB.index) {
          return -1;
        } else if (symbolA.index > symbolB.index) {
          return 1;
        }
        return 0;
      }
      compareByKindAndScore(symbolA, symbolB) {
        const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
        const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
        const result = kindA.localeCompare(kindB);
        if (result === 0) {
          return this.compareByScore(symbolA, symbolB);
        }
        return result;
      }
      getDocumentSymbols(document2, token) {
        return __awaiter42(this, void 0, void 0, function* () {
          const model = yield OutlineModel.create(document2, token);
          return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();
        });
      }
    };
    AbstractGotoSymbolQuickAccessProvider.PREFIX = "@";
    AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ":";
    AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;
    FALLBACK_NLS_SYMBOL_KIND = localize("property", "properties ({0})");
    NLS_SYMBOL_KIND_CACHE = {
      [
        5
        /* Method */
      ]: localize("method", "methods ({0})"),
      [
        11
        /* Function */
      ]: localize("function", "functions ({0})"),
      [
        8
        /* Constructor */
      ]: localize("_constructor", "constructors ({0})"),
      [
        12
        /* Variable */
      ]: localize("variable", "variables ({0})"),
      [
        4
        /* Class */
      ]: localize("class", "classes ({0})"),
      [
        22
        /* Struct */
      ]: localize("struct", "structs ({0})"),
      [
        23
        /* Event */
      ]: localize("event", "events ({0})"),
      [
        24
        /* Operator */
      ]: localize("operator", "operators ({0})"),
      [
        10
        /* Interface */
      ]: localize("interface", "interfaces ({0})"),
      [
        2
        /* Namespace */
      ]: localize("namespace", "namespaces ({0})"),
      [
        3
        /* Package */
      ]: localize("package", "packages ({0})"),
      [
        25
        /* TypeParameter */
      ]: localize("typeParameter", "type parameters ({0})"),
      [
        1
        /* Module */
      ]: localize("modules", "modules ({0})"),
      [
        6
        /* Property */
      ]: localize("property", "properties ({0})"),
      [
        9
        /* Enum */
      ]: localize("enum", "enumerations ({0})"),
      [
        21
        /* EnumMember */
      ]: localize("enumMember", "enumeration members ({0})"),
      [
        14
        /* String */
      ]: localize("string", "strings ({0})"),
      [
        0
        /* File */
      ]: localize("file", "files ({0})"),
      [
        17
        /* Array */
      ]: localize("array", "arrays ({0})"),
      [
        15
        /* Number */
      ]: localize("number", "numbers ({0})"),
      [
        16
        /* Boolean */
      ]: localize("boolean", "booleans ({0})"),
      [
        18
        /* Object */
      ]: localize("object", "objects ({0})"),
      [
        19
        /* Key */
      ]: localize("key", "keys ({0})"),
      [
        7
        /* Field */
      ]: localize("field", "fields ({0})"),
      [
        13
        /* Constant */
      ]: localize("constant", "constants ({0})")
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js
var __decorate57, __param57, StandaloneGotoSymbolQuickAccessProvider, GotoLineAction2;
var init_standaloneGotoSymbolQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js"() {
    init_codiconStyles();
    init_symbolIcons();
    init_gotoSymbolQuickAccess();
    init_platform2();
    init_quickAccess();
    init_codeEditorService();
    init_types();
    init_standaloneStrings();
    init_event();
    init_editorExtensions();
    init_editorContextKeys();
    init_quickInput();
    __decorate57 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param57 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    StandaloneGotoSymbolQuickAccessProvider = class StandaloneGotoSymbolQuickAccessProvider2 extends AbstractGotoSymbolQuickAccessProvider {
      constructor(editorService) {
        super();
        this.editorService = editorService;
        this.onDidActiveTextEditorControlChange = Event.None;
      }
      get activeTextEditorControl() {
        return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
      }
    };
    StandaloneGotoSymbolQuickAccessProvider = __decorate57([
      __param57(0, ICodeEditorService)
    ], StandaloneGotoSymbolQuickAccessProvider);
    Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
      ctor: StandaloneGotoSymbolQuickAccessProvider,
      prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
      helpEntries: [
        { description: QuickOutlineNLS.quickOutlineActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX, needsEditor: true },
        { description: QuickOutlineNLS.quickOutlineByCategoryActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY, needsEditor: true }
      ]
    });
    GotoLineAction2 = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.quickOutline",
          label: QuickOutlineNLS.quickOutlineActionLabel,
          alias: "Go to Symbol...",
          precondition: EditorContextKeys.hasDocumentSymbolProvider,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 2048 | 1024 | 45,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "navigation",
            order: 3
          }
        });
      }
      run(accessor) {
        accessor.get(IQuickInputService).quickAccess.show(AbstractGotoSymbolQuickAccessProvider.PREFIX);
      }
    };
    registerEditorAction(GotoLineAction2);
  }
});

// node_modules/monaco-editor/esm/vs/base/common/errorMessage.js
function exceptionToErrorMessage(exception, verbose) {
  if (verbose && (exception.stack || exception.stacktrace)) {
    return localize("stackTrace.format", "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
  }
  return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
  if (Array.isArray(stack)) {
    return stack.join("\n");
  }
  return stack;
}
function detectSystemErrorMessage(exception) {
  if (typeof exception.code === "string" && typeof exception.errno === "number" && typeof exception.syscall === "string") {
    return localize("nodeExceptionMessage", "A system error occurred ({0})", exception.message);
  }
  return exception.message || localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function toErrorMessage(error = null, verbose = false) {
  if (!error) {
    return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  }
  if (Array.isArray(error)) {
    const errors = coalesce(error);
    const msg = toErrorMessage(errors[0], verbose);
    if (errors.length > 1) {
      return localize("error.moreErrors", "{0} ({1} errors in total)", msg, errors.length);
    }
    return msg;
  }
  if (isString(error)) {
    return error;
  }
  if (error.detail) {
    const detail = error.detail;
    if (detail.error) {
      return exceptionToErrorMessage(detail.error, verbose);
    }
    if (detail.exception) {
      return exceptionToErrorMessage(detail.exception, verbose);
    }
  }
  if (error.stack) {
    return exceptionToErrorMessage(error, verbose);
  }
  if (error.message) {
    return error.message;
  }
  return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
var init_errorMessage = __esm({
  "node_modules/monaco-editor/esm/vs/base/common/errorMessage.js"() {
    init_arrays();
    init_types();
    init_nls();
  }
});

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js
function isPicksWithActive(obj) {
  const candidate = obj;
  return Array.isArray(candidate.items);
}
function isFastAndSlowPicks(obj) {
  const candidate = obj;
  return !!candidate.picks && candidate.additionalPicks instanceof Promise;
}
var __awaiter43, TriggerAction, PickerQuickAccessProvider;
var init_pickerQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js"() {
    init_async();
    init_cancellation();
    init_lifecycle();
    __awaiter43 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    (function(TriggerAction2) {
      TriggerAction2[TriggerAction2["NO_ACTION"] = 0] = "NO_ACTION";
      TriggerAction2[TriggerAction2["CLOSE_PICKER"] = 1] = "CLOSE_PICKER";
      TriggerAction2[TriggerAction2["REFRESH_PICKER"] = 2] = "REFRESH_PICKER";
      TriggerAction2[TriggerAction2["REMOVE_ITEM"] = 3] = "REMOVE_ITEM";
    })(TriggerAction || (TriggerAction = {}));
    PickerQuickAccessProvider = class _PickerQuickAccessProvider extends Disposable {
      constructor(prefix, options) {
        super();
        this.prefix = prefix;
        this.options = options;
      }
      provide(picker, token) {
        var _a5;
        const disposables = new DisposableStore();
        picker.canAcceptInBackground = !!((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.canAcceptInBackground);
        picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
        let picksCts = void 0;
        const picksDisposable = disposables.add(new MutableDisposable());
        const updatePickerItems = () => __awaiter43(this, void 0, void 0, function* () {
          const picksDisposables = picksDisposable.value = new DisposableStore();
          picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
          picker.busy = false;
          picksCts = new CancellationTokenSource(token);
          const picksToken = picksCts.token;
          const picksFilter = picker.value.substr(this.prefix.length).trim();
          const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken);
          const applyPicks = (picks, skipEmpty) => {
            var _a6;
            let items;
            let activeItem = void 0;
            if (isPicksWithActive(picks)) {
              items = picks.items;
              activeItem = picks.active;
            } else {
              items = picks;
            }
            if (items.length === 0) {
              if (skipEmpty) {
                return false;
              }
              if (picksFilter.length > 0 && ((_a6 = this.options) === null || _a6 === void 0 ? void 0 : _a6.noResultsPick)) {
                items = [this.options.noResultsPick];
              }
            }
            picker.items = items;
            if (activeItem) {
              picker.activeItems = [activeItem];
            }
            return true;
          };
          if (providedPicks === null) {
          } else if (isFastAndSlowPicks(providedPicks)) {
            let fastPicksApplied = false;
            let slowPicksApplied = false;
            yield Promise.all([
              // Fast Picks: to reduce amount of flicker, we race against
              // the slow picks over 500ms and then set the fast picks.
              // If the slow picks are faster, we reduce the flicker by
              // only setting the items once.
              (() => __awaiter43(this, void 0, void 0, function* () {
                yield timeout(_PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY);
                if (picksToken.isCancellationRequested) {
                  return;
                }
                if (!slowPicksApplied) {
                  fastPicksApplied = applyPicks(
                    providedPicks.picks,
                    true
                    /* skip over empty to reduce flicker */
                  );
                }
              }))(),
              // Slow Picks: we await the slow picks and then set them at
              // once together with the fast picks, but only if we actually
              // have additional results.
              (() => __awaiter43(this, void 0, void 0, function* () {
                picker.busy = true;
                try {
                  const awaitedAdditionalPicks = yield providedPicks.additionalPicks;
                  if (picksToken.isCancellationRequested) {
                    return;
                  }
                  let picks;
                  let activePick = void 0;
                  if (isPicksWithActive(providedPicks.picks)) {
                    picks = providedPicks.picks.items;
                    activePick = providedPicks.picks.active;
                  } else {
                    picks = providedPicks.picks;
                  }
                  let additionalPicks;
                  let additionalActivePick = void 0;
                  if (isPicksWithActive(awaitedAdditionalPicks)) {
                    additionalPicks = awaitedAdditionalPicks.items;
                    additionalActivePick = awaitedAdditionalPicks.active;
                  } else {
                    additionalPicks = awaitedAdditionalPicks;
                  }
                  if (additionalPicks.length > 0 || !fastPicksApplied) {
                    let fallbackActivePick = void 0;
                    if (!activePick && !additionalActivePick) {
                      const fallbackActivePickCandidate = picker.activeItems[0];
                      if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {
                        fallbackActivePick = fallbackActivePickCandidate;
                      }
                    }
                    applyPicks({
                      items: [...picks, ...additionalPicks],
                      active: activePick || additionalActivePick || fallbackActivePick
                    });
                  }
                } finally {
                  if (!picksToken.isCancellationRequested) {
                    picker.busy = false;
                  }
                  slowPicksApplied = true;
                }
              }))()
            ]);
          } else if (!(providedPicks instanceof Promise)) {
            applyPicks(providedPicks);
          } else {
            picker.busy = true;
            try {
              const awaitedPicks = yield providedPicks;
              if (picksToken.isCancellationRequested) {
                return;
              }
              applyPicks(awaitedPicks);
            } finally {
              if (!picksToken.isCancellationRequested) {
                picker.busy = false;
              }
            }
          }
        });
        disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
        updatePickerItems();
        disposables.add(picker.onDidAccept((event) => {
          const [item] = picker.selectedItems;
          if (typeof (item === null || item === void 0 ? void 0 : item.accept) === "function") {
            if (!event.inBackground) {
              picker.hide();
            }
            item.accept(picker.keyMods, event);
          }
        }));
        disposables.add(picker.onDidTriggerItemButton(({ button, item }) => __awaiter43(this, void 0, void 0, function* () {
          var _b2, _c2;
          if (typeof item.trigger === "function") {
            const buttonIndex = (_c2 = (_b2 = item.buttons) === null || _b2 === void 0 ? void 0 : _b2.indexOf(button)) !== null && _c2 !== void 0 ? _c2 : -1;
            if (buttonIndex >= 0) {
              const result = item.trigger(buttonIndex, picker.keyMods);
              const action = typeof result === "number" ? result : yield result;
              if (token.isCancellationRequested) {
                return;
              }
              switch (action) {
                case TriggerAction.NO_ACTION:
                  break;
                case TriggerAction.CLOSE_PICKER:
                  picker.hide();
                  break;
                case TriggerAction.REFRESH_PICKER:
                  updatePickerItems();
                  break;
                case TriggerAction.REMOVE_ITEM:
                  const index = picker.items.indexOf(item);
                  if (index !== -1) {
                    const items = picker.items.slice();
                    const removed = items.splice(index, 1);
                    const activeItems = picker.activeItems.filter((activeItem) => activeItem !== removed[0]);
                    const keepScrollPositionBefore = picker.keepScrollPosition;
                    picker.keepScrollPosition = true;
                    picker.items = items;
                    if (activeItems) {
                      picker.activeItems = activeItems;
                    }
                    picker.keepScrollPosition = keepScrollPositionBefore;
                  }
                  break;
              }
            }
          }
        })));
        return disposables;
      }
    };
    PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY = 200;
  }
});

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
var __decorate58, __param58, __awaiter44, AbstractCommandsQuickAccessProvider, CommandsHistory;
var init_commandsQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js"() {
    init_errorMessage();
    init_errors();
    init_filters();
    init_lifecycle();
    init_map();
    init_severity();
    init_types();
    init_nls();
    init_commands();
    init_configuration();
    init_dialogs();
    init_instantiation();
    init_keybinding();
    init_pickerQuickAccess();
    init_storage();
    init_telemetry();
    __decorate58 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param58 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter44 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider2 extends PickerQuickAccessProvider {
      constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
        super(AbstractCommandsQuickAccessProvider2.PREFIX, options);
        this.instantiationService = instantiationService;
        this.keybindingService = keybindingService;
        this.commandService = commandService;
        this.telemetryService = telemetryService;
        this.dialogService = dialogService;
        this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));
        this.options = options;
      }
      _getPicks(filter, disposables, token) {
        return __awaiter44(this, void 0, void 0, function* () {
          const allCommandPicks = yield this.getCommandPicks(disposables, token);
          if (token.isCancellationRequested) {
            return [];
          }
          const filteredCommandPicks = [];
          for (const commandPick of allCommandPicks) {
            const labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider2.WORD_FILTER(filter, commandPick.label));
            const aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider2.WORD_FILTER(filter, commandPick.commandAlias)) : void 0;
            if (labelHighlights || aliasHighlights) {
              commandPick.highlights = {
                label: labelHighlights,
                detail: this.options.showAlias ? aliasHighlights : void 0
              };
              filteredCommandPicks.push(commandPick);
            } else if (filter === commandPick.commandId) {
              filteredCommandPicks.push(commandPick);
            }
          }
          const mapLabelToCommand = /* @__PURE__ */ new Map();
          for (const commandPick of filteredCommandPicks) {
            const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
            if (existingCommandForLabel) {
              commandPick.description = commandPick.commandId;
              existingCommandForLabel.description = existingCommandForLabel.commandId;
            } else {
              mapLabelToCommand.set(commandPick.label, commandPick);
            }
          }
          filteredCommandPicks.sort((commandPickA, commandPickB) => {
            const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
            const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
            if (commandACounter && commandBCounter) {
              return commandACounter > commandBCounter ? -1 : 1;
            }
            if (commandACounter) {
              return -1;
            }
            if (commandBCounter) {
              return 1;
            }
            return commandPickA.label.localeCompare(commandPickB.label);
          });
          const commandPicks = [];
          let addSeparator = false;
          for (let i = 0; i < filteredCommandPicks.length; i++) {
            const commandPick = filteredCommandPicks[i];
            const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
            const ariaLabel = keybinding ? localize("commandPickAriaLabelWithKeybinding", "{0}, {1}", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;
            if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {
              commandPicks.push({ type: "separator", label: localize("recentlyUsed", "recently used") });
              addSeparator = true;
            }
            if (i !== 0 && addSeparator && !this.commandsHistory.peek(commandPick.commandId)) {
              commandPicks.push({ type: "separator", label: localize("morecCommands", "other commands") });
              addSeparator = false;
            }
            commandPicks.push(Object.assign(Object.assign({}, commandPick), { ariaLabel, detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : void 0, keybinding, accept: () => __awaiter44(this, void 0, void 0, function* () {
              this.commandsHistory.push(commandPick.commandId);
              this.telemetryService.publicLog2("workbenchActionExecuted", {
                id: commandPick.commandId,
                from: "quick open"
              });
              try {
                yield this.commandService.executeCommand(commandPick.commandId);
              } catch (error) {
                if (!isPromiseCanceledError(error)) {
                  this.dialogService.show(severity_default.Error, localize("canNotRun", "Command '{0}' resulted in an error ({1})", commandPick.label, toErrorMessage(error)));
                }
              }
            }) }));
          }
          return commandPicks;
        });
      }
    };
    AbstractCommandsQuickAccessProvider.PREFIX = ">";
    AbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);
    AbstractCommandsQuickAccessProvider = __decorate58([
      __param58(1, IInstantiationService),
      __param58(2, IKeybindingService),
      __param58(3, ICommandService),
      __param58(4, ITelemetryService),
      __param58(5, IDialogService)
    ], AbstractCommandsQuickAccessProvider);
    CommandsHistory = class CommandsHistory2 extends Disposable {
      constructor(storageService, configurationService) {
        super();
        this.storageService = storageService;
        this.configurationService = configurationService;
        this.configuredCommandsHistoryLength = 0;
        this.updateConfiguration();
        this.load();
        this.registerListeners();
      }
      registerListeners() {
        this._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));
      }
      updateConfiguration() {
        this.configuredCommandsHistoryLength = CommandsHistory2.getConfiguredCommandHistoryLength(this.configurationService);
        if (CommandsHistory2.cache && CommandsHistory2.cache.limit !== this.configuredCommandsHistoryLength) {
          CommandsHistory2.cache.limit = this.configuredCommandsHistoryLength;
          CommandsHistory2.saveState(this.storageService);
        }
      }
      load() {
        const raw = this.storageService.get(
          CommandsHistory2.PREF_KEY_CACHE,
          0
          /* GLOBAL */
        );
        let serializedCache;
        if (raw) {
          try {
            serializedCache = JSON.parse(raw);
          } catch (error) {
          }
        }
        const cache = CommandsHistory2.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);
        if (serializedCache) {
          let entries;
          if (serializedCache.usesLRU) {
            entries = serializedCache.entries;
          } else {
            entries = serializedCache.entries.sort((a, b) => a.value - b.value);
          }
          entries.forEach((entry) => cache.set(entry.key, entry.value));
        }
        CommandsHistory2.counter = this.storageService.getNumber(CommandsHistory2.PREF_KEY_COUNTER, 0, CommandsHistory2.counter);
      }
      push(commandId) {
        if (!CommandsHistory2.cache) {
          return;
        }
        CommandsHistory2.cache.set(commandId, CommandsHistory2.counter++);
        CommandsHistory2.saveState(this.storageService);
      }
      peek(commandId) {
        var _a5;
        return (_a5 = CommandsHistory2.cache) === null || _a5 === void 0 ? void 0 : _a5.peek(commandId);
      }
      static saveState(storageService) {
        if (!CommandsHistory2.cache) {
          return;
        }
        const serializedCache = { usesLRU: true, entries: [] };
        CommandsHistory2.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));
        storageService.store(
          CommandsHistory2.PREF_KEY_CACHE,
          JSON.stringify(serializedCache),
          0,
          0
          /* USER */
        );
        storageService.store(
          CommandsHistory2.PREF_KEY_COUNTER,
          CommandsHistory2.counter,
          0,
          0
          /* USER */
        );
      }
      static getConfiguredCommandHistoryLength(configurationService) {
        var _a5, _b2;
        const config = configurationService.getValue();
        const configuredCommandHistoryLength = (_b2 = (_a5 = config.workbench) === null || _a5 === void 0 ? void 0 : _a5.commandPalette) === null || _b2 === void 0 ? void 0 : _b2.history;
        if (typeof configuredCommandHistoryLength === "number") {
          return configuredCommandHistoryLength;
        }
        return CommandsHistory2.DEFAULT_COMMANDS_HISTORY_LENGTH;
      }
    };
    CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
    CommandsHistory.PREF_KEY_CACHE = "commandPalette.mru.cache";
    CommandsHistory.PREF_KEY_COUNTER = "commandPalette.mru.counter";
    CommandsHistory.counter = 1;
    CommandsHistory = __decorate58([
      __param58(0, IStorageService),
      __param58(1, IConfigurationService)
    ], CommandsHistory);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/commandsQuickAccess.js
var AbstractEditorCommandsQuickAccessProvider;
var init_commandsQuickAccess2 = __esm({
  "node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/commandsQuickAccess.js"() {
    init_iconLabels();
    init_commandsQuickAccess();
    AbstractEditorCommandsQuickAccessProvider = class extends AbstractCommandsQuickAccessProvider {
      constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
        super(options, instantiationService, keybindingService, commandService, telemetryService, dialogService);
      }
      getCodeEditorCommandPicks() {
        const activeTextEditorControl = this.activeTextEditorControl;
        if (!activeTextEditorControl) {
          return [];
        }
        const editorCommandPicks = [];
        for (const editorAction of activeTextEditorControl.getSupportedActions()) {
          editorCommandPicks.push({
            commandId: editorAction.id,
            commandAlias: editorAction.alias,
            label: stripIcons(editorAction.label) || editorAction.id
          });
        }
        return editorCommandPicks;
      }
    };
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js
var __decorate59, __param59, __awaiter45, StandaloneCommandsQuickAccessProvider, GotoLineAction3;
var init_standaloneCommandsQuickAccess = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js"() {
    init_platform2();
    init_quickAccess();
    init_standaloneStrings();
    init_codeEditorService();
    init_commandsQuickAccess2();
    init_types();
    init_instantiation();
    init_keybinding();
    init_commands();
    init_telemetry();
    init_dialogs();
    init_editorExtensions();
    init_editorContextKeys();
    init_quickInput();
    __decorate59 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param59 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter45 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    StandaloneCommandsQuickAccessProvider = class StandaloneCommandsQuickAccessProvider2 extends AbstractEditorCommandsQuickAccessProvider {
      constructor(instantiationService, codeEditorService, keybindingService, commandService, telemetryService, dialogService) {
        super({ showAlias: false }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
        this.codeEditorService = codeEditorService;
      }
      get activeTextEditorControl() {
        return withNullAsUndefined(this.codeEditorService.getFocusedCodeEditor());
      }
      getCommandPicks() {
        return __awaiter45(this, void 0, void 0, function* () {
          return this.getCodeEditorCommandPicks();
        });
      }
    };
    StandaloneCommandsQuickAccessProvider = __decorate59([
      __param59(0, IInstantiationService),
      __param59(1, ICodeEditorService),
      __param59(2, IKeybindingService),
      __param59(3, ICommandService),
      __param59(4, ITelemetryService),
      __param59(5, IDialogService)
    ], StandaloneCommandsQuickAccessProvider);
    Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
      ctor: StandaloneCommandsQuickAccessProvider,
      prefix: StandaloneCommandsQuickAccessProvider.PREFIX,
      helpEntries: [{ description: QuickCommandNLS.quickCommandHelp, needsEditor: true }]
    });
    GotoLineAction3 = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.quickCommand",
          label: QuickCommandNLS.quickCommandActionLabel,
          alias: "Command Palette",
          precondition: void 0,
          kbOpts: {
            kbExpr: EditorContextKeys.focus,
            primary: 59,
            weight: 100
            /* EditorContrib */
          },
          contextMenuOpts: {
            group: "z_commands",
            order: 1
          }
        });
      }
      run(accessor) {
        accessor.get(IQuickInputService).quickAccess.show(StandaloneCommandsQuickAccessProvider.PREFIX);
      }
    };
    registerEditorAction(GotoLineAction3);
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js
var __decorate60, __param60, StandaloneReferencesController;
var init_standaloneReferenceSearch = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js"() {
    init_editorExtensions();
    init_codeEditorService();
    init_referencesController();
    init_configuration();
    init_contextkey();
    init_instantiation();
    init_notification();
    init_storage();
    __decorate60 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
      else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param60 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    StandaloneReferencesController = class StandaloneReferencesController2 extends ReferencesController {
      constructor(editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
        super(true, editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
      }
    };
    StandaloneReferencesController = __decorate60([
      __param60(1, IContextKeyService),
      __param60(2, ICodeEditorService),
      __param60(3, INotificationService),
      __param60(4, IInstantiationService),
      __param60(5, IStorageService),
      __param60(6, IConfigurationService)
    ], StandaloneReferencesController);
    registerEditorContribution(ReferencesController.ID, StandaloneReferencesController);
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js
var ToggleHighContrast;
var init_toggleHighContrast = __esm({
  "node_modules/monaco-editor/esm/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js"() {
    init_editorExtensions();
    init_standaloneThemeService();
    init_standaloneStrings();
    ToggleHighContrast = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.toggleHighContrast",
          label: ToggleHighContrastNLS.toggleHighContrast,
          alias: "Toggle High Contrast Theme",
          precondition: void 0
        });
        this._originalThemeName = null;
      }
      run(accessor, editor2) {
        const standaloneThemeService = accessor.get(IStandaloneThemeService);
        if (this._originalThemeName) {
          standaloneThemeService.setTheme(this._originalThemeName);
          this._originalThemeName = null;
        } else {
          this._originalThemeName = standaloneThemeService.getColorTheme().themeName;
          standaloneThemeService.setTheme("hc-black");
        }
      }
    };
    registerEditorAction(ToggleHighContrast);
  }
});

// node_modules/monaco-editor/esm/vs/editor/edcore.main.js
var import_accessibilityHelp, import_inspectTokens;
var init_edcore_main = __esm({
  "node_modules/monaco-editor/esm/vs/editor/edcore.main.js"() {
    init_editor_all();
    import_accessibilityHelp = __toESM(require_accessibilityHelp());
    init_iPadShowKeyboard();
    import_inspectTokens = __toESM(require_inspectTokens());
    init_standaloneHelpQuickAccess();
    init_standaloneGotoLineQuickAccess();
    init_standaloneGotoSymbolQuickAccess();
    init_standaloneCommandsQuickAccess();
    init_standaloneReferenceSearch();
    init_toggleHighContrast();
    init_editor_api();
  }
});

// node_modules/monaco-editor/esm/vs/editor/editor.main.js
var editor_main_exports = {};
__export(editor_main_exports, {
  CancellationTokenSource: () => CancellationTokenSource2,
  Emitter: () => Emitter2,
  KeyCode: () => KeyCode,
  KeyMod: () => KeyMod,
  MarkerSeverity: () => MarkerSeverity2,
  MarkerTag: () => MarkerTag,
  Position: () => Position2,
  Range: () => Range2,
  Selection: () => Selection2,
  SelectionDirection: () => SelectionDirection,
  Token: () => Token,
  Uri: () => Uri,
  editor: () => editor,
  languages: () => languages
});
var init_editor_main = __esm({
  "node_modules/monaco-editor/esm/vs/editor/editor.main.js"() {
    init_monaco_contribution();
    init_monaco_contribution2();
    init_monaco_contribution3();
    init_monaco_contribution4();
    init_monaco_contribution5();
    init_edcore_main();
  }
});

// node_modules/monaco-languages/release/esm/_.contribution.js
function registerLanguage2(def) {
  var languageId = def.id;
  languageDefinitions2[languageId] = def;
  languages2.register(def);
  var lazyLanguageLoader = LazyLanguageLoader2.getOrCreate(languageId);
  languages2.setMonarchTokensProvider(languageId, lazyLanguageLoader.whenLoaded().then(function(mod) {
    return mod.language;
  }));
  languages2.onLanguage(languageId, function() {
    lazyLanguageLoader.load().then(function(mod) {
      languages2.setLanguageConfiguration(languageId, mod.conf);
    });
  });
}
var languageDefinitions2, lazyLanguageLoaders2, LazyLanguageLoader2;
var init_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/_.contribution.js"() {
    init_monaco_editor_core5();
    languageDefinitions2 = {};
    lazyLanguageLoaders2 = {};
    LazyLanguageLoader2 = /** @class */
    (function() {
      function LazyLanguageLoader3(languageId) {
        var _this = this;
        this._languageId = languageId;
        this._loadingTriggered = false;
        this._lazyLoadPromise = new Promise(function(resolve, reject) {
          _this._lazyLoadPromiseResolve = resolve;
          _this._lazyLoadPromiseReject = reject;
        });
      }
      LazyLanguageLoader3.getOrCreate = function(languageId) {
        if (!lazyLanguageLoaders2[languageId]) {
          lazyLanguageLoaders2[languageId] = new LazyLanguageLoader3(languageId);
        }
        return lazyLanguageLoaders2[languageId];
      };
      LazyLanguageLoader3.prototype.whenLoaded = function() {
        return this._lazyLoadPromise;
      };
      LazyLanguageLoader3.prototype.load = function() {
        var _this = this;
        if (!this._loadingTriggered) {
          this._loadingTriggered = true;
          languageDefinitions2[this._languageId].loader().then(function(mod) {
            return _this._lazyLoadPromiseResolve(mod);
          }, function(err) {
            return _this._lazyLoadPromiseReject(err);
          });
        }
        return this._lazyLoadPromise;
      };
      return LazyLanguageLoader3;
    })();
  }
});

// node_modules/monaco-languages/release/esm/abap/abap.contribution.js
var init_abap_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/abap/abap.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "abap",
      extensions: [".abap"],
      aliases: ["abap", "ABAP"],
      loader: function() {
        return import("./abap-JI4WF6JV.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/apex/apex.contribution.js
var init_apex_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/apex/apex.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "apex",
      extensions: [".cls"],
      aliases: ["Apex", "apex"],
      mimetypes: ["text/x-apex-source", "text/x-apex"],
      loader: function() {
        return import("./apex-IBJUMPJT.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/azcli/azcli.contribution.js
var init_azcli_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/azcli/azcli.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "azcli",
      extensions: [".azcli"],
      aliases: ["Azure CLI", "azcli"],
      loader: function() {
        return import("./azcli-AZNHLYRN.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/bat/bat.contribution.js
var init_bat_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/bat/bat.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "bat",
      extensions: [".bat", ".cmd"],
      aliases: ["Batch", "bat"],
      loader: function() {
        return import("./bat-ROI7HVIG.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/bicep/bicep.contribution.js
var init_bicep_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/bicep/bicep.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "bicep",
      extensions: [".bicep"],
      aliases: ["Bicep"],
      loader: function() {
        return import("./bicep-SJYG7MTY.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/cameligo/cameligo.contribution.js
var init_cameligo_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/cameligo/cameligo.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "cameligo",
      extensions: [".mligo"],
      aliases: ["Cameligo"],
      loader: function() {
        return import("./cameligo-BS4SSXXH.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/clojure/clojure.contribution.js
var init_clojure_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/clojure/clojure.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "clojure",
      extensions: [".clj", ".cljs", ".cljc", ".edn"],
      aliases: ["clojure", "Clojure"],
      loader: function() {
        return import("./clojure-O74IYYZM.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/coffee/coffee.contribution.js
var init_coffee_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/coffee/coffee.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "coffeescript",
      extensions: [".coffee"],
      aliases: ["CoffeeScript", "coffeescript", "coffee"],
      mimetypes: ["text/x-coffeescript", "text/coffeescript"],
      loader: function() {
        return import("./coffee-MAFOQACP.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/cpp/cpp.contribution.js
var init_cpp_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/cpp/cpp.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "c",
      extensions: [".c", ".h"],
      aliases: ["C", "c"],
      loader: function() {
        return import("./cpp-5524MBM3.js");
      }
    });
    registerLanguage2({
      id: "cpp",
      extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx"],
      aliases: ["C++", "Cpp", "cpp"],
      loader: function() {
        return import("./cpp-5524MBM3.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/csharp/csharp.contribution.js
var init_csharp_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/csharp/csharp.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "csharp",
      extensions: [".cs", ".csx", ".cake"],
      aliases: ["C#", "csharp"],
      loader: function() {
        return import("./csharp-USJK6ZLH.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/csp/csp.contribution.js
var init_csp_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/csp/csp.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "csp",
      extensions: [],
      aliases: ["CSP", "csp"],
      loader: function() {
        return import("./csp-BFMIRZV3.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/css/css.contribution.js
var init_css_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/css/css.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "css",
      extensions: [".css"],
      aliases: ["CSS", "css"],
      mimetypes: ["text/css"],
      loader: function() {
        return import("./css-W4EJ5SUT.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/dart/dart.contribution.js
var init_dart_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/dart/dart.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "dart",
      extensions: [".dart"],
      aliases: ["Dart", "dart"],
      mimetypes: ["text/x-dart-source", "text/x-dart"],
      loader: function() {
        return import("./dart-YNVHL3XJ.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/dockerfile/dockerfile.contribution.js
var init_dockerfile_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/dockerfile/dockerfile.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "dockerfile",
      extensions: [".dockerfile"],
      filenames: ["Dockerfile"],
      aliases: ["Dockerfile"],
      loader: function() {
        return import("./dockerfile-VIEOVB2C.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/ecl/ecl.contribution.js
var init_ecl_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/ecl/ecl.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "ecl",
      extensions: [".ecl"],
      aliases: ["ECL", "Ecl", "ecl"],
      loader: function() {
        return import("./ecl-ENSXPG7I.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/elixir/elixir.contribution.js
var init_elixir_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/elixir/elixir.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "elixir",
      extensions: [".ex", ".exs"],
      aliases: ["Elixir", "elixir", "ex"],
      loader: function() {
        return import("./elixir-5HO72G74.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/flow9/flow9.contribution.js
var init_flow9_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/flow9/flow9.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "flow9",
      extensions: [".flow"],
      aliases: ["Flow9", "Flow", "flow9", "flow"],
      loader: function() {
        return import("./flow9-GVPZBPLT.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/fsharp/fsharp.contribution.js
var init_fsharp_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/fsharp/fsharp.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "fsharp",
      extensions: [".fs", ".fsi", ".ml", ".mli", ".fsx", ".fsscript"],
      aliases: ["F#", "FSharp", "fsharp"],
      loader: function() {
        return import("./fsharp-A2RHHGD2.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/go/go.contribution.js
var init_go_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/go/go.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "go",
      extensions: [".go"],
      aliases: ["Go"],
      loader: function() {
        return import("./go-PUWIVIJB.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/graphql/graphql.contribution.js
var init_graphql_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/graphql/graphql.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "graphql",
      extensions: [".graphql", ".gql"],
      aliases: ["GraphQL", "graphql", "gql"],
      mimetypes: ["application/graphql"],
      loader: function() {
        return import("./graphql-FZVWOMUI.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/handlebars/handlebars.contribution.js
var init_handlebars_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/handlebars/handlebars.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "handlebars",
      extensions: [".handlebars", ".hbs"],
      aliases: ["Handlebars", "handlebars", "hbs"],
      mimetypes: ["text/x-handlebars-template"],
      loader: function() {
        return import("./handlebars-NSAURMOV.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/hcl/hcl.contribution.js
var init_hcl_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/hcl/hcl.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "hcl",
      extensions: [".tf", ".tfvars", ".hcl"],
      aliases: ["Terraform", "tf", "HCL", "hcl"],
      loader: function() {
        return import("./hcl-G5LOCPQY.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/html/html.contribution.js
var init_html_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/html/html.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "html",
      extensions: [".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm"],
      aliases: ["HTML", "htm", "html", "xhtml"],
      mimetypes: ["text/html", "text/x-jshtm", "text/template", "text/ng-template"],
      loader: function() {
        return import("./html-HJ6VHKQL.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/ini/ini.contribution.js
var init_ini_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/ini/ini.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "ini",
      extensions: [".ini", ".properties", ".gitconfig"],
      filenames: ["config", ".gitattributes", ".gitconfig", ".editorconfig"],
      aliases: ["Ini", "ini"],
      loader: function() {
        return import("./ini-JTRL46R4.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/java/java.contribution.js
var init_java_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/java/java.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "java",
      extensions: [".java", ".jav"],
      aliases: ["Java", "java"],
      mimetypes: ["text/x-java-source", "text/x-java"],
      loader: function() {
        return import("./java-CKKGZT2N.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/javascript/javascript.contribution.js
var init_javascript_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/javascript/javascript.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "javascript",
      extensions: [".js", ".es6", ".jsx", ".mjs"],
      firstLine: "^#!.*\\bnode",
      filenames: ["jakefile"],
      aliases: ["JavaScript", "javascript", "js"],
      mimetypes: ["text/javascript"],
      loader: function() {
        return import("./javascript-34O3YFYP.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/julia/julia.contribution.js
var init_julia_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/julia/julia.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "julia",
      extensions: [".jl"],
      aliases: ["julia", "Julia"],
      loader: function() {
        return import("./julia-GH37MKMG.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/kotlin/kotlin.contribution.js
var init_kotlin_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/kotlin/kotlin.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "kotlin",
      extensions: [".kt"],
      aliases: ["Kotlin", "kotlin"],
      mimetypes: ["text/x-kotlin-source", "text/x-kotlin"],
      loader: function() {
        return import("./kotlin-FOGPZWTT.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/less/less.contribution.js
var init_less_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/less/less.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "less",
      extensions: [".less"],
      aliases: ["Less", "less"],
      mimetypes: ["text/x-less", "text/less"],
      loader: function() {
        return import("./less-WYMPEQKA.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/lexon/lexon.contribution.js
var init_lexon_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/lexon/lexon.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "lexon",
      extensions: [".lex"],
      aliases: ["Lexon"],
      loader: function() {
        return import("./lexon-XGHGFMZ5.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/lua/lua.contribution.js
var init_lua_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/lua/lua.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "lua",
      extensions: [".lua"],
      aliases: ["Lua", "lua"],
      loader: function() {
        return import("./lua-KHYJ7SFP.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/liquid/liquid.contribution.js
var init_liquid_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/liquid/liquid.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "liquid",
      extensions: [".liquid", ".html.liquid"],
      aliases: ["Liquid", "liquid"],
      mimetypes: ["application/liquid"],
      loader: function() {
        return import("./liquid-UPUBEFAQ.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/m3/m3.contribution.js
var init_m3_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/m3/m3.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "m3",
      extensions: [".m3", ".i3", ".mg", ".ig"],
      aliases: ["Modula-3", "Modula3", "modula3", "m3"],
      loader: function() {
        return import("./m3-L76NWVQQ.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/markdown/markdown.contribution.js
var init_markdown_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/markdown/markdown.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "markdown",
      extensions: [".md", ".markdown", ".mdown", ".mkdn", ".mkd", ".mdwn", ".mdtxt", ".mdtext"],
      aliases: ["Markdown", "markdown"],
      loader: function() {
        return import("./markdown-YTFEXONM.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/mips/mips.contribution.js
var init_mips_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/mips/mips.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "mips",
      extensions: [".s"],
      aliases: ["MIPS", "MIPS-V"],
      mimetypes: ["text/x-mips", "text/mips", "text/plaintext"],
      loader: function() {
        return import("./mips-27H6Q6PY.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/msdax/msdax.contribution.js
var init_msdax_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/msdax/msdax.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "msdax",
      extensions: [".dax", ".msdax"],
      aliases: ["DAX", "MSDAX"],
      loader: function() {
        return import("./msdax-OHZ3OXHV.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/mysql/mysql.contribution.js
var init_mysql_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/mysql/mysql.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "mysql",
      extensions: [],
      aliases: ["MySQL", "mysql"],
      loader: function() {
        return import("./mysql-2VG4PWOV.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/objective-c/objective-c.contribution.js
var init_objective_c_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/objective-c/objective-c.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "objective-c",
      extensions: [".m"],
      aliases: ["Objective-C"],
      loader: function() {
        return import("./objective-c-SXYHACTW.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/pascal/pascal.contribution.js
var init_pascal_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/pascal/pascal.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "pascal",
      extensions: [".pas", ".p", ".pp"],
      aliases: ["Pascal", "pas"],
      mimetypes: ["text/x-pascal-source", "text/x-pascal"],
      loader: function() {
        return import("./pascal-OXR4DFU7.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/pascaligo/pascaligo.contribution.js
var init_pascaligo_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/pascaligo/pascaligo.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "pascaligo",
      extensions: [".ligo"],
      aliases: ["Pascaligo", "ligo"],
      loader: function() {
        return import("./pascaligo-3SSZPV7I.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/perl/perl.contribution.js
var init_perl_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/perl/perl.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "perl",
      extensions: [".pl"],
      aliases: ["Perl", "pl"],
      loader: function() {
        return import("./perl-NEJNCHJF.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/pgsql/pgsql.contribution.js
var init_pgsql_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/pgsql/pgsql.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "pgsql",
      extensions: [],
      aliases: ["PostgreSQL", "postgres", "pg", "postgre"],
      loader: function() {
        return import("./pgsql-UAW6VL3V.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/php/php.contribution.js
var init_php_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/php/php.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "php",
      extensions: [".php", ".php4", ".php5", ".phtml", ".ctp"],
      aliases: ["PHP", "php"],
      mimetypes: ["application/x-php"],
      loader: function() {
        return import("./php-7EZJNMHO.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/pla/pla.contributions.js
var init_pla_contributions = __esm({
  "node_modules/monaco-languages/release/esm/pla/pla.contributions.js"() {
    init_contribution2();
    registerLanguage2({
      id: "pla",
      extensions: [".pla"],
      loader: function() {
        return import("./pla-J4TWHDTG.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/postiats/postiats.contribution.js
var init_postiats_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/postiats/postiats.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "postiats",
      extensions: [".dats", ".sats", ".hats"],
      aliases: ["ATS", "ATS/Postiats"],
      loader: function() {
        return import("./postiats-6ZPARJNM.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/powerquery/powerquery.contribution.js
var init_powerquery_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/powerquery/powerquery.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "powerquery",
      extensions: [".pq", ".pqm"],
      aliases: ["PQ", "M", "Power Query", "Power Query M"],
      loader: function() {
        return import("./powerquery-OYWLF2EF.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/powershell/powershell.contribution.js
var init_powershell_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/powershell/powershell.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "powershell",
      extensions: [".ps1", ".psm1", ".psd1"],
      aliases: ["PowerShell", "powershell", "ps", "ps1"],
      loader: function() {
        return import("./powershell-IOEZVBBK.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/protobuf/protobuf.contribution.js
var init_protobuf_contribution = __esm({
  "node_modules/monaco-languages/release/esm/protobuf/protobuf.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "proto",
      extensions: [".proto"],
      aliases: ["protobuf", "Protocol Buffers"],
      loader: function() {
        return import("./protobuf-KG3PTETM.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/pug/pug.contribution.js
var init_pug_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/pug/pug.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "pug",
      extensions: [".jade", ".pug"],
      aliases: ["Pug", "Jade", "jade"],
      loader: function() {
        return import("./pug-63W7EHMM.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/python/python.contribution.js
var init_python_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/python/python.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "python",
      extensions: [".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi"],
      aliases: ["Python", "py"],
      firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
      loader: function() {
        return import("./python-ES3ZZGES.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/qsharp/qsharp.contribution.js
var init_qsharp_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/qsharp/qsharp.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "qsharp",
      extensions: [".qs"],
      aliases: ["Q#", "qsharp"],
      loader: function() {
        return import("./qsharp-PFYH6EFI.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/r/r.contribution.js
var init_r_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/r/r.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "r",
      extensions: [".r", ".rhistory", ".rmd", ".rprofile", ".rt"],
      aliases: ["R", "r"],
      loader: function() {
        return import("./r-DHZKADU7.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/razor/razor.contribution.js
var init_razor_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/razor/razor.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "razor",
      extensions: [".cshtml"],
      aliases: ["Razor", "razor"],
      mimetypes: ["text/x-cshtml"],
      loader: function() {
        return import("./razor-4CJSSGEV.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/redis/redis.contribution.js
var init_redis_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/redis/redis.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "redis",
      extensions: [".redis"],
      aliases: ["redis"],
      loader: function() {
        return import("./redis-P7X7JLOF.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/redshift/redshift.contribution.js
var init_redshift_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/redshift/redshift.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "redshift",
      extensions: [],
      aliases: ["Redshift", "redshift"],
      loader: function() {
        return import("./redshift-EAACPSWA.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/restructuredtext/restructuredtext.contribution.js
var init_restructuredtext_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/restructuredtext/restructuredtext.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "restructuredtext",
      extensions: [".rst"],
      aliases: ["reStructuredText", "restructuredtext"],
      loader: function() {
        return import("./restructuredtext-XEOYUTIU.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/ruby/ruby.contribution.js
var init_ruby_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/ruby/ruby.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "ruby",
      extensions: [".rb", ".rbx", ".rjs", ".gemspec", ".pp"],
      filenames: ["rakefile", "Gemfile"],
      aliases: ["Ruby", "rb"],
      loader: function() {
        return import("./ruby-IIUCVSTP.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/rust/rust.contribution.js
var init_rust_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/rust/rust.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "rust",
      extensions: [".rs", ".rlib"],
      aliases: ["Rust", "rust"],
      loader: function() {
        return import("./rust-ONFGZD3T.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/sb/sb.contribution.js
var init_sb_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/sb/sb.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "sb",
      extensions: [".sb"],
      aliases: ["Small Basic", "sb"],
      loader: function() {
        return import("./sb-7VS2DZ2Z.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/scala/scala.contribution.js
var init_scala_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/scala/scala.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "scala",
      extensions: [".scala", ".sc", ".sbt"],
      aliases: ["Scala", "scala", "SBT", "Sbt", "sbt", "Dotty", "dotty"],
      mimetypes: ["text/x-scala-source", "text/x-scala", "text/x-sbt", "text/x-dotty"],
      loader: function() {
        return import("./scala-H6QJP76U.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/scheme/scheme.contribution.js
var init_scheme_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/scheme/scheme.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "scheme",
      extensions: [".scm", ".ss", ".sch", ".rkt"],
      aliases: ["scheme", "Scheme"],
      loader: function() {
        return import("./scheme-RSUPUJY6.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/scss/scss.contribution.js
var init_scss_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/scss/scss.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "scss",
      extensions: [".scss"],
      aliases: ["Sass", "sass", "scss"],
      mimetypes: ["text/x-scss", "text/scss"],
      loader: function() {
        return import("./scss-5COB422F.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/shell/shell.contribution.js
var init_shell_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/shell/shell.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "shell",
      extensions: [".sh", ".bash"],
      aliases: ["Shell", "sh"],
      loader: function() {
        return import("./shell-FZB4EDQU.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/solidity/solidity.contribution.js
var init_solidity_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/solidity/solidity.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "sol",
      extensions: [".sol"],
      aliases: ["sol", "solidity", "Solidity"],
      loader: function() {
        return import("./solidity-OLHE2Q47.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/sophia/sophia.contribution.js
var init_sophia_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/sophia/sophia.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "aes",
      extensions: [".aes"],
      aliases: ["aes", "sophia", "Sophia"],
      loader: function() {
        return import("./sophia-AZH5LQZB.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/sparql/sparql.contribution.js
var init_sparql_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/sparql/sparql.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "sparql",
      extensions: [".rq"],
      aliases: ["sparql", "SPARQL"],
      loader: function() {
        return import("./sparql-5MILWJ2S.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/sql/sql.contribution.js
var init_sql_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/sql/sql.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "sql",
      extensions: [".sql"],
      aliases: ["SQL"],
      loader: function() {
        return import("./sql-LEHJJ54L.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/st/st.contribution.js
var init_st_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/st/st.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "st",
      extensions: [".st", ".iecst", ".iecplc", ".lc3lib"],
      aliases: ["StructuredText", "scl", "stl"],
      loader: function() {
        return import("./st-GMKEIZCJ.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/swift/swift.contribution.js
var init_swift_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/swift/swift.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "swift",
      aliases: ["Swift", "swift"],
      extensions: [".swift"],
      mimetypes: ["text/swift"],
      loader: function() {
        return import("./swift-O4IXOZSD.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/systemverilog/systemverilog.contribution.js
var init_systemverilog_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/systemverilog/systemverilog.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "systemverilog",
      extensions: [".sv", ".svh"],
      aliases: ["SV", "sv", "SystemVerilog", "systemverilog"],
      loader: function() {
        return import("./systemverilog-7BVO4FNT.js");
      }
    });
    registerLanguage2({
      id: "verilog",
      extensions: [".v", ".vh"],
      aliases: ["V", "v", "Verilog", "verilog"],
      loader: function() {
        return import("./systemverilog-7BVO4FNT.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/tcl/tcl.contribution.js
var init_tcl_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/tcl/tcl.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "tcl",
      extensions: [".tcl"],
      aliases: ["tcl", "Tcl", "tcltk", "TclTk", "tcl/tk", "Tcl/Tk"],
      loader: function() {
        return import("./tcl-XYJJIZUZ.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/twig/twig.contribution.js
var init_twig_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/twig/twig.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "twig",
      extensions: [".twig"],
      aliases: ["Twig", "twig"],
      mimetypes: ["text/x-twig"],
      loader: function() {
        return import("./twig-O5ZMVJUJ.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/typescript/typescript.contribution.js
var init_typescript_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/typescript/typescript.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "typescript",
      extensions: [".ts", ".tsx"],
      aliases: ["TypeScript", "ts", "typescript"],
      mimetypes: ["text/typescript"],
      loader: function() {
        return import("./typescript-H3TNAJGC.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/vb/vb.contribution.js
var init_vb_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/vb/vb.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "vb",
      extensions: [".vb"],
      aliases: ["Visual Basic", "vb"],
      loader: function() {
        return import("./vb-MAIEB3Y7.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/xml/xml.contribution.js
var init_xml_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/xml/xml.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "xml",
      extensions: [
        ".xml",
        ".dtd",
        ".ascx",
        ".csproj",
        ".config",
        ".wxi",
        ".wxl",
        ".wxs",
        ".xaml",
        ".svg",
        ".svgz",
        ".opf",
        ".xsl"
      ],
      firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
      aliases: ["XML", "xml"],
      mimetypes: ["text/xml", "application/xml", "application/xaml+xml", "application/xml-dtd"],
      loader: function() {
        return import("./xml-EUM5KCX4.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/yaml/yaml.contribution.js
var init_yaml_contribution2 = __esm({
  "node_modules/monaco-languages/release/esm/yaml/yaml.contribution.js"() {
    init_contribution2();
    registerLanguage2({
      id: "yaml",
      extensions: [".yaml", ".yml"],
      aliases: ["YAML", "yaml", "YML", "yml"],
      mimetypes: ["application/x-yaml", "text/x-yaml"],
      loader: function() {
        return import("./yaml-5D3QDVE6.js");
      }
    });
  }
});

// node_modules/monaco-languages/release/esm/monaco.contribution.js
var init_monaco_contribution6 = __esm({
  "node_modules/monaco-languages/release/esm/monaco.contribution.js"() {
    init_abap_contribution2();
    init_apex_contribution2();
    init_azcli_contribution2();
    init_bat_contribution2();
    init_bicep_contribution2();
    init_cameligo_contribution2();
    init_clojure_contribution2();
    init_coffee_contribution2();
    init_cpp_contribution2();
    init_csharp_contribution2();
    init_csp_contribution2();
    init_css_contribution2();
    init_dart_contribution2();
    init_dockerfile_contribution2();
    init_ecl_contribution2();
    init_elixir_contribution2();
    init_flow9_contribution2();
    init_fsharp_contribution2();
    init_go_contribution2();
    init_graphql_contribution2();
    init_handlebars_contribution2();
    init_hcl_contribution2();
    init_html_contribution2();
    init_ini_contribution2();
    init_java_contribution2();
    init_javascript_contribution2();
    init_julia_contribution2();
    init_kotlin_contribution2();
    init_less_contribution2();
    init_lexon_contribution2();
    init_lua_contribution2();
    init_liquid_contribution2();
    init_m3_contribution2();
    init_markdown_contribution2();
    init_mips_contribution2();
    init_msdax_contribution2();
    init_mysql_contribution2();
    init_objective_c_contribution2();
    init_pascal_contribution2();
    init_pascaligo_contribution2();
    init_perl_contribution2();
    init_pgsql_contribution2();
    init_php_contribution2();
    init_pla_contributions();
    init_postiats_contribution2();
    init_powerquery_contribution2();
    init_powershell_contribution2();
    init_protobuf_contribution();
    init_pug_contribution2();
    init_python_contribution2();
    init_qsharp_contribution2();
    init_r_contribution2();
    init_razor_contribution2();
    init_redis_contribution2();
    init_redshift_contribution2();
    init_restructuredtext_contribution2();
    init_ruby_contribution2();
    init_rust_contribution2();
    init_sb_contribution2();
    init_scala_contribution2();
    init_scheme_contribution2();
    init_scss_contribution2();
    init_shell_contribution2();
    init_solidity_contribution2();
    init_sophia_contribution2();
    init_sparql_contribution2();
    init_sql_contribution2();
    init_st_contribution2();
    init_swift_contribution2();
    init_systemverilog_contribution2();
    init_tcl_contribution2();
    init_twig_contribution2();
    init_typescript_contribution2();
    init_vb_contribution2();
    init_xml_contribution2();
    init_yaml_contribution2();
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable2;
    (function(Disposable3) {
      function create2(func) {
        return {
          dispose: func
        };
      }
      Disposable3.create = create2;
    })(Disposable2 = exports2.Disposable || (exports2.Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event2;
    (function(Event3) {
      const _disposable = { dispose() {
      } };
      Event3.None = function() {
        return _disposable;
      };
    })(Event2 = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            ral_1.default().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter3 = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter3;
    Emitter3._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/browser/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ral_1 = require_ral();
    var disposable_1 = require_disposable();
    var events_1 = require_events();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class _MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
        this.asciiDecoder = new TextDecoder("ascii");
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, _encoding) {
        return new TextEncoder().encode(value);
      }
      toString(value, encoding) {
        if (encoding === "ascii") {
          return this.asciiDecoder.decode(value);
        } else {
          return new TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer;
        } else {
          return buffer.slice(0, length);
        }
      }
      allocNative(length) {
        return new Uint8Array(length);
      }
    };
    MessageBuffer.emptyBuffer = new Uint8Array(0);
    var ReadableStreamWrapper = class {
      constructor(socket) {
        this.socket = socket;
        this._onData = new events_1.Emitter();
        this._messageListener = (event) => {
          const blob = event.data;
          blob.arrayBuffer().then((buffer) => {
            this._onData.fire(new Uint8Array(buffer));
          });
        };
        this.socket.addEventListener("message", this._messageListener);
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      onData(listener) {
        return this._onData.event(listener);
      }
    };
    var WritableStreamWrapper = class {
      constructor(socket) {
        this.socket = socket;
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return disposable_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      write(data, encoding) {
        if (typeof data === "string") {
          if (encoding !== void 0 && encoding !== "utf-8") {
            throw new Error(`In a Browser environments only utf-8 text encding is supported. But got encoding: ${encoding}`);
          }
          this.socket.send(data);
        } else {
          this.socket.send(data);
        }
        return Promise.resolve();
      }
      end() {
        this.socket.close();
      }
    };
    var _textEncoder = new TextEncoder();
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            if (options.charset !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encding is supported. But got encoding: ${options.charset}`);
            }
            return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            if (!(buffer instanceof Uint8Array)) {
              throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
            }
            return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
          clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
          return setTimeout(callback, 0, ...args);
        },
        clearImmediate(handle) {
          clearTimeout(handle);
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isResponseMessage = exports2.isNotificationMessage = exports2.isRequestMessage = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = ErrorCodes2.jsonrpcReservedErrorRangeStart;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = ErrorCodes2.jsonrpcReservedErrorRangeEnd;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports2.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports2.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      const candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports2.isResponseMessage = isResponseMessage;
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var events_1 = require_events();
    var CancellationToken2;
    (function(CancellationToken3) {
      CancellationToken3.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken3.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken3.None || candidate === CancellationToken3.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken3.is = is;
    })(CancellationToken2 = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        ral_1.default().timer.clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource3 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken2.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken2.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource3;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var events_1 = require_events();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        var _a5;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options !== null && options !== void 0 ? options : "utf-8";
        } else {
          charset = (_a5 = options.charset) !== null && _a5 !== void 0 ? _a5 : "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = ral_1.default().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout2) {
        this._partialMessageTimeout = timeout2;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          ral_1.default().timer.clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout2) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout2 });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        var _a5, _b2;
        if (options === void 0 || typeof options === "string") {
          return { charset: options !== null && options !== void 0 ? options : "utf-8", contentTypeEncoder: ral_1.default().applicationJson.encoder };
        } else {
          return { charset: (_a5 = options.charset) !== null && _a5 !== void 0 ? _a5 : "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: (_b2 = options.contentTypeEncoder) !== null && _b2 !== void 0 ? _b2 : ral_1.default().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[Symbol.toStringTag] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a5;
        return (_a5 = this._head) === null || _a5 === void 0 ? void 0 : _a5.value;
      }
      get last() {
        var _a5;
        return (_a5 = this._tail) === null || _a5 === void 0 ? void 0 : _a5.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]() {
            return iterator;
          },
          next() {
            if (map._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache2 = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.NullLogger = exports2.ProgressType = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Verbose"] = 2] = "Verbose";
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ Object.create(null);
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ Object.create(null);
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ Object.create(null);
      let requestTokens = /* @__PURE__ */ Object.create(null);
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            const key = createRequestQueueKey(message.params.id);
            const toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = String(requestMessage.id);
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = String(responseMessage.id);
          const responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            const id = params.id;
            const source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          const element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                if (type !== void 0) {
                  if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                  }
                  if (type.numberOfParams !== message.params.length) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);
                  }
                }
                notificationHandler(...message.params);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = String(responseMessage.id);
          const responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
            break;
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Recevied parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first2 = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first2)) {
              paramStart = 1;
              parameterStructures = first2;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              method = type.method;
              notificationHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                delete notificationHandlers[method];
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first2 = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first2)) {
              paramStart = 1;
              parameterStructures = first2;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              cancellationStrategy.sender.sendCancellation(connection, id);
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers[type] = { handler, type: void 0 };
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers[type.method] = { type, handler };
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                delete requestHandlers[method];
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = /* @__PURE__ */ Object.create(null);
          requestTokens = /* @__PURE__ */ Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          ral_1.default().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.ProgressType = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.RAL = void 0;
    exports2.CancellationStrategy = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/browser/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/browser/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.BrowserMessageWriter = exports2.BrowserMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var BrowserMessageReader = class extends api_1.AbstractMessageReader {
      constructor(context) {
        super();
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
          this._onData.fire(event.data);
        };
        context.addEventListener("error", (event) => this.fireError(event));
        context.onmessage = this._messageListener;
      }
      listen(callback) {
        return this._onData.event(callback);
      }
    };
    exports2.BrowserMessageReader = BrowserMessageReader;
    var BrowserMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(context) {
        super();
        this.context = context;
        this.errorCount = 0;
        context.addEventListener("error", (event) => this.fireError(event));
      }
      write(msg) {
        try {
          this.context.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.BrowserMessageWriter = BrowserMessageWriter;
    function createMessageConnection(reader, writer, logger, options) {
      if (logger === void 0) {
        logger = api_1.NullLogger;
      }
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return api_1.createMessageConnection(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/browser.js
var require_browser = __commonJS({
  "node_modules/vscode-jsonrpc/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(__require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = void 0;
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
      })(integer = exports3.integer || (exports3.integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
      })(uinteger = exports3.uinteger || (exports3.uinteger = {}));
      var Position3;
      (function(Position4) {
        function create2(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position4.create = create2;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position4.is = is;
      })(Position3 = exports3.Position || (exports3.Position = {}));
      var Range3;
      (function(Range4) {
        function create2(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position3.create(one, two), end: Position3.create(three, four) };
          } else if (Position3.is(one) && Position3.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
          }
        }
        Range4.create = create2;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position3.is(candidate.start) && Position3.is(candidate.end);
        }
        Range4.is = is;
      })(Range3 = exports3.Range || (exports3.Range = {}));
      var Location;
      (function(Location2) {
        function create2(uri, range) {
          return { uri, range };
        }
        Location2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location = exports3.Location || (exports3.Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create2(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range3.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range3.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink = exports3.LocationLink || (exports3.LocationLink = {}));
      var Color2;
      (function(Color3) {
        function create2(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color3.create = create2;
        function is(value) {
          var candidate = value;
          return Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color3.is = is;
      })(Color2 = exports3.Color || (exports3.Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create2(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create2;
        function is(value) {
          var candidate = value;
          return Range3.is(candidate.range) && Color2.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation = exports3.ColorInformation || (exports3.ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create2(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation = exports3.ColorPresentation || (exports3.ColorPresentation = {}));
      var FoldingRangeKind2;
      (function(FoldingRangeKind3) {
        FoldingRangeKind3["Comment"] = "comment";
        FoldingRangeKind3["Imports"] = "imports";
        FoldingRangeKind3["Region"] = "region";
      })(FoldingRangeKind2 = exports3.FoldingRangeKind || (exports3.FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create2(startLine, endLine, startCharacter, endCharacter, kind) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          return result;
        }
        FoldingRange2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange = exports3.FoldingRange || (exports3.FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create2(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation = exports3.DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity = exports3.DiagnosticSeverity || (exports3.DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag = exports3.DiagnosticTag || (exports3.DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription = exports3.CodeDescription || (exports3.CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create2(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create2;
        function is(value) {
          var _a5;
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a5 = candidate.codeDescription) === null || _a5 === void 0 ? void 0 : _a5.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic = exports3.Diagnostic || (exports3.Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create2(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command = exports3.Command || (exports3.Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range3.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit = exports3.TextEdit || (exports3.TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create2(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation = exports3.ChangeAnnotation || (exports3.ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return typeof candidate === "string";
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier = exports3.ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit = exports3.AnnotatedTextEdit || (exports3.AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create2(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit = exports3.TextDocumentEdit || (exports3.TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create2(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile = exports3.CreateFile || (exports3.CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create2(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile = exports3.RenameFile || (exports3.RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create2(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile = exports3.DeleteFile || (exports3.DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit = exports3.WorkspaceEdit || (exports3.WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        (function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        })()
      );
      var ChangeAnnotations = (
        /** @class */
        (function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id " + id + " is already in use.");
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id " + id);
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        })()
      );
      var WorkspaceChange = (
        /** @class */
        (function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        })()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create2(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier = exports3.TextDocumentIdentifier || (exports3.TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create2(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create2(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier = exports3.OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create2(uri, languageId, version, text2) {
          return { uri, languageId, version, text: text2 };
        }
        TextDocumentItem2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem = exports3.TextDocumentItem || (exports3.TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
      })(MarkupKind = exports3.MarkupKind || (exports3.MarkupKind = {}));
      (function(MarkupKind2) {
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind = exports3.MarkupKind || (exports3.MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent = exports3.MarkupContent || (exports3.MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind = exports3.CompletionItemKind || (exports3.CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat = exports3.InsertTextFormat || (exports3.InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag = exports3.CompletionItemTag || (exports3.CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create2(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range3.is(candidate.insert) && Range3.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit = exports3.InsertReplaceEdit || (exports3.InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode = exports3.InsertTextMode || (exports3.InsertTextMode = {}));
      var CompletionItem2;
      (function(CompletionItem3) {
        function create2(label) {
          return { label };
        }
        CompletionItem3.create = create2;
      })(CompletionItem2 = exports3.CompletionItem || (exports3.CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create2(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create2;
      })(CompletionList = exports3.CompletionList || (exports3.CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString = exports3.MarkedString || (exports3.MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range3.is(value.range));
        }
        Hover2.is = is;
      })(Hover = exports3.Hover || (exports3.Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create2(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create2;
      })(ParameterInformation = exports3.ParameterInformation || (exports3.ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create2(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create2;
      })(SignatureInformation = exports3.SignatureInformation || (exports3.SignatureInformation = {}));
      var DocumentHighlightKind2;
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3.Text = 1;
        DocumentHighlightKind3.Read = 2;
        DocumentHighlightKind3.Write = 3;
      })(DocumentHighlightKind2 = exports3.DocumentHighlightKind || (exports3.DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create2(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create2;
      })(DocumentHighlight = exports3.DocumentHighlight || (exports3.DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind = exports3.SymbolKind || (exports3.SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag = exports3.SymbolTag || (exports3.SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create2(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create2;
      })(SymbolInformation = exports3.SymbolInformation || (exports3.SymbolInformation = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create2(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range3.is(candidate.range) && Range3.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol = exports3.DocumentSymbol || (exports3.DocumentSymbol = {}));
      var CodeActionKind2;
      (function(CodeActionKind3) {
        CodeActionKind3.Empty = "";
        CodeActionKind3.QuickFix = "quickfix";
        CodeActionKind3.Refactor = "refactor";
        CodeActionKind3.RefactorExtract = "refactor.extract";
        CodeActionKind3.RefactorInline = "refactor.inline";
        CodeActionKind3.RefactorRewrite = "refactor.rewrite";
        CodeActionKind3.Source = "source";
        CodeActionKind3.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind3.SourceFixAll = "source.fixAll";
      })(CodeActionKind2 = exports3.CodeActionKind || (exports3.CodeActionKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create2(diagnostics, only) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          return result;
        }
        CodeActionContext2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
        }
        CodeActionContext2.is = is;
      })(CodeActionContext = exports3.CodeActionContext || (exports3.CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create2(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction = exports3.CodeAction || (exports3.CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create2(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens = exports3.CodeLens || (exports3.CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create2(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions = exports3.FormattingOptions || (exports3.FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create2(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range3.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink = exports3.DocumentLink || (exports3.DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create2(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create2;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && Range3.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange = exports3.SelectionRange || (exports3.SelectionRange = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument2;
      (function(TextDocument3) {
        function create2(uri, languageId, version, content) {
          return new FullTextDocument2(uri, languageId, version, content);
        }
        TextDocument3.create = create2;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument3.is = is;
        function applyEdits2(document2, edits) {
          var text2 = document2.getText();
          var sortedEdits = mergeSort2(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text2.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document2.offsetAt(e.range.start);
            var endOffset = document2.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text2 = text2.substring(0, startOffset) + e.newText + text2.substring(endOffset, text2.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text2;
        }
        TextDocument3.applyEdits = applyEdits2;
        function mergeSort2(data, compare2) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort2(left, compare2);
          mergeSort2(right, compare2);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare2(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument2 = exports3.TextDocument || (exports3.TextDocument = {}));
      var FullTextDocument2 = (
        /** @class */
        (function() {
          function FullTextDocument3(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument3.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument3.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument3.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument3.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument3.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text2 = this._content;
              var isLineStart = true;
              for (var i = 0; i < text2.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text2.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text2.length && text2.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text2.length > 0) {
                lineOffsets.push(text2.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument3.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position3.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position3.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument3.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument3;
        })()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRequest = exports2.FoldingRangeKind = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeKind2;
    (function(FoldingRangeKind3) {
      FoldingRangeKind3["Comment"] = "comment";
      FoldingRangeKind3["Imports"] = "imports";
      FoldingRangeKind3["Region"] = "region";
    })(FoldingRangeKind2 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
    })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
    })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = void 0;
    var messages_1 = require_messages2();
    var SemanticTokenTypes;
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
    })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
    var SemanticTokenModifiers;
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
    var SemanticTokens;
    (function(SemanticTokens2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
    })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2["document"] = "document";
      UniquenessLevel2["project"] = "project";
      UniquenessLevel2["group"] = "group";
      UniquenessLevel2["scheme"] = "scheme";
      UniquenessLevel2["global"] = "global";
    })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2["import"] = "import";
      MonikerKind2["export"] = "export";
      MonikerKind2["local"] = "local";
    })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeError = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.DocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = void 0;
    var Is = require_is2();
    var messages_1 = require_messages2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokenTypes", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenTypes;
    } });
    Object.defineProperty(exports2, "SemanticTokenModifiers", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokenModifiers;
    } });
    Object.defineProperty(exports2, "SemanticTokens", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokens;
    } });
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var DocumentFilter;
    (function(DocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
      }
      DocumentFilter2.is = is;
    })(DocumentFilter = exports2.DocumentFilter || (exports2.DocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !DocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeError;
    (function(InitializeError2) {
      InitializeError2.unknownProtocolVersion = 1;
    })(InitializeError = exports2.InitializeError || (exports2.InitializeError = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind2;
    (function(SignatureHelpTriggerKind3) {
      SignatureHelpTriggerKind3.Invoked = 1;
      SignatureHelpTriggerKind3.TriggerCharacter = 2;
      SignatureHelpTriggerKind3.ContentChange = 3;
    })(SignatureHelpTriggerKind2 = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/browser/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var browser_1 = require_browser();
    __exportStar(require_browser(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(reader, writer, logger, options) {
      return browser_1.createMessageConnection(reader, writer, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  TextDocument: () => TextDocument
});
function mergeSort(data, compare2) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare2);
  mergeSort(right, compare2);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare2(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text2, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text2.length; i++) {
    const ch = text2.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text2.length && text2.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument, TextDocument;
var init_main = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument = class _FullTextDocument {
      constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(changes, version) {
        for (const change of changes) {
          if (_FullTextDocument.isIncremental(change)) {
            const range = getWellformedRange(change.range);
            const startOffset = this.offsetAt(range.start);
            const endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            const startLine = Math.max(range.start.line, 0);
            const endLine = Math.max(range.end.line, 0);
            let lineOffsets = this._lineOffsets;
            const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            const diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (_FullTextDocument.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          const mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
          return lineOffset;
        }
        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
      }
      ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
          offset--;
        }
        return offset;
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
      static isIncremental(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      static isFull(event) {
        const candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
    };
    (function(TextDocument2) {
      function create2(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument2.create = create2;
      function update(document2, changes, version) {
        if (document2 instanceof FullTextDocument) {
          document2.update(changes, version);
          return document2;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument2.update = update;
      function applyEdits2(document2, edits) {
        const text2 = document2.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
          const diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
          const startOffset = document2.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text2.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document2.offsetAt(e.range.end);
        }
        spans.push(text2.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument2.applyEdits = applyEdits2;
    })(TextDocument || (TextDocument = {}));
  }
});

// node_modules/monaco-languageclient/lib/services.js
var require_services = __commonJS({
  "node_modules/monaco-languageclient/lib/services.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !exports3.hasOwnProperty(p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationTarget = exports2.DocumentIdentifier = exports2.VsCodeDiagnosticSeverity = exports2.SignatureHelpTriggerKind = exports2.isDocumentSelector = exports2.Services = exports2.TextDocument = exports2.Emitter = exports2.Event = exports2.CancellationToken = exports2.Disposable = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
    Object.defineProperty(exports2, "TextDocument", { enumerable: true, get: function() {
      return vscode_languageserver_textdocument_1.TextDocument;
    } });
    var vscode_jsonrpc_1 = require_main();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.Disposable;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.CancellationToken;
    } });
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return vscode_jsonrpc_1.Emitter;
    } });
    __exportStar(require_api2(), exports2);
    var Services;
    (function(Services2) {
      const global = window;
      const symbol = Symbol("Services");
      Services2.get = () => {
        const services = global[symbol];
        if (!services) {
          throw new Error("Language Client services has not been installed");
        }
        return services;
      };
      function install(services) {
        if (global[symbol]) {
          console.warn("Language Client services have been overridden");
        }
        global[symbol] = services;
        return vscode_jsonrpc_1.Disposable.create(() => global[symbol] = void 0);
      }
      Services2.install = install;
    })(Services = exports2.Services || (exports2.Services = {}));
    function isDocumentSelector(selector) {
      if (!selector || !Array.isArray(selector)) {
        return false;
      }
      return selector.every((value) => typeof value === "string" || vscode_languageserver_protocol_1.DocumentFilter.is(value));
    }
    exports2.isDocumentSelector = isDocumentSelector;
    var SignatureHelpTriggerKind2;
    (function(SignatureHelpTriggerKind3) {
      SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["Invoke"] = 1] = "Invoke";
      SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["TriggerCharacter"] = 2] = "TriggerCharacter";
      SignatureHelpTriggerKind3[SignatureHelpTriggerKind3["ContentChange"] = 3] = "ContentChange";
    })(SignatureHelpTriggerKind2 = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var VsCodeDiagnosticSeverity;
    (function(VsCodeDiagnosticSeverity2) {
      VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Error"] = 0] = "Error";
      VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Warning"] = 1] = "Warning";
      VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Information"] = 2] = "Information";
      VsCodeDiagnosticSeverity2[VsCodeDiagnosticSeverity2["Hint"] = 3] = "Hint";
    })(VsCodeDiagnosticSeverity = exports2.VsCodeDiagnosticSeverity || (exports2.VsCodeDiagnosticSeverity = {}));
    var DocumentIdentifier;
    (function(DocumentIdentifier2) {
      function is(arg) {
        return !!arg && "uri" in arg && "languageId" in arg;
      }
      DocumentIdentifier2.is = is;
    })(DocumentIdentifier = exports2.DocumentIdentifier || (exports2.DocumentIdentifier = {}));
    var ConfigurationTarget;
    (function(ConfigurationTarget2) {
      ConfigurationTarget2[ConfigurationTarget2["Global"] = 1] = "Global";
      ConfigurationTarget2[ConfigurationTarget2["Workspace"] = 2] = "Workspace";
      ConfigurationTarget2[ConfigurationTarget2["WorkspaceFolder"] = 3] = "WorkspaceFolder";
    })(ConfigurationTarget = exports2.ConfigurationTarget || (exports2.ConfigurationTarget = {}));
  }
});

// node_modules/monaco-languageclient/lib/disposable.js
var require_disposable2 = __commonJS({
  "node_modules/monaco-languageclient/lib/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DisposableCollection = exports2.Disposable = void 0;
    var services_1 = require_services();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return services_1.Disposable;
    } });
    var DisposableCollection = class {
      constructor() {
        this.disposables = [];
      }
      dispose() {
        while (this.disposables.length !== 0) {
          this.disposables.pop().dispose();
        }
      }
      push(disposable) {
        const disposables = this.disposables;
        disposables.push(disposable);
        return {
          dispose() {
            const index = disposables.indexOf(disposable);
            if (index !== -1) {
              disposables.splice(index, 1);
            }
          }
        };
      }
    };
    exports2.DisposableCollection = DisposableCollection;
  }
});

// node_modules/monaco-languageclient/lib/connection.js
var require_connection3 = __commonJS({
  "node_modules/monaco-languageclient/lib/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is2();
    function createConnection2(connection, errorHandler, closeHandler) {
      connection.onError((data) => {
        errorHandler(data[0], data[1], data[2]);
      });
      connection.onClose(closeHandler);
      return {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),
        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),
        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),
        trace: (value, tracer, sendNotification = false) => connection.trace(value, tracer, sendNotification),
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        dispose: () => connection.dispose(),
        end: () => connection.end()
      };
    }
    exports2.createConnection = createConnection2;
  }
});

// node_modules/vscode-uri/lib/umd/index.js
var require_umd = __commonJS({
  "node_modules/vscode-uri/lib/umd/index.js"(exports2, module2) {
    !(function(t, e) {
      if ("object" == typeof exports2 && "object" == typeof module2) module2.exports = e();
      else if ("function" == typeof define && define.amd) define([], e);
      else {
        var r = e();
        for (var n in r) ("object" == typeof exports2 ? exports2 : t)[n] = r[n];
      }
    })(exports2, (() => (() => {
      "use strict";
      var t = { 975: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", i = 0, o = -1, s = 0, a = 0; a <= t3.length; ++a) {
            if (a < t3.length) r3 = t3.charCodeAt(a);
            else {
              if (47 === r3) break;
              r3 = 47;
            }
            if (47 === r3) {
              if (o === a - 1 || 1 === s) ;
              else if (o !== a - 1 && 2 === s) {
                if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var h = n3.lastIndexOf("/");
                    if (h !== n3.length - 1) {
                      -1 === h ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), o = a, s = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", i = 0, o = a, s = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
              } else n3.length > 0 ? n3 += "/" + t3.slice(o + 1, a) : n3 = t3.slice(o + 1, a), i = a - o - 1;
              o = a, s = 0;
            } else 46 === r3 && -1 !== s ? ++s : s = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
            var s;
            o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
          }
          return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length) return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var i = arguments[r3];
            e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3) return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
          for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;
          for (var o = t3.length, s = o - i, a = 1; a < r3.length && 47 === r3.charCodeAt(a); ++a) ;
          for (var h = r3.length - a, c = s < h ? s : h, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (h > c) {
                if (47 === r3.charCodeAt(a + u)) return r3.slice(a + u + 1);
                if (0 === u) return r3.slice(a + u);
              } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(i + u);
            if (l !== r3.charCodeAt(a + u)) break;
            47 === l && (f = u);
          }
          var d = "";
          for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === d.length ? d += ".." : d += "/..");
          return d.length > 0 ? d + r3.slice(a + f) : (a += f, 47 === r3.charCodeAt(a) && ++a, r3.slice(a));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {
            if (!o) {
              i = s;
              break;
            }
          } else o = false;
          return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, i = 0, o = -1, s = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3) return "";
            var a = r3.length - 1, h = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!s) {
                  i = n3 + 1;
                  break;
                }
              } else -1 === h && (s = false, h = n3 + 1), a >= 0 && (c === r3.charCodeAt(a) ? -1 == --a && (o = n3) : (a = -1, o = h));
            }
            return i === o ? o = h : -1 === o && (o = t3.length), t3.slice(i, o);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else -1 === o && (s = false, o = n3 + 1);
          return -1 === o ? "" : t3.slice(i, o);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, a = t3.length - 1; a >= 0; --a) {
            var h = t3.charCodeAt(a);
            if (47 !== h) -1 === i && (o = false, i = a + 1), 46 === h ? -1 === r3 ? r3 = a : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
            else if (!o) {
              n3 = a + 1;
              break;
            }
          }
          return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return (function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          })(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length) return r3;
          var n3, i = t3.charCodeAt(0), o = 47 === i;
          o ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var s = -1, a = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f) if (47 !== (i = t3.charCodeAt(f))) -1 === h && (c = false, h = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
          else if (!c) {
            a = f + 1;
            break;
          }
          return -1 === s || -1 === h || 0 === u || 1 === u && s === h - 1 && s === a + 1 ? -1 !== h && (r3.base = r3.name = 0 === a && o ? t3.slice(1, h) : t3.slice(a, h)) : (0 === a && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(a, s), r3.base = t3.slice(a, h)), r3.ext = t3.slice(s, h)), a > 0 ? r3.dir = t3.slice(0, a - 1) : o && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      }, 70: (t2, e2) => {
        if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process) e2.isWindows = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          let t3 = navigator.userAgent;
          e2.isWindows = t3.indexOf("Windows") >= 0;
        }
      }, 231: (t2, e2, r2) => {
        Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
        const n2 = r2(70), i = /^\w[\w\d+.-]*$/, o = /^\//, s = /^\/\//;
        function a(t3, e3) {
          if (!t3.scheme && e3) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
          if (t3.scheme && !i.test(t3.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!o.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (s.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        const h = "", c = "/", f = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        class u {
          static isUri(t3) {
            return t3 instanceof u || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
          }
          scheme;
          authority;
          path;
          query;
          fragment;
          constructor(t3, e3, r3, n3, i2, o2 = false) {
            "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ (function(t4, e4) {
              return t4 || e4 ? t4 : "file";
            })(t3, o2), this.authority = e3 || h, this.path = (function(t4, e4) {
              switch (t4) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== c && (e4 = c + e4) : e4 = c;
              }
              return e4;
            })(this.scheme, r3 || h), this.query = n3 || h, this.fragment = i2 || h, a(this, o2));
          }
          get fsPath() {
            return v(this, false);
          }
          with(t3) {
            if (!t3) return this;
            let { scheme: e3, authority: r3, path: n3, query: i2, fragment: o2 } = t3;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = h), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r3 === this.authority && n3 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e3, r3, n3, i2, o2);
          }
          static parse(t3, e3 = false) {
            const r3 = f.exec(t3);
            return r3 ? new d(r3[2] || h, w(r3[4] || h), w(r3[5] || h), w(r3[7] || h), w(r3[9] || h), e3) : new d(h, h, h, h, h);
          }
          static file(t3) {
            let e3 = h;
            if (n2.isWindows && (t3 = t3.replace(/\\/g, c)), t3[0] === c && t3[1] === c) {
              const r3 = t3.indexOf(c, 2);
              -1 === r3 ? (e3 = t3.substring(2), t3 = c) : (e3 = t3.substring(2, r3), t3 = t3.substring(r3) || c);
            }
            return new d("file", e3, t3, h, h);
          }
          static from(t3) {
            const e3 = new d(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
            return a(e3, true), e3;
          }
          toString(t3 = false) {
            return y(this, t3);
          }
          toJSON() {
            return this;
          }
          static revive(t3) {
            if (t3) {
              if (t3 instanceof u) return t3;
              {
                const e3 = new d(t3);
                return e3._formatted = t3.external, e3._fsPath = t3._sep === l ? t3.fsPath : null, e3;
              }
            }
            return t3;
          }
        }
        e2.URI = u;
        const l = n2.isWindows ? 1 : void 0;
        class d extends u {
          _formatted = null;
          _fsPath = null;
          get fsPath() {
            return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
          }
          toString(t3 = false) {
            return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
          }
          toJSON() {
            const t3 = { $mid: 1 };
            return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = l), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
          }
        }
        const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
        function g(t3, e3, r3) {
          let n3, i2 = -1;
          for (let o2 = 0; o2 < t3.length; o2++) {
            const s2 = t3.charCodeAt(o2);
            if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r3 && 91 === s2 || r3 && 93 === s2 || r3 && 58 === s2) -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n3 && (n3 += t3.charAt(o2));
            else {
              void 0 === n3 && (n3 = t3.substr(0, o2));
              const e4 = p[s2];
              void 0 !== e4 ? (-1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n3 += e4) : -1 === i2 && (i2 = o2);
            }
          }
          return -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2))), void 0 !== n3 ? n3 : t3;
        }
        function m(t3) {
          let e3;
          for (let r3 = 0; r3 < t3.length; r3++) {
            const n3 = t3.charCodeAt(r3);
            35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += p[n3]) : void 0 !== e3 && (e3 += t3[r3]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function v(t3, e3) {
          let r3;
          return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? `//${t3.authority}${t3.path}` : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n2.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function y(t3, e3) {
          const r3 = e3 ? m : g;
          let n3 = "", { scheme: i2, authority: o2, path: s2, query: a2, fragment: h2 } = t3;
          if (i2 && (n3 += i2, n3 += ":"), (o2 || "file" === i2) && (n3 += c, n3 += c), o2) {
            let t4 = o2.indexOf("@");
            if (-1 !== t4) {
              const e4 = o2.substr(0, t4);
              o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n3 += r3(e4, false, false) : (n3 += r3(e4.substr(0, t4), false, false), n3 += ":", n3 += r3(e4.substr(t4 + 1), false, true)), n3 += "@";
            }
            o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n3 += r3(o2, false, true) : (n3 += r3(o2.substr(0, t4), false, true), n3 += o2.substr(t4));
          }
          if (s2) {
            if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
              const t4 = s2.charCodeAt(1);
              t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
            } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
              const t4 = s2.charCodeAt(0);
              t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
            }
            n3 += r3(s2, true, false);
          }
          return a2 && (n3 += "?", n3 += r3(a2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : g(h2, false, false)), n3;
        }
        function b(t3) {
          try {
            return decodeURIComponent(t3);
          } catch {
            return t3.length > 3 ? t3.substr(0, 3) + b(t3.substr(3)) : t3;
          }
        }
        e2.uriToFsPath = v;
        const C = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function w(t3) {
          return t3.match(C) ? t3.replace(C, ((t4) => b(t4))) : t3;
        }
      }, 552: function(t2, e2, r2) {
        var n2 = this && this.__createBinding || (Object.create ? function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3);
          var i2 = Object.getOwnPropertyDescriptor(e3, r3);
          i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return e3[r3];
          } }), Object.defineProperty(t3, n3, i2);
        } : function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3), t3[n3] = e3[r3];
        }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
          Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
        } : function(t3, e3) {
          t3.default = e3;
        }), o = this && this.__importStar || function(t3) {
          if (t3 && t3.__esModule) return t3;
          var e3 = {};
          if (null != t3) for (var r3 in t3) "default" !== r3 && Object.prototype.hasOwnProperty.call(t3, r3) && n2(e3, t3, r3);
          return i(e3, t3), e3;
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
        const s = o(r2(975)), a = s.posix || s, h = "/";
        var c;
        !(function(t3) {
          t3.joinPath = function(t4, ...e3) {
            return t4.with({ path: a.join(t4.path, ...e3) });
          }, t3.resolvePath = function(t4, ...e3) {
            let r3 = t4.path, n3 = false;
            r3[0] !== h && (r3 = h + r3, n3 = true);
            let i2 = a.resolve(r3, ...e3);
            return n3 && i2[0] === h && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
          }, t3.dirname = function(t4) {
            if (0 === t4.path.length || t4.path === h) return t4;
            let e3 = a.dirname(t4.path);
            return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return a.basename(t4.path);
          }, t3.extname = function(t4) {
            return a.extname(t4.path);
          };
        })(c || (e2.Utils = c = {}));
      } }, e = {};
      function r(n2) {
        var i = e[n2];
        if (void 0 !== i) return i.exports;
        var o = e[n2] = { exports: {} };
        return t[n2].call(o.exports, o, o.exports, r), o.exports;
      }
      var n = {};
      return (() => {
        var t2 = n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
        const e2 = r(231);
        Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
          return e2.URI;
        } });
        const i = r(552);
        Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
          return i.Utils;
        } });
      })(), n;
    })()));
  }
});

// node_modules/monaco-languageclient/lib/vscode-api.js
var require_vscode_api = __commonJS({
  "node_modules/monaco-languageclient/lib/vscode-api.js"(exports2) {
    "use strict";
    var __awaiter46 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createVSCodeApi = void 0;
    var vscode = require_vscode_compatibility();
    var vscode_uri_1 = require_umd();
    var disposable_1 = require_disposable2();
    var services_1 = require_services();
    var ServicesModule = require_services();
    var vscode_languageserver_protocol_1 = require_main3();
    function createVSCodeApi(servicesProvider) {
      const unsupported = () => {
        throw new Error("unsupported");
      };
      const Uri2 = class VSCodeUri extends vscode_uri_1.URI {
        static joinPath(uri, ...pathFragment) {
          return unsupported();
        }
      };
      class CompletionItem2 {
        constructor(label, kind) {
          this.label = label;
          this.kind = kind;
        }
      }
      class CodeLens {
        constructor(range, command) {
          this.range = range;
          this.command = command;
        }
        get isResolved() {
          return !!this.command;
        }
      }
      class DocumentLink {
        constructor(range, target) {
          this.range = range;
          this.target = target;
        }
      }
      class CodeActionKind2 {
        constructor(value) {
          this.value = value;
          this.contains = unsupported;
          this.intersects = unsupported;
        }
        append(parts) {
          return new CodeActionKind2(this.value ? this.value + CodeActionKind2.sep + parts : parts);
        }
      }
      CodeActionKind2.sep = ".";
      CodeActionKind2.Empty = new CodeActionKind2("");
      CodeActionKind2.QuickFix = new CodeActionKind2("quickfix");
      CodeActionKind2.Refactor = new CodeActionKind2("refactor");
      CodeActionKind2.RefactorExtract = CodeActionKind2.Refactor.append("extract");
      CodeActionKind2.RefactorInline = CodeActionKind2.Refactor.append("inline");
      CodeActionKind2.RefactorRewrite = CodeActionKind2.Refactor.append("rewrite");
      CodeActionKind2.Source = new CodeActionKind2("source");
      CodeActionKind2.SourceOrganizeImports = CodeActionKind2.Source.append("organizeImports");
      CodeActionKind2.SourceFixAll = CodeActionKind2.Source.append("fixAll");
      class Diagnostic {
        constructor(range, message, severity = vscode_languageserver_protocol_1.DiagnosticSeverity.Error) {
          this.range = range;
          this.message = message;
          this.severity = severity;
        }
      }
      class CallHierarchyItem {
        constructor(kind, name, detail, uri, range, selectionRange) {
          this.kind = kind;
          this.name = name;
          this.detail = detail;
          this.uri = uri;
          this.range = range;
          this.selectionRange = selectionRange;
        }
      }
      class CodeAction {
        constructor(title, kind) {
          this.title = title;
          this.kind = kind;
        }
      }
      class SemanticTokens {
        constructor(data, resultId) {
          this.data = data;
          this.resultId = resultId;
        }
      }
      class EmptyFileSystem {
        isWritableFileSystem(scheme) {
          return false;
        }
        stat(uri) {
          throw new Error("Method not implemented.");
        }
        readDirectory(uri) {
          return Promise.resolve([]);
        }
        createDirectory(uri) {
          return Promise.resolve();
        }
        readFile(uri) {
          return Promise.resolve(new Uint8Array(0));
        }
        writeFile(uri, content) {
          return Promise.resolve();
        }
        delete(uri, options) {
          return Promise.resolve();
        }
        rename(source, target, options) {
          return Promise.resolve();
        }
        copy(source, target, options) {
          return Promise.resolve();
        }
      }
      const workspace = {
        fs: new EmptyFileSystem(),
        workspaceFile: void 0,
        createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
          const services = servicesProvider();
          if (typeof globPattern !== "string") {
            throw new Error("unsupported");
          }
          if (services.workspace.createFileSystemWatcher) {
            const watcher = services.workspace.createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
            return Object.assign(watcher, {
              ignoreCreateEvents: !!ignoreCreateEvents,
              ignoreChangeEvents: !!ignoreChangeEvents,
              ignoreDeleteEvents: !!ignoreDeleteEvents
            });
          }
          return {
            ignoreCreateEvents: !!ignoreCreateEvents,
            ignoreChangeEvents: !!ignoreChangeEvents,
            ignoreDeleteEvents: !!ignoreDeleteEvents,
            onDidCreate: services_1.Event.None,
            onDidChange: services_1.Event.None,
            onDidDelete: services_1.Event.None,
            dispose: () => {
            }
          };
        },
        applyEdit: (edit) => __awaiter46(this, void 0, void 0, function* () {
          const services = servicesProvider();
          if (services_1.WorkspaceEdit.is(edit)) {
            return services.workspace.applyEdit(edit);
          }
          throw new Error("unsupported");
        }),
        getConfiguration(section, resource) {
          const { workspace: workspace2 } = servicesProvider();
          const configuration = workspace2.configurations ? workspace2.configurations.getConfiguration(section, resource ? resource.toString() : void 0) : void 0;
          const result = {
            get: (section2, defaultValue) => {
              return configuration ? configuration.get(section2, defaultValue) : defaultValue;
            },
            has: (section2) => {
              return configuration ? configuration.has(section2) : false;
            },
            inspect: unsupported,
            update: unsupported
          };
          return Object.assign(result, {
            toJSON: () => configuration ? configuration.toJSON() : void 0
          });
        },
        get onDidChangeConfiguration() {
          const services = servicesProvider();
          if (services.workspace.configurations) {
            return services.workspace.configurations.onDidChangeConfiguration;
          }
          return services_1.Event.None;
        },
        get workspaceFolders() {
          const services = servicesProvider();
          if ("workspaceFolders" in services.workspace) {
            return services.workspace.workspaceFolders;
          }
          const rootUri = services.workspace.rootUri;
          if (!rootUri) {
            return void 0;
          }
          const uri = Uri2.parse(rootUri);
          return [{
            uri,
            index: 0,
            name: uri.toString()
          }];
        },
        get onDidChangeWorkspaceFolders() {
          const services = servicesProvider();
          return services.workspace.onDidChangeWorkspaceFolders || services_1.Event.None;
        },
        get textDocuments() {
          const services = servicesProvider();
          return services.workspace.textDocuments;
        },
        get onDidOpenTextDocument() {
          const services = servicesProvider();
          return services.workspace.onDidOpenTextDocument;
        },
        get onDidCloseTextDocument() {
          const services = servicesProvider();
          return services.workspace.onDidCloseTextDocument;
        },
        get onDidChangeTextDocument() {
          const services = servicesProvider();
          return (listener, thisArgs, disposables) => {
            return services.workspace.onDidChangeTextDocument(({ textDocument, contentChanges }) => {
              const l = listener.bind(thisArgs);
              l({
                document: textDocument,
                contentChanges
              });
            }, void 0, disposables);
          };
        },
        get onWillSaveTextDocument() {
          const services = servicesProvider();
          const onWillSaveTextDocument = services.workspace.onWillSaveTextDocument;
          if (!onWillSaveTextDocument) {
            return services_1.Event.None;
          }
          return (listener, thisArgs, disposables) => {
            return onWillSaveTextDocument(({ textDocument, reason, waitUntil }) => {
              const l = listener.bind(thisArgs);
              l({
                document: textDocument,
                reason,
                waitUntil: (edits) => {
                  if (waitUntil) {
                    waitUntil(edits);
                  }
                }
              });
            }, void 0, disposables);
          };
        },
        get onDidSaveTextDocument() {
          const services = servicesProvider();
          return services.workspace.onDidSaveTextDocument || services_1.Event.None;
        },
        get onWillCreateFiles() {
          return services_1.Event.None;
        },
        get onDidCreateFiles() {
          return services_1.Event.None;
        },
        get onWillDeleteFiles() {
          return services_1.Event.None;
        },
        get onDidDeleteFiles() {
          return services_1.Event.None;
        },
        get onWillRenameFiles() {
          return services_1.Event.None;
        },
        get onDidRenameFiles() {
          return services_1.Event.None;
        },
        getWorkspaceFolder: unsupported,
        asRelativePath: unsupported,
        updateWorkspaceFolders: unsupported,
        findFiles: unsupported,
        saveAll: unsupported,
        openTextDocument: unsupported,
        registerTextDocumentContentProvider: unsupported,
        registerTaskProvider: unsupported,
        registerFileSystemProvider: unsupported,
        rootPath: void 0,
        name: void 0
      };
      function isVsCodeUri(v) {
        return v instanceof vscode_uri_1.URI !== void 0;
      }
      class ApiDiagnosticCollection {
        constructor(name) {
          this.name = name || "default", this.services = servicesProvider();
          this.collection = this.services.languages.createDiagnosticCollection ? this.services.languages.createDiagnosticCollection(name) : void 0;
        }
        entries() {
        }
        set(arg0, arg1) {
          function toInternalSeverity(severity) {
            return severity;
          }
          function toInternalCode(code) {
            if (code != null && typeof code === "object") {
              return code.value;
            }
            return code;
          }
          if (isVsCodeUri(arg0)) {
            if (this.collection) {
              if (arg1) {
                this.collection.set(arg0.toString(), arg1.map((diag) => {
                  return {
                    range: diag.range,
                    code: toInternalCode(diag.code),
                    source: diag.source,
                    message: diag.message,
                    tags: diag.tags,
                    relatedInformation: void 0,
                    severity: toInternalSeverity(diag.severity)
                  };
                }));
              } else {
                this.collection.set(arg0.toString(), []);
              }
            }
          } else {
            arg0.forEach((element) => {
              this.set(element[0], element[1]);
            });
          }
        }
        dispose() {
          if (this.collection) {
            this.collection.dispose();
          }
        }
        delete(uri) {
        }
        clear() {
        }
        forEach(callback, thisArg) {
        }
        get(uri) {
          return void 0;
        }
        has(uri) {
          return false;
        }
      }
      const languages3 = {
        match(selector, document2) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          if (!services_1.DocumentIdentifier.is(document2)) {
            throw new Error("unexpected document: " + JSON.stringify(document2));
          }
          const services = servicesProvider();
          const result = services.languages.match(selector, document2);
          return result ? 1 : 0;
        },
        registerCallHierarchyProvider(selector, provider) {
          return {
            dispose() {
            }
          };
        },
        createDiagnosticCollection(name) {
          return new ApiDiagnosticCollection(name);
        },
        registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerCompletionItemProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          const resolveCompletionItem = provider.resolveCompletionItem;
          return languages4.registerCompletionItemProvider(selector, {
            provideCompletionItems({ textDocument, position, context }, token) {
              return provider.provideCompletionItems(textDocument, position, token, context || {
                triggerKind: services_1.CompletionTriggerKind.Invoked
              });
            },
            resolveCompletionItem: resolveCompletionItem ? (item, token) => {
              return resolveCompletionItem(item, token);
            } : void 0
          }, ...triggerCharacters);
        },
        registerCodeActionsProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerCodeActionsProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerCodeActionsProvider(selector, {
            provideCodeActions({ textDocument, range, context }, token) {
              return provider.provideCodeActions(textDocument, range, context, token);
            }
          });
        },
        registerCodeLensProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerCodeLensProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          const resolveCodeLens = provider.resolveCodeLens;
          return languages4.registerCodeLensProvider(selector, {
            provideCodeLenses({ textDocument }, token) {
              return provider.provideCodeLenses(textDocument, token);
            },
            resolveCodeLens: resolveCodeLens ? (codeLens, token) => {
              return resolveCodeLens(codeLens, token);
            } : void 0
          });
        },
        registerDefinitionProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDefinitionProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDefinitionProvider(selector, {
            provideDefinition({ textDocument, position }, token) {
              return provider.provideDefinition(textDocument, position, token);
            }
          });
        },
        registerImplementationProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerImplementationProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerImplementationProvider(selector, {
            provideImplementation({ textDocument, position }, token) {
              return provider.provideImplementation(textDocument, position, token);
            }
          });
        },
        registerTypeDefinitionProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerTypeDefinitionProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerTypeDefinitionProvider(selector, {
            provideTypeDefinition({ textDocument, position }, token) {
              return provider.provideTypeDefinition(textDocument, position, token);
            }
          });
        },
        registerDeclarationProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDeclarationProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDeclarationProvider(selector, {
            provideDeclaration({ textDocument, position }, token) {
              return provider.provideDeclaration(textDocument, position, token);
            }
          });
        },
        registerHoverProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (languages4.registerHoverProvider) {
            return languages4.registerHoverProvider(selector, {
              provideHover({ textDocument, position }, token) {
                return provider.provideHover(textDocument, position, token);
              }
            });
          }
          return disposable_1.Disposable.create(() => {
          });
        },
        registerDocumentHighlightProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDocumentHighlightProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDocumentHighlightProvider(selector, {
            provideDocumentHighlights({ textDocument, position }, token) {
              return provider.provideDocumentHighlights(textDocument, position, token);
            }
          });
        },
        registerDocumentSymbolProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDocumentSymbolProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDocumentSymbolProvider(selector, {
            provideDocumentSymbols({ textDocument }, token) {
              return provider.provideDocumentSymbols(textDocument, token);
            }
          });
        },
        registerWorkspaceSymbolProvider(provider) {
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerWorkspaceSymbolProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerWorkspaceSymbolProvider({
            provideWorkspaceSymbols({ query }, token) {
              return provider.provideWorkspaceSymbols(query, token);
            }
          });
        },
        registerReferenceProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerReferenceProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerReferenceProvider(selector, {
            provideReferences({ textDocument, position, context }, token) {
              return provider.provideReferences(textDocument, position, context, token);
            }
          });
        },
        registerRenameProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerRenameProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerRenameProvider(selector, {
            provideRenameEdits({ textDocument, position, newName }, token) {
              return provider.provideRenameEdits(textDocument, position, newName, token);
            }
          });
        },
        registerDocumentFormattingEditProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDocumentFormattingEditProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDocumentFormattingEditProvider(selector, {
            provideDocumentFormattingEdits({ textDocument, options }, token) {
              return provider.provideDocumentFormattingEdits(textDocument, options, token);
            }
          });
        },
        registerDocumentRangeFormattingEditProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDocumentRangeFormattingEditProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDocumentRangeFormattingEditProvider(selector, {
            provideDocumentRangeFormattingEdits({ textDocument, range, options }, token) {
              return provider.provideDocumentRangeFormattingEdits(textDocument, range, options, token);
            }
          });
        },
        registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacter) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerOnTypeFormattingEditProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerOnTypeFormattingEditProvider(selector, {
            provideOnTypeFormattingEdits({ textDocument, position, ch, options }, token) {
              return provider.provideOnTypeFormattingEdits(textDocument, position, ch, options, token);
            }
          }, firstTriggerCharacter, ...moreTriggerCharacter);
        },
        registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerSignatureHelpProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          let triggerCharacters;
          let retriggerCharacters;
          if (typeof firstItem === "string") {
            triggerCharacters = [firstItem, ...remaining];
          } else if (firstItem) {
            triggerCharacters = firstItem.triggerCharacters;
            retriggerCharacters = firstItem.retriggerCharacters;
          }
          return languages4.registerSignatureHelpProvider(selector, {
            triggerCharacters,
            retriggerCharacters,
            provideSignatureHelp({ textDocument, position }, token, context) {
              return provider.provideSignatureHelp(textDocument, position, token, context);
            }
          });
        },
        registerDocumentLinkProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDocumentLinkProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          const resolveDocumentLink = provider.resolveDocumentLink;
          return languages4.registerDocumentLinkProvider(selector, {
            provideDocumentLinks({ textDocument }, token) {
              return provider.provideDocumentLinks(textDocument, token);
            },
            resolveDocumentLink: resolveDocumentLink ? (link, token) => {
              return resolveDocumentLink(link, token);
            } : void 0
          });
        },
        registerColorProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerColorProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerColorProvider(selector, {
            provideDocumentColors({ textDocument }, token) {
              return provider.provideDocumentColors(textDocument, token);
            },
            provideColorPresentations({ textDocument, color, range }, token) {
              return provider.provideColorPresentations(color, {
                document: textDocument,
                range
              }, token);
            }
          });
        },
        registerFoldingRangeProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerFoldingRangeProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerFoldingRangeProvider(selector, {
            provideFoldingRanges({ textDocument }, token) {
              return provider.provideFoldingRanges(textDocument, {}, token);
            }
          });
        },
        registerSelectionRangeProvider(selector, provider) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerSelectionRangeProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerSelectionRangeProvider(selector, {
            provideSelectionRanges({ textDocument, positions }, token) {
              return provider.provideSelectionRanges(textDocument, positions, token);
            }
          });
        },
        registerEvaluatableExpressionProvider: unsupported,
        registerDocumentSemanticTokensProvider(selector, provider, legend) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDocumentSemanticTokensProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDocumentSemanticTokensProvider(selector, {
            provideDocumentSemanticTokens({ textDocument }, token) {
              return provider.provideDocumentSemanticTokens(textDocument, token);
            },
            provideDocumentSemanticTokensEdits: provider.provideDocumentSemanticTokensEdits && (({ textDocument, previousResultId }, token) => {
              return provider.provideDocumentSemanticTokensEdits(textDocument, previousResultId, token);
            })
          }, legend);
        },
        registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
          if (!services_1.isDocumentSelector(selector)) {
            throw new Error("unexpected selector: " + JSON.stringify(selector));
          }
          const { languages: languages4 } = servicesProvider();
          if (!languages4.registerDocumentRangeSemanticTokensProvider) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return languages4.registerDocumentRangeSemanticTokensProvider(selector, {
            provideDocumentRangeSemanticTokens({ textDocument, range }, token) {
              return provider.provideDocumentRangeSemanticTokens(textDocument, range, token);
            }
          }, legend);
        },
        getLanguages: unsupported,
        setTextDocumentLanguage: unsupported,
        getDiagnostics: unsupported,
        setLanguageConfiguration: unsupported,
        onDidChangeDiagnostics: unsupported,
        registerLinkedEditingRangeProvider: unsupported
      };
      function showMessage(type, arg0, ...arg1) {
        if (typeof arg0 !== "string") {
          throw new Error("unexpected message: " + JSON.stringify(arg0));
        }
        const message = arg0;
        if (arg1 !== void 0 && !Array.isArray(arg1)) {
          throw new Error("unexpected actions: " + JSON.stringify(arg1));
        }
        const actions = arg1 || [];
        const { window: window3 } = servicesProvider();
        if (!window3) {
          return Promise.resolve(void 0);
        }
        return window3.showMessage(type, message, ...actions);
      }
      const window2 = {
        showInformationMessage: showMessage.bind(void 0, services_1.MessageType.Info),
        showWarningMessage: showMessage.bind(void 0, services_1.MessageType.Warning),
        showErrorMessage: showMessage.bind(void 0, services_1.MessageType.Error),
        createOutputChannel(name) {
          const { window: window3 } = servicesProvider();
          const createOutputChannel = window3 ? window3.createOutputChannel : void 0;
          const channel = createOutputChannel ? createOutputChannel.bind(window3)(name) : void 0;
          return {
            name,
            append: channel ? channel.append.bind(channel) : () => {
            },
            appendLine: channel ? channel.appendLine.bind(channel) : () => {
            },
            clear: unsupported,
            show: (arg) => {
              if (arg !== void 0 && typeof arg !== "boolean") {
                throw new Error("unexpected preserveFocus argument: " + JSON.stringify(arg, void 0, 4));
              }
              return channel ? channel.show(arg) : () => {
              };
            },
            hide: unsupported,
            dispose: channel ? channel.dispose.bind(channel) : () => {
            }
          };
        },
        withProgress: (options, task) => {
          const { window: window3 } = servicesProvider();
          if (window3 && window3.withProgress) {
            return window3.withProgress(options, task);
          }
          return task({ report: () => {
          } }, new vscode.CancellationTokenSource().token);
        },
        showTextDocument: unsupported,
        createTextEditorDecorationType: unsupported,
        showQuickPick: unsupported,
        showWorkspaceFolderPick: unsupported,
        showOpenDialog: unsupported,
        showSaveDialog: unsupported,
        showInputBox: unsupported,
        createWebviewPanel: unsupported,
        setStatusBarMessage: unsupported,
        withScmProgress: unsupported,
        createStatusBarItem: unsupported,
        createTerminal: unsupported,
        registerTreeDataProvider: unsupported,
        createTreeView: unsupported,
        registerWebviewPanelSerializer: unsupported,
        get activeTextEditor() {
          return unsupported();
        },
        get visibleTextEditors() {
          return unsupported();
        },
        onDidChangeActiveTextEditor: unsupported,
        onDidChangeVisibleTextEditors: unsupported,
        onDidChangeTextEditorSelection: unsupported,
        onDidChangeTextEditorVisibleRanges: unsupported,
        onDidChangeTextEditorOptions: unsupported,
        onDidChangeTextEditorViewColumn: unsupported,
        get terminals() {
          return unsupported();
        },
        get activeTerminal() {
          return unsupported();
        },
        onDidChangeActiveTerminal: unsupported,
        onDidOpenTerminal: unsupported,
        onDidCloseTerminal: unsupported,
        get state() {
          return unsupported();
        },
        onDidChangeWindowState: unsupported,
        createQuickPick: unsupported,
        createInputBox: unsupported,
        registerUriHandler: unsupported,
        registerWebviewViewProvider: unsupported,
        registerCustomEditorProvider: unsupported,
        registerTerminalLinkProvider: unsupported,
        get activeColorTheme() {
          return unsupported();
        },
        onDidChangeActiveColorTheme: unsupported,
        registerFileDecorationProvider: unsupported
      };
      const commands = {
        registerCommand(command, callback, thisArg) {
          const { commands: commands2 } = servicesProvider();
          if (!commands2) {
            return disposable_1.Disposable.create(() => {
            });
          }
          return commands2.registerCommand(command, callback, thisArg);
        },
        registerTextEditorCommand: unsupported,
        executeCommand: unsupported,
        getCommands: unsupported
      };
      class CodeDisposable {
        constructor(callOnDispose) {
          this.callOnDispose = callOnDispose;
        }
        static from(...inDisposables) {
          let disposables = inDisposables;
          return new CodeDisposable(function() {
            if (disposables) {
              for (const disposable of disposables) {
                if (disposable && typeof disposable.dispose === "function") {
                  disposable.dispose();
                }
              }
              disposables = void 0;
            }
          });
        }
        dispose() {
          this.callOnDispose();
        }
      }
      const env = {
        appName: "Monaco",
        appRoot: "",
        language: navigator.language || "en-US",
        get uriScheme() {
          return unsupported();
        },
        get clipboard() {
          return unsupported();
        },
        get machineId() {
          return unsupported();
        },
        get sessionId() {
          return unsupported();
        },
        remoteName: void 0,
        shell: "",
        uiKind: 2,
        asExternalUri: unsupported,
        openExternal: unsupported
      };
      const partialApi = {
        workspace,
        languages: languages3,
        window: window2,
        commands,
        env,
        Uri: Uri2,
        CompletionItem: CompletionItem2,
        CodeLens,
        DocumentLink,
        CodeActionKind: CodeActionKind2,
        CodeAction,
        Diagnostic,
        CallHierarchyItem,
        SemanticTokens,
        Disposable: CodeDisposable,
        SignatureHelpTriggerKind: services_1.SignatureHelpTriggerKind,
        DiagnosticSeverity: ServicesModule.DiagnosticSeverity,
        EventEmitter: ServicesModule.Emitter
      };
      return partialApi;
    }
    exports2.createVSCodeApi = createVSCodeApi;
  }
});

// node_modules/monaco-languageclient/lib/vscode-compatibility.js
var require_vscode_compatibility = __commonJS({
  "node_modules/monaco-languageclient/lib/vscode-compatibility.js"(exports2, module2) {
    "use strict";
    var vscode_api_1 = require_vscode_api();
    var services_1 = require_services();
    module2.exports = vscode_api_1.createVSCodeApi(services_1.Services.get);
  }
});

// node_modules/vscode-languageclient/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageclient/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toJSONObject = exports2.ConfigurationFeature = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var ConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
      }
      initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
          let configuration = (params2) => {
            let result = [];
            for (let item of params2.items) {
              let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : void 0;
              result.push(this.getConfiguration(resource, item.section !== null ? item.section : void 0));
            }
            return result;
          };
          let middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section) {
        let result = null;
        if (section) {
          let index = section.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(vscode_1.workspace.getConfiguration(void 0, resource).get(section));
          } else {
            let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
            if (config) {
              result = toJSONObject(config.get(section.substr(index + 1)));
            }
          }
        } else {
          let config = vscode_1.workspace.getConfiguration(void 0, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        if (result === void 0) {
          result = null;
        }
        return result;
      }
      dispose() {
      }
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
    function toJSONObject(obj) {
      if (obj) {
        if (Array.isArray(obj)) {
          return obj.map(toJSONObject);
        } else if (typeof obj === "object") {
          const res = /* @__PURE__ */ Object.create(null);
          for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              res[key] = toJSONObject(obj[key]);
            }
          }
          return res;
        }
      }
      return obj;
    }
    exports2.toJSONObject = toJSONObject;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asPromise = exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
    function asPromise(value) {
      if (value instanceof Promise) {
        return value;
      } else if (thenable(value)) {
        return new Promise((resolve, reject) => {
          value.then((resolved) => resolve(resolved), (error2) => reject(error2));
        });
      } else {
        return Promise.resolve(value);
      }
    }
    exports2.asPromise = asPromise;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js
var require_protocolCompletionItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require_vscode_compatibility();
    var ProtocolCompletionItem = class extends code.CompletionItem {
      constructor(label) {
        super(label);
      }
    };
    exports2.default = ProtocolCompletionItem;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCodeLens.js
var require_protocolCodeLens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCodeLens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require_vscode_compatibility();
    var ProtocolCodeLens = class extends code.CodeLens {
      constructor(range) {
        super(range);
      }
    };
    exports2.default = ProtocolCodeLens;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js
var require_protocolDocumentLink = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require_vscode_compatibility();
    var ProtocolDocumentLink = class extends code.DocumentLink {
      constructor(range, target) {
        super(range, target);
      }
    };
    exports2.default = ProtocolDocumentLink;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCodeAction.js
var require_protocolCodeAction = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCodeAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode = require_vscode_compatibility();
    var ProtocolCodeAction = class extends vscode.CodeAction {
      constructor(title, data) {
        super(title);
        this.data = data;
      }
    };
    exports2.default = ProtocolCodeAction;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js
var require_protocolDiagnostic = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolDiagnostic = exports2.DiagnosticCode = void 0;
    var vscode = require_vscode_compatibility();
    var Is = require_is3();
    var DiagnosticCode;
    (function(DiagnosticCode2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
      }
      DiagnosticCode2.is = is;
    })(DiagnosticCode = exports2.DiagnosticCode || (exports2.DiagnosticCode = {}));
    var ProtocolDiagnostic = class extends vscode.Diagnostic {
      constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
      }
    };
    exports2.ProtocolDiagnostic = ProtocolDiagnostic;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js
var require_protocolCallHierarchyItem = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code = require_vscode_compatibility();
    var ProtocolCallHierarchyItem = class extends code.CallHierarchyItem {
      constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== void 0) {
          this.data = data;
        }
      }
    };
    exports2.default = ProtocolCallHierarchyItem;
  }
});

// node_modules/vscode-languageclient/lib/common/codeConverter.js
var require_codeConverter = __commonJS({
  "node_modules/vscode-languageclient/lib/common/codeConverter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConverter = void 0;
    var code = require_vscode_compatibility();
    var proto = require_main3();
    var Is = require_is3();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var vscode_languageserver_protocol_1 = require_main3();
    var InsertReplaceRange;
    (function(InsertReplaceRange2) {
      function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
      }
      InsertReplaceRange2.is = is;
    })(InsertReplaceRange || (InsertReplaceRange = {}));
    function createConverter(uriConverter) {
      const nullConverter = (value) => value.toString();
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri)
        };
      }
      function asVersionedTextDocumentIdentifier(textDocument) {
        return {
          uri: _uriConverter(textDocument.uri),
          version: textDocument.version
        };
      }
      function asOpenTextDocumentParams(textDocument) {
        return {
          textDocument: {
            uri: _uriConverter(textDocument.uri),
            languageId: textDocument.languageId,
            version: textDocument.version,
            text: textDocument.getText()
          }
        };
      }
      function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
      }
      function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
      }
      function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
          let result = {
            textDocument: {
              uri: _uriConverter(arg.uri),
              version: arg.version
            },
            contentChanges: [{ text: arg.getText() }]
          };
          return result;
        } else if (isTextDocumentChangeEvent(arg)) {
          let document2 = arg.document;
          let result = {
            textDocument: {
              uri: _uriConverter(document2.uri),
              version: document2.version
            },
            contentChanges: arg.contentChanges.map((change) => {
              let range = change.range;
              return {
                range: {
                  start: { line: range.start.line, character: range.start.character },
                  end: { line: range.end.line, character: range.end.character }
                },
                rangeLength: change.rangeLength,
                text: change.text
              };
            })
          };
          return result;
        } else {
          throw Error("Unsupported text document change parameter");
        }
      }
      function asCloseTextDocumentParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
          result.text = textDocument.getText();
        }
        return result;
      }
      function asTextDocumentSaveReason(reason) {
        switch (reason) {
          case code.TextDocumentSaveReason.Manual:
            return proto.TextDocumentSaveReason.Manual;
          case code.TextDocumentSaveReason.AfterDelay:
            return proto.TextDocumentSaveReason.AfterDelay;
          case code.TextDocumentSaveReason.FocusOut:
            return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
      }
      function asWillSaveTextDocumentParams(event) {
        return {
          textDocument: asTextDocumentIdentifier(event.document),
          reason: asTextDocumentSaveReason(event.reason)
        };
      }
      function asDidCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asDidRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asDidDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillCreateFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asWillRenameFilesParams(event) {
        return {
          files: event.files.map((file) => ({
            oldUri: _uriConverter(file.oldUri),
            newUri: _uriConverter(file.newUri)
          }))
        };
      }
      function asWillDeleteFilesParams(event) {
        return {
          files: event.files.map((fileUri) => ({
            uri: _uriConverter(fileUri)
          }))
        };
      }
      function asTextDocumentPositionParams(textDocument, position) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position)
        };
      }
      function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.CompletionTriggerKind.TriggerCharacter:
            return proto.CompletionTriggerKind.TriggerCharacter;
          case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
            return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
          default:
            return proto.CompletionTriggerKind.Invoked;
        }
      }
      function asCompletionParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            triggerKind: asCompletionTriggerKind(context.triggerKind),
            triggerCharacter: context.triggerCharacter
          }
        };
      }
      function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
          case code.SignatureHelpTriggerKind.Invoke:
            return proto.SignatureHelpTriggerKind.Invoked;
          case code.SignatureHelpTriggerKind.TriggerCharacter:
            return proto.SignatureHelpTriggerKind.TriggerCharacter;
          case code.SignatureHelpTriggerKind.ContentChange:
            return proto.SignatureHelpTriggerKind.ContentChange;
        }
      }
      function asParameterInformation(value) {
        return {
          label: value.label
        };
      }
      function asParameterInformations(values) {
        return values.map(asParameterInformation);
      }
      function asSignatureInformation(value) {
        return {
          label: value.label,
          parameters: asParameterInformations(value.parameters)
        };
      }
      function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
      }
      function asSignatureHelp(value) {
        if (value === void 0) {
          return value;
        }
        return {
          signatures: asSignatureInformations(value.signatures),
          activeSignature: value.activeSignature,
          activeParameter: value.activeParameter
        };
      }
      function asSignatureHelpParams(textDocument, position, context) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: {
            isRetrigger: context.isRetrigger,
            triggerCharacter: context.triggerCharacter,
            triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
            activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
          }
        };
      }
      function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
      }
      function asPosition(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { line: value.line, character: value.character };
      }
      function asPositions(value) {
        let result = [];
        for (let elem of value) {
          result.push(asPosition(elem));
        }
        return result;
      }
      function asRange(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
      }
      function asLocation(value) {
        if (value === void 0 || value === null) {
          return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
      }
      function asDiagnosticSeverity(value) {
        switch (value) {
          case code.DiagnosticSeverity.Error:
            return proto.DiagnosticSeverity.Error;
          case code.DiagnosticSeverity.Warning:
            return proto.DiagnosticSeverity.Warning;
          case code.DiagnosticSeverity.Information:
            return proto.DiagnosticSeverity.Information;
          case code.DiagnosticSeverity.Hint:
            return proto.DiagnosticSeverity.Hint;
        }
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case code.DiagnosticTag.Unnecessary:
            return proto.DiagnosticTag.Unnecessary;
          case code.DiagnosticTag.Deprecated:
            return proto.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asRelatedInformation(item) {
        return {
          message: item.message,
          location: asLocation(item.location)
        };
      }
      function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
      }
      function asDiagnosticCode(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        if (Is.number(value) || Is.string(value)) {
          return value;
        }
        return { value: value.value, target: asUri(value.target) };
      }
      function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : void 0;
        if (protocolDiagnostic !== void 0 && protocolDiagnostic.data !== void 0) {
          result.data = protocolDiagnostic.data;
        }
        const code2 = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code2)) {
          if (protocolDiagnostic !== void 0 && protocolDiagnostic.hasDiagnosticCode) {
            result.code = code2;
          } else {
            result.code = code2.value;
            result.codeDescription = { href: code2.target };
          }
        } else {
          result.code = code2;
        }
        if (Is.number(item.severity)) {
          result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
          result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
          result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
          result.source = item.source;
        }
        return result;
      }
      function asDiagnostics(items) {
        if (items === void 0 || items === null) {
          return items;
        }
        return items.map(asDiagnostic);
      }
      function asDocumentation(format2, documentation) {
        switch (format2) {
          case "$string":
            return documentation;
          case proto.MarkupKind.PlainText:
            return { kind: format2, value: documentation };
          case proto.MarkupKind.Markdown:
            return { kind: format2, value: documentation.value };
          default:
            return `Unsupported Markup content received. Kind is: ${format2}`;
        }
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case code.CompletionItemTag.Deprecated:
            return proto.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0) {
          return tags;
        }
        const result = [];
        for (let tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItemKind(value, original) {
        if (original !== void 0) {
          return original;
        }
        return value + 1;
      }
      function asCompletionItem(item) {
        let result = { label: item.label };
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : void 0;
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          if (!protocolItem || protocolItem.documentationFormat === "$string") {
            result.documentation = item.documentation;
          } else {
            result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
          }
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
          result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
          result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
          if (protocolItem.data !== void 0) {
            result.data = protocolItem.data;
          }
          if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
            if (protocolItem.deprecated === true && tags !== void 0 && tags.length > 0) {
              const index = tags.indexOf(code.CompletionItemTag.Deprecated);
              if (index !== -1) {
                tags.splice(index, 1);
              }
            }
            result.deprecated = protocolItem.deprecated;
          }
          if (protocolItem.insertTextMode !== void 0) {
            result.insertTextMode = protocolItem.insertTextMode;
          }
        }
        if (tags !== void 0 && tags.length > 0) {
          result.tags = tags;
        }
        if (result.insertTextMode === void 0 && item.keepWhitespace === true) {
          result.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        }
        return result;
      }
      function fillPrimaryInsertText(target, source) {
        let format2 = proto.InsertTextFormat.PlainText;
        let text2 = void 0;
        let range = void 0;
        if (source.textEdit) {
          text2 = source.textEdit.newText;
          range = source.textEdit.range;
        } else if (source.insertText instanceof code.SnippetString) {
          format2 = proto.InsertTextFormat.Snippet;
          text2 = source.insertText.value;
        } else {
          text2 = source.insertText;
        }
        if (source.range) {
          range = source.range;
        }
        target.insertTextFormat = format2;
        if (source.fromEdit && text2 !== void 0 && range !== void 0) {
          target.textEdit = asCompletionTextEdit(text2, range);
        } else {
          target.insertText = text2;
        }
      }
      function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
          return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        } else {
          return { newText, range: asRange(range) };
        }
      }
      function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
      }
      function asTextEdits(edits) {
        if (edits === void 0 || edits === null) {
          return edits;
        }
        return edits.map(asTextEdit);
      }
      function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
          return item + 1;
        }
        return proto.SymbolKind.Property;
      }
      function asSymbolTag(item) {
        return item;
      }
      function asSymbolTags(items) {
        return items.map(asSymbolTag);
      }
      function asReferenceParams(textDocument, position, options) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument),
          position: asWorkerPosition(position),
          context: { includeDeclaration: options.includeDeclaration }
        };
      }
      function asCodeAction(item) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== void 0) {
          result.data = item.data;
        }
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== void 0) {
          throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeActionContext(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
          only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), only);
      }
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        return item.value;
      }
      function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
          if (item.data) {
            result.data = item.data;
          }
        }
        return result;
      }
      function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
          result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
          result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
          result.insertFinalNewline = true;
        }
        return result;
      }
      function asDocumentSymbolParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCodeLensParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
          result.target = asUri(item.target);
        }
        if (item.tooltip !== void 0) {
          result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : void 0;
        if (protocolItem && protocolItem.data) {
          result.data = protocolItem.data;
        }
        return result;
      }
      function asDocumentLinkParams(textDocument) {
        return {
          textDocument: asTextDocumentIdentifier(textDocument)
        };
      }
      function asCallHierarchyItem(value) {
        const result = {
          name: value.name,
          kind: asSymbolKind(value.kind),
          uri: asUri(value.uri),
          range: asRange(value.range),
          selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== void 0 && value.detail.length > 0) {
          result.detail = value.detail;
        }
        if (value.tags !== void 0) {
          result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== void 0) {
          result.data = value.data;
        }
        return result;
      }
      return {
        asUri,
        asTextDocumentIdentifier,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem
      };
    }
    exports2.createConverter = createConverter;
  }
});

// node_modules/vscode-languageclient/lib/common/protocolConverter.js
var require_protocolConverter = __commonJS({
  "node_modules/vscode-languageclient/lib/common/protocolConverter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConverter = void 0;
    var code = require_vscode_compatibility();
    var ls = require_main3();
    var Is = require_is3();
    var protocolCompletionItem_1 = require_protocolCompletionItem();
    var protocolCodeLens_1 = require_protocolCodeLens();
    var protocolDocumentLink_1 = require_protocolDocumentLink();
    var protocolCodeAction_1 = require_protocolCodeAction();
    var protocolDiagnostic_1 = require_protocolDiagnostic();
    var protocolCallHierarchyItem_1 = require_protocolCallHierarchyItem();
    var vscode_languageserver_protocol_1 = require_main3();
    var CodeBlock;
    (function(CodeBlock2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
      }
      CodeBlock2.is = is;
    })(CodeBlock || (CodeBlock = {}));
    function createConverter(uriConverter, trustMarkdown) {
      const nullConverter = (value) => code.Uri.parse(value);
      const _uriConverter = uriConverter || nullConverter;
      function asUri(value) {
        return _uriConverter(value);
      }
      function asDiagnostics(diagnostics) {
        return diagnostics.map(asDiagnostic);
      }
      function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== void 0) {
          if (ls.CodeDescription.is(diagnostic.codeDescription)) {
            result.code = {
              value: diagnostic.code,
              target: asUri(diagnostic.codeDescription.href)
            };
          } else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
            result.hasDiagnosticCode = true;
            result.code = {
              value: diagnostic.code.value,
              target: asUri(diagnostic.code.target)
            };
          } else {
            result.code = diagnostic.code;
          }
        }
        if (diagnostic.source) {
          result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
          result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
          result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
      }
      function asRelatedInformation(relatedInformation) {
        return relatedInformation.map(asDiagnosticRelatedInformation);
      }
      function asDiagnosticRelatedInformation(information) {
        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);
      }
      function asDiagnosticTags(tags) {
        if (!tags) {
          return void 0;
        }
        let result = [];
        for (let tag of tags) {
          let converted = asDiagnosticTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length > 0 ? result : void 0;
      }
      function asDiagnosticTag(tag) {
        switch (tag) {
          case ls.DiagnosticTag.Unnecessary:
            return code.DiagnosticTag.Unnecessary;
          case ls.DiagnosticTag.Deprecated:
            return code.DiagnosticTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asPosition(value) {
        if (!value) {
          return void 0;
        }
        return new code.Position(value.line, value.character);
      }
      function asRange(value) {
        if (!value) {
          return void 0;
        }
        return new code.Range(asPosition(value.start), asPosition(value.end));
      }
      function asRanges(value) {
        return value.map((value2) => asRange(value2));
      }
      function asDiagnosticSeverity(value) {
        if (value === void 0 || value === null) {
          return code.DiagnosticSeverity.Error;
        }
        switch (value) {
          case ls.DiagnosticSeverity.Error:
            return code.DiagnosticSeverity.Error;
          case ls.DiagnosticSeverity.Warning:
            return code.DiagnosticSeverity.Warning;
          case ls.DiagnosticSeverity.Information:
            return code.DiagnosticSeverity.Information;
          case ls.DiagnosticSeverity.Hint:
            return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
      }
      function asHoverContent(value) {
        if (Is.string(value)) {
          return asMarkdownString(value);
        } else if (CodeBlock.is(value)) {
          let result = asMarkdownString();
          return result.appendCodeblock(value.value, value.language);
        } else if (Array.isArray(value)) {
          let result = [];
          for (let element of value) {
            let item = asMarkdownString();
            if (CodeBlock.is(element)) {
              item.appendCodeblock(element.value, element.language);
            } else {
              item.appendMarkdown(element);
            }
            result.push(item);
          }
          return result;
        } else {
          let result;
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              return asMarkdownString(value.value);
            case ls.MarkupKind.PlainText:
              result = asMarkdownString();
              result.appendText(value.value);
              return result;
            default:
              result = asMarkdownString();
              result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
              return result;
          }
        }
      }
      function asDocumentation(value) {
        if (Is.string(value)) {
          return value;
        } else {
          switch (value.kind) {
            case ls.MarkupKind.Markdown:
              return asMarkdownString(value.value);
            case ls.MarkupKind.PlainText:
              return value.value;
            default:
              return `Unsupported Markup content received. Kind is: ${value.kind}`;
          }
        }
      }
      function asMarkdownString(value) {
        const result = new code.MarkdownString(value);
        if (trustMarkdown === true) {
          result.isTrusted = trustMarkdown;
        }
        return result;
      }
      function asHover(hover) {
        if (!hover) {
          return void 0;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
      }
      function asCompletionResult(result) {
        if (!result) {
          return void 0;
        }
        if (Array.isArray(result)) {
          let items = result;
          return items.map(asCompletionItem);
        }
        let list = result;
        return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);
      }
      function asCompletionItemKind(value) {
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
          return [value - 1, void 0];
        }
        return [code.CompletionItemKind.Text, value];
      }
      function asCompletionItemTag(tag) {
        switch (tag) {
          case ls.CompletionItemTag.Deprecated:
            return code.CompletionItemTag.Deprecated;
        }
        return void 0;
      }
      function asCompletionItemTags(tags) {
        if (tags === void 0 || tags === null) {
          return [];
        }
        const result = [];
        for (let tag of tags) {
          const converted = asCompletionItemTag(tag);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result;
      }
      function asCompletionItem(item) {
        let tags = asCompletionItemTags(item.tags);
        let result = new protocolCompletionItem_1.default(item.label);
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
          result.documentationFormat = Is.string(item.documentation) ? "$string" : item.documentation.kind;
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        let insertText = asCompletionInsertText(item);
        if (insertText) {
          result.insertText = insertText.text;
          result.range = insertText.range;
          result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
          let [itemKind, original] = asCompletionItemKind(item.kind);
          result.kind = itemKind;
          if (original) {
            result.originalItemKind = original;
          }
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
          result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
          result.deprecated = item.deprecated;
          if (item.deprecated === true) {
            tags.push(code.CompletionItemTag.Deprecated);
          }
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        if (item.data !== void 0) {
          result.data = item.data;
        }
        if (tags.length > 0) {
          result.tags = tags;
        }
        if (item.insertTextMode !== void 0) {
          result.insertTextMode = item.insertTextMode;
          if (item.insertTextMode === vscode_languageserver_protocol_1.InsertTextMode.asIs) {
            result.keepWhitespace = true;
          }
        }
        return result;
      }
      function asCompletionInsertText(item) {
        if (item.textEdit) {
          if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(item.textEdit.newText), range: asCompletionRange(item.textEdit), fromEdit: true };
          } else {
            return { text: item.textEdit.newText, range: asCompletionRange(item.textEdit), fromEdit: true };
          }
        } else if (item.insertText) {
          if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
            return { text: new code.SnippetString(item.insertText), fromEdit: false };
          } else {
            return { text: item.insertText, fromEdit: false };
          }
        } else {
          return void 0;
        }
      }
      function asCompletionRange(value) {
        if (ls.InsertReplaceEdit.is(value)) {
          return { inserting: asRange(value.insert), replacing: asRange(value.replace) };
        } else {
          return asRange(value.range);
        }
      }
      function asTextEdit(edit) {
        if (!edit) {
          return void 0;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
      }
      function asTextEdits(items) {
        if (!items) {
          return void 0;
        }
        return items.map(asTextEdit);
      }
      function asSignatureHelp(item) {
        if (!item) {
          return void 0;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
          result.activeSignature = item.activeSignature;
        } else {
          result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
          result.activeParameter = item.activeParameter;
        } else {
          result.activeParameter = 0;
        }
        if (item.signatures) {
          result.signatures = asSignatureInformations(item.signatures);
        }
        return result;
      }
      function asSignatureInformations(items) {
        return items.map(asSignatureInformation);
      }
      function asSignatureInformation(item) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== void 0) {
          result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== void 0) {
          result.parameters = asParameterInformations(item.parameters);
        }
        if (item.activeParameter !== void 0) {
          result.activeParameter = item.activeParameter;
        }
        {
          return result;
        }
      }
      function asParameterInformations(item) {
        return item.map(asParameterInformation);
      }
      function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
          result.documentation = asDocumentation(item.documentation);
        }
        return result;
      }
      function asLocation(item) {
        if (!item) {
          return void 0;
        }
        return new code.Location(_uriConverter(item.uri), asRange(item.range));
      }
      function asDeclarationResult(item) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item);
      }
      function asDefinitionResult(item) {
        if (!item) {
          return void 0;
        }
        return asLocationResult(item);
      }
      function asLocationLink(item) {
        if (!item) {
          return void 0;
        }
        let result = {
          targetUri: _uriConverter(item.targetUri),
          targetRange: asRange(item.targetRange),
          originSelectionRange: asRange(item.originSelectionRange),
          targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
          throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
      }
      function asLocationResult(item) {
        if (!item) {
          return void 0;
        }
        if (Is.array(item)) {
          if (item.length === 0) {
            return [];
          } else if (ls.LocationLink.is(item[0])) {
            let links = item;
            return links.map((link) => asLocationLink(link));
          } else {
            let locations = item;
            return locations.map((location) => asLocation(location));
          }
        } else if (ls.LocationLink.is(item)) {
          return [asLocationLink(item)];
        } else {
          return asLocation(item);
        }
      }
      function asReferences(values) {
        if (!values) {
          return void 0;
        }
        return values.map((location) => asLocation(location));
      }
      function asDocumentHighlights(values) {
        if (!values) {
          return void 0;
        }
        return values.map(asDocumentHighlight);
      }
      function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
          result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
      }
      function asDocumentHighlightKind(item) {
        switch (item) {
          case ls.DocumentHighlightKind.Text:
            return code.DocumentHighlightKind.Text;
          case ls.DocumentHighlightKind.Read:
            return code.DocumentHighlightKind.Read;
          case ls.DocumentHighlightKind.Write:
            return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
      }
      function asSymbolInformations(values, uri) {
        if (!values) {
          return void 0;
        }
        return values.map((information) => asSymbolInformation(information, uri));
      }
      function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
          return item - 1;
        }
        return code.SymbolKind.Property;
      }
      function asSymbolTag(value) {
        switch (value) {
          case ls.SymbolTag.Deprecated:
            return code.SymbolTag.Deprecated;
          default:
            return void 0;
        }
      }
      function asSymbolTags(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        const result = [];
        for (const item of items) {
          const converted = asSymbolTag(item);
          if (converted !== void 0) {
            result.push(converted);
          }
        }
        return result.length === 0 ? void 0 : result;
      }
      function asSymbolInformation(item, uri) {
        let result = new code.SymbolInformation(item.name, asSymbolKind(item.kind), asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);
        fillTags(result, item);
        if (item.containerName) {
          result.containerName = item.containerName;
        }
        return result;
      }
      function asDocumentSymbols(values) {
        if (values === void 0 || values === null) {
          return void 0;
        }
        return values.map(asDocumentSymbol);
      }
      function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || "", asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== void 0 && value.children.length > 0) {
          let children = [];
          for (let child of value.children) {
            children.push(asDocumentSymbol(child));
          }
          result.children = children;
        }
        return result;
      }
      function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
          if (!result.tags) {
            result.tags = [code.SymbolTag.Deprecated];
          } else {
            if (!result.tags.includes(code.SymbolTag.Deprecated)) {
              result.tags = result.tags.concat(code.SymbolTag.Deprecated);
            }
          }
        }
      }
      function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
          result.arguments = item.arguments;
        }
        return result;
      }
      function asCommands(items) {
        if (!items) {
          return void 0;
        }
        return items.map(asCommand);
      }
      const kindMapping = /* @__PURE__ */ new Map();
      kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
      kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
      kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
      kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
      kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
      kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
      kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
      kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
      function asCodeActionKind(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = kindMapping.get(item);
        if (result) {
          return result;
        }
        let parts = item.split(".");
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
          result = result.append(part);
        }
        return result;
      }
      function asCodeActionKinds(items) {
        if (items === void 0 || items === null) {
          return void 0;
        }
        return items.map((kind) => asCodeActionKind(kind));
      }
      function asCodeAction(item) {
        if (item === void 0 || item === null) {
          return void 0;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== void 0) {
          result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== void 0) {
          result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== void 0) {
          result.edit = asWorkspaceEdit(item.edit);
        }
        if (item.command !== void 0) {
          result.command = asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== void 0) {
          result.disabled = { reason: item.disabled.reason };
        }
        return result;
      }
      function asCodeLens(item) {
        if (!item) {
          return void 0;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
          result.command = asCommand(item.command);
        }
        if (item.data !== void 0 && item.data !== null) {
          result.data = item.data;
        }
        return result;
      }
      function asCodeLenses(items) {
        if (!items) {
          return void 0;
        }
        return items.map((codeLens) => asCodeLens(codeLens));
      }
      function asWorkspaceEdit(item) {
        if (!item) {
          return void 0;
        }
        const sharedMetadata = /* @__PURE__ */ new Map();
        if (item.changeAnnotations !== void 0) {
          for (const key of Object.keys(item.changeAnnotations)) {
            const metaData = asWorkspaceEditEntryMetadata(item.changeAnnotations[key]);
            sharedMetadata.set(key, metaData);
          }
        }
        const asMetadata = (annotation) => {
          if (annotation === void 0) {
            return void 0;
          } else {
            return sharedMetadata.get(annotation);
          }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
          for (const change of item.documentChanges) {
            if (ls.CreateFile.is(change)) {
              result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.RenameFile.is(change)) {
              result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
            } else if (ls.DeleteFile.is(change)) {
              result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
            } else if (ls.TextDocumentEdit.is(change)) {
              const uri = _uriConverter(change.textDocument.uri);
              for (const edit of change.edits) {
                if (vscode_languageserver_protocol_1.AnnotatedTextEdit.is(edit)) {
                  result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                } else {
                  result.replace(uri, asRange(edit.range), edit.newText);
                }
              }
            } else {
              throw new Error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
            }
          }
        } else if (item.changes) {
          Object.keys(item.changes).forEach((key) => {
            result.set(_uriConverter(key), asTextEdits(item.changes[key]));
          });
        }
        return result;
      }
      function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === void 0) {
          return void 0;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
      }
      function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : void 0;
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== void 0) {
          link.tooltip = item.tooltip;
        }
        if (item.data !== void 0 && item.data !== null) {
          link.data = item.data;
        }
        return link;
      }
      function asDocumentLinks(items) {
        if (!items) {
          return void 0;
        }
        return items.map(asDocumentLink);
      }
      function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
      }
      function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
      }
      function asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
          return colorInformation.map(asColorInformation);
        }
        return void 0;
      }
      function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);
        if (cp.textEdit) {
          presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
      }
      function asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
          return colorPresentations.map(asColorPresentation);
        }
        return void 0;
      }
      function asFoldingRangeKind(kind) {
        if (kind) {
          switch (kind) {
            case ls.FoldingRangeKind.Comment:
              return code.FoldingRangeKind.Comment;
            case ls.FoldingRangeKind.Imports:
              return code.FoldingRangeKind.Imports;
            case ls.FoldingRangeKind.Region:
              return code.FoldingRangeKind.Region;
          }
        }
        return void 0;
      }
      function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
      }
      function asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
          return foldingRanges.map(asFoldingRange);
        }
        return void 0;
      }
      function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : void 0);
      }
      function asSelectionRanges(selectionRanges) {
        if (!Array.isArray(selectionRanges)) {
          return [];
        }
        let result = [];
        for (let range of selectionRanges) {
          result.push(asSelectionRange(range));
        }
        return result;
      }
      function asCallHierarchyItem(item) {
        if (item === null) {
          return void 0;
        }
        let result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || "", asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== void 0) {
          result.tags = asSymbolTags(item.tags);
        }
        return result;
      }
      function asCallHierarchyItems(items) {
        if (items === null) {
          return void 0;
        }
        return items.map((item) => asCallHierarchyItem(item));
      }
      function asCallHierarchyIncomingCall(item) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), asRanges(item.fromRanges));
      }
      function asCallHierarchyIncomingCalls(items) {
        if (items === null) {
          return void 0;
        }
        return items.map((item) => asCallHierarchyIncomingCall(item));
      }
      function asCallHierarchyOutgoingCall(item) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), asRanges(item.fromRanges));
      }
      function asCallHierarchyOutgoingCalls(items) {
        if (items === null) {
          return void 0;
        }
        return items.map((item) => asCallHierarchyOutgoingCall(item));
      }
      function asSemanticTokens(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
      }
      function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== void 0 ? new Uint32Array(value.data) : void 0);
      }
      function asSemanticTokensEdits(value) {
        if (value === void 0 || value === null) {
          return void 0;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
      }
      function asSemanticTokensLegend(value) {
        return value;
      }
      function asLinkedEditingRanges(value) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new code.LinkedEditingRanges(asRanges(value.ranges), asRegularExpression(value.wordPattern));
      }
      function asRegularExpression(value) {
        if (value === null || value === void 0) {
          return void 0;
        }
        return new RegExp(value);
      }
      return {
        asUri,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges
      };
    }
    exports2.createConverter = createConverter;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/async.js
var require_async = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Delayer = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Delayer2 = class {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = void 0;
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
      }
      trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
          this.cancelTimeout();
        }
        if (!this.completionPromise) {
          this.completionPromise = new Promise((resolve) => {
            this.onSuccess = resolve;
          }).then(() => {
            this.completionPromise = void 0;
            this.onSuccess = void 0;
            var result = this.task();
            this.task = void 0;
            return result;
          });
        }
        if (delay >= 0 || this.timeout === void 0) {
          this.timeout = vscode_languageserver_protocol_1.RAL().timer.setTimeout(() => {
            this.timeout = void 0;
            this.onSuccess(void 0);
          }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
      }
      forceDelivery() {
        if (!this.completionPromise) {
          return void 0;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = void 0;
        this.onSuccess = void 0;
        this.task = void 0;
        return result;
      }
      isTriggered() {
        return this.timeout !== void 0;
      }
      cancel() {
        this.cancelTimeout();
        this.completionPromise = void 0;
      }
      cancelTimeout() {
        if (this.timeout !== void 0) {
          vscode_languageserver_protocol_1.RAL().timer.clearTimeout(this.timeout);
          this.timeout = void 0;
        }
      }
    };
    exports2.Delayer = Delayer2;
  }
});

// node_modules/vscode-languageclient/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageclient/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse3(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse3;
    function generateUuid2() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid2;
  }
});

// node_modules/vscode-languageclient/lib/common/progressPart.js
var require_progressPart = __commonJS({
  "node_modules/vscode-languageclient/lib/common/progressPart.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressPart = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is3();
    var ProgressPart = class {
      constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._disposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done();
              done && done(this);
              break;
          }
        });
      }
      begin(params) {
        vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
          this._progress = progress;
          this._infinite = params.percentage === void 0;
          this._cancellationToken = cancellationToken;
          this._cancellationToken.onCancellationRequested(() => {
            this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
          });
          this.report(params);
          return new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
          });
        });
      }
      report(params) {
        if (this._infinite && Is.string(params.message)) {
          this._progress.report({ message: params.message });
        } else if (Is.number(params.percentage)) {
          let percentage = Math.max(0, Math.min(params.percentage, 100));
          let delta = Math.max(0, percentage - this._reported);
          this._progress.report({ message: params.message, increment: delta });
          this._reported += delta;
        }
      }
      cancel() {
        if (this._disposable) {
          this._disposable.dispose();
          this._disposable = void 0;
        }
        if (this._reject) {
          this._reject();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      done() {
        if (this._disposable) {
          this._disposable.dispose();
          this._disposable = void 0;
        }
        if (this._resolve) {
          this._resolve();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
    };
    exports2.ProgressPart = ProgressPart;
  }
});

// node_modules/vscode-languageclient/lib/common/client.js
var require_client = __commonJS({
  "node_modules/vscode-languageclient/lib/common/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseLanguageClient = exports2.MessageTransports = exports2.TextDocumentFeature = exports2.State = exports2.RevealOutputChannelOn = exports2.CloseAction = exports2.ErrorAction = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var configuration_1 = require_configuration();
    var c2p = require_codeConverter();
    var p2c = require_protocolConverter();
    var Is = require_is3();
    var async_1 = require_async();
    var UUID = require_uuid();
    var progressPart_1 = require_progressPart();
    var ConsoleLogger = class {
      error(message) {
        vscode_languageserver_protocol_1.RAL().console.error(message);
      }
      warn(message) {
        vscode_languageserver_protocol_1.RAL().console.warn(message);
      }
      info(message) {
        vscode_languageserver_protocol_1.RAL().console.info(message);
      }
      log(message) {
        vscode_languageserver_protocol_1.RAL().console.log(message);
      }
    };
    function createConnection2(input, output, errorHandler, closeHandler, options) {
      let logger = new ConsoleLogger();
      let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, options);
      connection.onError((data) => {
        errorHandler(data[0], data[1], data[2]);
      });
      connection.onClose(closeHandler);
      let result = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),
        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),
        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
          const defaultTraceOptions = {
            sendNotification: false,
            traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
          };
          if (sendNotificationOrTraceOptions === void 0) {
            connection.trace(value, tracer, defaultTraceOptions);
          } else if (Is.boolean(sendNotificationOrTraceOptions)) {
            connection.trace(value, tracer, sendNotificationOrTraceOptions);
          } else {
            connection.trace(value, tracer, sendNotificationOrTraceOptions);
          }
        },
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, void 0),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        end: () => connection.end(),
        dispose: () => connection.dispose()
      };
      return result;
    }
    var ErrorAction2;
    (function(ErrorAction3) {
      ErrorAction3[ErrorAction3["Continue"] = 1] = "Continue";
      ErrorAction3[ErrorAction3["Shutdown"] = 2] = "Shutdown";
    })(ErrorAction2 = exports2.ErrorAction || (exports2.ErrorAction = {}));
    var CloseAction2;
    (function(CloseAction3) {
      CloseAction3[CloseAction3["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction3[CloseAction3["Restart"] = 2] = "Restart";
    })(CloseAction2 = exports2.CloseAction || (exports2.CloseAction = {}));
    var DefaultErrorHandler = class {
      constructor(name, maxRestartCount) {
        this.name = name;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return ErrorAction2.Continue;
        }
        return ErrorAction2.Shutdown;
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
          return CloseAction2.Restart;
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            vscode_1.window.showErrorMessage(`The ${this.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted.`);
            return CloseAction2.DoNotRestart;
          } else {
            this.restarts.shift();
            return CloseAction2.Restart;
          }
        }
      }
    };
    var RevealOutputChannelOn;
    (function(RevealOutputChannelOn2) {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
    })(RevealOutputChannelOn = exports2.RevealOutputChannelOn || (exports2.RevealOutputChannelOn = {}));
    var State;
    (function(State2) {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Starting"] = 3] = "Starting";
      State2[State2["Running"] = 2] = "Running";
    })(State = exports2.State || (exports2.State = {}));
    var ClientState;
    (function(ClientState2) {
      ClientState2[ClientState2["Initial"] = 0] = "Initial";
      ClientState2[ClientState2["Starting"] = 1] = "Starting";
      ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
      ClientState2[ClientState2["Running"] = 3] = "Running";
      ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
      ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
    })(ClientState || (ClientState = {}));
    var SupportedSymbolKinds = [
      vscode_languageserver_protocol_1.SymbolKind.File,
      vscode_languageserver_protocol_1.SymbolKind.Module,
      vscode_languageserver_protocol_1.SymbolKind.Namespace,
      vscode_languageserver_protocol_1.SymbolKind.Package,
      vscode_languageserver_protocol_1.SymbolKind.Class,
      vscode_languageserver_protocol_1.SymbolKind.Method,
      vscode_languageserver_protocol_1.SymbolKind.Property,
      vscode_languageserver_protocol_1.SymbolKind.Field,
      vscode_languageserver_protocol_1.SymbolKind.Constructor,
      vscode_languageserver_protocol_1.SymbolKind.Enum,
      vscode_languageserver_protocol_1.SymbolKind.Interface,
      vscode_languageserver_protocol_1.SymbolKind.Function,
      vscode_languageserver_protocol_1.SymbolKind.Variable,
      vscode_languageserver_protocol_1.SymbolKind.Constant,
      vscode_languageserver_protocol_1.SymbolKind.String,
      vscode_languageserver_protocol_1.SymbolKind.Number,
      vscode_languageserver_protocol_1.SymbolKind.Boolean,
      vscode_languageserver_protocol_1.SymbolKind.Array,
      vscode_languageserver_protocol_1.SymbolKind.Object,
      vscode_languageserver_protocol_1.SymbolKind.Key,
      vscode_languageserver_protocol_1.SymbolKind.Null,
      vscode_languageserver_protocol_1.SymbolKind.EnumMember,
      vscode_languageserver_protocol_1.SymbolKind.Struct,
      vscode_languageserver_protocol_1.SymbolKind.Event,
      vscode_languageserver_protocol_1.SymbolKind.Operator,
      vscode_languageserver_protocol_1.SymbolKind.TypeParameter
    ];
    var SupportedCompletionItemKinds = [
      vscode_languageserver_protocol_1.CompletionItemKind.Text,
      vscode_languageserver_protocol_1.CompletionItemKind.Method,
      vscode_languageserver_protocol_1.CompletionItemKind.Function,
      vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
      vscode_languageserver_protocol_1.CompletionItemKind.Field,
      vscode_languageserver_protocol_1.CompletionItemKind.Variable,
      vscode_languageserver_protocol_1.CompletionItemKind.Class,
      vscode_languageserver_protocol_1.CompletionItemKind.Interface,
      vscode_languageserver_protocol_1.CompletionItemKind.Module,
      vscode_languageserver_protocol_1.CompletionItemKind.Property,
      vscode_languageserver_protocol_1.CompletionItemKind.Unit,
      vscode_languageserver_protocol_1.CompletionItemKind.Value,
      vscode_languageserver_protocol_1.CompletionItemKind.Enum,
      vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
      vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
      vscode_languageserver_protocol_1.CompletionItemKind.Color,
      vscode_languageserver_protocol_1.CompletionItemKind.File,
      vscode_languageserver_protocol_1.CompletionItemKind.Reference,
      vscode_languageserver_protocol_1.CompletionItemKind.Folder,
      vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
      vscode_languageserver_protocol_1.CompletionItemKind.Constant,
      vscode_languageserver_protocol_1.CompletionItemKind.Struct,
      vscode_languageserver_protocol_1.CompletionItemKind.Event,
      vscode_languageserver_protocol_1.CompletionItemKind.Operator,
      vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
    ];
    var SupportedSymbolTags = [
      vscode_languageserver_protocol_1.SymbolTag.Deprecated
    ];
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var FileFormattingOptions;
    (function(FileFormattingOptions2) {
      function fromConfiguration(document2) {
        const filesConfig = vscode_1.workspace.getConfiguration("files", document2);
        return {
          trimTrailingWhitespace: filesConfig.get("trimTrailingWhitespace"),
          trimFinalNewlines: filesConfig.get("trimFinalNewlines"),
          insertFinalNewline: filesConfig.get("insertFinalNewline")
        };
      }
      FileFormattingOptions2.fromConfiguration = fromConfiguration;
    })(FileFormattingOptions || (FileFormattingOptions = {}));
    var DynamicFeature;
    (function(DynamicFeature2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.register) && Is.func(candidate.unregister) && Is.func(candidate.dispose) && candidate.registrationType !== void 0;
      }
      DynamicFeature2.is = is;
    })(DynamicFeature || (DynamicFeature = {}));
    var DocumentNotifications = class {
      constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
      }
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (vscode_1.languages.match(selector, textDocument)) {
            return true;
          }
        }
        return false;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(data) {
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
          if (this._middleware) {
            this._middleware(data, (data2) => this._client.sendNotification(this._type, this._createParams(data2)));
          } else {
            this._client.sendNotification(this._type, this._createParams(data));
          }
          this.notificationSent(data);
        }
      }
      notificationSent(_data2) {
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const selector of this._selectors.values()) {
          if (vscode_1.languages.match(selector, document2)) {
            return {
              send: (data) => {
                this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    var DidOpenTextDocumentFeature = class extends DocumentNotifications {
      constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
        }
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
          let uri = textDocument.uri.toString();
          if (this._syncedDocuments.has(uri)) {
            return;
          }
          if (vscode_1.languages.match(documentSelector, textDocument)) {
            let middleware = this._client.clientOptions.middleware;
            let didOpen = (textDocument2) => {
              this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            if (middleware.didOpen) {
              middleware.didOpen(textDocument, didOpen);
            } else {
              didOpen(textDocument);
            }
            this._syncedDocuments.set(uri, textDocument);
          }
        });
      }
      notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      }
    };
    var DidCloseTextDocumentFeature = class extends DocumentNotifications {
      constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector } });
        }
      }
      notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
      }
      unregister(id) {
        let selector = this._selectors.get(id);
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (vscode_1.languages.match(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {
            let middleware = this._client.clientOptions.middleware;
            let didClose = (textDocument2) => {
              this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            if (middleware.didClose) {
              middleware.didClose(textDocument, didClose);
            } else {
              didClose(textDocument);
            }
          }
        });
      }
    };
    var DidChangeTextDocumentFeature = class {
      constructor(_client) {
        this._client = _client;
        this._changeData = /* @__PURE__ */ new Map();
        this._forcingDelivery = false;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          documentSelector: data.registerOptions.documentSelector,
          syncKind: data.registerOptions.syncKind
        });
      }
      callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        for (const changeData of this._changeData.values()) {
          if (vscode_1.languages.match(changeData.documentSelector, event.document)) {
            let middleware = this._client.clientOptions.middleware;
            if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
              let params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
              if (middleware.didChange) {
                middleware.didChange(event, () => this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params));
              } else {
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
              }
            } else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
              let didChange = (event2) => {
                if (this._changeDelayer) {
                  if (this._changeDelayer.uri !== event2.document.uri.toString()) {
                    this.forceDelivery();
                    this._changeDelayer.uri = event2.document.uri.toString();
                  }
                  this._changeDelayer.delayer.trigger(() => {
                    this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2.document));
                  });
                } else {
                  this._changeDelayer = {
                    uri: event2.document.uri.toString(),
                    delayer: new async_1.Delayer(200)
                  };
                  this._changeDelayer.delayer.trigger(() => {
                    this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event2.document));
                  }, -1);
                }
              };
              if (middleware.didChange) {
                middleware.didChange(event, didChange);
              } else {
                didChange(event);
              }
            }
          }
        }
      }
      unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._changeDelayer = void 0;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
          return;
        }
        try {
          this._forcingDelivery = true;
          this._changeDelayer.delayer.forceDelivery();
        } finally {
          this._forcingDelivery = false;
        }
      }
      getProvider(document2) {
        for (const changeData of this._changeData.values()) {
          if (vscode_1.languages.match(changeData.documentSelector, document2)) {
            return {
              send: (event) => {
                this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
    };
    var WillSaveFeature = class extends DocumentNotifications {
      constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifications.textDocumentFilter(selectors, willSaveEvent.document));
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
    };
    var WillSaveWaitUntilFeature = class {
      constructor(_client) {
        this._client = _client;
        this._selectors = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(event) {
        if (DocumentNotifications.textDocumentFilter(this._selectors.values(), event.document)) {
          let middleware = this._client.clientOptions.middleware;
          let willSaveWaitUntil = (event2) => {
            return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2)).then((edits) => {
              let vEdits = this._client.protocol2CodeConverter.asTextEdits(edits);
              return vEdits === void 0 ? [] : vEdits;
            });
          };
          event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    var DidSaveTextDocumentFeature = class extends DocumentNotifications {
      constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifications.textDocumentFilter);
        this._includeText = false;
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
    };
    var FileSystemWatcherFeature = class {
      constructor(_client, _notifyFileEvent) {
        this._client = _client;
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
      }
      initialize(_capabilities, _documentSelector) {
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
          if (!Is.string(watcher.globPattern)) {
            continue;
          }
          let watchCreate = true, watchChange = true, watchDelete = true;
          if (watcher.kind !== void 0 && watcher.kind !== null) {
            watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
            watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
          }
          let fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
          this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
          this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Created
          }), null, listeners);
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Changed
          }), null, listeners);
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
            uri: this._client.code2ProtocolConverter.asUri(resource),
            type: vscode_languageserver_protocol_1.FileChangeType.Deleted
          }), null, listeners);
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        }
      }
      dispose() {
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
    var TextDocumentFeature = class {
      constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability) {
          return [void 0, void 0];
        } else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
          const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
          const selector = capability.documentSelector || documentSelector;
          if (selector) {
            return [id, Object.assign({}, capability, { documentSelector: selector })];
          }
        } else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
          if (!documentSelector) {
            return [void 0, void 0];
          }
          let options = Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
          return [UUID.generateUuid(), options];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && vscode_1.languages.match(selector, textDocument)) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
    exports2.TextDocumentFeature = TextDocumentFeature;
    var WorkspaceFeature = class {
      constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((registration) => {
          registration.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    var CompletionItemFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let completion = ensure(ensure(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport: true,
          commitCharactersSupport: true,
          documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
          deprecatedSupport: true,
          preselectSupport: true,
          tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
          insertReplaceSupport: true,
          resolveSupport: {
            properties: ["documentation", "detail", "additionalTextEdits"]
          },
          insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const triggerCharacters = options.triggerCharacters || [];
        const provider = {
          provideCompletionItems: (document2, position, token, context) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const provideCompletionItems = (document3, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document3, position2, context2), token2).then(client.protocol2CodeConverter.asCompletionResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, error, null);
              });
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
          },
          resolveCompletionItem: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item2), token2).then(client.protocol2CodeConverter.asCompletionItem, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, error, item2);
              });
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCompletionItemProvider(options.documentSelector, provider, ...triggerCharacters), provider];
      }
    };
    var HoverFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = ensure(ensure(capabilities, "textDocument"), "hover");
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideHover: (document2, position, token) => {
            const client = this._client;
            const provideHover = (document3, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then(client.protocol2CodeConverter.asHover, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
          }
        };
        return [vscode_1.languages.registerHoverProvider(options.documentSelector, provider), provider];
      }
    };
    var SignatureHelpFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideSignatureHelp: (document2, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document3, position2, context2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document3, position2, context2), token2).then(client.protocol2CodeConverter.asSignatureHelp, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
          }
        };
        let disposable;
        if (options.retriggerCharacters === void 0) {
          const triggerCharacters = options.triggerCharacters || [];
          disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, ...triggerCharacters);
        } else {
          const metaData = {
            triggerCharacters: options.triggerCharacters || [],
            retriggerCharacters: options.retriggerCharacters || []
          };
          disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, metaData);
        }
        return [disposable, provider];
      }
    };
    var DefinitionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDefinition: (document2, position, token) => {
            const client = this._client;
            const provideDefinition = (document3, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
          }
        };
        return [vscode_1.languages.registerDefinitionProvider(options.documentSelector, provider), provider];
      }
    };
    var ReferencesFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "references").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideReferences: (document2, position, options2, token) => {
            const client = this._client;
            const _providerReferences = (document3, position2, options3, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document3, position2, options3), token2).then(client.protocol2CodeConverter.asReferences, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document2, position, options2, token, _providerReferences) : _providerReferences(document2, position, options2, token);
          }
        };
        return [vscode_1.languages.registerReferenceProvider(options.documentSelector, provider), provider];
      }
    };
    var DocumentHighlightFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentHighlights: (document2, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document3, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then(client.protocol2CodeConverter.asDocumentHighlights, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
          }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
      }
    };
    var DocumentSymbolFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentSymbols: (document2, token) => {
            const client = this._client;
            const _provideDocumentSymbols = (document3, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document3), token2).then((data) => {
                if (data === null) {
                  return void 0;
                }
                if (data.length === 0) {
                  return [];
                } else {
                  let element = data[0];
                  if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                    return client.protocol2CodeConverter.asDocumentSymbols(data);
                  } else {
                    return client.protocol2CodeConverter.asSymbolInformations(data);
                  }
                }
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
          }
        };
        const metaData = options.label !== void 0 ? { label: options.label } : void 0;
        return [vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, provider, metaData), provider];
      }
    };
    var WorkspaceSymbolFeature = class extends WorkspaceFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(_options) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query: query2 }, token2).then(client.protocol2CodeConverter.asSymbolInformations, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          }
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
      }
    };
    var CodeActionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              vscode_languageserver_protocol_1.CodeActionKind.Empty,
              vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
              vscode_languageserver_protocol_1.CodeActionKind.Refactor,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
              vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
              vscode_languageserver_protocol_1.CodeActionKind.Source,
              vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
            ]
          }
        };
        cap.honorsChangeAnnotations = false;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideCodeActions: (document2, range, context, token) => {
            const client = this._client;
            const _provideCodeActions = (document3, range2, context2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range: client.code2ProtocolConverter.asRange(range2),
                context: client.code2ProtocolConverter.asCodeActionContext(context2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token2).then((values) => {
                if (values === null) {
                  return void 0;
                }
                const result = [];
                for (let item of values) {
                  if (vscode_languageserver_protocol_1.Command.is(item)) {
                    result.push(client.protocol2CodeConverter.asCommand(item));
                  } else {
                    result.push(client.protocol2CodeConverter.asCodeAction(item));
                  }
                }
                return result;
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
          },
          resolveCodeAction: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const resolveCodeAction = (item2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, client.code2ProtocolConverter.asCodeAction(item2), token2).then(client.protocol2CodeConverter.asCodeAction, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, error, item2);
              });
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeActionsProvider(options.documentSelector, provider, options.codeActionKinds ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) } : void 0), provider];
      }
    };
    var CodeLensFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
          onDidChangeCodeLenses: eventEmitter.event,
          provideCodeLenses: (document2, token) => {
            const client = this._client;
            const provideCodeLenses = (document3, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document3), token2).then(client.protocol2CodeConverter.asCodeLenses, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
          },
          resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens2), token2).then(client.protocol2CodeConverter.asCodeLens, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, error, codeLens2);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [vscode_1.languages.registerCodeLensProvider(options.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
      }
    };
    var DocumentFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentFormattingEdits: (document2, options2, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document3, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token2).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options2, token);
          }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, provider), provider];
      }
    };
    var DocumentRangeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "rangeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentRangeFormattingEdits: (document2, range, options2, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document3, range2, options3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range: client.code2ProtocolConverter.asRange(range2),
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token2).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options2, token);
          }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, provider), provider];
      }
    };
    var DocumentOnTypeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideOnTypeFormattingEdits: (document2, position, ch, options2, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document3, position2, ch2, options3, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                position: client.code2ProtocolConverter.asPosition(position2),
                ch: ch2,
                options: client.code2ProtocolConverter.asFormattingOptions(options3, FileFormattingOptions.fromConfiguration(document3))
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token2).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options2, token);
          }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(options.documentSelector, provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
      }
    };
    var RenameFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename2 = ensure(ensure(capabilities, "textDocument"), "rename");
        rename2.dynamicRegistration = true;
        rename2.prepareSupport = true;
        rename2.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename2.honorsChangeAnnotations = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
          return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
          options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideRenameEdits: (document2, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document3, position2, newName2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                position: client.code2ProtocolConverter.asPosition(position2),
                newName: newName2
              };
              return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token2).then(client.protocol2CodeConverter.asWorkspaceEdit, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
          },
          prepareRename: options.prepareProvider ? (document2, position, token) => {
            const client = this._client;
            const prepareRename = (document3, position2, token2) => {
              let params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                position: client.code2ProtocolConverter.asPosition(position2)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token2).then((result) => {
                if (vscode_languageserver_protocol_1.Range.is(result)) {
                  return client.protocol2CodeConverter.asRange(result);
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                  return {
                    range: client.protocol2CodeConverter.asRange(result.range),
                    placeholder: result.placeholder
                  };
                }
                return Promise.reject(new Error(`The element can't be renamed.`));
              }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, error, void 0);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
          } : void 0
        };
        return [vscode_1.languages.registerRenameProvider(options.documentSelector, provider), provider];
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
      }
    };
    var DocumentLinkFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
          return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentLinks: (document2, token) => {
            const client = this._client;
            const provideDocumentLinks = (document3, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document3), token2).then(client.protocol2CodeConverter.asDocumentLinks, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
          },
          resolveDocumentLink: options.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link2), token2).then(client.protocol2CodeConverter.asDocumentLink, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, error, link2);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, provider), provider];
      }
    };
    var ConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        let section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== void 0) {
          this.register({
            id: UUID.generateUuid(),
            registerOptions: {
              section
            }
          });
        }
      }
      register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
          this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== void 0) {
          this.onDidChangeConfiguration(data.registerOptions.section, void 0);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        if (sections !== void 0 && event !== void 0) {
          let affected = sections.some((section) => event.affectsConfiguration(section));
          if (!affected) {
            return;
          }
        }
        let didChangeConfiguration = (sections2) => {
          if (sections2 === void 0) {
            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
            return;
          }
          this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections2) });
        };
        let middleware = this.getMiddleware();
        middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections);
      }
      extractSettingsInformation(keys) {
        function ensurePath(config, path) {
          let current = config;
          for (let i = 0; i < path.length - 1; i++) {
            let obj = current[path[i]];
            if (!obj) {
              obj = /* @__PURE__ */ Object.create(null);
              current[path[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let resource = this._client.clientOptions.workspaceFolder ? this._client.clientOptions.workspaceFolder.uri : void 0;
        let result = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config = null;
          if (index >= 0) {
            config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
          } else {
            config = vscode_1.workspace.getConfiguration(void 0, resource).get(key);
          }
          if (config) {
            let path = keys[i].split(".");
            ensurePath(result, path)[path[path.length - 1]] = configuration_1.toJSONObject(config);
          }
        }
        return result;
      }
      getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
          return middleware.workspace.didChangeConfiguration;
        } else {
          return void 0;
        }
      }
    };
    var ExecuteCommandFeature = class {
      constructor(_client) {
        this._client = _client;
        this._commands = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: UUID.generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
          let params = {
            command,
            arguments: args
          };
          return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(void 0, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, error, void 0);
          });
        };
        if (data.registerOptions.commands) {
          const disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      dispose() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
    var MessageTransports;
    (function(MessageTransports2) {
      function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports = exports2.MessageTransports || (exports2.MessageTransports = {}));
    var OnReady = class {
      constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
      }
      get isUsed() {
        return this._used;
      }
      resolve() {
        this._used = true;
        this._resolve();
      }
      reject(error) {
        this._used = true;
        this._reject(error);
      }
    };
    var BaseLanguageClient = class _BaseLanguageClient {
      constructor(id, name, clientOptions) {
        var _a5;
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false };
        if (clientOptions.markdown !== void 0 && clientOptions.markdown.isTrusted === true) {
          markdown.isTrusted = true;
        }
        this._clientOptions = {
          documentSelector: clientOptions.documentSelector || [],
          synchronize: clientOptions.synchronize || {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName || this._name,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error,
          stdioEncoding: clientOptions.stdioEncoding || "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: !!clientOptions.progressOnInitialization,
          errorHandler: clientOptions.errorHandler || this.createDefaultErrorHandler((_a5 = clientOptions.connectionOptions) === null || _a5 === void 0 ? void 0 : _a5.maxRestartCount),
          middleware: clientOptions.middleware || {},
          uriConverters: clientOptions.uriConverters,
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        this._initializeResult = void 0;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
          this._disposeOutputChannel = false;
        } else {
          this._outputChannel = void 0;
          this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._listeners = void 0;
        this._providers = void 0;
        this._diagnostics = void 0;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
          this._onReadyCallbacks = new OnReady(resolve, reject);
        });
        this._onStop = void 0;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (Is.string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : void 0);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : void 0, this._clientOptions.markdown.isTrusted);
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
      }
      get state() {
        return this._state;
      }
      set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      getPublicState() {
        if (this.state === ClientState.Running) {
          return State.Running;
        } else if (this.state === ClientState.Starting) {
          return State.Starting;
        } else {
          return State.Stopped;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        this.forceDocumentSync();
        try {
          return this._resolvedConnection.sendRequest(type, ...params);
        } catch (error) {
          this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onRequest(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          return this._resolvedConnection.onRequest(type, handler);
        } catch (error) {
          this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      sendNotification(type, params) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        this.forceDocumentSync();
        try {
          this._resolvedConnection.sendNotification(type, params);
        } catch (error) {
          this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onNotification(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          return this._resolvedConnection.onNotification(type, handler);
        } catch (error) {
          this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          if (vscode_languageserver_protocol_1.WorkDoneProgress.is(type)) {
            const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
            if (handleWorkDoneProgress !== void 0) {
              return this._resolvedConnection.onProgress(type, token, (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
              });
            }
          }
          return this._resolvedConnection.onProgress(type, token, handler);
        } catch (error) {
          this.error(`Registering progress handler for token ${token} failed.`, error);
          throw error;
        }
      }
      sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        this.forceDocumentSync();
        try {
          this._resolvedConnection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get protocol2CodeConverter() {
        return this._p2c;
      }
      get code2ProtocolConverter() {
        return this._c2p;
      }
      get onTelemetry() {
        return this._telemetryEmitter.event;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get traceOutputChannel() {
        if (this._traceOutputChannel) {
          return this._traceOutputChannel;
        }
        return this.outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== void 0 && maxRestartCount < 0) {
          throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this._name, maxRestartCount !== null && maxRestartCount !== void 0 ? maxRestartCount : 4);
      }
      set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
          this.resolveConnection().then((connection) => {
            connection.trace(this._trace, this._tracer, {
              sendNotification: false,
              traceFormat: this._traceFormat
            });
          });
        }, () => {
        });
      }
      data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (Is.string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (Is.string(data)) {
          return data;
        }
        return data.toString();
      }
      info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
          this.showNotificationMessage();
        }
      }
      warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
          this.showNotificationMessage();
        }
      }
      error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
          this.showNotificationMessage();
        }
      }
      showNotificationMessage() {
        vscode_1.window.showInformationMessage("A request has failed. See the output for more information.", "Go to output").then(() => {
          this.outputChannel.show(true);
        });
      }
      logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        if (data) {
          this.traceOutputChannel.appendLine(this.data2String(data));
        }
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.traceOutputChannel.append(`[LSP   - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
        } else {
          this.traceOutputChannel.append(`[Trace - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] `);
        }
        if (data) {
          this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      needsStart() {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
      }
      needsStop() {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
      }
      onReady() {
        return this._onReady;
      }
      isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
      }
      start() {
        if (this._onReadyCallbacks.isUsed) {
          this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = new OnReady(resolve, reject);
          });
        }
        this._listeners = [];
        this._providers = [];
        if (!this._diagnostics) {
          this._diagnostics = this._clientOptions.diagnosticCollectionName ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName) : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then((connection) => {
          connection.onLogMessage((message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                this.error(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                this.warn(message.message, void 0, false);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                this.info(message.message, void 0, false);
                break;
              default:
                this.outputChannel.appendLine(message.message);
            }
          });
          connection.onShowMessage((message) => {
            switch (message.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                vscode_1.window.showErrorMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                vscode_1.window.showWarningMessage(message.message);
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                vscode_1.window.showInformationMessage(message.message);
                break;
              default:
                vscode_1.window.showInformationMessage(message.message);
            }
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
              case vscode_languageserver_protocol_1.MessageType.Error:
                messageFunc = vscode_1.window.showErrorMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Warning:
                messageFunc = vscode_1.window.showWarningMessage;
                break;
              case vscode_languageserver_protocol_1.MessageType.Info:
                messageFunc = vscode_1.window.showInformationMessage;
                break;
              default:
                messageFunc = vscode_1.window.showInformationMessage;
            }
            let actions = params.actions || [];
            return messageFunc(params.message, ...actions);
          });
          connection.onTelemetry((data) => {
            this._telemetryEmitter.fire(data);
          });
          connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
            var _a5;
            const showDocument = async (params2) => {
              const uri = this.protocol2CodeConverter.asUri(params2.uri);
              try {
                if (params2.external === true) {
                  const success = await vscode_1.env.openExternal(uri);
                  return { success };
                } else {
                  const options = {};
                  if (params2.selection !== void 0) {
                    options.selection = this.protocol2CodeConverter.asRange(params2.selection);
                  }
                  if (params2.takeFocus === void 0 || params2.takeFocus === false) {
                    options.preserveFocus = true;
                  } else if (params2.takeFocus === true) {
                    options.preserveFocus = false;
                  }
                  await vscode_1.window.showTextDocument(uri, options);
                  return { success: true };
                }
              } catch (error) {
                return { success: true };
              }
            };
            const middleware = (_a5 = this._clientOptions.middleware.window) === null || _a5 === void 0 ? void 0 : _a5.showDocument;
            if (middleware !== void 0) {
              return middleware(params, showDocument);
            } else {
              return showDocument(params);
            }
          });
          connection.listen();
          return this.initialize(connection);
        }).then(void 0, (error) => {
          this.state = ClientState.StartFailed;
          this._onReadyCallbacks.reject(error);
          this.error("Starting client failed", error);
          vscode_1.window.showErrorMessage(`Couldn't start client ${this._name}`);
        });
        return new vscode_1.Disposable(() => {
          if (this.needsStop()) {
            this.stop();
          }
        });
      }
      resolveConnection() {
        if (!this._connectionPromise) {
          this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
      }
      initialize(connection) {
        this.refreshTrace(connection, false);
        let initOption = this._clientOptions.initializationOptions;
        let rootPath = this._clientOptions.workspaceFolder ? this._clientOptions.workspaceFolder.uri.fsPath : this._clientGetRootPath();
        let initParams = {
          processId: null,
          clientInfo: {
            name: vscode_1.env.appName,
            version: vscode_1.version
          },
          locale: this.getLocale(),
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: Is.func(initOption) ? initOption() : initOption,
          trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
          workspaceFolders: null
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
          const token = UUID.generateUuid();
          const part = new progressPart_1.ProgressPart(connection, token);
          initParams.workDoneToken = token;
          return this.doInitialize(connection, initParams).then((result) => {
            part.done();
            return result;
          }, (error) => {
            part.cancel();
            throw error;
          });
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      doInitialize(connection, initParams) {
        return connection.initialize(initParams).then((result) => {
          this._resolvedConnection = connection;
          this._initializeResult = result;
          this.state = ClientState.Running;
          let textDocumentSyncOptions = void 0;
          if (Is.number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection.onDiagnostics((params) => this.handleDiagnostics(params));
          connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
          this.hookFileEvents(connection);
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          this._onReadyCallbacks.resolve();
          return result;
        }).then(void 0, (error) => {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              this.initialize(connection);
            } else {
              this.stop();
              this._onReadyCallbacks.reject(error);
            }
          } else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
            vscode_1.window.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              if (item && item.id === "retry") {
                this.initialize(connection);
              } else {
                this.stop();
                this._onReadyCallbacks.reject(error);
              }
            });
          } else {
            if (error && error.message) {
              vscode_1.window.showErrorMessage(error.message);
            }
            this.error("Server initialization failed.", error);
            this.stop();
            this._onReadyCallbacks.reject(error);
          }
          throw error;
        });
      }
      _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
          return void 0;
        }
        let folder = folders[0];
        if (folder.uri.scheme === "file") {
          return folder.uri.fsPath;
        }
        return void 0;
      }
      stop() {
        this._initializeResult = void 0;
        if (!this._connectionPromise) {
          this.state = ClientState.Stopped;
          return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
          return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp(false);
        return this._onStop = this.resolveConnection().then((connection) => {
          return connection.shutdown().then(() => {
            connection.exit();
            connection.end();
            connection.dispose();
            this.state = ClientState.Stopped;
            this.cleanUpChannel();
            this._onStop = void 0;
            this._connectionPromise = void 0;
            this._resolvedConnection = void 0;
          });
        });
      }
      cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
          this._listeners.forEach((listener) => listener.dispose());
          this._listeners = void 0;
        }
        if (this._providers) {
          this._providers.forEach((provider) => provider.dispose());
          this._providers = void 0;
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (const feature of this._features.values()) {
          feature.dispose();
        }
        if (channel) {
          this.cleanUpChannel();
        }
        if (diagnostics && this._diagnostics) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel && this._disposeOutputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      notifyFileEvent(event) {
        var _a5;
        const client = this;
        function didChangeWatchedFile(event2) {
          client._fileEvents.push(event2);
          client._fileEventDelayer.trigger(() => {
            client.onReady().then(() => {
              client.resolveConnection().then((connection) => {
                if (client.isConnectionActive()) {
                  client.forceDocumentSync();
                  connection.didChangeWatchedFiles({ changes: client._fileEvents });
                }
                client._fileEvents = [];
              });
            }, (error) => {
              client.error(`Notify file events failed.`, error);
            });
          });
        }
        const workSpaceMiddleware = (_a5 = this.clientOptions.middleware) === null || _a5 === void 0 ? void 0 : _a5.workspace;
        (workSpaceMiddleware === null || workSpaceMiddleware === void 0 ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
      }
      forceDocumentSync() {
        if (this._didChangeTextDocumentFeature === void 0) {
          this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
        }
        this._didChangeTextDocumentFeature.forceDelivery();
      }
      handleDiagnostics(params) {
        if (!this._diagnostics) {
          return;
        }
        let uri = this._p2c.asUri(params.uri);
        let diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        let middleware = this.clientOptions.middleware;
        if (middleware.handleDiagnostics) {
          middleware.handleDiagnostics(uri, diagnostics, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
        } else {
          this.setDiagnostics(uri, diagnostics);
        }
      }
      setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
          return;
        }
        this._diagnostics.set(uri, diagnostics);
      }
      createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
          this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8").then((transports) => {
          return createConnection2(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        });
      }
      handleConnectionClosed() {
        if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
          return;
        }
        try {
          if (this._resolvedConnection) {
            this._resolvedConnection.dispose();
          }
        } catch (error) {
        }
        let action = CloseAction2.DoNotRestart;
        try {
          action = this._clientOptions.errorHandler.closed();
        } catch (error) {
        }
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        if (action === CloseAction2.DoNotRestart) {
          this.error("Connection to server got closed. Server will not be restarted.");
          if (this.state === ClientState.Starting) {
            this._onReadyCallbacks.reject(new Error(`Connection to server got closed. Server will not be restarted.`));
            this.state = ClientState.StartFailed;
          } else {
            this.state = ClientState.Stopped;
          }
          this.cleanUp(false, true);
        } else if (action === CloseAction2.Restart) {
          this.info("Connection to server got closed. Server will restart.");
          this.cleanUp(false, false);
          this.state = ClientState.Initial;
          this.start();
        }
      }
      handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction2.Shutdown) {
          this.error("Connection to server is erroring. Shutting down server.");
          this.stop();
        }
      }
      hookConfigurationChanged(connection) {
        vscode_1.workspace.onDidChangeConfiguration(() => {
          this.refreshTrace(connection, true);
        });
      }
      refreshTrace(connection, sendNotification = false) {
        let config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
          } else {
            trace = vscode_languageserver_protocol_1.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        });
      }
      hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
          return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
          watchers = fileEvents;
        } else {
          watchers = [fileEvents];
        }
        if (!watchers) {
          return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature);
        }
      }
      registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getFeature(request) {
        return this._dynamicFeatures.get(request);
      }
      registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new CompletionItemFeature(this));
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (Is.func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        ensure(result, "workspace").applyEdit = true;
        const workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: true
        };
        const diagnostics = ensure(ensure(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = ensure(result, "window");
        const showMessage = ensure(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = ensure(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = ensure(result, "general");
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = { parser: "marked", version: "1.1.0" };
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      handleRegistrationRequest(params) {
        return new Promise((resolve, reject) => {
          for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (feature === void 0) {
              reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
              return;
            }
            const options = registration.registerOptions || {};
            options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
            const data = {
              id: registration.id,
              registerOptions: options
            };
            try {
              feature.register(data);
            } catch (err) {
              reject(err);
              return;
            }
          }
          resolve();
        });
      }
      handleUnregistrationRequest(params) {
        return new Promise((resolve, reject) => {
          for (let unregistration of params.unregisterations) {
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
              return;
            }
            feature.unregister(unregistration.id);
          }
          resolve();
        });
      }
      handleApplyWorkspaceEdit(params) {
        let workspaceEdit = params.edit;
        let openTextDocuments = /* @__PURE__ */ new Map();
        vscode_1.workspace.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              let textDocument = openTextDocuments.get(change.textDocument.uri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then((value) => {
          return { applied: value };
        }));
      }
      handleFailedRequest(type, error, defaultValue) {
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
          if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled) {
            throw this.makeCancelError();
          } else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
            return defaultValue;
          }
        }
        this.error(`Request ${type.method} failed.`, error);
        throw error;
      }
      makeCancelError() {
        const result = new Error(_BaseLanguageClient.Canceled);
        result.name = _BaseLanguageClient.Canceled;
        return result;
      }
    };
    exports2.BaseLanguageClient = BaseLanguageClient;
    BaseLanguageClient.Canceled = "Canceled";
  }
});

// node_modules/vscode-languageclient/lib/common/typeDefinition.js
var require_typeDefinition = __commonJS({
  "node_modules/vscode-languageclient/lib/common/typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionFeature = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var TypeDefinitionFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "typeDefinition").dynamicRegistration = true;
        let typeDefinitionSupport = ensure(ensure(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideTypeDefinition: (document2, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document3, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
          }
        };
        return [vscode_1.languages.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
      }
    };
    exports2.TypeDefinitionFeature = TypeDefinitionFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/implementation.js
var require_implementation = __commonJS({
  "node_modules/vscode-languageclient/lib/common/implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationFeature = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var ImplementationFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let implementationSupport = ensure(ensure(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideImplementation: (document2, position, token) => {
            const client = this._client;
            const provideImplementation = (document3, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
          }
        };
        return [vscode_1.languages.registerImplementationProvider(options.documentSelector, provider), provider];
      }
    };
    exports2.ImplementationFeature = ImplementationFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/colorProvider.js
var require_colorProvider = __commonJS({
  "node_modules/vscode-languageclient/lib/common/colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorProviderFeature = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var ColorProviderFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
                range: client.code2ProtocolConverter.asRange(context2.range)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token2).then(this.asColorPresentations.bind(this), (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document2, token) => {
            const client = this._client;
            const provideDocumentColors = (document3, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token2).then(this.asColorInformations.bind(this), (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
          }
        };
        return [vscode_1.languages.registerColorProvider(options.documentSelector, provider), provider];
      }
      asColor(color) {
        return new vscode_1.Color(color.red, color.green, color.blue, color.alpha);
      }
      asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
          return colorInformation.map((ci) => {
            return new vscode_1.ColorInformation(this._client.protocol2CodeConverter.asRange(ci.range), this.asColor(ci.color));
          });
        }
        return [];
      }
      asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
          return colorPresentations.map((cp) => {
            let presentation = new vscode_1.ColorPresentation(cp.label);
            presentation.additionalTextEdits = this._client.protocol2CodeConverter.asTextEdits(cp.additionalTextEdits);
            presentation.textEdit = this._client.protocol2CodeConverter.asTextEdit(cp.textEdit);
            return presentation;
          });
        }
        return [];
      }
    };
    exports2.ColorProviderFeature = ColorProviderFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/workspaceFolders.js
var require_workspaceFolders = __commonJS({
  "node_modules/vscode-languageclient/lib/common/workspaceFolders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = exports2.arrayDiff = void 0;
    var UUID = require_uuid();
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    function access(target, key) {
      if (target === void 0) {
        return void 0;
      }
      return target[key];
    }
    function arrayDiff(left, right) {
      return left.filter((element) => right.indexOf(element) < 0);
    }
    exports2.arrayDiff = arrayDiff;
    var WorkspaceFoldersFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
      }
      fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
          const workspaceFolders = () => {
            const folders = vscode_1.workspace.workspaceFolders;
            if (folders === void 0) {
              return null;
            }
            const result = folders.map((folder) => {
              return this.asProtocol(folder);
            });
            return result;
          };
          const middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value === true) {
          id = UUID.generateUuid();
        }
        if (id) {
          this.register({ id, registerOptions: void 0 });
        }
      }
      sendInitialEvent(currentWorkspaceFolders) {
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          this.doSendEvent(currentWorkspaceFolders, []);
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
      }
      register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (event2) => {
            this.doSendEvent(event2.added, event2.removed);
          };
          let middleware = client.clientOptions.middleware.workspace;
          middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
          return;
        }
        this._listeners.delete(id);
        disposable.dispose();
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
          return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
      }
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageclient/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var FoldingRangeFeature = class _FoldingRangeFeature extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideFoldingRanges: (document2, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document3, _, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
              };
              return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token2).then(_FoldingRangeFeature.asFoldingRanges, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
          }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(options.documentSelector, provider), provider];
      }
      static asFoldingRangeKind(kind) {
        if (kind) {
          switch (kind) {
            case vscode_languageserver_protocol_1.FoldingRangeKind.Comment:
              return vscode_1.FoldingRangeKind.Comment;
            case vscode_languageserver_protocol_1.FoldingRangeKind.Imports:
              return vscode_1.FoldingRangeKind.Imports;
            case vscode_languageserver_protocol_1.FoldingRangeKind.Region:
              return vscode_1.FoldingRangeKind.Region;
          }
        }
        return void 0;
      }
      static asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
          return foldingRanges.map((r) => {
            return new vscode_1.FoldingRange(r.startLine, r.endLine, _FoldingRangeFeature.asFoldingRangeKind(r.kind));
          });
        }
        return [];
      }
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageclient/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var CallHierarchyProvider = class {
      constructor(client) {
        this.client = client;
        this.middleware = client.clientOptions.middleware;
      }
      prepareCallHierarchy(document2, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document3, position2, token2) => {
          const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asCallHierarchyItems(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, error, null);
          });
        };
        return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
      }
      provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, error, null);
          });
        };
        return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
      }
      provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item2, token2) => {
          const params = {
            item: client.code2ProtocolConverter.asCallHierarchyItem(item2)
          };
          return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token2).then((result) => {
            return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result);
          }, (error) => {
            return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, error, null);
          });
        };
        return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
      }
    };
    var CallHierarchyFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(options.documentSelector, provider), provider];
      }
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageclient/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensFeature = void 0;
    var vscode = require_vscode_compatibility();
    var client_1 = require_client();
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is3();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var SemanticTokensFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
          vscode_languageserver_protocol_1.SemanticTokenTypes.type,
          vscode_languageserver_protocol_1.SemanticTokenTypes.class,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
          vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
          vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
          vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
          vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
          vscode_languageserver_protocol_1.SemanticTokenTypes.property,
          vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
          vscode_languageserver_protocol_1.SemanticTokenTypes.event,
          vscode_languageserver_protocol_1.SemanticTokenTypes.function,
          vscode_languageserver_protocol_1.SemanticTokenTypes.method,
          vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
          vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
          vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
          vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
          vscode_languageserver_protocol_1.SemanticTokenTypes.string,
          vscode_languageserver_protocol_1.SemanticTokenTypes.number,
          vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
          vscode_languageserver_protocol_1.SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
          vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
          vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        ensure(ensure(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== void 0;
        const hasEditProvider = options.full !== void 0 && typeof options.full !== "boolean" && options.full.delta === true;
        const eventEmitter = new vscode.EventEmitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document2, token) => {
            const client2 = this._client;
            const middleware = client2.clientOptions.middleware;
            const provideDocumentSemanticTokens = (document3, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token2).then((result) => {
                return client2.protocol2CodeConverter.asSemanticTokens(result);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
            const client2 = this._client;
            const middleware = client2.clientOptions.middleware;
            const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                previousResultId: previousResultId2
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token2).then((result) => {
                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                  return client2.protocol2CodeConverter.asSemanticTokens(result);
                } else {
                  return client2.protocol2CodeConverter.asSemanticTokensEdits(result);
                }
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, error, null);
              });
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document2, range, token) => {
            const client2 = this._client;
            const middleware = client2.clientOptions.middleware;
            const provideDocumentRangeSemanticTokens = (document3, range2, token2) => {
              const params = {
                textDocument: client2.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range: client2.code2ProtocolConverter.asRange(range2)
              };
              return client2.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token2).then((result) => {
                return client2.protocol2CodeConverter.asSemanticTokens(result);
              }, (error) => {
                return client2.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, error, null);
              });
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range, token);
          }
        } : void 0;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        if (documentProvider !== void 0) {
          disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(options.documentSelector, documentProvider, legend));
        }
        if (rangeProvider !== void 0) {
          disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(options.documentSelector, rangeProvider, legend));
        }
        return [new vscode.Disposable(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
  }
});

// node_modules/vscode-languageclient/lib/common/declaration.js
var require_declaration = __commonJS({
  "node_modules/vscode-languageclient/lib/common/declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationFeature = void 0;
    var vscode_1 = require_vscode_compatibility();
    var vscode_languageserver_protocol_1 = require_main3();
    var client_1 = require_client();
    function ensure(target, key) {
      if (target[key] === void 0) {
        target[key] = {};
      }
      return target[key];
    }
    var DeclarationFeature = class extends client_1.TextDocumentFeature {
      constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const declarationSupport = ensure(ensure(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
          return;
        }
        this.register({ id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDeclaration: (document2, position, token) => {
            const client = this._client;
            const provideDeclaration = (document3, position2, token2) => {
              return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2).then(client.protocol2CodeConverter.asDeclarationResult, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, error, null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
          }
        };
        return [vscode_1.languages.registerDeclarationProvider(options.documentSelector, provider), provider];
      }
    };
    exports2.DeclarationFeature = DeclarationFeature;
  }
});

// node_modules/monaco-languageclient/lib/monaco-language-client.js
var require_monaco_language_client = __commonJS({
  "node_modules/monaco-languageclient/lib/monaco-language-client.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !exports3.hasOwnProperty(p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonacoLanguageClient = void 0;
    var client_1 = require_client();
    var typeDefinition_1 = require_typeDefinition();
    var configuration_1 = require_configuration();
    var implementation_1 = require_implementation();
    var colorProvider_1 = require_colorProvider();
    var workspaceFolders_1 = require_workspaceFolders();
    var foldingRange_1 = require_foldingRange();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var declaration_1 = require_declaration();
    __exportStar(require_client(), exports2);
    var MonacoLanguageClient2 = class _MonacoLanguageClient extends client_1.BaseLanguageClient {
      constructor({ id, name, clientOptions, connectionProvider }) {
        super(id || name.toLowerCase(), name, clientOptions);
        this.connectionProvider = connectionProvider;
        this.createConnection = this.doCreateConnection.bind(this);
        const self2 = this;
        self2._p2c = new Proxy(self2._p2c, {
          get: (target, prop) => {
            if (prop === "asUri") {
              return target[prop];
            }
            return _MonacoLanguageClient.bypassConversion;
          }
        });
        self2._c2p = new Proxy(self2._c2p, {
          get: (target, prop) => {
            if (prop === "asUri") {
              return target[prop];
            }
            if (prop === "asCompletionParams") {
              return (textDocument, position, context) => {
                return {
                  textDocument: target.asTextDocumentIdentifier(textDocument),
                  position,
                  context
                };
              };
            }
            if (prop === "asWillSaveTextDocumentParams") {
              return (event) => {
                return {
                  textDocument: target.asTextDocumentIdentifier(event.document),
                  reason: event.reason
                };
              };
            }
            if (prop.endsWith("Params")) {
              return target[prop];
            }
            return _MonacoLanguageClient.bypassConversion;
          }
        });
      }
      doCreateConnection() {
        const errorHandler = this.handleConnectionError.bind(this);
        const closeHandler = this.handleConnectionClosed.bind(this);
        return this.connectionProvider.get(errorHandler, closeHandler, this.outputChannel);
      }
      createMessageTransports(encoding) {
        throw new Error("Unsupported");
      }
      registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        foldingRange_1.FoldingRangeFeature["asFoldingRanges"] = _MonacoLanguageClient.bypassConversion;
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        const features = this["_features"];
        for (const feature of features) {
          if (feature instanceof colorProvider_1.ColorProviderFeature) {
            feature["asColor"] = _MonacoLanguageClient.bypassConversion;
            feature["asColorInformations"] = _MonacoLanguageClient.bypassConversion;
            feature["asColorPresentations"] = _MonacoLanguageClient.bypassConversion;
          }
        }
      }
      registerProposedFeatures() {
      }
      getLocale() {
        return navigator.language || "en-US";
      }
    };
    exports2.MonacoLanguageClient = MonacoLanguageClient2;
    MonacoLanguageClient2.bypassConversion = (result) => result || void 0;
  }
});

// node_modules/monaco-languageclient/lib/monaco-commands.js
var require_monaco_commands = __commonJS({
  "node_modules/monaco-languageclient/lib/monaco-commands.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonacoCommands = void 0;
    var MonacoCommands = class {
      constructor(_monaco) {
        this._monaco = _monaco;
      }
      registerCommand(command, callback, thisArg) {
        return this._monaco.editor.registerCommand(command, (accessor, ...args) => callback.call(thisArg, ...args));
      }
    };
    exports2.MonacoCommands = MonacoCommands;
  }
});

// node_modules/monaco-languageclient/lib/console-window.js
var require_console_window = __commonJS({
  "node_modules/monaco-languageclient/lib/console-window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConsoleWindow = void 0;
    var services_1 = require_services();
    var ConsoleWindow = class {
      constructor() {
        this.channels = /* @__PURE__ */ new Map();
      }
      showMessage(type, message, ...actions) {
        if (type === services_1.MessageType.Error) {
          console.error(message);
        }
        if (type === services_1.MessageType.Warning) {
          console.warn(message);
        }
        if (type === services_1.MessageType.Info) {
          console.info(message);
        }
        if (type === services_1.MessageType.Log) {
          console.log(message);
        }
        return Promise.resolve(void 0);
      }
      createOutputChannel(name) {
        const existing = this.channels.get(name);
        if (existing) {
          return existing;
        }
        const channel = {
          append(value) {
            console.log(name + ": " + value);
          },
          appendLine(line) {
            console.log(name + ": " + line);
          },
          show() {
          },
          dispose() {
          }
        };
        this.channels.set(name, channel);
        return channel;
      }
    };
    exports2.ConsoleWindow = ConsoleWindow;
  }
});

// node_modules/glob-to-regexp/index.js
var require_glob_to_regexp = __commonJS({
  "node_modules/glob-to-regexp/index.js"(exports2, module2) {
    module2.exports = function(glob, opts) {
      if (typeof glob !== "string") {
        throw new TypeError("Expected a string");
      }
      var str = String(glob);
      var reStr = "";
      var extended = opts ? !!opts.extended : false;
      var globstar = opts ? !!opts.globstar : false;
      var inGroup = false;
      var flags = opts && typeof opts.flags === "string" ? opts.flags : "";
      var c;
      for (var i = 0, len = str.length; i < len; i++) {
        c = str[i];
        switch (c) {
          case "/":
          case "$":
          case "^":
          case "+":
          case ".":
          case "(":
          case ")":
          case "=":
          case "!":
          case "|":
            reStr += "\\" + c;
            break;
          case "?":
            if (extended) {
              reStr += ".";
              break;
            }
          case "[":
          case "]":
            if (extended) {
              reStr += c;
              break;
            }
          case "{":
            if (extended) {
              inGroup = true;
              reStr += "(";
              break;
            }
          case "}":
            if (extended) {
              inGroup = false;
              reStr += ")";
              break;
            }
          case ",":
            if (inGroup) {
              reStr += "|";
              break;
            }
            reStr += "\\" + c;
            break;
          case "*":
            var prevChar = str[i - 1];
            var starCount = 1;
            while (str[i + 1] === "*") {
              starCount++;
              i++;
            }
            var nextChar = str[i + 1];
            if (!globstar) {
              reStr += ".*";
            } else {
              var isGlobstar = starCount > 1 && (prevChar === "/" || prevChar === void 0) && (nextChar === "/" || nextChar === void 0);
              if (isGlobstar) {
                reStr += "((?:[^/]*(?:/|$))*)";
                i++;
              } else {
                reStr += "([^/]*)";
              }
            }
            break;
          default:
            reStr += c;
        }
      }
      if (!flags || !~flags.indexOf("g")) {
        reStr = "^" + reStr + "$";
      }
      return new RegExp(reStr, flags);
    };
  }
});

// node_modules/monaco-languageclient/lib/monaco-diagnostic-collection.js
var require_monaco_diagnostic_collection = __commonJS({
  "node_modules/monaco-languageclient/lib/monaco-diagnostic-collection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonacoModelDiagnostics = exports2.MonacoDiagnosticCollection = void 0;
    var disposable_1 = require_disposable2();
    var MonacoDiagnosticCollection = class {
      constructor(_monaco, name, p2m) {
        this._monaco = _monaco;
        this.name = name;
        this.p2m = p2m;
        this.diagnostics = /* @__PURE__ */ new Map();
        this.toDispose = new disposable_1.DisposableCollection();
      }
      dispose() {
        this.toDispose.dispose();
      }
      get(uri) {
        const diagnostics = this.diagnostics.get(uri);
        return !!diagnostics ? diagnostics.diagnostics : [];
      }
      set(uri, diagnostics) {
        const existing = this.diagnostics.get(uri);
        if (existing) {
          existing.diagnostics = diagnostics;
        } else {
          const modelDiagnostics = new MonacoModelDiagnostics(this._monaco, uri, diagnostics, this.name, this.p2m);
          this.diagnostics.set(uri, modelDiagnostics);
          this.toDispose.push(disposable_1.Disposable.create(() => {
            this.diagnostics.delete(uri);
            modelDiagnostics.dispose();
          }));
        }
      }
    };
    exports2.MonacoDiagnosticCollection = MonacoDiagnosticCollection;
    var MonacoModelDiagnostics = class {
      constructor(_monaco, uri, diagnostics, owner, p2m) {
        this._monaco = _monaco;
        this.owner = owner;
        this.p2m = p2m;
        this._markers = [];
        this._diagnostics = [];
        this.toDispose = new disposable_1.DisposableCollection();
        this.uri = this._monaco.Uri.parse(uri);
        this.diagnostics = diagnostics;
        this.toDispose.push(this._monaco.editor.onDidCreateModel((model) => this.doUpdateModelMarkers(model)));
      }
      set diagnostics(diagnostics) {
        this._diagnostics = diagnostics;
        this._markers = this.p2m.asDiagnostics(diagnostics);
        this.updateModelMarkers();
      }
      get diagnostics() {
        return this._diagnostics;
      }
      get markers() {
        return this._markers;
      }
      dispose() {
        this._markers = [];
        this.updateModelMarkers();
        this.toDispose.dispose();
      }
      updateModelMarkers() {
        const model = this._monaco.editor.getModel(this.uri);
        this.doUpdateModelMarkers(model ? model : void 0);
      }
      doUpdateModelMarkers(model) {
        if (model && this.uri.toString() === model.uri.toString()) {
          this._monaco.editor.setModelMarkers(model, this.owner, this._markers);
        }
      }
    };
    exports2.MonacoModelDiagnostics = MonacoModelDiagnostics;
  }
});

// node_modules/monaco-languageclient/lib/monaco-languages.js
var require_monaco_languages = __commonJS({
  "node_modules/monaco-languageclient/lib/monaco-languages.js"(exports2) {
    "use strict";
    var __awaiter46 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonacoLanguages = exports2.testGlob = exports2.MonacoModelIdentifier = void 0;
    var globToRegExp = require_glob_to_regexp();
    var services_1 = require_services();
    var monaco_diagnostic_collection_1 = require_monaco_diagnostic_collection();
    var disposable_1 = require_disposable2();
    var MonacoModelIdentifier;
    (function(MonacoModelIdentifier2) {
      function fromDocument(_monaco, document2) {
        return {
          uri: _monaco.Uri.parse(document2.uri),
          languageId: document2.languageId
        };
      }
      MonacoModelIdentifier2.fromDocument = fromDocument;
      function fromModel(model) {
        return {
          uri: model.uri,
          languageId: model.getModeId()
        };
      }
      MonacoModelIdentifier2.fromModel = fromModel;
    })(MonacoModelIdentifier = exports2.MonacoModelIdentifier || (exports2.MonacoModelIdentifier = {}));
    function testGlob(pattern, value) {
      const regExp = globToRegExp(pattern, {
        extended: true,
        globstar: true
      });
      return regExp.test(value);
    }
    exports2.testGlob = testGlob;
    var MonacoLanguages = class {
      constructor(_monaco, p2m, m2p) {
        this._monaco = _monaco;
        this.p2m = p2m;
        this.m2p = m2p;
      }
      match(selector, document2) {
        return this.matchModel(selector, MonacoModelIdentifier.fromDocument(this._monaco, document2));
      }
      createDiagnosticCollection(name) {
        return new monaco_diagnostic_collection_1.MonacoDiagnosticCollection(this._monaco, name || "default", this.p2m);
      }
      registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
        const completionProvider = this.createCompletionProvider(selector, provider, ...triggerCharacters);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerCompletionItemProvider(language, completionProvider));
        }
        ;
        return providers;
      }
      createCompletionProvider(selector, provider, ...triggerCharacters) {
        return {
          triggerCharacters,
          provideCompletionItems: (model, position, context, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const wordUntil = model.getWordUntilPosition(position);
            const defaultRange = new this._monaco.Range(position.lineNumber, wordUntil.startColumn, position.lineNumber, wordUntil.endColumn);
            const params = this.m2p.asCompletionParams(model, position, context);
            const result = yield provider.provideCompletionItems(params, token);
            return result && this.p2m.asCompletionResult(result, defaultRange);
          }),
          resolveCompletionItem: provider.resolveCompletionItem ? (item, token) => __awaiter46(this, void 0, void 0, function* () {
            const protocolItem = this.m2p.asCompletionItem(item);
            const resolvedItem = yield provider.resolveCompletionItem(protocolItem, token);
            if (resolvedItem) {
              const resolvedCompletionItem = this.p2m.asCompletionItem(resolvedItem, item.range);
              Object.assign(item, resolvedCompletionItem);
            }
            return item;
          }) : void 0
        };
      }
      registerHoverProvider(selector, provider) {
        const hoverProvider = this.createHoverProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerHoverProvider(language, hoverProvider));
        }
        return providers;
      }
      createHoverProvider(selector, provider) {
        return {
          provideHover: (model, position, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asTextDocumentPositionParams(model, position);
            const hover = yield provider.provideHover(params, token);
            return hover && this.p2m.asHover(hover);
          })
        };
      }
      registerSignatureHelpProvider(selector, provider, ...triggerCharacters) {
        const signatureHelpProvider = this.createSignatureHelpProvider(selector, provider, ...triggerCharacters);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerSignatureHelpProvider(language, signatureHelpProvider));
        }
        return providers;
      }
      createSignatureHelpProvider(selector, provider, ...triggerCharacters) {
        const signatureHelpTriggerCharacters = [...provider.triggerCharacters || triggerCharacters || []];
        return {
          signatureHelpTriggerCharacters,
          signatureHelpRetriggerCharacters: provider.retriggerCharacters,
          provideSignatureHelp: (model, position, token, context) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asTextDocumentPositionParams(model, position);
            const signatureHelp = yield provider.provideSignatureHelp(params, token, this.m2p.asSignatureHelpContext(context));
            return signatureHelp && this.p2m.asSignatureHelpResult(signatureHelp);
          })
        };
      }
      registerDefinitionProvider(selector, provider) {
        const definitionProvider = this.createDefinitionProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerDefinitionProvider(language, definitionProvider));
        }
        return providers;
      }
      createDefinitionProvider(selector, provider) {
        return {
          provideDefinition: (model, position, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asTextDocumentPositionParams(model, position);
            const result = yield provider.provideDefinition(params, token);
            return result && this.p2m.asDefinitionResult(result);
          })
        };
      }
      registerReferenceProvider(selector, provider) {
        const referenceProvider = this.createReferenceProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerReferenceProvider(language, referenceProvider));
        }
        return providers;
      }
      createReferenceProvider(selector, provider) {
        return {
          provideReferences: (model, position, context, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asReferenceParams(model, position, context);
            const result = yield provider.provideReferences(params, token);
            return result && this.p2m.asReferences(result);
          })
        };
      }
      registerDocumentHighlightProvider(selector, provider) {
        const documentHighlightProvider = this.createDocumentHighlightProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerDocumentHighlightProvider(language, documentHighlightProvider));
        }
        return providers;
      }
      createDocumentHighlightProvider(selector, provider) {
        return {
          provideDocumentHighlights: (model, position, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asTextDocumentPositionParams(model, position);
            const result = yield provider.provideDocumentHighlights(params, token);
            return result && this.p2m.asDocumentHighlights(result);
          })
        };
      }
      registerDocumentSymbolProvider(selector, provider) {
        const documentSymbolProvider = this.createDocumentSymbolProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerDocumentSymbolProvider(language, documentSymbolProvider));
        }
        return providers;
      }
      createDocumentSymbolProvider(selector, provider) {
        return {
          provideDocumentSymbols: (model, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asDocumentSymbolParams(model);
            const result = yield provider.provideDocumentSymbols(params, token);
            return result && this.p2m.asDocumentSymbols(result);
          })
        };
      }
      registerCodeActionsProvider(selector, provider) {
        const codeActionProvider = this.createCodeActionProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerCodeActionProvider(language, codeActionProvider));
        }
        return providers;
      }
      createCodeActionProvider(selector, provider) {
        return {
          provideCodeActions: (model, range, context, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asCodeActionParams(model, range, context);
            const result = yield provider.provideCodeActions(params, token);
            return result && this.p2m.asCodeActionList(result) || void 0;
          })
        };
      }
      registerCodeLensProvider(selector, provider) {
        const codeLensProvider = this.createCodeLensProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerCodeLensProvider(language, codeLensProvider));
        }
        return providers;
      }
      createCodeLensProvider(selector, provider) {
        return {
          provideCodeLenses: (model, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asCodeLensParams(model);
            const result = yield provider.provideCodeLenses(params, token);
            return result && this.p2m.asCodeLensList(result);
          }),
          resolveCodeLens: provider.resolveCodeLens ? (model, codeLens, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return codeLens;
            }
            const protocolCodeLens = this.m2p.asCodeLens(codeLens);
            const result = yield provider.resolveCodeLens(protocolCodeLens, token);
            if (result) {
              const resolvedCodeLens = this.p2m.asCodeLens(result);
              Object.assign(codeLens, resolvedCodeLens);
            }
            return codeLens;
          }) : ((_, codeLens) => codeLens)
        };
      }
      registerDocumentFormattingEditProvider(selector, provider) {
        const documentFormattingEditProvider = this.createDocumentFormattingEditProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerDocumentFormattingEditProvider(language, documentFormattingEditProvider));
        }
        return providers;
      }
      createDocumentFormattingEditProvider(selector, provider) {
        return {
          provideDocumentFormattingEdits: (model, options, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asDocumentFormattingParams(model, options);
            const result = yield provider.provideDocumentFormattingEdits(params, token);
            return result && this.p2m.asTextEdits(result);
          })
        };
      }
      registerDocumentRangeFormattingEditProvider(selector, provider) {
        const documentRangeFormattingEditProvider = this.createDocumentRangeFormattingEditProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerDocumentRangeFormattingEditProvider(language, documentRangeFormattingEditProvider));
        }
        return providers;
      }
      createDocumentRangeFormattingEditProvider(selector, provider) {
        return {
          provideDocumentRangeFormattingEdits: (model, range, options, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asDocumentRangeFormattingParams(model, range, options);
            const result = yield provider.provideDocumentRangeFormattingEdits(params, token);
            return result && this.p2m.asTextEdits(result);
          })
        };
      }
      registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacter) {
        const onTypeFormattingEditProvider = this.createOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacter);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerOnTypeFormattingEditProvider(language, onTypeFormattingEditProvider));
        }
        return providers;
      }
      createOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacter) {
        const autoFormatTriggerCharacters = [firstTriggerCharacter].concat(moreTriggerCharacter);
        return {
          autoFormatTriggerCharacters,
          provideOnTypeFormattingEdits: (model, position, ch, options, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asDocumentOnTypeFormattingParams(model, position, ch, options);
            const result = yield provider.provideOnTypeFormattingEdits(params, token);
            return result && this.p2m.asTextEdits(result);
          })
        };
      }
      registerRenameProvider(selector, provider) {
        const renameProvider = this.createRenameProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerRenameProvider(language, renameProvider));
        }
        return providers;
      }
      createRenameProvider(selector, provider) {
        return {
          provideRenameEdits: (model, position, newName, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asRenameParams(model, position, newName);
            const result = yield provider.provideRenameEdits(params, token);
            return result && this.p2m.asWorkspaceEdit(result);
          })
        };
      }
      registerDocumentLinkProvider(selector, provider) {
        const linkProvider = this.createDocumentLinkProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerLinkProvider(language, linkProvider));
        }
        return providers;
      }
      createDocumentLinkProvider(selector, provider) {
        return {
          provideLinks: (model, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asDocumentLinkParams(model);
            const result = yield provider.provideDocumentLinks(params, token);
            return result && this.p2m.asDocumentLinks(result);
          }),
          resolveLink: (link, token) => __awaiter46(this, void 0, void 0, function* () {
            if (provider.resolveDocumentLink && (link.url === null || link.url === void 0)) {
              const documentLink = this.m2p.asDocumentLink(link);
              const result = yield provider.resolveDocumentLink(documentLink, token);
              if (result) {
                const resolvedLink = this.p2m.asDocumentLink(result);
                Object.assign(link, resolvedLink);
              }
            }
            return link;
          })
        };
      }
      registerImplementationProvider(selector, provider) {
        const implementationProvider = this.createImplementationProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerImplementationProvider(language, implementationProvider));
        }
        return providers;
      }
      createImplementationProvider(selector, provider) {
        return {
          provideImplementation: (model, position, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asTextDocumentPositionParams(model, position);
            const result = yield provider.provideImplementation(params, token);
            return result && this.p2m.asDefinitionResult(result);
          })
        };
      }
      registerTypeDefinitionProvider(selector, provider) {
        const typeDefinitionProvider = this.createTypeDefinitionProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerTypeDefinitionProvider(language, typeDefinitionProvider));
        }
        return providers;
      }
      createTypeDefinitionProvider(selector, provider) {
        return {
          provideTypeDefinition: (model, position, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const params = this.m2p.asTextDocumentPositionParams(model, position);
            const result = yield provider.provideTypeDefinition(params, token);
            return result && this.p2m.asDefinitionResult(result);
          })
        };
      }
      registerColorProvider(selector, provider) {
        const documentColorProvider = this.createDocumentColorProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerColorProvider(language, documentColorProvider));
        }
        return providers;
      }
      createDocumentColorProvider(selector, provider) {
        return {
          provideDocumentColors: (model, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const textDocument = this.m2p.asTextDocumentIdentifier(model);
            const result = yield provider.provideDocumentColors({ textDocument }, token);
            return result && this.p2m.asColorInformations(result);
          }),
          provideColorPresentations: (model, info, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const textDocument = this.m2p.asTextDocumentIdentifier(model);
            const range = this.m2p.asRange(info.range);
            const result = yield provider.provideColorPresentations({
              textDocument,
              color: info.color,
              range
            }, token);
            return result && this.p2m.asColorPresentations(result);
          })
        };
      }
      registerFoldingRangeProvider(selector, provider) {
        const foldingRangeProvider = this.createFoldingRangeProvider(selector, provider);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerFoldingRangeProvider(language, foldingRangeProvider));
        }
        return providers;
      }
      createFoldingRangeProvider(selector, provider) {
        return {
          provideFoldingRanges: (model, context, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const textDocument = this.m2p.asTextDocumentIdentifier(model);
            const result = yield provider.provideFoldingRanges({
              textDocument
            }, token);
            return result && this.p2m.asFoldingRanges(result);
          })
        };
      }
      registerDocumentSemanticTokensProvider(selector, provider, legend) {
        const semanticTokensProvider = this.createSemanticTokensProvider(selector, provider, legend);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerDocumentSemanticTokensProvider(language, semanticTokensProvider));
        }
        return providers;
      }
      createSemanticTokensProvider(selector, provider, legend) {
        return {
          getLegend() {
            return legend;
          },
          provideDocumentSemanticTokens: (model, lastResultId, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const textDocument = this.m2p.asTextDocumentIdentifier(model);
            const result = yield provider.provideDocumentSemanticTokens({
              textDocument
            }, token);
            return result && this.p2m.asSemanticTokens(result);
          }),
          releaseDocumentSemanticTokens: (resultId) => {
          }
        };
      }
      registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        const rangeSemanticTokensProvider = this.createRangeSemanticTokensProvider(selector, provider, legend);
        const providers = new disposable_1.DisposableCollection();
        for (const language of this.matchLanguage(selector)) {
          providers.push(this._monaco.languages.registerDocumentRangeSemanticTokensProvider(language, rangeSemanticTokensProvider));
        }
        return providers;
      }
      createRangeSemanticTokensProvider(selector, provider, legend) {
        return {
          getLegend() {
            return legend;
          },
          provideDocumentRangeSemanticTokens: (model, range, token) => __awaiter46(this, void 0, void 0, function* () {
            if (!this.matchModel(selector, MonacoModelIdentifier.fromModel(model))) {
              return void 0;
            }
            const textDocument = this.m2p.asTextDocumentIdentifier(model);
            const result = yield provider.provideDocumentRangeSemanticTokens({
              textDocument,
              range: this.m2p.asRange(range)
            }, token);
            return result && this.p2m.asSemanticTokens(result);
          })
        };
      }
      matchModel(selector, model) {
        if (Array.isArray(selector)) {
          return selector.some((filter) => this.matchModel(filter, model));
        }
        if (services_1.DocumentFilter.is(selector)) {
          if (!!selector.language && selector.language !== model.languageId) {
            return false;
          }
          if (!!selector.scheme && selector.scheme !== model.uri.scheme) {
            return false;
          }
          if (!!selector.pattern && !testGlob(selector.pattern, model.uri.path)) {
            return false;
          }
          return true;
        }
        return selector === model.languageId;
      }
      matchLanguage(selector) {
        const languages3 = /* @__PURE__ */ new Set();
        if (Array.isArray(selector)) {
          for (const filter of selector) {
            languages3.add(this.matchLanguageByFilter(filter));
          }
        } else {
          languages3.add(this.matchLanguageByFilter(selector));
        }
        return languages3;
      }
      matchLanguageByFilter(selector) {
        if (services_1.DocumentFilter.is(selector)) {
          if (!selector.language) {
            return "*";
          }
          return selector.language;
        }
        return selector;
      }
    };
    exports2.MonacoLanguages = MonacoLanguages;
  }
});

// node_modules/monaco-languageclient/lib/monaco-workspace.js
var require_monaco_workspace = __commonJS({
  "node_modules/monaco-languageclient/lib/monaco-workspace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonacoWorkspace = void 0;
    var services_1 = require_services();
    var vscode_languageserver_textdocument_1 = (init_main(), __toCommonJS(main_exports));
    var MonacoWorkspace = class {
      constructor(_monaco, p2m, m2p, _rootUri = null) {
        this._monaco = _monaco;
        this.p2m = p2m;
        this.m2p = m2p;
        this._rootUri = _rootUri;
        this.documents = /* @__PURE__ */ new Map();
        this.onDidOpenTextDocumentEmitter = new services_1.Emitter();
        this.onDidCloseTextDocumentEmitter = new services_1.Emitter();
        this.onDidChangeTextDocumentEmitter = new services_1.Emitter();
        for (const model of this._monaco.editor.getModels()) {
          this.addModel(model);
        }
        this._monaco.editor.onDidCreateModel((model) => this.addModel(model));
        this._monaco.editor.onWillDisposeModel((model) => this.removeModel(model));
      }
      get rootUri() {
        return this._rootUri;
      }
      removeModel(model) {
        const uri = model.uri.toString();
        const document2 = this.documents.get(uri);
        if (document2) {
          this.documents.delete(uri);
          this.onDidCloseTextDocumentEmitter.fire(document2);
        }
      }
      addModel(model) {
        const uri = model.uri.toString();
        const document2 = this.setModel(uri, model);
        this.onDidOpenTextDocumentEmitter.fire(document2);
        model.onDidChangeContent((event) => this.onDidChangeContent(uri, model, event));
      }
      onDidChangeContent(uri, model, event) {
        const textDocument = this.setModel(uri, model);
        const contentChanges = [];
        for (const change of event.changes) {
          const range = this.m2p.asRange(change.range);
          const rangeLength = change.rangeLength;
          const text2 = change.text;
          contentChanges.push({ range, rangeLength, text: text2 });
        }
        this.onDidChangeTextDocumentEmitter.fire({
          textDocument,
          contentChanges
        });
      }
      setModel(uri, model) {
        const document2 = vscode_languageserver_textdocument_1.TextDocument.create(uri, model.getModeId(), model.getVersionId(), model.getValue());
        this.documents.set(uri, document2);
        return document2;
      }
      get textDocuments() {
        return Array.from(this.documents.values());
      }
      get onDidOpenTextDocument() {
        return this.onDidOpenTextDocumentEmitter.event;
      }
      get onDidCloseTextDocument() {
        return this.onDidCloseTextDocumentEmitter.event;
      }
      get onDidChangeTextDocument() {
        return this.onDidChangeTextDocumentEmitter.event;
      }
      applyEdit(workspaceEdit) {
        const edit = this.p2m.asWorkspaceEdit(workspaceEdit);
        const models = edit.edits ? edit.edits.reduce((acc, currentEdit) => {
          const textEdit = currentEdit;
          acc[textEdit.resource.toString()] = this._monaco.editor.getModel(textEdit.resource);
          return acc;
        }, {}) : {};
        if (!Object.keys(models).map((uri) => models[uri]).every((model) => !!model)) {
          return Promise.resolve(false);
        }
        const editsByResource = edit.edits ? edit.edits.reduce((acc, currentEdit) => {
          const textEdit = currentEdit;
          const uri = textEdit.resource.toString();
          if (!(uri in acc)) {
            acc[uri] = [];
          }
          acc[uri].push({
            range: this._monaco.Range.lift(textEdit.edit.range),
            text: textEdit.edit.text
          });
          return acc;
        }, {}) : {};
        Object.keys(editsByResource).forEach((uri) => {
          models[uri].pushEditOperations(
            [],
            // Do not try and preserve editor selections.
            editsByResource[uri].map((resourceEdit) => {
              return {
                identifier: { major: 1, minor: 0 },
                range: resourceEdit.range,
                text: resourceEdit.text,
                forceMoveMarkers: true
              };
            }),
            () => []
          );
        });
        return Promise.resolve(true);
      }
    };
    exports2.MonacoWorkspace = MonacoWorkspace;
  }
});

// node_modules/monaco-languageclient/lib/monaco-converter.js
var require_monaco_converter = __commonJS({
  "node_modules/monaco-languageclient/lib/monaco-converter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolToMonacoConverter = exports2.MonacoToProtocolConverter = exports2.ProtocolCodeAction = exports2.ProtocolCompletionItem = exports2.ProtocolCodeLens = exports2.ProtocolDocumentLink = void 0;
    var ls = require_main3();
    var Is = require_is2();
    var services_1 = require_services();
    var ProtocolDocumentLink;
    (function(ProtocolDocumentLink2) {
      function is(item) {
        return !!item && "data" in item;
      }
      ProtocolDocumentLink2.is = is;
    })(ProtocolDocumentLink = exports2.ProtocolDocumentLink || (exports2.ProtocolDocumentLink = {}));
    var ProtocolCodeLens;
    (function(ProtocolCodeLens2) {
      function is(item) {
        return !!item && "data" in item;
      }
      ProtocolCodeLens2.is = is;
    })(ProtocolCodeLens = exports2.ProtocolCodeLens || (exports2.ProtocolCodeLens = {}));
    var ProtocolCompletionItem;
    (function(ProtocolCompletionItem2) {
      function is(item) {
        return !!item && "data" in item;
      }
      ProtocolCompletionItem2.is = is;
    })(ProtocolCompletionItem = exports2.ProtocolCompletionItem || (exports2.ProtocolCompletionItem = {}));
    var ProtocolCodeAction;
    (function(ProtocolCodeAction2) {
      function is(item) {
        return !!item && "data" in item;
      }
      ProtocolCodeAction2.is = is;
    })(ProtocolCodeAction = exports2.ProtocolCodeAction || (exports2.ProtocolCodeAction = {}));
    function isRangeReplace(v) {
      return v.insert !== void 0;
    }
    var MonacoToProtocolConverter = class {
      constructor(_monaco) {
        this._monaco = _monaco;
      }
      asPosition(lineNumber, column) {
        const line = lineNumber === void 0 || lineNumber === null ? void 0 : lineNumber - 1;
        const character = column === void 0 || column === null ? void 0 : column - 1;
        return {
          line,
          character
        };
      }
      asRange(range) {
        if (range === void 0) {
          return void 0;
        }
        if (range === null) {
          return null;
        }
        if (isRangeReplace(range)) {
          return this.asRange(range.insert);
        } else {
          const start = this.asPosition(range.startLineNumber, range.startColumn);
          const end = this.asPosition(range.endLineNumber, range.endColumn);
          return {
            start,
            end
          };
        }
      }
      asTextDocumentIdentifier(model) {
        return {
          uri: model.uri.toString()
        };
      }
      asTextDocumentPositionParams(model, position) {
        return {
          textDocument: this.asTextDocumentIdentifier(model),
          position: this.asPosition(position.lineNumber, position.column)
        };
      }
      asCompletionParams(model, position, context) {
        return Object.assign(this.asTextDocumentPositionParams(model, position), {
          context: this.asCompletionContext(context)
        });
      }
      asCompletionContext(context) {
        return {
          triggerKind: this.asCompletionTriggerKind(context.triggerKind),
          triggerCharacter: context.triggerCharacter
        };
      }
      asSignatureHelpContext(context) {
        return {
          triggerKind: this.asSignatureHelpTriggerKind(context.triggerKind),
          triggerCharacter: context.triggerCharacter,
          isRetrigger: context.isRetrigger,
          activeSignatureHelp: this.asSignatureHelp(context.activeSignatureHelp)
        };
      }
      asSignatureHelp(signatureHelp) {
        if (signatureHelp === void 0) {
          return void 0;
        }
        return {
          signatures: signatureHelp.signatures.map((signatureInfo) => this.asSignatureInformation(signatureInfo)),
          activeParameter: signatureHelp.activeParameter,
          activeSignature: signatureHelp.activeSignature
        };
      }
      asSignatureInformation(signatureInformation) {
        return {
          documentation: this.asMarkupContent(signatureInformation.documentation),
          label: signatureInformation.label,
          parameters: signatureInformation.parameters.map((paramInfo) => this.asParameterInformation(paramInfo)),
          activeParameter: signatureInformation.activeParameter
        };
      }
      asParameterInformation(parameterInformation) {
        return {
          documentation: this.asMarkupContent(parameterInformation.documentation),
          label: parameterInformation.label
        };
      }
      asMarkupContent(markupContent) {
        if (markupContent === void 0) {
          return void 0;
        }
        if (typeof markupContent === "string") {
          return markupContent;
        }
        return {
          kind: services_1.MarkupKind.Markdown,
          value: markupContent.value
        };
      }
      asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
          case this._monaco.languages.SignatureHelpTriggerKind.ContentChange:
            return services_1.SignatureHelpTriggerKind.ContentChange;
          case this._monaco.languages.SignatureHelpTriggerKind.TriggerCharacter:
            return services_1.SignatureHelpTriggerKind.TriggerCharacter;
          default:
            return services_1.SignatureHelpTriggerKind.Invoke;
        }
      }
      asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
          case this._monaco.languages.CompletionTriggerKind.TriggerCharacter:
            return services_1.CompletionTriggerKind.TriggerCharacter;
          case this._monaco.languages.CompletionTriggerKind.TriggerForIncompleteCompletions:
            return services_1.CompletionTriggerKind.TriggerForIncompleteCompletions;
          default:
            return services_1.CompletionTriggerKind.Invoked;
        }
      }
      asCompletionItem(item) {
        const result = { label: item.label };
        const protocolItem = ProtocolCompletionItem.is(item) ? item : void 0;
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          if (!protocolItem || !protocolItem.documentationFormat) {
            result.documentation = item.documentation;
          } else {
            result.documentation = this.asDocumentation(protocolItem.documentationFormat, item.documentation);
          }
        }
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        this.fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
          result.kind = this.asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = this.asTextEdits(item.additionalTextEdits);
        }
        if (item.command) {
          result.command = this.asCommand(item.command);
        }
        if (item.commitCharacters) {
          result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
          result.command = this.asCommand(item.command);
        }
        if (protocolItem) {
          if (protocolItem.data !== void 0) {
            result.data = protocolItem.data;
          }
          if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
            result.deprecated = protocolItem.deprecated;
          }
        }
        return result;
      }
      asCompletionItemKind(value, original) {
        if (original !== void 0) {
          return original;
        }
        switch (value) {
          case this._monaco.languages.CompletionItemKind.Method:
            return services_1.CompletionItemKind.Method;
          case this._monaco.languages.CompletionItemKind.Function:
            return services_1.CompletionItemKind.Function;
          case this._monaco.languages.CompletionItemKind.Constructor:
            return services_1.CompletionItemKind.Constructor;
          case this._monaco.languages.CompletionItemKind.Field:
            return services_1.CompletionItemKind.Field;
          case this._monaco.languages.CompletionItemKind.Variable:
            return services_1.CompletionItemKind.Variable;
          case this._monaco.languages.CompletionItemKind.Class:
            return services_1.CompletionItemKind.Class;
          case this._monaco.languages.CompletionItemKind.Struct:
            return services_1.CompletionItemKind.Struct;
          case this._monaco.languages.CompletionItemKind.Interface:
            return services_1.CompletionItemKind.Interface;
          case this._monaco.languages.CompletionItemKind.Module:
            return services_1.CompletionItemKind.Module;
          case this._monaco.languages.CompletionItemKind.Property:
            return services_1.CompletionItemKind.Property;
          case this._monaco.languages.CompletionItemKind.Event:
            return services_1.CompletionItemKind.Event;
          case this._monaco.languages.CompletionItemKind.Operator:
            return services_1.CompletionItemKind.Operator;
          case this._monaco.languages.CompletionItemKind.Unit:
            return services_1.CompletionItemKind.Unit;
          case this._monaco.languages.CompletionItemKind.Value:
            return services_1.CompletionItemKind.Value;
          case this._monaco.languages.CompletionItemKind.Constant:
            return services_1.CompletionItemKind.Constant;
          case this._monaco.languages.CompletionItemKind.Enum:
            return services_1.CompletionItemKind.Enum;
          case this._monaco.languages.CompletionItemKind.EnumMember:
            return services_1.CompletionItemKind.EnumMember;
          case this._monaco.languages.CompletionItemKind.Keyword:
            return services_1.CompletionItemKind.Keyword;
          case this._monaco.languages.CompletionItemKind.Text:
            return services_1.CompletionItemKind.Text;
          case this._monaco.languages.CompletionItemKind.Color:
            return services_1.CompletionItemKind.Color;
          case this._monaco.languages.CompletionItemKind.File:
            return services_1.CompletionItemKind.File;
          case this._monaco.languages.CompletionItemKind.Reference:
            return services_1.CompletionItemKind.Reference;
          case this._monaco.languages.CompletionItemKind.Customcolor:
            return services_1.CompletionItemKind.Color;
          case this._monaco.languages.CompletionItemKind.Folder:
            return services_1.CompletionItemKind.Folder;
          case this._monaco.languages.CompletionItemKind.TypeParameter:
            return services_1.CompletionItemKind.TypeParameter;
          case this._monaco.languages.CompletionItemKind.Snippet:
            return services_1.CompletionItemKind.Snippet;
          default:
            return value + 1;
        }
      }
      asDocumentation(format2, documentation) {
        switch (format2) {
          case services_1.MarkupKind.PlainText:
            return { kind: format2, value: documentation };
          case services_1.MarkupKind.Markdown:
            return { kind: format2, value: documentation.value };
          default:
            return `Unsupported Markup content received. Kind is: ${format2}`;
        }
      }
      fillPrimaryInsertText(target, source) {
        let format2 = services_1.InsertTextFormat.PlainText;
        let text2;
        let range;
        if (source.insertTextRules !== void 0 && (source.insertTextRules & this._monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet) === 0) {
          format2 = services_1.InsertTextFormat.Snippet;
          text2 = source.insertText;
        }
        target.insertTextFormat = format2;
        text2 = source.insertText;
        if (source.range) {
          range = this.asRange(source.range);
        }
        target.insertTextFormat = format2;
        if (source.fromEdit && text2 && range) {
          target.textEdit = { newText: text2, range };
        } else {
          target.insertText = text2;
        }
        target.insertTextMode = source.insertTextMode;
      }
      asTextEdit(edit) {
        const range = this.asRange(edit.range);
        return {
          range,
          newText: edit.text || ""
        };
      }
      asTextEdits(items) {
        if (!items) {
          return void 0;
        }
        return items.map((item) => this.asTextEdit(item));
      }
      asReferenceParams(model, position, options) {
        return {
          textDocument: this.asTextDocumentIdentifier(model),
          position: this.asPosition(position.lineNumber, position.column),
          context: { includeDeclaration: options.includeDeclaration }
        };
      }
      asDocumentSymbolParams(model) {
        return {
          textDocument: this.asTextDocumentIdentifier(model)
        };
      }
      asCodeLensParams(model) {
        return {
          textDocument: this.asTextDocumentIdentifier(model)
        };
      }
      asDiagnosticSeverity(value) {
        switch (value) {
          case this._monaco.MarkerSeverity.Error:
            return services_1.DiagnosticSeverity.Error;
          case this._monaco.MarkerSeverity.Warning:
            return services_1.DiagnosticSeverity.Warning;
          case this._monaco.MarkerSeverity.Info:
            return services_1.DiagnosticSeverity.Information;
          case this._monaco.MarkerSeverity.Hint:
            return services_1.DiagnosticSeverity.Hint;
        }
        return void 0;
      }
      asDiagnostic(marker) {
        const range = this.asRange(new this._monaco.Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn));
        const severity = this.asDiagnosticSeverity(marker.severity);
        return services_1.Diagnostic.create(range, marker.message, severity, marker.code, marker.source);
      }
      asDiagnostics(markers) {
        if (markers === void 0 || markers === null) {
          return markers;
        }
        return markers.map((marker) => this.asDiagnostic(marker));
      }
      asCodeActionContext(context) {
        if (context === void 0 || context === null) {
          return context;
        }
        const diagnostics = this.asDiagnostics(context.markers);
        return services_1.CodeActionContext.create(diagnostics, Is.string(context.only) ? [context.only] : void 0);
      }
      asCodeActionParams(model, range, context) {
        return {
          textDocument: this.asTextDocumentIdentifier(model),
          range: this.asRange(range),
          context: this.asCodeActionContext(context)
        };
      }
      asCommand(item) {
        if (item) {
          let args = item.arguments || [];
          return services_1.Command.create(item.title, item.id, ...args);
        }
        return void 0;
      }
      asCodeLens(item) {
        let result = services_1.CodeLens.create(this.asRange(item.range));
        if (item.command) {
          result.command = this.asCommand(item.command);
        }
        if (ProtocolCodeLens.is(item)) {
          if (item.data) {
            result.data = item.data;
          }
          ;
        }
        return result;
      }
      asFormattingOptions(options) {
        return { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
      }
      asDocumentFormattingParams(model, options) {
        return {
          textDocument: this.asTextDocumentIdentifier(model),
          options: this.asFormattingOptions(options)
        };
      }
      asDocumentRangeFormattingParams(model, range, options) {
        return {
          textDocument: this.asTextDocumentIdentifier(model),
          range: this.asRange(range),
          options: this.asFormattingOptions(options)
        };
      }
      asDocumentOnTypeFormattingParams(model, position, ch, options) {
        return {
          textDocument: this.asTextDocumentIdentifier(model),
          position: this.asPosition(position.lineNumber, position.column),
          ch,
          options: this.asFormattingOptions(options)
        };
      }
      asRenameParams(model, position, newName) {
        return {
          textDocument: this.asTextDocumentIdentifier(model),
          position: this.asPosition(position.lineNumber, position.column),
          newName
        };
      }
      asDocumentLinkParams(model) {
        return {
          textDocument: this.asTextDocumentIdentifier(model)
        };
      }
      asDocumentLink(item) {
        let result = services_1.DocumentLink.create(this.asRange(item.range));
        if (item.url) {
          result.target = typeof item.url === "string" ? item.url : item.url.toString();
        }
        if (ProtocolDocumentLink.is(item) && item.data) {
          result.data = item.data;
        }
        if (item.tooltip) {
          result.tooltip = item.tooltip;
        }
        return result;
      }
      asCodeAction(item) {
        const result = { title: item.title };
        const protocolCodeAction = ProtocolCodeAction.is(item) ? item : void 0;
        if (Is.number(item.kind)) {
          result.kind = item.kind;
        }
        if (item.diagnostics) {
          result.diagnostics = this.asDiagnostics(item.diagnostics);
        }
        if (item.edit) {
          throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command) {
          result.command = this.asCommand(item.command);
        }
        if (item.isPreferred !== void 0) {
          result.isPreferred = item.isPreferred;
        }
        if (item.disabled) {
          result.disabled = { reason: item.disabled };
        }
        if (protocolCodeAction) {
          if (protocolCodeAction.data !== void 0) {
            result.data = protocolCodeAction.data;
          }
        }
        return result;
      }
    };
    exports2.MonacoToProtocolConverter = MonacoToProtocolConverter;
    var ProtocolToMonacoConverter = class {
      constructor(_monaco) {
        this._monaco = _monaco;
      }
      asResourceEdits(resource, edits, asMetadata, modelVersionId) {
        return edits.map((edit) => ({
          resource,
          edit: this.asTextEdit(edit),
          modelVersionId,
          metadata: services_1.AnnotatedTextEdit.is(edit) ? asMetadata(edit.annotationId) : void 0
        }));
      }
      asWorkspaceEditMetadata(changeAnnotation) {
        return {
          needsConfirmation: changeAnnotation.needsConfirmation === true,
          label: changeAnnotation.label,
          description: changeAnnotation.description
        };
      }
      asWorkspaceEdit(item) {
        if (!item) {
          return void 0;
        }
        const sharedMetadata = /* @__PURE__ */ new Map();
        if (item.changeAnnotations !== void 0) {
          for (const key of Object.keys(item.changeAnnotations)) {
            const metaData = this.asWorkspaceEditMetadata(item.changeAnnotations[key]);
            sharedMetadata.set(key, metaData);
          }
        }
        const asMetadata = (annotation) => {
          if (annotation === void 0) {
            return void 0;
          } else {
            return sharedMetadata.get(annotation);
          }
        };
        const edits = [];
        if (item.documentChanges) {
          item.documentChanges.forEach((change) => {
            if (ls.CreateFile.is(change)) {
              edits.push({
                newUri: this._monaco.Uri.parse(change.uri),
                options: change.options,
                metadata: asMetadata(change.annotationId)
              });
            } else if (ls.RenameFile.is(change)) {
              edits.push({
                oldUri: this._monaco.Uri.parse(change.oldUri),
                newUri: this._monaco.Uri.parse(change.newUri),
                options: change.options,
                metadata: asMetadata(change.annotationId)
              });
            } else if (ls.DeleteFile.is(change)) {
              edits.push({
                oldUri: this._monaco.Uri.parse(change.uri),
                options: change.options,
                metadata: asMetadata(change.annotationId)
              });
            } else if (ls.TextDocumentEdit.is(change)) {
              const resource = this._monaco.Uri.parse(change.textDocument.uri);
              const version = typeof change.textDocument.version === "number" ? change.textDocument.version : void 0;
              edits.push(...this.asResourceEdits(resource, change.edits, asMetadata, version));
            } else {
              console.error(`Unknown workspace edit change received:
${JSON.stringify(change, void 0, 4)}`);
            }
          });
        } else if (item.changes) {
          for (const key of Object.keys(item.changes)) {
            const resource = this._monaco.Uri.parse(key);
            edits.push(...this.asResourceEdits(resource, item.changes[key], asMetadata));
          }
        }
        return {
          edits
        };
      }
      asTextEdit(edit) {
        if (!edit) {
          return void 0;
        }
        const range = this.asRange(edit.range);
        return {
          range,
          text: edit.newText
        };
      }
      asTextEdits(items) {
        if (!items) {
          return void 0;
        }
        return items.map((item) => this.asTextEdit(item));
      }
      asCodeLens(item) {
        if (!item) {
          return void 0;
        }
        const range = this.asRange(item.range);
        let result = { range };
        if (item.command) {
          result.command = this.asCommand(item.command);
        }
        if (item.data !== void 0 && item.data !== null) {
          result.data = item.data;
        }
        return result;
      }
      asCodeLensList(items) {
        if (!items) {
          return void 0;
        }
        return {
          lenses: items.map((codeLens) => this.asCodeLens(codeLens)),
          dispose: () => {
          }
        };
      }
      asCodeActionList(actions) {
        return {
          actions: actions.map((action) => this.asCodeAction(action)),
          dispose: () => {
          }
        };
      }
      asCodeAction(item) {
        if (services_1.CodeAction.is(item)) {
          return {
            title: item.title,
            command: this.asCommand(item.command),
            edit: this.asWorkspaceEdit(item.edit),
            diagnostics: this.asDiagnostics(item.diagnostics),
            kind: item.kind,
            disabled: item.disabled ? item.disabled.reason : void 0,
            isPreferred: item.isPreferred,
            data: item.data
          };
        }
        return {
          command: {
            id: item.command,
            title: item.title,
            arguments: item.arguments
          },
          title: item.title
        };
      }
      asCommand(command) {
        if (!command) {
          return void 0;
        }
        return {
          id: command.command,
          title: command.title,
          arguments: command.arguments
        };
      }
      asDocumentSymbol(value) {
        const children = value.children && value.children.map((c) => this.asDocumentSymbol(c));
        return {
          name: value.name,
          detail: value.detail || "",
          kind: this.asSymbolKind(value.kind),
          tags: value.tags || [],
          range: this.asRange(value.range),
          selectionRange: this.asRange(value.selectionRange),
          children
        };
      }
      asDocumentSymbols(values) {
        if (services_1.DocumentSymbol.is(values[0])) {
          return values.map((s) => this.asDocumentSymbol(s));
        }
        return this.asSymbolInformations(values);
      }
      asSymbolInformations(values, uri) {
        if (!values) {
          return void 0;
        }
        return values.map((information) => this.asSymbolInformation(information, uri));
      }
      asSymbolInformation(item, uri) {
        const location = this.asLocation(uri ? Object.assign(Object.assign({}, item.location), { uri: uri.toString() }) : item.location);
        return {
          name: item.name,
          detail: "",
          containerName: item.containerName,
          kind: this.asSymbolKind(item.kind),
          tags: item.tags || [],
          range: location.range,
          selectionRange: location.range
        };
      }
      asSymbolKind(item) {
        if (item <= services_1.SymbolKind.TypeParameter) {
          return item - 1;
        }
        return this._monaco.languages.SymbolKind.Property;
      }
      asDocumentHighlights(values) {
        if (!values) {
          return void 0;
        }
        return values.map((item) => this.asDocumentHighlight(item));
      }
      asDocumentHighlight(item) {
        const range = this.asRange(item.range);
        const kind = Is.number(item.kind) ? this.asDocumentHighlightKind(item.kind) : void 0;
        return { range, kind };
      }
      asDocumentHighlightKind(item) {
        switch (item) {
          case services_1.DocumentHighlightKind.Text:
            return this._monaco.languages.DocumentHighlightKind.Text;
          case services_1.DocumentHighlightKind.Read:
            return this._monaco.languages.DocumentHighlightKind.Read;
          case services_1.DocumentHighlightKind.Write:
            return this._monaco.languages.DocumentHighlightKind.Write;
        }
        return this._monaco.languages.DocumentHighlightKind.Text;
      }
      asReferences(values) {
        if (!values) {
          return void 0;
        }
        return values.map((location) => this.asLocation(location));
      }
      asDefinitionResult(item) {
        if (!item) {
          return void 0;
        }
        if (Is.array(item)) {
          if (item.length == 0) {
            return void 0;
          } else if (services_1.LocationLink.is(item[0])) {
            let links = item;
            return links.map((location) => this.asLocationLink(location));
          } else {
            let locations = item;
            return locations.map((location) => this.asLocation(location));
          }
        } else {
          return this.asLocation(item);
        }
      }
      asLocation(item) {
        if (!item) {
          return void 0;
        }
        const uri = this._monaco.Uri.parse(item.uri);
        const range = this.asRange(item.range);
        return {
          uri,
          range
        };
      }
      asLocationLink(item) {
        if (!item) {
          return void 0;
        }
        let result = {
          uri: this._monaco.Uri.parse(item.targetUri),
          range: this.asRange(item.targetSelectionRange),
          originSelectionRange: this.asRange(item.originSelectionRange),
          targetSelectionRange: this.asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
          throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
      }
      asSignatureHelpResult(item) {
        if (!item) {
          return void 0;
        }
        let result = {};
        if (Is.number(item.activeSignature)) {
          result.activeSignature = item.activeSignature;
        } else {
          result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
          result.activeParameter = item.activeParameter;
        } else {
          result.activeParameter = 0;
        }
        if (item.signatures) {
          result.signatures = this.asSignatureInformations(item.signatures);
        } else {
          result.signatures = [];
        }
        return {
          value: result,
          dispose: () => {
          }
        };
      }
      asSignatureInformations(items) {
        return items.map((item) => this.asSignatureInformation(item));
      }
      asSignatureInformation(item) {
        let result = { label: item.label };
        if (item.documentation) {
          result.documentation = this.asDocumentation(item.documentation);
        }
        if (item.parameters) {
          result.parameters = this.asParameterInformations(item.parameters);
        } else {
          result.parameters = [];
        }
        if (item.activeParameter) {
          result.activeParameter = item.activeParameter;
        }
        return result;
      }
      asParameterInformations(item) {
        return item.map((item2) => this.asParameterInformation(item2));
      }
      asParameterInformation(item) {
        let result = { label: item.label };
        if (item.documentation) {
          result.documentation = this.asDocumentation(item.documentation);
        }
        ;
        return result;
      }
      asHover(hover) {
        if (!hover) {
          return void 0;
        }
        return {
          contents: this.asHoverContent(hover.contents),
          range: this.asRange(hover.range)
        };
      }
      asHoverContent(contents) {
        if (Array.isArray(contents)) {
          return contents.map((content) => this.asMarkdownString(content));
        }
        return [this.asMarkdownString(contents)];
      }
      asDocumentation(value) {
        if (Is.string(value)) {
          return value;
        }
        if (value.kind === services_1.MarkupKind.PlainText) {
          return value.value;
        }
        return this.asMarkdownString(value);
      }
      asMarkdownString(content) {
        if (services_1.MarkupContent.is(content)) {
          return {
            value: content.value
          };
        }
        if (Is.string(content)) {
          return { value: content };
        }
        const { language, value } = content;
        return {
          value: "```" + language + "\n" + value + "\n```"
        };
      }
      asSeverity(severity) {
        if (severity === 1) {
          return this._monaco.MarkerSeverity.Error;
        }
        if (severity === 2) {
          return this._monaco.MarkerSeverity.Warning;
        }
        if (severity === 3) {
          return this._monaco.MarkerSeverity.Info;
        }
        return this._monaco.MarkerSeverity.Hint;
      }
      asDiagnostics(diagnostics) {
        if (!diagnostics) {
          return void 0;
        }
        return diagnostics.map((diagnostic) => this.asDiagnostic(diagnostic));
      }
      asDiagnostic(diagnostic) {
        return {
          code: typeof diagnostic.code === "number" ? diagnostic.code.toString() : diagnostic.code,
          severity: this.asSeverity(diagnostic.severity),
          message: diagnostic.message,
          source: diagnostic.source,
          startLineNumber: diagnostic.range.start.line + 1,
          startColumn: diagnostic.range.start.character + 1,
          endLineNumber: diagnostic.range.end.line + 1,
          endColumn: diagnostic.range.end.character + 1,
          relatedInformation: this.asRelatedInformations(diagnostic.relatedInformation)
        };
      }
      asRelatedInformations(relatedInformation) {
        if (!relatedInformation) {
          return void 0;
        }
        return relatedInformation.map((item) => this.asRelatedInformation(item));
      }
      asRelatedInformation(relatedInformation) {
        return {
          resource: this._monaco.Uri.parse(relatedInformation.location.uri),
          startLineNumber: relatedInformation.location.range.start.line + 1,
          startColumn: relatedInformation.location.range.start.character + 1,
          endLineNumber: relatedInformation.location.range.end.line + 1,
          endColumn: relatedInformation.location.range.end.character + 1,
          message: relatedInformation.message
        };
      }
      asCompletionResult(result, defaultRange) {
        if (!result) {
          return {
            incomplete: false,
            suggestions: []
          };
        }
        if (Array.isArray(result)) {
          const suggestions = result.map((item) => this.asCompletionItem(item, defaultRange));
          return {
            incomplete: false,
            suggestions
          };
        }
        return {
          incomplete: result.isIncomplete,
          suggestions: result.items.map((item) => this.asCompletionItem(item, defaultRange))
        };
      }
      asCompletionItem(item, defaultRange) {
        const result = { label: item.label };
        if (item.detail) {
          result.detail = item.detail;
        }
        if (item.documentation) {
          result.documentation = this.asDocumentation(item.documentation);
          result.documentationFormat = Is.string(item.documentation) ? void 0 : item.documentation.kind;
        }
        ;
        if (item.filterText) {
          result.filterText = item.filterText;
        }
        const insertText = this.asCompletionInsertText(item, defaultRange);
        result.insertText = insertText.insertText;
        result.range = insertText.range;
        result.fromEdit = insertText.fromEdit;
        if (insertText.isSnippet) {
          result.insertTextRules = this._monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet;
        }
        if (Is.number(item.kind)) {
          let [itemKind, original] = this.asCompletionItemKind(item.kind);
          result.kind = itemKind;
          if (original) {
            result.originalItemKind = original;
          }
        }
        if (item.sortText) {
          result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
          result.additionalTextEdits = this.asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
          result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
          result.command = this.asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
          result.deprecated = item.deprecated;
        }
        if (item.preselect === true || item.preselect === false) {
          result.preselect = item.preselect;
        }
        if (item.data !== void 0) {
          result.data = item.data;
        }
        if (item.deprecated === true || item.deprecated === false) {
          result.deprecated = item.deprecated;
        }
        result.insertTextMode = item.insertTextMode;
        return result;
      }
      asCompletionItemKind(value) {
        if (services_1.CompletionItemKind.Text <= value && value <= services_1.CompletionItemKind.TypeParameter) {
          switch (value) {
            case services_1.CompletionItemKind.Text:
              return [this._monaco.languages.CompletionItemKind.Text, void 0];
            case services_1.CompletionItemKind.Method:
              return [this._monaco.languages.CompletionItemKind.Method, void 0];
            case services_1.CompletionItemKind.Function:
              return [this._monaco.languages.CompletionItemKind.Function, void 0];
            case services_1.CompletionItemKind.Constructor:
              return [this._monaco.languages.CompletionItemKind.Constructor, void 0];
            case services_1.CompletionItemKind.Field:
              return [this._monaco.languages.CompletionItemKind.Field, void 0];
            case services_1.CompletionItemKind.Variable:
              return [this._monaco.languages.CompletionItemKind.Variable, void 0];
            case services_1.CompletionItemKind.Class:
              return [this._monaco.languages.CompletionItemKind.Class, void 0];
            case services_1.CompletionItemKind.Interface:
              return [this._monaco.languages.CompletionItemKind.Interface, void 0];
            case services_1.CompletionItemKind.Module:
              return [this._monaco.languages.CompletionItemKind.Module, void 0];
            case services_1.CompletionItemKind.Property:
              return [this._monaco.languages.CompletionItemKind.Property, void 0];
            case services_1.CompletionItemKind.Unit:
              return [this._monaco.languages.CompletionItemKind.Unit, void 0];
            case services_1.CompletionItemKind.Value:
              return [this._monaco.languages.CompletionItemKind.Value, void 0];
            case services_1.CompletionItemKind.Enum:
              return [this._monaco.languages.CompletionItemKind.Enum, void 0];
            case services_1.CompletionItemKind.Keyword:
              return [this._monaco.languages.CompletionItemKind.Keyword, void 0];
            case services_1.CompletionItemKind.Snippet:
              return [this._monaco.languages.CompletionItemKind.Snippet, void 0];
            case services_1.CompletionItemKind.Color:
              return [this._monaco.languages.CompletionItemKind.Color, void 0];
            case services_1.CompletionItemKind.File:
              return [this._monaco.languages.CompletionItemKind.File, void 0];
            case services_1.CompletionItemKind.Reference:
              return [this._monaco.languages.CompletionItemKind.Reference, void 0];
            case services_1.CompletionItemKind.Folder:
              return [this._monaco.languages.CompletionItemKind.Folder, void 0];
            case services_1.CompletionItemKind.EnumMember:
              return [this._monaco.languages.CompletionItemKind.EnumMember, void 0];
            case services_1.CompletionItemKind.Constant:
              return [this._monaco.languages.CompletionItemKind.Constant, void 0];
            case services_1.CompletionItemKind.Struct:
              return [this._monaco.languages.CompletionItemKind.Struct, void 0];
            case services_1.CompletionItemKind.Event:
              return [this._monaco.languages.CompletionItemKind.Event, void 0];
            case services_1.CompletionItemKind.Operator:
              return [this._monaco.languages.CompletionItemKind.Operator, void 0];
            case services_1.CompletionItemKind.TypeParameter:
              return [this._monaco.languages.CompletionItemKind.TypeParameter, void 0];
            default:
              return [value - 1, void 0];
          }
        }
        ;
        return [services_1.CompletionItemKind.Text, value];
      }
      asCompletionInsertText(item, defaultRange) {
        const isSnippet = item.insertTextFormat === services_1.InsertTextFormat.Snippet;
        if (item.textEdit) {
          if (services_1.TextEdit.is(item.textEdit)) {
            const range = this.asRange(item.textEdit.range);
            const value = item.textEdit.newText;
            return { isSnippet, insertText: value, range, fromEdit: true };
          } else {
            const range = {
              insert: this.asRange(item.textEdit.insert),
              replace: this.asRange(item.textEdit.replace)
            };
            const value = item.textEdit.newText;
            return { isSnippet, insertText: value, range, fromEdit: true };
          }
        }
        if (item.insertText) {
          return { isSnippet, insertText: item.insertText, fromEdit: false, range: defaultRange };
        }
        return { insertText: item.label, range: defaultRange, fromEdit: false, isSnippet: false };
      }
      asDocumentLinks(documentLinks) {
        const links = documentLinks.map((link) => this.asDocumentLink(link));
        return { links };
      }
      asDocumentLink(documentLink) {
        return {
          range: this.asRange(documentLink.range),
          url: documentLink.target,
          data: documentLink.data,
          tooltip: documentLink.tooltip
        };
      }
      asRange(range) {
        if (range === void 0) {
          return void 0;
        }
        if (range === null) {
          return null;
        }
        const start = this.asPosition(range.start);
        const end = this.asPosition(range.end);
        if (start instanceof this._monaco.Position && end instanceof this._monaco.Position) {
          return new this._monaco.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        }
        const startLineNumber = !start || start.lineNumber === void 0 ? void 0 : start.lineNumber;
        const startColumn = !start || start.column === void 0 ? void 0 : start.column;
        const endLineNumber = !end || end.lineNumber === void 0 ? void 0 : end.lineNumber;
        const endColumn = !end || end.column === void 0 ? void 0 : end.column;
        return { startLineNumber, startColumn, endLineNumber, endColumn };
      }
      asPosition(position) {
        if (position === void 0) {
          return void 0;
        }
        if (position === null) {
          return null;
        }
        const { line, character } = position;
        const lineNumber = line === void 0 ? void 0 : line + 1;
        const column = character === void 0 ? void 0 : character + 1;
        if (lineNumber !== void 0 && column !== void 0) {
          return new this._monaco.Position(lineNumber, column);
        }
        return { lineNumber, column };
      }
      asColorInformations(items) {
        return items.map((item) => this.asColorInformation(item));
      }
      asColorInformation(item) {
        return {
          range: this.asRange(item.range),
          color: item.color
        };
      }
      asColorPresentations(items) {
        return items.map((item) => this.asColorPresentation(item));
      }
      asColorPresentation(item) {
        return {
          label: item.label,
          textEdit: this.asTextEdit(item.textEdit),
          additionalTextEdits: this.asTextEdits(item.additionalTextEdits)
        };
      }
      asFoldingRanges(items) {
        if (!items) {
          return items;
        }
        return items.map((item) => this.asFoldingRange(item));
      }
      asFoldingRange(item) {
        return {
          start: item.startLine + 1,
          end: item.endLine + 1,
          kind: this.asFoldingRangeKind(item.kind)
        };
      }
      asFoldingRangeKind(kind) {
        if (kind) {
          switch (kind) {
            case services_1.FoldingRangeKind.Comment:
              return this._monaco.languages.FoldingRangeKind.Comment;
            case services_1.FoldingRangeKind.Imports:
              return this._monaco.languages.FoldingRangeKind.Imports;
            case services_1.FoldingRangeKind.Region:
              return this._monaco.languages.FoldingRangeKind.Region;
          }
          ;
        }
        return void 0;
      }
      asSemanticTokens(semanticTokens) {
        return {
          resultId: semanticTokens.resultId,
          data: Uint32Array.from(semanticTokens.data)
        };
      }
    };
    exports2.ProtocolToMonacoConverter = ProtocolToMonacoConverter;
  }
});

// node_modules/monaco-languageclient/lib/monaco-services.js
var require_monaco_services = __commonJS({
  "node_modules/monaco-languageclient/lib/monaco-services.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonacoServices = void 0;
    var monaco_converter_1 = require_monaco_converter();
    var monaco_commands_1 = require_monaco_commands();
    var monaco_languages_1 = require_monaco_languages();
    var monaco_workspace_1 = require_monaco_workspace();
    var console_window_1 = require_console_window();
    var services_1 = require_services();
    var MonacoServices2;
    (function(MonacoServices3) {
      function create2(_monaco, options = {}) {
        const m2p = new monaco_converter_1.MonacoToProtocolConverter(_monaco);
        const p2m = new monaco_converter_1.ProtocolToMonacoConverter(_monaco);
        return {
          commands: new monaco_commands_1.MonacoCommands(_monaco),
          languages: new monaco_languages_1.MonacoLanguages(_monaco, p2m, m2p),
          workspace: new monaco_workspace_1.MonacoWorkspace(_monaco, p2m, m2p, options.rootUri),
          window: new console_window_1.ConsoleWindow()
        };
      }
      MonacoServices3.create = create2;
      function install(_monaco, options = {}) {
        const services = create2(_monaco, options);
        services_1.Services.install(services);
        return services;
      }
      MonacoServices3.install = install;
      function get() {
        return services_1.Services.get();
      }
      MonacoServices3.get = get;
    })(MonacoServices2 = exports2.MonacoServices || (exports2.MonacoServices = {}));
  }
});

// node_modules/monaco-languageclient/lib/index.js
var require_lib = __commonJS({
  "node_modules/monaco-languageclient/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !exports3.hasOwnProperty(p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_disposable2(), exports2);
    __exportStar(require_services(), exports2);
    __exportStar(require_connection3(), exports2);
    __exportStar(require_monaco_language_client(), exports2);
    __exportStar(require_monaco_commands(), exports2);
    __exportStar(require_console_window(), exports2);
    __exportStar(require_monaco_languages(), exports2);
    __exportStar(require_monaco_workspace(), exports2);
    __exportStar(require_monaco_services(), exports2);
    __exportStar(require_monaco_converter(), exports2);
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/disposable.js
var require_disposable3 = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DisposableCollection = exports2.Disposable = void 0;
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var DisposableCollection = class {
      constructor() {
        this.disposables = [];
      }
      dispose() {
        while (this.disposables.length !== 0) {
          this.disposables.pop().dispose();
        }
      }
      push(disposable) {
        const disposables = this.disposables;
        disposables.push(disposable);
        return {
          dispose() {
            const index = disposables.indexOf(disposable);
            if (index !== -1) {
              disposables.splice(index, 1);
            }
          }
        };
      }
    };
    exports2.DisposableCollection = DisposableCollection;
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/socket/socket.js
var require_socket = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/socket/socket.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/socket/reader.js
var require_reader = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/socket/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebSocketMessageReader = void 0;
    var messageReader_1 = require_messageReader();
    var WebSocketMessageReader = class extends messageReader_1.AbstractMessageReader {
      constructor(socket) {
        super();
        this.socket = socket;
        this.state = "initial";
        this.events = [];
        this.socket.onMessage((message) => this.readMessage(message));
        this.socket.onError((error) => this.fireError(error));
        this.socket.onClose((code, reason) => {
          if (code !== 1e3) {
            const error = {
              name: "" + code,
              message: `Error during socket reconnect: code = ${code}, reason = ${reason}`
            };
            this.fireError(error);
          }
          this.fireClose();
        });
      }
      listen(callback) {
        if (this.state === "initial") {
          this.state = "listening";
          this.callback = callback;
          while (this.events.length !== 0) {
            const event = this.events.pop();
            if (event.message) {
              this.readMessage(event.message);
            } else if (event.error) {
              this.fireError(event.error);
            } else {
              this.fireClose();
            }
          }
        }
        return {
          dispose: () => {
            if (this.callback === callback) {
              this.callback = void 0;
            }
          }
        };
      }
      readMessage(message) {
        if (this.state === "initial") {
          this.events.splice(0, 0, { message });
        } else if (this.state === "listening") {
          const data = JSON.parse(message);
          this.callback(data);
        }
      }
      fireError(error) {
        if (this.state === "initial") {
          this.events.splice(0, 0, { error });
        } else if (this.state === "listening") {
          super.fireError(error);
        }
      }
      fireClose() {
        if (this.state === "initial") {
          this.events.splice(0, 0, {});
        } else if (this.state === "listening") {
          super.fireClose();
        }
        this.state = "closed";
      }
    };
    exports2.WebSocketMessageReader = WebSocketMessageReader;
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/socket/writer.js
var require_writer = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/socket/writer.js"(exports2) {
    "use strict";
    var __awaiter46 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebSocketMessageWriter = void 0;
    var messageWriter_1 = require_messageWriter();
    var WebSocketMessageWriter = class extends messageWriter_1.AbstractMessageWriter {
      constructor(socket) {
        super();
        this.socket = socket;
        this.errorCount = 0;
      }
      end() {
      }
      write(msg) {
        return __awaiter46(this, void 0, void 0, function* () {
          try {
            const content = JSON.stringify(msg);
            this.socket.send(content);
          } catch (e) {
            this.errorCount++;
            this.fireError(e, msg, this.errorCount);
          }
        });
      }
    };
    exports2.WebSocketMessageWriter = WebSocketMessageWriter;
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/socket/connection.js
var require_connection4 = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/socket/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createWebSocketConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var reader_1 = require_reader();
    var writer_1 = require_writer();
    function createWebSocketConnection(socket, logger) {
      const messageReader = new reader_1.WebSocketMessageReader(socket);
      const messageWriter = new writer_1.WebSocketMessageWriter(socket);
      const connection = vscode_jsonrpc_1.createMessageConnection(messageReader, messageWriter, logger);
      connection.onClose(() => connection.dispose());
      return connection;
    }
    exports2.createWebSocketConnection = createWebSocketConnection;
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/socket/index.js
var require_socket2 = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/socket/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_socket(), exports2);
    __exportStar(require_reader(), exports2);
    __exportStar(require_writer(), exports2);
    __exportStar(require_connection4(), exports2);
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/logger.js
var require_logger = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/logger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConsoleLogger = void 0;
    var ConsoleLogger = class {
      error(message) {
        console.error(message);
      }
      warn(message) {
        console.warn(message);
      }
      info(message) {
        console.info(message);
      }
      log(message) {
        console.log(message);
      }
      debug(message) {
        console.debug(message);
      }
    };
    exports2.ConsoleLogger = ConsoleLogger;
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/connection.js
var require_connection5 = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toSocket = exports2.listen = void 0;
    var socket_1 = require_socket2();
    var logger_1 = require_logger();
    function listen2(options) {
      const { webSocket, onConnection } = options;
      const logger = options.logger || new logger_1.ConsoleLogger();
      webSocket.onopen = () => {
        const socket = toSocket(webSocket);
        const connection = socket_1.createWebSocketConnection(socket, logger);
        onConnection(connection);
      };
    }
    exports2.listen = listen2;
    function toSocket(webSocket) {
      return {
        send: (content) => webSocket.send(content),
        onMessage: (cb) => webSocket.onmessage = (event) => cb(event.data),
        onError: (cb) => webSocket.onerror = (event) => {
          if ("message" in event) {
            cb(event.message);
          }
        },
        onClose: (cb) => webSocket.onclose = (event) => cb(event.code, event.reason),
        dispose: () => webSocket.close()
      };
    }
    exports2.toSocket = toSocket;
  }
});

// node_modules/@codingame/monaco-jsonrpc/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@codingame/monaco-jsonrpc/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_main(), exports2);
    __exportStar(require_messages(), exports2);
    __exportStar(require_disposable3(), exports2);
    __exportStar(require_socket2(), exports2);
    __exportStar(require_logger(), exports2);
    __exportStar(require_connection5(), exports2);
  }
});

// src/code/workbench/common/workbench.editor/workbench.editor.ts
var import_monaco_languageclient, import_monaco_jsonrpc, Editor, _editor;
var init_workbench_editor = __esm({
  "src/code/workbench/common/workbench.editor/workbench.editor.ts"() {
    init_editor_main();
    init_monaco_contribution6();
    import_monaco_languageclient = __toESM(require_lib());
    import_monaco_jsonrpc = __toESM(require_lib2());
    init_workbench_standalone();
    init_workbench_store();
    init_workbench_store_slice();
    init_workbench_store_selector();
    init_workbench_utils();
    init_workbench_editor_theme();
    Object.assign(window, {
      MonacoEnvironment: {
        getWorker(_moduleId, label) {
          const base = "/workers/";
          const workers = {
            json: "json.worker.js",
            css: "css.worker.js",
            html: "html.worker.js",
            typescript: "ts.worker.js",
            javascript: "ts.worker.js"
          };
          return new Worker(`${base}${workers[label] || "editor.worker.js"}`, {
            type: "module"
          });
        }
      }
    });
    import_monaco_languageclient.MonacoServices.install(editor_main_exports);
    Editor = class {
      _tabs = [];
      _editor;
      _editorLayout = document.querySelector(".editor-area");
      _languageClient;
      _models = /* @__PURE__ */ new Map();
      _fileWatchers = /* @__PURE__ */ new Map();
      _isUpdatingFromExternal = false;
      _saveActionDisposable;
      constructor() {
        registerTheme(editor_main_exports);
        this._setupHoverProvider();
      }
      _setupHoverProvider() {
        languages.registerHoverProvider("python", {
          provideHover: (model, position) => {
            const word = model.getWordAtPosition(position);
            if (!word) return null;
            const lineText = model.getLineContent(position.lineNumber);
            const beforeWord = lineText.substring(0, word.startColumn - 1);
            const afterWord = lineText.substring(word.endColumn - 1);
            return {
              range: new Range2(
                position.lineNumber,
                word.startColumn,
                position.lineNumber,
                word.endColumn
              ),
              contents: [
                { value: `**Symbol**: ${word.word}` },
                {
                  value: `**Position**: Line ${position.lineNumber}, Column ${position.column}`
                },
                { value: `**Context**: ${beforeWord}**${word.word}**${afterWord}` },
                { value: `**Language**: Python` }
              ]
            };
          }
        });
      }
      _mount() {
        if (this._editor) return;
        this._editor = editor.create(this._editorLayout, {
          theme: "meridia-theme",
          automaticLayout: true,
          fontSize: 20,
          fontFamily: "Jetbrains Mono",
          cursorBlinking: "smooth",
          cursorSmoothCaretAnimation: true,
          minimap: { enabled: false },
          renderWhitespace: "none"
        });
        document.querySelector(".monaco-editor").style.display = "none";
        this._setupLanguageClient();
        this._setupCursorTracking();
        this._setupSaveAction();
      }
      _setupSaveAction() {
        this._saveActionDisposable = this._editor.addAction({
          id: "workbench.save",
          label: "Save File",
          keybindings: [KeyMod.CtrlCmd | KeyCode.KEY_S],
          contextMenuGroupId: "file",
          contextMenuOrder: 1,
          run: async () => {
            const model = this._editor.getModel();
            if (model) await this._saveFile(model.uri.fsPath);
          }
        });
      }
      _setupCursorTracking() {
        this._editor.onDidChangeCursorPosition(async () => {
          const model = this._editor?.getModel();
          if (!model) return;
          const symbols = await this._getDocumentSymbols(
            model,
            this._editor.getPosition()?.lineNumber
          );
          document.dispatchEvent(
            new CustomEvent("statusbar.update.referenace.path", {
              detail: { message: symbols, userId: Date.now() }
            })
          );
        });
      }
      _setupLanguageClient() {
        try {
          const ws = new WebSocket("ws://localhost:3000");
          ws.onopen = () => {
            console.log("WebSocket connected");
            this._editor.updateOptions({ readOnly: false });
          };
          ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            this._editor.updateOptions({ readOnly: true });
          };
          ws.onclose = () => {
            console.log("WebSocket disconnected");
            this._editor.updateOptions({ readOnly: true });
          };
          (0, import_monaco_jsonrpc.listen)({
            webSocket: ws,
            onConnection: (connection) => {
              this._languageClient = new import_monaco_languageclient.MonacoLanguageClient({
                name: "Pyright Language Client",
                clientOptions: {
                  documentSelector: ["python"],
                  errorHandler: {
                    error: () => import_monaco_languageclient.ErrorAction.Continue,
                    closed: () => import_monaco_languageclient.CloseAction.DoNotRestart
                  },
                  initializationOptions: {
                    settings: {
                      python: {
                        pythonPath: "/usr/bin/python",
                        analysis: {
                          autoSearchPaths: true,
                          useLibraryCodeForTypes: true,
                          diagnosticMode: "openFilesOnly"
                        }
                      }
                    }
                  }
                },
                connectionProvider: {
                  get: (errorHandler, closeHandler) => Promise.resolve(
                    (0, import_monaco_languageclient.createConnection)(connection, errorHandler, closeHandler)
                  )
                }
              });
              this._languageClient.onReady().then(() => {
                console.log("Language client ready");
                this._editor.updateOptions({ readOnly: false });
              }).catch((error) => {
                console.error("Language client initialization failed:", error);
                this._editor.updateOptions({ readOnly: false });
              });
              try {
                const disposable = this._languageClient.start();
                connection.onClose(() => disposable.dispose());
              } catch (error) {
                console.error("Failed to start language client:", error);
                this._editor.updateOptions({ readOnly: false });
              }
            }
          });
        } catch (error) {
          console.error("WebSocket setup failed:", error);
          this._editor.updateOptions({ readOnly: false });
        }
      }
      async _getDocumentSymbols(model, lineNumber) {
        if (!this._languageClient) return null;
        try {
          const symbols = await this._languageClient.sendRequest(
            "textDocument/documentSymbol",
            {
              textDocument: { uri: model.uri.toString() }
            }
          );
          return symbols?.length ? this._findSymbolAtLine(symbols, lineNumber) : null;
        } catch {
          return null;
        }
      }
      _findSymbolAtLine(symbols, lineNumber) {
        for (const symbol of symbols) {
          const range = symbol.range || symbol.location?.range;
          if (!range) continue;
          const startLine = (range.start?.line ?? range.startLineNumber) + (typeof range.start?.line === "number" ? 1 : 0);
          const endLine = (range.end?.line ?? range.endLineNumber) + (typeof range.end?.line === "number" ? 1 : 0);
          if (lineNumber >= startLine && lineNumber <= endLine) {
            return symbol.children?.length ? this._findSymbolAtLine(symbol.children, lineNumber) || symbol : symbol;
          }
        }
        return null;
      }
      async _open(tab) {
        if (!this._editor) return;
        document.querySelector(".monaco-editor").style.display = "flex";
        let model = this._models.get(tab.uri);
        if (!model) {
          const uri = Uri.file(tab.uri);
          model = editor.getModel(uri) || editor.createModel(
            await window.fs.readFile(tab.uri),
            getLanguage(tab.uri),
            uri
          );
          this._models.set(tab.uri, model);
          if (!this._tabs.find((t) => t.uri === tab.uri)) this._tabs.push(tab);
          model.onDidChangeContent(() => {
            if (!this._isUpdatingFromExternal) this._updateTabState(tab.uri, true);
          });
          this._startFileWatching(tab.uri);
        }
        this._editor.setModel(model);
      }
      _startFileWatching(uri) {
        if (this._fileWatchers.has(uri)) return;
        try {
          const watcher = window.fs.watchFile(
            uri,
            { persistent: true, interval: 1e3 },
            () => this._handleExternalFileChange(uri)
          );
          this._fileWatchers.set(uri, watcher);
        } catch {
        }
      }
      async _handleExternalFileChange(uri) {
        const model = this._models.get(uri);
        if (!model) return;
        try {
          const [newContent, currentPosition, currentSelection] = await Promise.all(
            [
              window.fs.readFile(uri),
              Promise.resolve(this._editor.getPosition()),
              Promise.resolve(this._editor.getSelection())
            ]
          );
          this._isUpdatingFromExternal = true;
          model.setValue(newContent);
          this._isUpdatingFromExternal = false;
          if (currentPosition && this._editor.getModel() === model) {
            this._editor.setPosition(currentPosition);
            if (currentSelection) this._editor.setSelection(currentSelection);
          }
          this._updateTabState(uri, false);
        } catch {
        }
      }
      _updateTabState(uri, isTouched) {
        this._tabs = this._tabs.map(
          (tab) => tab.uri === uri ? { ...tab, is_touched: isTouched } : tab
        );
        const updatedTabs = select((s) => s.main.editor_tabs).map(
          (tab) => tab.uri === uri ? { ...tab, is_touched: isTouched } : tab
        );
        dispatch(update_editor_tabs(updatedTabs));
      }
      async _saveFile(uri) {
        const model = this._models.get(uri);
        if (!model) return;
        try {
          await window.fs.createFile(uri, model.getValue());
          this._updateTabState(uri, false);
        } catch {
        }
      }
      close(uri) {
        const model = this._models.get(uri);
        if (!model) return;
        const watcher = this._fileWatchers.get(uri);
        if (watcher) {
          try {
            window.fs.unwatchFile(uri);
          } catch {
          }
          this._fileWatchers.delete(uri);
        }
        this._models.delete(uri);
        model.dispose();
        this._tabs = this._tabs.filter((tab) => tab.uri !== uri);
        if (this._editor.getModel() === model) {
          if (this._tabs.length > 0) {
            this._open(this._tabs[this._tabs.length - 1]);
          } else {
            this._editor.setModel(null);
            this._saveActionDisposable?.dispose();
            this._saveActionDisposable = void 0;
          }
        }
        this._editor.focus();
      }
    };
    _editor = new Editor();
    registerStandalone("editor", _editor);
  }
});

export {
  Editor,
  init_workbench_editor
};
/*! Bundled license information:

monaco-editor/esm/vs/base/browser/dompurify/dompurify.js:
  (*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE *)
*/
